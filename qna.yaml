version: 2
created_by: GMC2alg
task_description: Teach the model how to generate a Turbo Integrator process
created_at: '2024-10-21'
seed_examples:
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der die begrenzten Planungsoptionen
    in Chores überwindet. Dieser Prozess muss der erste in einem Chore sein. Beispiel: Wenn
    ein Chore jeden Montag und Mittwoch ausgeführt werden soll, wird er für die tägliche Ausführung
    geplant, aber der Parameter pWeekdays wird auf Montag und Mittwoch gesetzt. Der Chore startet
    dann jeden Tag, aber dieser Prozess führt an allen Tagen, die nicht in pWeekdays angegeben
    sind, eine ProcessExitByChoreQuit-Funktion aus. Anwendungsfälle: Für produktive Systeme.
    1. Ein Chore sollte alle 30 Minuten zwischen 8 Uhr und 20 Uhr an Wochentagen ausgeführt
    werden. Planen Sie den Chore für alle 30 Minuten und fügen Sie diesen Prozess zuerst im
    Chore mit den Parametern pWeekDays=MON&TUE&WED&THU&FRI, pStartTime=8, pEndTime=20 ein. 2.
    Ein Chore sollte nur am ersten Kalendertag jedes Monats ausgeführt werden. Planen Sie den
    Chore für die tägliche Ausführung und fügen Sie diesen Prozess zuerst im Chore mit dem Parameter
    pMonthDays=1 ein. Hinweis: Dieser Prozess beendet einen Chore, wenn zeitgebundene, wochentagsgebundene
    oder datumsgebundene Bedingungen erfüllt sind, die definieren, wann der Chore nicht ausgeführt
    werden soll. Nur die benötigten Parameter sollten angegeben werden. Nur geplante Ausführungen
    werden außerhalb der Parameter beendet. Wenn ein Chore manuell von einem Benutzer ausgeführt
    wird, werden die Überprüfungen umgangen. Dies wird durch die Überprüfung der TM1User-Funktion
    erreicht. Zeitbedingungen werden in der folgenden Prioritätsreihenfolge überprüft: 1. pMonthDays:
    Tage im Monat, an denen der Chore ausgeführt werden darf. Geben Sie eine durch Trennzeichen
    getrennte Liste von Tagen ein, z.B. 1&2&30&31 (leer = keine Beschränkung auf zulässige Monatstage).
    2. pWeekDays: Tage in der Woche, an denen der Chore ausgeführt werden darf. Geben Sie eine
    durch Trennzeichen getrennte Liste von Wochentagen ein, z.B. MON&FRI (leer = keine Beschränkung
    auf zulässige Wochentage). 3. pStartTime & pEndTime: Tageszeit, zu der der Chore ausgeführt
    werden darf, z.B. pStartTime=7, pEndTime=22, die Ausführung wird zwischen 7 Uhr und 22 Uhr
    erlaubt (leer = keine zeitgebundenen Beschränkungen).'
  answer: "#Section Prolog\n\n#Region @DOC\n# Description:\n# This TI was created to overcome\
    \ the limited scheduling options in chores. In order to use this TI it has to be the 1st\
    \ TI in the chore.\n# As an example, if you need to run a chore every Monday & Wednesday\
    \ you would schedule it to run EVERY day but set the pWeekdays parameter to Mon & Wed.\n\
    # The chore would then kick off every day but this TI will perform a ProcessExitByChoreQuit\
    \ function on all days NOT mentioned in pWeekdays.\n\n# Use case: For productive systems.\n\
    # 1. A chore should run every 30 minutes between 8am & 8pm on weekdays. Schedule chore for\
    \ every 30 minutes and include this process 1st in chore with parameters pWeekDays=MON&TUE&WED&THU&FRI\
    \ pStartTime=8 pEndTime=20.\n# 2. A chore should run only on 1st calendar day of each month.\
    \ Schedule chore for daily execution and include this process 1st in chore with parameters\
    \ pMonthDays=1.\n\n# Note:\n# * This process will quit a chore if any time-bound, weekday-bound\
    \ or date-bound conditions which define when the chore should NOT run are met.\n# * Only\
    \ the parameter(s) needed shoudl be specified.\n# * Only scheduled executions will be quit\
    \ outside the parameters. The checks are bypassed if a chore is manually executed by a user.\
    \ This is done by checking the TM1User function.\n# * Time conditions are checked using\
    \ these parameters in the following order of priority.\n#   1. pMonthDays : Days in month\
    \ when chore is allowed to run. Enter delimited list of days e.g. 1&2&30&31 (blank = no\
    \ restriction on allowed days of month).\n#   2. pWeekDays : Days in week when chore is\
    \ allowed to run Enter delimited list of weekdays e.g. MON&FRI (blank = no restriction on\
    \ allowed weekdays).\n#   3. pStartTime & pEndTime : Time of day when chore is allowed to\
    \ run e.g. pStartTime=7, pEndTime=22 execution will be allowed between 7AM & 10PM ( blank\
    \ = no time-bound restrictionss).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncStartTime      = NumberToString(\
    \ pStartTime );\ncEndTime        = NumberToString( pEndTime );\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'User:%cUserName% Process:%cThisProcName% Message: %sMsg%';\ncLogInfo\
    \        = 'User:%cUserName% Process:%cThisProcName% run to check if chore should run with\
    \ parameters pMonthDays:%pMonthDays%, pWeekDays:%pWeekDays%, pDelim:%pDelim%, pStartTime:%cStartTime%,\
    \ pEndTime:%cEndTime%.' ; \nnErrors         = 0;\nsMsg            = '';\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nEndIf;\n\
    \n### Check params\nIf( pDelim @= '' );\n    pDelim = '&';\nElse;\n    pDelim = SubSt( pDelim,\
    \ 1, 1 );\nEndIf;\n\nIf( pMonthDays @= 'ALL' );\n    pMonthDays = '';\nEndIf;\nIf( pMonthDays\
    \ @<> '' );\n    If( SubSt( pMonthDays, Long( pMonthDays ), 1 ) @<> pDelim );\n        pMonthDays\
    \ = pMonthDays | pDelim;\n    EndIf;\nEndIf;\n\nIf( pWeekDays @= 'ALL' );\n    pWeekDays\
    \ = '';\nEndIf;\nIf( pWeekDays @<> '' );\n    pWeekDays = Upper( pWeekDays );\n    If( SubSt(\
    \ pWeekDays, Long( pWeekDays ), 1 ) @<> pDelim );\n        pWeekDays = pWeekDays | pDelim;\n\
    \    EndIf;\nEndIf;\n\nIf( pStartTime <= 0 % pStartTime > 24 );\n    pStartTime = 0;\nElse;\n\
    \    pStartTime = Round(pStartTime);\nEndIf;\nsStartTime = NumberToString( pStartTime );\n\
    \nIf( pEndTime <= 0 % pEndTime > 24 );\n    pEndTime = 24;\nElse;\n    pEndTime = Round(pEndTime);\n\
    EndIf;\n\nIf( pEndTime < pStartTime );\n    pEndTime = pStartTime;\nEndIf;\nsEndTime = NumberToString(\
    \ pEndTime );\n\n### Initialize quit Boolean\nbQuit = 0;\n\n### Check the user\nIf( DIMIX(\
    \ '}Clients', cUserName ) > 0 );\n    If( pLogOutput >= 1 );\n        sMsg = 'This chore\
    \ will NOT quit since executed by a user.';\n        LogOutput( 'INFO', Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\nElse;\n    \n    ### Check the day of the month\n    If( pMonthDays\
    \ @<> '' );\n        sDayInMonth = TimSt(Now, '\\d');\n        If( Scan( sDayInMonth | pDelim,\
    \ pMonthDays ) = 0 & Scan( sDayInMonth |' '| pDelim, pMonthDays ) = 0 );\n            #\
    \ could not find the day in the list of acceptable days\n            bQuit = 1;\n      \
    \      sMsg = Expand('Bedrock debug %cThisProcName%: chore will quit. Could not find today\
    \ %sDayInMonth% in list of acceptable days %pMonthDays%');\n            IF( pLogoutput =\
    \ 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        Else;\n            sMsg = Expand('Bedrock\
    \ debug %cThisProcName%: today %sDayInMonth% found in list of acceptable days %pMonthDays%');\n\
    \            IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        EndIF;\n \
    \   EndIf;\n\n    ### Check the day of the week\n    If( pWeekDays @<> '' );\n        nDayIndex\
    \ = Mod( DayNo ( Today ) + 21915, 7 );\n        sWeekday = '';\n        If( nDayIndex =\
    \ 0 );\n            sWeekday = 'SUN';\n        ElseIf( nDayIndex = 1 );\n            sWeekday\
    \ = 'MON';\n        ElseIf( nDayIndex = 2 );\n            sWeekday = 'TUE';\n        ElseIf(\
    \ nDayIndex = 3 );\n            sWeekday = 'WED';\n        ElseIf( nDayIndex = 4 );\n  \
    \          sWeekday = 'THU';\n        ElseIf( nDayIndex = 5 );\n            sWeekday = 'FRI';\n\
    \        ElseIf( nDayIndex = 6 );\n            sWeekday = 'SAT';\n        EndIf;\n     \
    \   If( Scan( sWeekday | pDelim, pWeekDays ) = 0 & Scan( sWeekday |' '| pDelim, pWeekDays\
    \ ) = 0 );\n            # could not find the day in the list of acceptable days\n      \
    \      bQuit = 1;\n            sMsg = Expand('Bedrock debug %cThisProcName%: chore will\
    \ quit. Could not find today %sWeekday% in list of acceptable days %pWeekDays%');\n    \
    \        IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        Else;\n      \
    \      sMsg = Expand('Bedrock debug %cThisProcName%: today %sWeekday% found in list of acceptable\
    \ days %pWeekDays%');\n            IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n\
    \        EndIF;\n    EndIf;\n    \n    ### Check the time of day\n    sMinute = TimSt(Now,\
    \ '\\h:\\i');\n    vTimeNow = StringToNumber(SubSt(sMinute, 1, 2));\n    If( pStartTime\
    \ = 0 & pEndTime = 24 );\n        # no time exclusion parameters are set\n    ElseIf( vTimeNow\
    \ < pStartTime % vTimeNow >= pEndTime );\n        # we are in the exclusion zone do not\
    \ execute chore\n        bQuit = 1;\n        sMsg = Expand('Bedrock debug %cThisProcName%:\
    \ chore will quit. current time %sMinute% is outside the defined execution time from %sStartTime%:00\
    \ to %sEndTime%:00');\n        IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n\
    \    Else;\n        # we are not in the exclusion zone, proceed as normal \n        sMsg\
    \ = Expand('Bedrock debug %cThisProcName%: current time %sMinute% is within the defined\
    \ execution time from %sStartTime%:00 to %sEndTime%:00');\n        IF( pLogoutput = 1 );\
    \ LogOutput( 'INFO', sMsg ); EndIf;\n    EndIF;\n\nEndIf;\n\n### Quit chore if quit conditions\
    \ met\nIf( bQuit = 1 );\n    sMsg = Expand('Bedrock debug %cThisProcName%: terminated the\
    \ chore for the reasons stated above.');\n    If( pLogoutput = 1 ); LogOutput( 'INFO' ,\
    \ Expand( cMsgErrorContent ) ); EndIf;\n    nProcessReturnCode = ProcessExitByChoreQuit();\n\
    \    sProcessReturnCode = 'ProcessExitByChoreQuit';\n    ChoreQuit;\nElse;\n    ### Return\
    \ Code\n    sProcessAction      = Expand('Bedrock debug %cThisProcName%: validated the chore\
    \ to run as normal.');\n    sProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode  = 1;\n    If( pLogoutput = 1 ); LogOutput('INFO', Expand(\
    \ sProcessAction ) );  EndIf;\nEndIf;\n\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% completed normally' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###\n"
- question: 'Develop an IBM Turbo Integrator process to overcome the limited scheduling options
    in chores. This process must be the first in a chore. For example, if a chore needs to run
    every Monday and Wednesday, schedule it to run every day but set the pWeekdays parameter
    to Mon and Wed. The chore will then kick off daily, but this process will perform a ProcessExitByChoreQuit
    function on all days NOT mentioned in pWeekdays. Use case: For productive systems. 1. A
    chore should run every 30 minutes between 8am and 8pm on weekdays. Schedule the chore every
    30 minutes and include this process first in the chore with parameters pWeekDays=MON&TUE&WED&THU&FRI,
    pStartTime=8, pEndTime=20. 2. A chore should run only on the first calendar day of each
    month. Schedule the chore for daily execution and include this process first in the chore
    with the parameter pMonthDays=1. Note: This process will quit a chore if any time-bound,
    weekday-bound, or date-bound conditions which define when the chore should NOT run are met.
    Only the parameter(s) needed should be specified. Only scheduled executions will be quit
    outside the parameters. The checks are bypassed if a chore is manually executed by a user,
    achieved by checking the TM1User function. Time conditions are checked in the following
    order of priority: 1. pMonthDays: Days in the month when the chore is allowed to run. Enter
    a delimited list of days, e.g., 1&2&30&31 (blank = no restriction on allowed days of the
    month). 2. pWeekDays: Days of the week when the chore is allowed to run. Enter a delimited
    list of weekdays, e.g., MON&FRI (blank = no restriction on allowed weekdays). 3. pStartTime
    & pEndTime: Time of day when the chore is allowed to run, e.g., pStartTime=7, pEndTime=22,
    execution will be allowed between 7AM and 10PM (blank = no time-bound restrictions).'
  answer: "#Section Prolog\n\n#Region @DOC\n# Description:\n# This TI was created to overcome\
    \ the limited scheduling options in chores. In order to use this TI it has to be the 1st\
    \ TI in the chore.\n# As an example, if you need to run a chore every Monday & Wednesday\
    \ you would schedule it to run EVERY day but set the pWeekdays parameter to Mon & Wed.\n\
    # The chore would then kick off every day but this TI will perform a ProcessExitByChoreQuit\
    \ function on all days NOT mentioned in pWeekdays.\n\n# Use case: For productive systems.\n\
    # 1. A chore should run every 30 minutes between 8am & 8pm on weekdays. Schedule chore for\
    \ every 30 minutes and include this process 1st in chore with parameters pWeekDays=MON&TUE&WED&THU&FRI\
    \ pStartTime=8 pEndTime=20.\n# 2. A chore should run only on 1st calendar day of each month.\
    \ Schedule chore for daily execution and include this process 1st in chore with parameters\
    \ pMonthDays=1.\n\n# Note:\n# * This process will quit a chore if any time-bound, weekday-bound\
    \ or date-bound conditions which define when the chore should NOT run are met.\n# * Only\
    \ the parameter(s) needed shoudl be specified.\n# * Only scheduled executions will be quit\
    \ outside the parameters. The checks are bypassed if a chore is manually executed by a user.\
    \ This is done by checking the TM1User function.\n# * Time conditions are checked using\
    \ these parameters in the following order of priority.\n#   1. pMonthDays : Days in month\
    \ when chore is allowed to run. Enter delimited list of days e.g. 1&2&30&31 (blank = no\
    \ restriction on allowed days of month).\n#   2. pWeekDays : Days in week when chore is\
    \ allowed to run Enter delimited list of weekdays e.g. MON&FRI (blank = no restriction on\
    \ allowed weekdays).\n#   3. pStartTime & pEndTime : Time of day when chore is allowed to\
    \ run e.g. pStartTime=7, pEndTime=22 execution will be allowed between 7AM & 10PM ( blank\
    \ = no time-bound restrictionss).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncStartTime      = NumberToString(\
    \ pStartTime );\ncEndTime        = NumberToString( pEndTime );\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'User:%cUserName% Process:%cThisProcName% Message: %sMsg%';\ncLogInfo\
    \        = 'User:%cUserName% Process:%cThisProcName% run to check if chore should run with\
    \ parameters pMonthDays:%pMonthDays%, pWeekDays:%pWeekDays%, pDelim:%pDelim%, pStartTime:%cStartTime%,\
    \ pEndTime:%cEndTime%.' ; \nnErrors         = 0;\nsMsg            = '';\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nEndIf;\n\
    \n### Check params\nIf( pDelim @= '' );\n    pDelim = '&';\nElse;\n    pDelim = SubSt( pDelim,\
    \ 1, 1 );\nEndIf;\n\nIf( pMonthDays @= 'ALL' );\n    pMonthDays = '';\nEndIf;\nIf( pMonthDays\
    \ @<> '' );\n    If( SubSt( pMonthDays, Long( pMonthDays ), 1 ) @<> pDelim );\n        pMonthDays\
    \ = pMonthDays | pDelim;\n    EndIf;\nEndIf;\n\nIf( pWeekDays @= 'ALL' );\n    pWeekDays\
    \ = '';\nEndIf;\nIf( pWeekDays @<> '' );\n    pWeekDays = Upper( pWeekDays );\n    If( SubSt(\
    \ pWeekDays, Long( pWeekDays ), 1 ) @<> pDelim );\n        pWeekDays = pWeekDays | pDelim;\n\
    \    EndIf;\nEndIf;\n\nIf( pStartTime <= 0 % pStartTime > 24 );\n    pStartTime = 0;\nElse;\n\
    \    pStartTime = Round(pStartTime);\nEndIf;\nsStartTime = NumberToString( pStartTime );\n\
    \nIf( pEndTime <= 0 % pEndTime > 24 );\n    pEndTime = 24;\nElse;\n    pEndTime = Round(pEndTime);\n\
    EndIf;\n\nIf( pEndTime < pStartTime );\n    pEndTime = pStartTime;\nEndIf;\nsEndTime = NumberToString(\
    \ pEndTime );\n\n### Initialize quit Boolean\nbQuit = 0;\n\n### Check the user\nIf( DIMIX(\
    \ '}Clients', cUserName ) > 0 );\n    If( pLogOutput >= 1 );\n        sMsg = 'This chore\
    \ will NOT quit since executed by a user.';\n        LogOutput( 'INFO', Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\nElse;\n    \n    ### Check the day of the month\n    If( pMonthDays\
    \ @<> '' );\n        sDayInMonth = TimSt(Now, '\\d');\n        If( Scan( sDayInMonth | pDelim,\
    \ pMonthDays ) = 0 & Scan( sDayInMonth |' '| pDelim, pMonthDays ) = 0 );\n            #\
    \ could not find the day in the list of acceptable days\n            bQuit = 1;\n      \
    \      sMsg = Expand('Bedrock debug %cThisProcName%: chore will quit. Could not find today\
    \ %sDayInMonth% in list of acceptable days %pMonthDays%');\n            IF( pLogoutput =\
    \ 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        Else;\n            sMsg = Expand('Bedrock\
    \ debug %cThisProcName%: today %sDayInMonth% found in list of acceptable days %pMonthDays%');\n\
    \            IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        EndIF;\n \
    \   EndIf;\n\n    ### Check the day of the week\n    If( pWeekDays @<> '' );\n        nDayIndex\
    \ = Mod( DayNo ( Today ) + 21915, 7 );\n        sWeekday = '';\n        If( nDayIndex =\
    \ 0 );\n            sWeekday = 'SUN';\n        ElseIf( nDayIndex = 1 );\n            sWeekday\
    \ = 'MON';\n        ElseIf( nDayIndex = 2 );\n            sWeekday = 'TUE';\n        ElseIf(\
    \ nDayIndex = 3 );\n            sWeekday = 'WED';\n        ElseIf( nDayIndex = 4 );\n  \
    \          sWeekday = 'THU';\n        ElseIf( nDayIndex = 5 );\n            sWeekday = 'FRI';\n\
    \        ElseIf( nDayIndex = 6 );\n            sWeekday = 'SAT';\n        EndIf;\n     \
    \   If( Scan( sWeekday | pDelim, pWeekDays ) = 0 & Scan( sWeekday |' '| pDelim, pWeekDays\
    \ ) = 0 );\n            # could not find the day in the list of acceptable days\n      \
    \      bQuit = 1;\n            sMsg = Expand('Bedrock debug %cThisProcName%: chore will\
    \ quit. Could not find today %sWeekday% in list of acceptable days %pWeekDays%');\n    \
    \        IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        Else;\n      \
    \      sMsg = Expand('Bedrock debug %cThisProcName%: today %sWeekday% found in list of acceptable\
    \ days %pWeekDays%');\n            IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n\
    \        EndIF;\n    EndIf;\n    \n    ### Check the time of day\n    sMinute = TimSt(Now,\
    \ '\\h:\\i');\n    vTimeNow = StringToNumber(SubSt(sMinute, 1, 2));\n    If( pStartTime\
    \ = 0 & pEndTime = 24 );\n        # no time exclusion parameters are set\n    ElseIf( vTimeNow\
    \ < pStartTime % vTimeNow >= pEndTime );\n        # we are in the exclusion zone do not\
    \ execute chore\n        bQuit = 1;\n        sMsg = Expand('Bedrock debug %cThisProcName%:\
    \ chore will quit. current time %sMinute% is outside the defined execution time from %sStartTime%:00\
    \ to %sEndTime%:00');\n        IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n\
    \    Else;\n        # we are not in the exclusion zone, proceed as normal \n        sMsg\
    \ = Expand('Bedrock debug %cThisProcName%: current time %sMinute% is within the defined\
    \ execution time from %sStartTime%:00 to %sEndTime%:00');\n        IF( pLogoutput = 1 );\
    \ LogOutput( 'INFO', sMsg ); EndIf;\n    EndIF;\n\nEndIf;\n\n### Quit chore if quit conditions\
    \ met\nIf( bQuit = 1 );\n    sMsg = Expand('Bedrock debug %cThisProcName%: terminated the\
    \ chore for the reasons stated above.');\n    If( pLogoutput = 1 ); LogOutput( 'INFO' ,\
    \ Expand( cMsgErrorContent ) ); EndIf;\n    nProcessReturnCode = ProcessExitByChoreQuit();\n\
    \    sProcessReturnCode = 'ProcessExitByChoreQuit';\n    ChoreQuit;\nElse;\n    ### Return\
    \ Code\n    sProcessAction      = Expand('Bedrock debug %cThisProcName%: validated the chore\
    \ to run as normal.');\n    sProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode  = 1;\n    If( pLogoutput = 1 ); LogOutput('INFO', Expand(\
    \ sProcessAction ) );  EndIf;\nEndIf;\n\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% completed normally' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###\n"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der die Replikation eines vorhandenen
    Würfels ermöglicht. Der Prozess sollte die Option bieten, sowohl Daten als auch Regeln einzuschließen.
    Nutzen Sie diesen Prozess vorrangig für Entwicklungs- und Prototyping-Zwecke. Der Prozess
    umfasst: 1. Eine Momentaufnahme der Würfeldaten, wobei alle Regeln in Werte konvertiert
    werden, 2. Eine exakte Kopie des Würfels in einem einfachen Schritt als Ausgangspunkt für
    Regeländerungen oder die Entwicklung neuer Funktionen. Beachten Sie dabei folgende Punkte:
    Es gibt Parameteroptionen, um Daten (pIncludeData) und Regeln (pIncludeRules) bei der Erstellung
    einzuschließen. Wenn der Quellwürfel (pSrcCube) leer bleibt oder nicht existiert, wird der
    Prozess ohne Aktion beendet. Genauso wird der Prozess beendet, wenn der Zielwürfel (pTgtCube)
    bereits existiert. Sollte der Zielwürfel leer oder identisch mit dem Quellwürfel sein, erhält
    der Klon-Würfel den Namen des Quellwürfels mit dem Anhang ''_Clone''. Falls die Quellwürfeldaten
    nur teilweise kopiert werden sollen, nutzen Sie den Parameter pFilter.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process replicates an existing cube. It can include\
    \ data & rules too.\n\n# Use case: Intended for development/prototyping.\n# 1. Take a snapshot\
    \ of cube data copying all rules to values.\n# 2. Take an exact copy of a cube in a 'one\
    \ click action' as a starting point for prototyping rule changes or developing new features.\n\
    \n# Note:\n# * There are parameter options to include data (pIncludeData) and rules (pIncludeRules)\
    \ with the creation of the cube.\n# * If the source cube (pSrcCube) is left blank or doesn't\
    \ exist in the model, process will terminate withoud doing anything.\n# * If the target\
    \ cube (pTgtCube) already exists in the model, process will terminate withoud doing anything.\n\
    # * If the target cube is left blank or is the same as the source cube the cloned cube will\
    \ inherit the source cube name with '_Clone' appended.\n# * If the source cube data only\
    \ needs to be partially copied, then the pFilter parameter should be entered otherwise all\
    \ other parameters can be left as is.\n# * In productive systems this process may be called\
    \ internally by other processes (}bedrock.cube.data.copy, }bedrock.cube.data.copy.intercube)\
    \ if copying data via intermediate cloned cube.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pSrcCube:%pSrcCube%, pTgtCube:%pTgtCube%, pIncludeRules:%pIncludeRules%,\
    \ pIncludeData:%pIncludeData%, pFilter:%pFilter%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%, pSuppressRules:%pSuppressRules%, pTemp:%pTemp%, pCubeLogging:%pCubeLogging%.'\
    \ ;   \ncDimCountMax    = 30 ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Initialise ###\nnErrors         = 0;\nnDataCheck\
    \      = 0;\nsDimCountMax    = NumberToString( cDimCountMax );\nsDimsString     = '';\n\
    sDelim          = '+';\n\n### Validate Parameters ###\n\n## Default filter delimiters\n\
    If( pDimDelim     @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n\
    \    pEleStartDelim= '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\n\
    EndIf;\n\n# Validate source cube\nIf( Trim( pSrcCube ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    ElseIf( CubeExists( pSrcCube ) = 0 );    \n    sMessage = Expand( 'Invalid source cube specified:\
    \ %pSrcCube%.' );\n    nErrors = 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate target cube\nIf( pTgtCube @= '' % pTgtCube @= pSrcCube );\n\
    \    pTgtCube = pSrcCube | '_Clone';\nEndIf;\nIf( CubeExists( pTgtCube ) = 1 );    \n  \
    \  sMessage = Expand( 'Invalid target cube : %pTgtCube%.' );\n    nErrors = 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Create the clone cube ###\n\
    nDimCount = 1;\nWhile( TabDim( pSrcCube, nDimCount ) @<> '' );\n  sDimName = TabDim (pSrcCube,\
    \ nDimCount);\n  sDimsString = sDimsString | sDimName | sDelim;\n  nDimCount = nDimCount\
    \ + 1;\nEnd;\nnDimCount = nDimCount - 1;\nsDimsString = Subst(sDimsString,1,long(sDimsString)-long(sDelim));\n\
    \nIf( nDimCount > cDimCountMax );\n  nErrors = 1;\n  sMessage = Expand( 'Cube has too many\
    \ dimensions: %pSrcCube% max %sDimCountMax% dims catered for, TI must be altered to accomodate.'\
    \ );\n  DataSourceType = 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsProc\
    \ = '}bedrock.cube.create';\nnRet = ExecuteProcess( sProc,\n  'pLogOutput', pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n  'pCube', pTgtCube,\n  'pDims', sDimsString,\n\
    \  'pRecreate', 1,\n  'pDelim', sDelim\n  );\n\nIF(nRet <> 0);\n  sMessage = 'Error creating\
    \ the target cube.';\n  nErrors = 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nENDIF;\n\n\n### copy data ####\nIf( pIncludeData = 1 );\nnRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n  \t\
    'pSrcCube',pSrcCube,\n  \t'pFilter',pFilter,\n  \t'pTgtCube',pTgtCube,\n  \t'pMappingToNewDims','',\n\
    \  \t'pSuppressConsol',1,\n  \t'pSuppressRules',pSuppressRules,\n  \t'pZeroTarget',0,\n\
    \  \t'pZeroSource',0,\n  \t'pFactor',1,\n    'pDimDelim', pDimDelim,\n    'pEleStartDelim',\
    \ pEleStartDelim,\n    'pEleDelim', pEleDelim,\n    'pTemp', pTemp,\n    'pCubeLogging',\
    \ pCubeLogging);\n\n  IF(nRet <> 0);\n    sMessage = 'Error copying data.';\n    nErrors\
    \ = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    If(\
    \ pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\n  ENDIF;\n\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n\n\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Attach\
    \ rules to cloned cube ###\nIf( nErrors = 0 & pIncludeRules = 1 );\n  sRuleFile = pSrcCube\
    \ | '.rux';\n  If( FileExists( sRuleFile ) = 1 );\n    If( nErrors = 0 );\n      RuleLoadFromFile(\
    \ pTgtCube, sRuleFile );\n    EndIf;\n  EndIf;\nEndIf;\n    \n### Return code & final error\
    \ message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1\
    \ error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned the %pSrcCube%\
    \ cube to %pTgtCube%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that replicates an existing cube. The process
    should include options to incorporate both data and rules. This process is primarily intended
    for development and prototyping purposes. It includes: 1. Taking a snapshot of the cube
    data with all rules converted to values, 2. Making an exact copy of a cube in a single step
    as a starting point for rule changes or developing new features. Please note: There are
    parameter options to include data (pIncludeData) and rules (pIncludeRules) in the creation.
    If the source cube (pSrcCube) is left blank or doesn''t exist, the process will terminate
    without any action. Similarly, if the target cube (pTgtCube) already exists, the process
    will stop. If the target cube is left blank or is the same as the source cube, the cloned
    cube will inherit the source cube name with ''_Clone'' appended. If only partial data from
    the source cube is needed, use the pFilter parameter.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process replicates an existing cube. It can include\
    \ data & rules too.\n\n# Use case: Intended for development/prototyping.\n# 1. Take a snapshot\
    \ of cube data copying all rules to values.\n# 2. Take an exact copy of a cube in a 'one\
    \ click action' as a starting point for prototyping rule changes or developing new features.\n\
    \n# Note:\n# * There are parameter options to include data (pIncludeData) and rules (pIncludeRules)\
    \ with the creation of the cube.\n# * If the source cube (pSrcCube) is left blank or doesn't\
    \ exist in the model, process will terminate withoud doing anything.\n# * If the target\
    \ cube (pTgtCube) already exists in the model, process will terminate withoud doing anything.\n\
    # * If the target cube is left blank or is the same as the source cube the cloned cube will\
    \ inherit the source cube name with '_Clone' appended.\n# * If the source cube data only\
    \ needs to be partially copied, then the pFilter parameter should be entered otherwise all\
    \ other parameters can be left as is.\n# * In productive systems this process may be called\
    \ internally by other processes (}bedrock.cube.data.copy, }bedrock.cube.data.copy.intercube)\
    \ if copying data via intermediate cloned cube.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pSrcCube:%pSrcCube%, pTgtCube:%pTgtCube%, pIncludeRules:%pIncludeRules%,\
    \ pIncludeData:%pIncludeData%, pFilter:%pFilter%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%, pSuppressRules:%pSuppressRules%, pTemp:%pTemp%, pCubeLogging:%pCubeLogging%.'\
    \ ;   \ncDimCountMax    = 30 ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Initialise ###\nnErrors         = 0;\nnDataCheck\
    \      = 0;\nsDimCountMax    = NumberToString( cDimCountMax );\nsDimsString     = '';\n\
    sDelim          = '+';\n\n### Validate Parameters ###\n\n## Default filter delimiters\n\
    If( pDimDelim     @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n\
    \    pEleStartDelim= '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\n\
    EndIf;\n\n# Validate source cube\nIf( Trim( pSrcCube ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    ElseIf( CubeExists( pSrcCube ) = 0 );    \n    sMessage = Expand( 'Invalid source cube specified:\
    \ %pSrcCube%.' );\n    nErrors = 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate target cube\nIf( pTgtCube @= '' % pTgtCube @= pSrcCube );\n\
    \    pTgtCube = pSrcCube | '_Clone';\nEndIf;\nIf( CubeExists( pTgtCube ) = 1 );    \n  \
    \  sMessage = Expand( 'Invalid target cube : %pTgtCube%.' );\n    nErrors = 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Create the clone cube ###\n\
    nDimCount = 1;\nWhile( TabDim( pSrcCube, nDimCount ) @<> '' );\n  sDimName = TabDim (pSrcCube,\
    \ nDimCount);\n  sDimsString = sDimsString | sDimName | sDelim;\n  nDimCount = nDimCount\
    \ + 1;\nEnd;\nnDimCount = nDimCount - 1;\nsDimsString = Subst(sDimsString,1,long(sDimsString)-long(sDelim));\n\
    \nIf( nDimCount > cDimCountMax );\n  nErrors = 1;\n  sMessage = Expand( 'Cube has too many\
    \ dimensions: %pSrcCube% max %sDimCountMax% dims catered for, TI must be altered to accomodate.'\
    \ );\n  DataSourceType = 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsProc\
    \ = '}bedrock.cube.create';\nnRet = ExecuteProcess( sProc,\n  'pLogOutput', pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n  'pCube', pTgtCube,\n  'pDims', sDimsString,\n\
    \  'pRecreate', 1,\n  'pDelim', sDelim\n  );\n\nIF(nRet <> 0);\n  sMessage = 'Error creating\
    \ the target cube.';\n  nErrors = 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nENDIF;\n\n\n### copy data ####\nIf( pIncludeData = 1 );\nnRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n  \t\
    'pSrcCube',pSrcCube,\n  \t'pFilter',pFilter,\n  \t'pTgtCube',pTgtCube,\n  \t'pMappingToNewDims','',\n\
    \  \t'pSuppressConsol',1,\n  \t'pSuppressRules',pSuppressRules,\n  \t'pZeroTarget',0,\n\
    \  \t'pZeroSource',0,\n  \t'pFactor',1,\n    'pDimDelim', pDimDelim,\n    'pEleStartDelim',\
    \ pEleStartDelim,\n    'pEleDelim', pEleDelim,\n    'pTemp', pTemp,\n    'pCubeLogging',\
    \ pCubeLogging);\n\n  IF(nRet <> 0);\n    sMessage = 'Error copying data.';\n    nErrors\
    \ = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    If(\
    \ pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\n  ENDIF;\n\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n\n\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Attach\
    \ rules to cloned cube ###\nIf( nErrors = 0 & pIncludeRules = 1 );\n  sRuleFile = pSrcCube\
    \ | '.rux';\n  If( FileExists( sRuleFile ) = 1 );\n    If( nErrors = 0 );\n      RuleLoadFromFile(\
    \ pTgtCube, sRuleFile );\n    EndIf;\n  EndIf;\nEndIf;\n    \n### Return code & final error\
    \ message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1\
    \ error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned the %pSrcCube%\
    \ cube to %pTgtCube%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der automatisch einen Würfel basierend
    auf einer durch Trennzeichen getrennten Zeichenkette von Dimensionsnamen erstellt. Verwende
    diesen Prozess für Entwicklungszwecke oder Prototyping, um schnell einen Würfel für eine
    Demo oder Entwicklung zu erstellen. Beachte, dass der Parameter pDims die Dimensionenliste
    enthält und obligatorisch ist. Das Format des pDims-Parameters verwendet ''&'' als Trennzeichen
    (z.B. Dim1 & Dim2 & Dim3). Leerzeichen werden ignoriert, um die Lesbarkeit des Filters zu
    verbessern. Die Reihenfolge der Dimensionenliste bestimmt die anfängliche Indexreihenfolge
    der Dimensionen im Würfel. Der pRecreate-Parameter ist optional und für die Neuerstellung
    von Würfeln gedacht: Wenn ein Würfel bereits existiert und pRecreate auf 0 gesetzt ist,
    wird der Prozess abgebrochen. Wenn ein Würfel bereits existiert und pRecreate auf 1 gesetzt
    ist, wird der alte Würfel zerstört und mit der angegebenen Dimensionalität neu erstellt.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description: \n# This process automatically creates a cube based on a\
    \ delimited string of dimension names.\n\n# Use case: Intended for development/prototyping.\n\
    # 1/ This can be used to quickly create a cube for a demo or development.\n\n# Note:\n#\
    \ The pDims parameter contains the dimenson list and is mandatory.\n# The format of the\
    \ pDims parameter is as follows for delimiter of '&' (e.g. Dim1 & Dim2 & Dim3 ).\n# Spaces\
    \ are ignored so use them to make your filter more readable.\n# The order of the dimension\
    \ list specifies the initial index order of dimensions in the cube.\n# pRecreate is an optional\
    \ parameter for creating new cubes:\n# - If a cube already exists and pRecreate is set to\
    \ 0 then the process will abort.\n# - If a cube already exists and pRecreate is set to 1\
    \ then the process will destroy the old cube and recreate with the specified dimensionality.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncDelimDim         = TRIM(pDelim);\n\
    nDims             = 0;\nnDimMax           = 100;\nnErrors           = 0;\nsMessage     \
    \     = '';\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo         \
    \ = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDims:%pDims%, pRecreate:%pRecreate%,\
    \ pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n## Validate the Cube parameter\nIf( TRIM(pCube) @=\
    \ '' );\n  sMessage = 'A cube name must be provided.';\n  nErrors = nErrors + 1;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If specified cube exists and\
    \ recreate option not set to true then terminate process\nIf( CubeExists(   pCube   ) =\
    \ 1 );\n  If( pRecreate <> 1 );\n    sMessage = Expand( 'Cube %pCube% already exists. Aborting\
    \ cube create.' );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  EndIf;\nEndIf;\n\n# Check the delimiter\nIf( cDelimDim @= '' );\n    cDelimDim\
    \ = '&';\nEndIf;\n\n# Check the dimension list can't be empty\nIf( pDims @= '' );\n  sMessage\
    \ = 'The dimension list is blank.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check the dimension list must contain delimiter\n\
    If( Scan( cDelimDim, pDims ) < 2 );\n  sMessage = 'The dimension list must contain at least\
    \ 2 dimension names separated by the delimiter.';\n  nErrors = nErrors + 1;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Initialise the dimension\
    \ variables ###\nsDim01 = '';\nsDim02 = '';\nsDim03 = '';\nsDim04 = '';\nsDim05 = '';\n\
    sDim06 = '';\nsDim07 = '';\nsDim08 = '';\nsDim09 = '';\nsDim10 = '';\nsDim11 = '';\nsDim12\
    \ = '';\nsDim13 = '';\nsDim14 = '';\nsDim15 = '';\nsDim16 = '';\nsDim17 = '';\nsDim18 =\
    \ '';\nsDim19 = '';\nsDim20 = '';\nsDim21 = '';\nsDim22 = '';\nsDim23 = '';\nsDim24 = '';\n\
    sDim25 = '';\nsDim26 = '';\nsDim27 = '';\nsDim28 = '';\nsDim29 = '';\nsDim30 = '';\nsDim31\
    \ = '';\nsDim32 = '';\nsDim33 = '';\nsDim34 = '';\nsDim35 = '';\nsDim36 = '';\nsDim37 =\
    \ '';\nsDim38 = '';\nsDim39 = '';\nsDim40 = '';\nsDim41 = '';\nsDim42 = '';\nsDim43 = '';\n\
    sDim44 = '';\nsDim45 = '';\nsDim46 = '';\nsDim47 = '';\nsDim48 = '';\nsDim49 = '';\nsDim50\
    \ = '';\nsDim51 = '';\nsDim52 = '';\nsDim53 = '';\nsDim54 = '';\nsDim55 = '';\nsDim56 =\
    \ '';\nsDim57 = '';\nsDim58 = '';\nsDim59 = '';\nsDim60 = '';\nsDim61 = '';\nsDim62 = '';\n\
    sDim63 = '';\nsDim64 = '';\nsDim65 = '';\nsDim66 = '';\nsDim67 = '';\nsDim68 = '';\nsDim69\
    \ = '';\nsDim70 = '';\nsDim71 = '';\nsDim72 = '';\nsDim73 = '';\nsDim74 = '';\nsDim75 =\
    \ '';\nsDim76 = '';\nsDim77 = '';\nsDim78 = '';\nsDim79 = '';\nsDim80 = '';\nsDim81 = '';\n\
    sDim82 = '';\nsDim83 = '';\nsDim84 = '';\nsDim85 = '';\nsDim86 = '';\nsDim87 = '';\nsDim88\
    \ = '';\nsDim89 = '';\nsDim90 = '';\nsDim91 = '';\nsDim92 = '';\nsDim93 = '';\nsDim94 =\
    \ '';\nsDim95 = '';\nsDim96 = '';\nsDim97 = '';\nsDim98 = '';\nsDim99 = '';\nsDim100 = '';\n\
    \n### Split delimited dimension list and count number of dimensions ###\nsDims = TRIM( pDims\
    \ );\nnDelimIndex = 1;\n\nWhile( nDelimIndex > 0 & Long( sDims ) > 0 );\n\n  nDelimIndex\
    \ = Scan( cDelimDim, sDims );\n  If( nDelimIndex > 0 );\n    sDim = Trim( SubSt( sDims,\
    \ 1, nDelimIndex - 1 ) );\n    sDims = Trim( SubSt( sDims, nDelimIndex + Long( cDelimDim\
    \ ), Long( sDims ) ) );\n  Else;\n    sDim = Trim( sDims );\n  EndIf;\n\n  If( DimensionExists(\
    \ sDim ) = 1 );\n    # sDim recognized as a dimension, increment the dim counter and set\
    \ the dim name variable (how we wish Expand worked on the LHS of = ...)\n    nDims = nDims\
    \ + 1;\n    If( nDims > nDimMax );\n      sMessage = 'Maximum number of dimensions exceeded.\
    \ Aborting';\n      nErrors = nErrors + 1;\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\n    If( nDims = 1 );\n      sDim01 = sDim;\n    ElseIf( nDims = 2 );\n\
    \      sDim02 = sDim;\n    ElseIf( nDims = 3 );\n      sDim03 = sDim;\n    ElseIf( nDims\
    \ = 4 );\n      sDim04 = sDim;\n    ElseIf( nDims = 5 );\n      sDim05 = sDim;\n    ElseIf(\
    \ nDims = 6 );\n      sDim06 = sDim;\n    ElseIf( nDims = 7 );\n      sDim07 = sDim;\n \
    \   ElseIf( nDims = 8 );\n      sDim08 = sDim;\n    ElseIf( nDims = 9 );\n      sDim09 =\
    \ sDim;\n    ElseIf( nDims = 10 );\n      sDim10 = sDim;\n    ElseIf( nDims = 11 );\n  \
    \    sDim11 = sDim;\n    ElseIf( nDims = 12 );\n      sDim12 = sDim;\n    ElseIf( nDims\
    \ = 13 );\n      sDim13 = sDim;\n    ElseIf( nDims = 14 );\n      sDim14 = sDim;\n    ElseIf(\
    \ nDims = 15 );\n      sDim15 = sDim;\n    ElseIf( nDims = 16 );\n      sDim16 = sDim;\n\
    \    ElseIf( nDims = 17 );\n      sDim17 = sDim;\n    ElseIf( nDims = 18 );\n      sDim18\
    \ = sDim;\n    ElseIf( nDims = 19 );\n      sDim19 = sDim;\n    ElseIf( nDims = 20 );\n\
    \      sDim20 = sDim;\n    ElseIf( nDims = 21 );\n      sDim21 = sDim;\n    ElseIf( nDims\
    \ = 22 );\n      sDim22 = sDim;\n    ElseIf( nDims = 23 );\n      sDim23 = sDim;\n    ElseIf(\
    \ nDims = 24 );\n      sDim24 = sDim;\n    ElseIf( nDims = 25 );\n      sDim25 = sDim;\n\
    \    ElseIf( nDims = 26 );\n      sDim26 = sDim;\n    ElseIf( nDims = 27 );\n      sDim27\
    \ = sDim;\n    ElseIf( nDims = 28 );\n      sDim28 = sDim;\n    ElseIf( nDims = 29 );\n\
    \      sDim29 = sDim;\n    ElseIf( nDims = 30 );\n      sDim30 = sDim;\n    ElseIf( nDims\
    \ = 31 );\n      sDim31 = sDim;\n    ElseIf( nDims = 32 );\n      sDim32 = sDim;\n    ElseIf(\
    \ nDims = 33 );\n      sDim33 = sDim;\n    ElseIf( nDims = 34 );\n      sDim34 = sDim;\n\
    \    ElseIf( nDims = 35 );\n      sDim35 = sDim;\n    ElseIf( nDims = 36 );\n      sDim36\
    \ = sDim;\n    ElseIf( nDims = 37 );\n      sDim37 = sDim;\n    ElseIf( nDims = 38 );\n\
    \      sDim38 = sDim;\n    ElseIf( nDims = 39 );\n      sDim39 = sDim;\n    ElseIf( nDims\
    \ = 40 );\n      sDim40 = sDim;\n    ElseIf( nDims = 41 );\n      sDim41 = sDim;\n    ElseIf(\
    \ nDims = 42 );\n      sDim42 = sDim;\n    ElseIf( nDims = 43 );\n      sDim43 = sDim;\n\
    \    ElseIf( nDims = 44 );\n      sDim44 = sDim;\n    ElseIf( nDims = 45 );\n      sDim45\
    \ = sDim;\n    ElseIf( nDims = 46 );\n      sDim46 = sDim;\n    ElseIf( nDims = 47 );\n\
    \      sDim47 = sDim;\n    ElseIf( nDims = 48 );\n      sDim48 = sDim;\n    ElseIf( nDims\
    \ = 49 );\n      sDim49 = sDim;\n    ElseIf( nDims = 50 );\n      sDim50 = sDim;\n    ElseIf(\
    \ nDims = 51 );\n      sDim51 = sDim;\n    ElseIf( nDims = 52 );\n      sDim52 = sDim;\n\
    \    ElseIf( nDims = 53 );\n      sDim53 = sDim;\n    ElseIf( nDims = 54 );\n      sDim54\
    \ = sDim;\n    ElseIf( nDims = 55 );\n      sDim55 = sDim;\n    ElseIf( nDims = 56 );\n\
    \      sDim56 = sDim;\n    ElseIf( nDims = 57 );\n      sDim57 = sDim;\n    ElseIf( nDims\
    \ = 58 );\n      sDim58 = sDim;\n    ElseIf( nDims = 59 );\n      sDim59 = sDim;\n    ElseIf(\
    \ nDims = 60 );\n      sDim60 = sDim;\n    ElseIf( nDims = 61 );\n      sDim61 = sDim;\n\
    \    ElseIf( nDims = 62 );\n      sDim62 = sDim;\n    ElseIf( nDims = 63 );\n      sDim63\
    \ = sDim;\n    ElseIf( nDims = 64 );\n      sDim64 = sDim;\n    ElseIf( nDims = 65 );\n\
    \      sDim65 = sDim;\n    ElseIf( nDims = 66 );\n      sDim66 = sDim;\n    ElseIf( nDims\
    \ = 67 );\n      sDim67 = sDim;\n    ElseIf( nDims = 68 );\n      sDim68 = sDim;\n    ElseIf(\
    \ nDims = 69 );\n      sDim69 = sDim;\n    ElseIf( nDims = 70 );\n      sDim70 = sDim;\n\
    \    ElseIf( nDims = 71 );\n      sDim71 = sDim;\n    ElseIf( nDims = 72 );\n      sDim72\
    \ = sDim;\n    ElseIf( nDims = 73 );\n      sDim73 = sDim;\n    ElseIf( nDims = 74 );\n\
    \      sDim74 = sDim;\n    ElseIf( nDims = 75 );\n      sDim75 = sDim;\n    ElseIf( nDims\
    \ = 76 );\n      sDim76 = sDim;\n    ElseIf( nDims = 77 );\n      sDim77 = sDim;\n    ElseIf(\
    \ nDims = 78 );\n      sDim78 = sDim;\n    ElseIf( nDims = 79 );\n      sDim79 = sDim;\n\
    \    ElseIf( nDims = 80 );\n      sDim80 = sDim;\n    ElseIf( nDims = 81 );\n      sDim81\
    \ = sDim;\n    ElseIf( nDims = 82 );\n      sDim82 = sDim;\n    ElseIf( nDims = 83 );\n\
    \      sDim83 = sDim;\n    ElseIf( nDims = 84 );\n      sDim84 = sDim;\n    ElseIf( nDims\
    \ = 85 );\n      sDim85 = sDim;\n    ElseIf( nDims = 86 );\n      sDim86 = sDim;\n    ElseIf(\
    \ nDims = 87 );\n      sDim87 = sDim;\n    ElseIf( nDims = 88 );\n      sDim88 = sDim;\n\
    \    ElseIf( nDims = 89 );\n      sDim89 = sDim;\n    ElseIf( nDims = 90 );\n      sDim90\
    \ = sDim;\n    ElseIf( nDims = 91 );\n      sDim91 = sDim;\n    ElseIf( nDims = 92 );\n\
    \      sDim92 = sDim;\n    ElseIf( nDims = 93 );\n      sDim93 = sDim;\n    ElseIf( nDims\
    \ = 94 );\n      sDim94 = sDim;\n    ElseIf( nDims = 95 );\n      sDim95 = sDim;\n    ElseIf(\
    \ nDims = 96 );\n      sDim96 = sDim;\n    ElseIf( nDims = 97 );\n      sDim97 = sDim;\n\
    \    ElseIf( nDims = 98 );\n      sDim98 = sDim;\n    ElseIf( nDims = 99 );\n      sDim99\
    \ = sDim;\n    ElseIf( nDims = 100 );\n      sDim100 = sDim;\n    EndIf;   \n\n  Else;\n\
    \n    # sDim not recognized as valid dimension\n    sMessage = Expand( '%sDim% not recognized\
    \ as valid dimension.' );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n  EndIf;\n\nEnd;\n\n### Create the cube ###\n\nIf( nDims < 2 );\n\
    \  sMessage = 'Number of dimesnions specified is less than 2';\n  nErrors = nErrors + 1;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nIf( CubeExists( pCube ) = 1 & pRecreate\
    \ = 1 );\n  CubeDestroy( pCube );\nEndIf;\n\nIf( nDims = 2 );\n  CubeCreate( Trim( pCube\
    \ ), sDim01, sDim02 );\nElseIf( nDims = 3 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02,\
    \ sDim03 );\nElseIf( nDims = 4 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03,\
    \ sDim04 );\nElseIf( nDims = 5 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03,\
    \ sDim04, sDim05 );\nElseIf( nDims = 6 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02,\
    \ sDim03, sDim04, sDim05, sDim06 );\nElseIf( nDims = 7 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07 );\nElseIf( nDims = 8 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08 );\nElseIf(\
    \ nDims = 9 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09 );\nElseIf( nDims = 10 );\n  CubeCreate( Trim( pCube ), sDim01,\
    \ sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10 );\nElseIf( nDims\
    \ = 11 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11 );\nElseIf( nDims = 12 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12 );\nElseIf( nDims = 13 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02,\
    \ sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13\
    \ );\nElseIf( nDims = 14 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14 );\nElseIf(\
    \ nDims = 15 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15 );\nElseIf( nDims\
    \ = 16 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16 );\nElseIf(\
    \ nDims = 17 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17\
    \ );\nElseIf( nDims = 18 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18 );\nElseIf( nDims = 19 );\n  CubeCreate( Trim( pCube ), sDim01,\
    \ sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12,\
    \ sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19 );\nElseIf( nDims = 20 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20\
    \ );\nElseIf( nDims = 21 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21 );\nElseIf( nDims = 22 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22 );\nElseIf( nDims = 23 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02,\
    \ sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13,\
    \ sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23 );\nElseIf(\
    \ nDims = 24 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24 );\nElseIf( nDims = 25 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25 );\nElseIf( nDims = 26 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26 );\nElseIf( nDims = 27 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27 );\nElseIf( nDims = 28 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28 );\nElseIf( nDims = 29\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29\
    \ );\nElseIf( nDims = 30 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30 );\nElseIf( nDims = 31 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31 );\nElseIf( nDims\
    \ = 32 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32 );\nElseIf( nDims = 33 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33\
    \ );\nElseIf( nDims = 34 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34 );\nElseIf( nDims = 35\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35 );\nElseIf( nDims = 36 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36 );\nElseIf( nDims = 37 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37 );\nElseIf( nDims = 38 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38 );\nElseIf( nDims = 39 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39 );\nElseIf( nDims = 40\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40\
    \ );\nElseIf( nDims = 41 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41 );\nElseIf( nDims = 42 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42 );\nElseIf( nDims\
    \ = 43 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43 );\nElseIf( nDims = 44 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44\
    \ );\nElseIf( nDims = 45 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45 );\nElseIf( nDims = 46\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46 );\nElseIf( nDims = 47 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47 );\nElseIf( nDims = 48 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48 );\nElseIf( nDims = 49 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49 );\nElseIf( nDims = 50 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50 );\nElseIf( nDims = 51\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51\
    \ );\nElseIf( nDims = 52 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52 );\nElseIf( nDims = 53 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53 );\nElseIf( nDims\
    \ = 54 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50,\
    \ sDim51, sDim52, sDim53, sDim54 );\nElseIf( nDims = 55 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55\
    \ );\nElseIf( nDims = 56 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56 );\nElseIf( nDims = 57\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57 );\nElseIf( nDims = 58 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58 );\nElseIf( nDims = 59 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59 );\nElseIf( nDims = 60 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60 );\nElseIf( nDims = 61 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61 );\nElseIf( nDims = 62\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62\
    \ );\nElseIf( nDims = 63 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63 );\nElseIf( nDims = 64 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64 );\nElseIf( nDims\
    \ = 65 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50,\
    \ sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61,\
    \ sDim62, sDim63, sDim64, sDim65 );\nElseIf( nDims = 66 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66\
    \ );\nElseIf( nDims = 67 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67 );\nElseIf( nDims = 68\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68 );\nElseIf( nDims = 69 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69 );\nElseIf( nDims = 70 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70 );\nElseIf( nDims = 71 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70, sDim71 );\nElseIf( nDims = 72 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72 );\nElseIf( nDims = 73\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73\
    \ );\nElseIf( nDims = 74 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74 );\nElseIf( nDims = 75 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75 );\nElseIf( nDims\
    \ = 76 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50,\
    \ sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61,\
    \ sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72,\
    \ sDim73, sDim74, sDim75, sDim76 );\nElseIf( nDims = 77 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77\
    \ );\nElseIf( nDims = 78 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77, sDim78 );\nElseIf( nDims = 79\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73,\
    \ sDim74, sDim75, sDim76, sDim77, sDim78, sDim79 );\nElseIf( nDims = 80 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75,\
    \ sDim76, sDim77, sDim78, sDim79, sDim80 );\nElseIf( nDims = 81 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76,\
    \ sDim77, sDim78, sDim79, sDim80, sDim81 );\nElseIf( nDims = 82 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76,\
    \ sDim77, sDim78, sDim79, sDim80, sDim81, sDim82 );\nElseIf( nDims = 83 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75,\
    \ sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83 );\nElseIf( nDims = 84\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73,\
    \ sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84\
    \ );\nElseIf( nDims = 85 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81,\
    \ sDim82, sDim83, sDim84, sDim85 );\nElseIf( nDims = 86 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77,\
    \ sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86 );\nElseIf( nDims\
    \ = 87 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50,\
    \ sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61,\
    \ sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72,\
    \ sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83,\
    \ sDim84, sDim85, sDim86, sDim87 );\nElseIf( nDims = 88 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77,\
    \ sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88\
    \ );\nElseIf( nDims = 89 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81,\
    \ sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88, sDim89 );\nElseIf( nDims = 90\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73,\
    \ sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84,\
    \ sDim85, sDim86, sDim87, sDim88, sDim89, sDim90 );\nElseIf( nDims = 91 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75,\
    \ sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86,\
    \ sDim87, sDim88, sDim89, sDim90, sDim91 );\nElseIf( nDims = 92 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76,\
    \ sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86, sDim87,\
    \ sDim88, sDim89, sDim90, sDim91, sDim92 );\nElseIf( nDims = 93 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76,\
    \ sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86, sDim87,\
    \ sDim88, sDim89, sDim90, sDim91, sDim92, sDim93 );\nElseIf( nDims = 94 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75,\
    \ sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86,\
    \ sDim87, sDim88, sDim89, sDim90, sDim91, sDim92, sDim93, sDim94 );\nElseIf( nDims = 95\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73,\
    \ sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84,\
    \ sDim85, sDim86, sDim87, sDim88, sDim89, sDim90, sDim91, sDim92, sDim93, sDim94, sDim95\
    \ );\nElseIf( nDims = 96 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81,\
    \ sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88, sDim89, sDim90, sDim91, sDim92,\
    \ sDim93, sDim94, sDim95, sDim96 );\nElseIf( nDims = 97 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77,\
    \ sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88,\
    \ sDim89, sDim90, sDim91, sDim92, sDim93, sDim94, sDim95, sDim96, sDim97 );\nElseIf( nDims\
    \ = 98 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50,\
    \ sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61,\
    \ sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72,\
    \ sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83,\
    \ sDim84, sDim85, sDim86, sDim87, sDim88, sDim89, sDim90, sDim91, sDim92, sDim93, sDim94,\
    \ sDim95, sDim96, sDim97, sDim98 );\nElseIf( nDims = 99 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77,\
    \ sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88,\
    \ sDim89, sDim90, sDim91, sDim92, sDim93, sDim94, sDim95, sDim96, sDim97, sDim98, sDim99\
    \ );\nElseIf( nDims = 100 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81,\
    \ sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88, sDim89, sDim90, sDim91, sDim92,\
    \ sDim93, sDim94, sDim95, sDim96, sDim97, sDim98, sDim99, sDim100 );\nEndIf;\n\n\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created %pCube% with %pDims%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );  "
- question: 'Develop an IBM Turbo Integrator process that automatically creates a cube based
    on a delimited string of dimension names. Use this process for development purposes or prototyping
    to quickly create a cube for a demo or development. Note that the pDims parameter contains
    the dimension list and is mandatory. The format of the pDims parameter uses ''&'' as a delimiter
    (e.g., Dim1 & Dim2 & Dim3). Spaces are ignored to enhance the filter''s readability. The
    order of the dimension list specifies the initial index order of dimensions in the cube.
    The pRecreate parameter is optional and intended for creating new cubes: If a cube already
    exists and pRecreate is set to 0, the process will abort. If a cube already exists and pRecreate
    is set to 1, the old cube will be destroyed and recreated with the specified dimensionality.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description: \n# This process automatically creates a cube based on a\
    \ delimited string of dimension names.\n\n# Use case: Intended for development/prototyping.\n\
    # 1/ This can be used to quickly create a cube for a demo or development.\n\n# Note:\n#\
    \ The pDims parameter contains the dimenson list and is mandatory.\n# The format of the\
    \ pDims parameter is as follows for delimiter of '&' (e.g. Dim1 & Dim2 & Dim3 ).\n# Spaces\
    \ are ignored so use them to make your filter more readable.\n# The order of the dimension\
    \ list specifies the initial index order of dimensions in the cube.\n# pRecreate is an optional\
    \ parameter for creating new cubes:\n# - If a cube already exists and pRecreate is set to\
    \ 0 then the process will abort.\n# - If a cube already exists and pRecreate is set to 1\
    \ then the process will destroy the old cube and recreate with the specified dimensionality.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncDelimDim         = TRIM(pDelim);\n\
    nDims             = 0;\nnDimMax           = 100;\nnErrors           = 0;\nsMessage     \
    \     = '';\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo         \
    \ = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDims:%pDims%, pRecreate:%pRecreate%,\
    \ pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n## Validate the Cube parameter\nIf( TRIM(pCube) @=\
    \ '' );\n  sMessage = 'A cube name must be provided.';\n  nErrors = nErrors + 1;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If specified cube exists and\
    \ recreate option not set to true then terminate process\nIf( CubeExists(   pCube   ) =\
    \ 1 );\n  If( pRecreate <> 1 );\n    sMessage = Expand( 'Cube %pCube% already exists. Aborting\
    \ cube create.' );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  EndIf;\nEndIf;\n\n# Check the delimiter\nIf( cDelimDim @= '' );\n    cDelimDim\
    \ = '&';\nEndIf;\n\n# Check the dimension list can't be empty\nIf( pDims @= '' );\n  sMessage\
    \ = 'The dimension list is blank.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check the dimension list must contain delimiter\n\
    If( Scan( cDelimDim, pDims ) < 2 );\n  sMessage = 'The dimension list must contain at least\
    \ 2 dimension names separated by the delimiter.';\n  nErrors = nErrors + 1;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Initialise the dimension\
    \ variables ###\nsDim01 = '';\nsDim02 = '';\nsDim03 = '';\nsDim04 = '';\nsDim05 = '';\n\
    sDim06 = '';\nsDim07 = '';\nsDim08 = '';\nsDim09 = '';\nsDim10 = '';\nsDim11 = '';\nsDim12\
    \ = '';\nsDim13 = '';\nsDim14 = '';\nsDim15 = '';\nsDim16 = '';\nsDim17 = '';\nsDim18 =\
    \ '';\nsDim19 = '';\nsDim20 = '';\nsDim21 = '';\nsDim22 = '';\nsDim23 = '';\nsDim24 = '';\n\
    sDim25 = '';\nsDim26 = '';\nsDim27 = '';\nsDim28 = '';\nsDim29 = '';\nsDim30 = '';\nsDim31\
    \ = '';\nsDim32 = '';\nsDim33 = '';\nsDim34 = '';\nsDim35 = '';\nsDim36 = '';\nsDim37 =\
    \ '';\nsDim38 = '';\nsDim39 = '';\nsDim40 = '';\nsDim41 = '';\nsDim42 = '';\nsDim43 = '';\n\
    sDim44 = '';\nsDim45 = '';\nsDim46 = '';\nsDim47 = '';\nsDim48 = '';\nsDim49 = '';\nsDim50\
    \ = '';\nsDim51 = '';\nsDim52 = '';\nsDim53 = '';\nsDim54 = '';\nsDim55 = '';\nsDim56 =\
    \ '';\nsDim57 = '';\nsDim58 = '';\nsDim59 = '';\nsDim60 = '';\nsDim61 = '';\nsDim62 = '';\n\
    sDim63 = '';\nsDim64 = '';\nsDim65 = '';\nsDim66 = '';\nsDim67 = '';\nsDim68 = '';\nsDim69\
    \ = '';\nsDim70 = '';\nsDim71 = '';\nsDim72 = '';\nsDim73 = '';\nsDim74 = '';\nsDim75 =\
    \ '';\nsDim76 = '';\nsDim77 = '';\nsDim78 = '';\nsDim79 = '';\nsDim80 = '';\nsDim81 = '';\n\
    sDim82 = '';\nsDim83 = '';\nsDim84 = '';\nsDim85 = '';\nsDim86 = '';\nsDim87 = '';\nsDim88\
    \ = '';\nsDim89 = '';\nsDim90 = '';\nsDim91 = '';\nsDim92 = '';\nsDim93 = '';\nsDim94 =\
    \ '';\nsDim95 = '';\nsDim96 = '';\nsDim97 = '';\nsDim98 = '';\nsDim99 = '';\nsDim100 = '';\n\
    \n### Split delimited dimension list and count number of dimensions ###\nsDims = TRIM( pDims\
    \ );\nnDelimIndex = 1;\n\nWhile( nDelimIndex > 0 & Long( sDims ) > 0 );\n\n  nDelimIndex\
    \ = Scan( cDelimDim, sDims );\n  If( nDelimIndex > 0 );\n    sDim = Trim( SubSt( sDims,\
    \ 1, nDelimIndex - 1 ) );\n    sDims = Trim( SubSt( sDims, nDelimIndex + Long( cDelimDim\
    \ ), Long( sDims ) ) );\n  Else;\n    sDim = Trim( sDims );\n  EndIf;\n\n  If( DimensionExists(\
    \ sDim ) = 1 );\n    # sDim recognized as a dimension, increment the dim counter and set\
    \ the dim name variable (how we wish Expand worked on the LHS of = ...)\n    nDims = nDims\
    \ + 1;\n    If( nDims > nDimMax );\n      sMessage = 'Maximum number of dimensions exceeded.\
    \ Aborting';\n      nErrors = nErrors + 1;\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\n    If( nDims = 1 );\n      sDim01 = sDim;\n    ElseIf( nDims = 2 );\n\
    \      sDim02 = sDim;\n    ElseIf( nDims = 3 );\n      sDim03 = sDim;\n    ElseIf( nDims\
    \ = 4 );\n      sDim04 = sDim;\n    ElseIf( nDims = 5 );\n      sDim05 = sDim;\n    ElseIf(\
    \ nDims = 6 );\n      sDim06 = sDim;\n    ElseIf( nDims = 7 );\n      sDim07 = sDim;\n \
    \   ElseIf( nDims = 8 );\n      sDim08 = sDim;\n    ElseIf( nDims = 9 );\n      sDim09 =\
    \ sDim;\n    ElseIf( nDims = 10 );\n      sDim10 = sDim;\n    ElseIf( nDims = 11 );\n  \
    \    sDim11 = sDim;\n    ElseIf( nDims = 12 );\n      sDim12 = sDim;\n    ElseIf( nDims\
    \ = 13 );\n      sDim13 = sDim;\n    ElseIf( nDims = 14 );\n      sDim14 = sDim;\n    ElseIf(\
    \ nDims = 15 );\n      sDim15 = sDim;\n    ElseIf( nDims = 16 );\n      sDim16 = sDim;\n\
    \    ElseIf( nDims = 17 );\n      sDim17 = sDim;\n    ElseIf( nDims = 18 );\n      sDim18\
    \ = sDim;\n    ElseIf( nDims = 19 );\n      sDim19 = sDim;\n    ElseIf( nDims = 20 );\n\
    \      sDim20 = sDim;\n    ElseIf( nDims = 21 );\n      sDim21 = sDim;\n    ElseIf( nDims\
    \ = 22 );\n      sDim22 = sDim;\n    ElseIf( nDims = 23 );\n      sDim23 = sDim;\n    ElseIf(\
    \ nDims = 24 );\n      sDim24 = sDim;\n    ElseIf( nDims = 25 );\n      sDim25 = sDim;\n\
    \    ElseIf( nDims = 26 );\n      sDim26 = sDim;\n    ElseIf( nDims = 27 );\n      sDim27\
    \ = sDim;\n    ElseIf( nDims = 28 );\n      sDim28 = sDim;\n    ElseIf( nDims = 29 );\n\
    \      sDim29 = sDim;\n    ElseIf( nDims = 30 );\n      sDim30 = sDim;\n    ElseIf( nDims\
    \ = 31 );\n      sDim31 = sDim;\n    ElseIf( nDims = 32 );\n      sDim32 = sDim;\n    ElseIf(\
    \ nDims = 33 );\n      sDim33 = sDim;\n    ElseIf( nDims = 34 );\n      sDim34 = sDim;\n\
    \    ElseIf( nDims = 35 );\n      sDim35 = sDim;\n    ElseIf( nDims = 36 );\n      sDim36\
    \ = sDim;\n    ElseIf( nDims = 37 );\n      sDim37 = sDim;\n    ElseIf( nDims = 38 );\n\
    \      sDim38 = sDim;\n    ElseIf( nDims = 39 );\n      sDim39 = sDim;\n    ElseIf( nDims\
    \ = 40 );\n      sDim40 = sDim;\n    ElseIf( nDims = 41 );\n      sDim41 = sDim;\n    ElseIf(\
    \ nDims = 42 );\n      sDim42 = sDim;\n    ElseIf( nDims = 43 );\n      sDim43 = sDim;\n\
    \    ElseIf( nDims = 44 );\n      sDim44 = sDim;\n    ElseIf( nDims = 45 );\n      sDim45\
    \ = sDim;\n    ElseIf( nDims = 46 );\n      sDim46 = sDim;\n    ElseIf( nDims = 47 );\n\
    \      sDim47 = sDim;\n    ElseIf( nDims = 48 );\n      sDim48 = sDim;\n    ElseIf( nDims\
    \ = 49 );\n      sDim49 = sDim;\n    ElseIf( nDims = 50 );\n      sDim50 = sDim;\n    ElseIf(\
    \ nDims = 51 );\n      sDim51 = sDim;\n    ElseIf( nDims = 52 );\n      sDim52 = sDim;\n\
    \    ElseIf( nDims = 53 );\n      sDim53 = sDim;\n    ElseIf( nDims = 54 );\n      sDim54\
    \ = sDim;\n    ElseIf( nDims = 55 );\n      sDim55 = sDim;\n    ElseIf( nDims = 56 );\n\
    \      sDim56 = sDim;\n    ElseIf( nDims = 57 );\n      sDim57 = sDim;\n    ElseIf( nDims\
    \ = 58 );\n      sDim58 = sDim;\n    ElseIf( nDims = 59 );\n      sDim59 = sDim;\n    ElseIf(\
    \ nDims = 60 );\n      sDim60 = sDim;\n    ElseIf( nDims = 61 );\n      sDim61 = sDim;\n\
    \    ElseIf( nDims = 62 );\n      sDim62 = sDim;\n    ElseIf( nDims = 63 );\n      sDim63\
    \ = sDim;\n    ElseIf( nDims = 64 );\n      sDim64 = sDim;\n    ElseIf( nDims = 65 );\n\
    \      sDim65 = sDim;\n    ElseIf( nDims = 66 );\n      sDim66 = sDim;\n    ElseIf( nDims\
    \ = 67 );\n      sDim67 = sDim;\n    ElseIf( nDims = 68 );\n      sDim68 = sDim;\n    ElseIf(\
    \ nDims = 69 );\n      sDim69 = sDim;\n    ElseIf( nDims = 70 );\n      sDim70 = sDim;\n\
    \    ElseIf( nDims = 71 );\n      sDim71 = sDim;\n    ElseIf( nDims = 72 );\n      sDim72\
    \ = sDim;\n    ElseIf( nDims = 73 );\n      sDim73 = sDim;\n    ElseIf( nDims = 74 );\n\
    \      sDim74 = sDim;\n    ElseIf( nDims = 75 );\n      sDim75 = sDim;\n    ElseIf( nDims\
    \ = 76 );\n      sDim76 = sDim;\n    ElseIf( nDims = 77 );\n      sDim77 = sDim;\n    ElseIf(\
    \ nDims = 78 );\n      sDim78 = sDim;\n    ElseIf( nDims = 79 );\n      sDim79 = sDim;\n\
    \    ElseIf( nDims = 80 );\n      sDim80 = sDim;\n    ElseIf( nDims = 81 );\n      sDim81\
    \ = sDim;\n    ElseIf( nDims = 82 );\n      sDim82 = sDim;\n    ElseIf( nDims = 83 );\n\
    \      sDim83 = sDim;\n    ElseIf( nDims = 84 );\n      sDim84 = sDim;\n    ElseIf( nDims\
    \ = 85 );\n      sDim85 = sDim;\n    ElseIf( nDims = 86 );\n      sDim86 = sDim;\n    ElseIf(\
    \ nDims = 87 );\n      sDim87 = sDim;\n    ElseIf( nDims = 88 );\n      sDim88 = sDim;\n\
    \    ElseIf( nDims = 89 );\n      sDim89 = sDim;\n    ElseIf( nDims = 90 );\n      sDim90\
    \ = sDim;\n    ElseIf( nDims = 91 );\n      sDim91 = sDim;\n    ElseIf( nDims = 92 );\n\
    \      sDim92 = sDim;\n    ElseIf( nDims = 93 );\n      sDim93 = sDim;\n    ElseIf( nDims\
    \ = 94 );\n      sDim94 = sDim;\n    ElseIf( nDims = 95 );\n      sDim95 = sDim;\n    ElseIf(\
    \ nDims = 96 );\n      sDim96 = sDim;\n    ElseIf( nDims = 97 );\n      sDim97 = sDim;\n\
    \    ElseIf( nDims = 98 );\n      sDim98 = sDim;\n    ElseIf( nDims = 99 );\n      sDim99\
    \ = sDim;\n    ElseIf( nDims = 100 );\n      sDim100 = sDim;\n    EndIf;   \n\n  Else;\n\
    \n    # sDim not recognized as valid dimension\n    sMessage = Expand( '%sDim% not recognized\
    \ as valid dimension.' );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n  EndIf;\n\nEnd;\n\n### Create the cube ###\n\nIf( nDims < 2 );\n\
    \  sMessage = 'Number of dimesnions specified is less than 2';\n  nErrors = nErrors + 1;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nIf( CubeExists( pCube ) = 1 & pRecreate\
    \ = 1 );\n  CubeDestroy( pCube );\nEndIf;\n\nIf( nDims = 2 );\n  CubeCreate( Trim( pCube\
    \ ), sDim01, sDim02 );\nElseIf( nDims = 3 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02,\
    \ sDim03 );\nElseIf( nDims = 4 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03,\
    \ sDim04 );\nElseIf( nDims = 5 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03,\
    \ sDim04, sDim05 );\nElseIf( nDims = 6 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02,\
    \ sDim03, sDim04, sDim05, sDim06 );\nElseIf( nDims = 7 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07 );\nElseIf( nDims = 8 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08 );\nElseIf(\
    \ nDims = 9 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09 );\nElseIf( nDims = 10 );\n  CubeCreate( Trim( pCube ), sDim01,\
    \ sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10 );\nElseIf( nDims\
    \ = 11 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11 );\nElseIf( nDims = 12 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12 );\nElseIf( nDims = 13 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02,\
    \ sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13\
    \ );\nElseIf( nDims = 14 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14 );\nElseIf(\
    \ nDims = 15 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15 );\nElseIf( nDims\
    \ = 16 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16 );\nElseIf(\
    \ nDims = 17 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17\
    \ );\nElseIf( nDims = 18 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18 );\nElseIf( nDims = 19 );\n  CubeCreate( Trim( pCube ), sDim01,\
    \ sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12,\
    \ sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19 );\nElseIf( nDims = 20 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20\
    \ );\nElseIf( nDims = 21 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21 );\nElseIf( nDims = 22 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22 );\nElseIf( nDims = 23 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02,\
    \ sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13,\
    \ sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23 );\nElseIf(\
    \ nDims = 24 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24 );\nElseIf( nDims = 25 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25 );\nElseIf( nDims = 26 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26 );\nElseIf( nDims = 27 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27 );\nElseIf( nDims = 28 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28 );\nElseIf( nDims = 29\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29\
    \ );\nElseIf( nDims = 30 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30 );\nElseIf( nDims = 31 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31 );\nElseIf( nDims\
    \ = 32 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32 );\nElseIf( nDims = 33 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33\
    \ );\nElseIf( nDims = 34 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34 );\nElseIf( nDims = 35\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35 );\nElseIf( nDims = 36 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36 );\nElseIf( nDims = 37 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37 );\nElseIf( nDims = 38 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38 );\nElseIf( nDims = 39 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39 );\nElseIf( nDims = 40\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40\
    \ );\nElseIf( nDims = 41 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41 );\nElseIf( nDims = 42 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42 );\nElseIf( nDims\
    \ = 43 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43 );\nElseIf( nDims = 44 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44\
    \ );\nElseIf( nDims = 45 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45 );\nElseIf( nDims = 46\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46 );\nElseIf( nDims = 47 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47 );\nElseIf( nDims = 48 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48 );\nElseIf( nDims = 49 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49 );\nElseIf( nDims = 50 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50 );\nElseIf( nDims = 51\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51\
    \ );\nElseIf( nDims = 52 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52 );\nElseIf( nDims = 53 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53 );\nElseIf( nDims\
    \ = 54 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50,\
    \ sDim51, sDim52, sDim53, sDim54 );\nElseIf( nDims = 55 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55\
    \ );\nElseIf( nDims = 56 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56 );\nElseIf( nDims = 57\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57 );\nElseIf( nDims = 58 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58 );\nElseIf( nDims = 59 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59 );\nElseIf( nDims = 60 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60 );\nElseIf( nDims = 61 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61 );\nElseIf( nDims = 62\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62\
    \ );\nElseIf( nDims = 63 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63 );\nElseIf( nDims = 64 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64 );\nElseIf( nDims\
    \ = 65 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50,\
    \ sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61,\
    \ sDim62, sDim63, sDim64, sDim65 );\nElseIf( nDims = 66 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66\
    \ );\nElseIf( nDims = 67 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67 );\nElseIf( nDims = 68\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68 );\nElseIf( nDims = 69 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69 );\nElseIf( nDims = 70 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70 );\nElseIf( nDims = 71 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70, sDim71 );\nElseIf( nDims = 72 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72 );\nElseIf( nDims = 73\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73\
    \ );\nElseIf( nDims = 74 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74 );\nElseIf( nDims = 75 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75 );\nElseIf( nDims\
    \ = 76 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50,\
    \ sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61,\
    \ sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72,\
    \ sDim73, sDim74, sDim75, sDim76 );\nElseIf( nDims = 77 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77\
    \ );\nElseIf( nDims = 78 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77, sDim78 );\nElseIf( nDims = 79\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73,\
    \ sDim74, sDim75, sDim76, sDim77, sDim78, sDim79 );\nElseIf( nDims = 80 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75,\
    \ sDim76, sDim77, sDim78, sDim79, sDim80 );\nElseIf( nDims = 81 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76,\
    \ sDim77, sDim78, sDim79, sDim80, sDim81 );\nElseIf( nDims = 82 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76,\
    \ sDim77, sDim78, sDim79, sDim80, sDim81, sDim82 );\nElseIf( nDims = 83 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75,\
    \ sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83 );\nElseIf( nDims = 84\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73,\
    \ sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84\
    \ );\nElseIf( nDims = 85 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81,\
    \ sDim82, sDim83, sDim84, sDim85 );\nElseIf( nDims = 86 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77,\
    \ sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86 );\nElseIf( nDims\
    \ = 87 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50,\
    \ sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61,\
    \ sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72,\
    \ sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83,\
    \ sDim84, sDim85, sDim86, sDim87 );\nElseIf( nDims = 88 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77,\
    \ sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88\
    \ );\nElseIf( nDims = 89 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81,\
    \ sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88, sDim89 );\nElseIf( nDims = 90\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73,\
    \ sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84,\
    \ sDim85, sDim86, sDim87, sDim88, sDim89, sDim90 );\nElseIf( nDims = 91 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75,\
    \ sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86,\
    \ sDim87, sDim88, sDim89, sDim90, sDim91 );\nElseIf( nDims = 92 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76,\
    \ sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86, sDim87,\
    \ sDim88, sDim89, sDim90, sDim91, sDim92 );\nElseIf( nDims = 93 );\n  CubeCreate( Trim(\
    \ pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10,\
    \ sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21,\
    \ sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32,\
    \ sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43,\
    \ sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54,\
    \ sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65,\
    \ sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76,\
    \ sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86, sDim87,\
    \ sDim88, sDim89, sDim90, sDim91, sDim92, sDim93 );\nElseIf( nDims = 94 );\n  CubeCreate(\
    \ Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09,\
    \ sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20,\
    \ sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31,\
    \ sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42,\
    \ sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53,\
    \ sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64,\
    \ sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75,\
    \ sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86,\
    \ sDim87, sDim88, sDim89, sDim90, sDim91, sDim92, sDim93, sDim94 );\nElseIf( nDims = 95\
    \ );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07,\
    \ sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18,\
    \ sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29,\
    \ sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40,\
    \ sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51,\
    \ sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62,\
    \ sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73,\
    \ sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84,\
    \ sDim85, sDim86, sDim87, sDim88, sDim89, sDim90, sDim91, sDim92, sDim93, sDim94, sDim95\
    \ );\nElseIf( nDims = 96 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81,\
    \ sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88, sDim89, sDim90, sDim91, sDim92,\
    \ sDim93, sDim94, sDim95, sDim96 );\nElseIf( nDims = 97 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77,\
    \ sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88,\
    \ sDim89, sDim90, sDim91, sDim92, sDim93, sDim94, sDim95, sDim96, sDim97 );\nElseIf( nDims\
    \ = 98 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04, sDim05, sDim06,\
    \ sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15, sDim16, sDim17,\
    \ sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26, sDim27, sDim28,\
    \ sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37, sDim38, sDim39,\
    \ sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48, sDim49, sDim50,\
    \ sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59, sDim60, sDim61,\
    \ sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70, sDim71, sDim72,\
    \ sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81, sDim82, sDim83,\
    \ sDim84, sDim85, sDim86, sDim87, sDim88, sDim89, sDim90, sDim91, sDim92, sDim93, sDim94,\
    \ sDim95, sDim96, sDim97, sDim98 );\nElseIf( nDims = 99 );\n  CubeCreate( Trim( pCube ),\
    \ sDim01, sDim02, sDim03, sDim04, sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11,\
    \ sDim12, sDim13, sDim14, sDim15, sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22,\
    \ sDim23, sDim24, sDim25, sDim26, sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33,\
    \ sDim34, sDim35, sDim36, sDim37, sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44,\
    \ sDim45, sDim46, sDim47, sDim48, sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55,\
    \ sDim56, sDim57, sDim58, sDim59, sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66,\
    \ sDim67, sDim68, sDim69, sDim70, sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77,\
    \ sDim78, sDim79, sDim80, sDim81, sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88,\
    \ sDim89, sDim90, sDim91, sDim92, sDim93, sDim94, sDim95, sDim96, sDim97, sDim98, sDim99\
    \ );\nElseIf( nDims = 100 );\n  CubeCreate( Trim( pCube ), sDim01, sDim02, sDim03, sDim04,\
    \ sDim05, sDim06, sDim07, sDim08, sDim09, sDim10, sDim11, sDim12, sDim13, sDim14, sDim15,\
    \ sDim16, sDim17, sDim18, sDim19, sDim20, sDim21, sDim22, sDim23, sDim24, sDim25, sDim26,\
    \ sDim27, sDim28, sDim29, sDim30, sDim31, sDim32, sDim33, sDim34, sDim35, sDim36, sDim37,\
    \ sDim38, sDim39, sDim40, sDim41, sDim42, sDim43, sDim44, sDim45, sDim46, sDim47, sDim48,\
    \ sDim49, sDim50, sDim51, sDim52, sDim53, sDim54, sDim55, sDim56, sDim57, sDim58, sDim59,\
    \ sDim60, sDim61, sDim62, sDim63, sDim64, sDim65, sDim66, sDim67, sDim68, sDim69, sDim70,\
    \ sDim71, sDim72, sDim73, sDim74, sDim75, sDim76, sDim77, sDim78, sDim79, sDim80, sDim81,\
    \ sDim82, sDim83, sDim84, sDim85, sDim86, sDim87, sDim88, sDim89, sDim90, sDim91, sDim92,\
    \ sDim93, sDim94, sDim95, sDim96, sDim97, sDim98, sDim99, sDim100 );\nEndIf;\n\n\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created %pCube% with %pDims%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );  "
- question: 'Beschreiben Sie einen IBM Turbo Integrator Prozess zur Löschung bestimmter Daten
    aus einem Cube, bevor Daten in diesen Cube kopiert werden. Der Prozess wird hauptsächlich
    in Produktionssystemen eingesetzt. Er wird im Prolog von benutzerdefinierten Prozessen aufgerufen,
    bevor eine Datenquelle abgefragt wird, um die Cube-Daten zu aktualisieren. Während der Entwicklung
    oder Prototyping kann dieser Prozess manuell ausgeführt werden, um einen Teil eines Cubes
    zu leeren. Es können Wildcards verwendet oder eine Liste von Cubes angegeben werden, um
    Daten aus mehreren Cubes gleichzeitig zu löschen. Wenn kein Cube (pCube) oder ein ungültiger
    Cube angegeben wird, wird der Prozess abgebrochen. ACHTUNG: Wenn weder ein View (pView)
    noch ein Filter (pFilter) angegeben wird, werden die gesamten Cube-Daten gelöscht. Wenn
    ein gültiger View angegeben ist, werden einfach nur die Daten in diesem View auf Null gesetzt,
    und ein etwaiger Filter (pFilter) wird ignoriert. Wenn kein gültiger View angegeben ist,
    wird basierend auf dem Filter ein temporärer View erstellt, dessen Daten gelöscht werden.
    Der Filter kann spezifische Elemente für beliebig viele Dimensionen und Elemente verarbeiten.
    Der Parameter pFilter enthält die Dimension und die zu filternden Elemente. Die Namen der
    Dimensionen müssen nicht in der Reihenfolge der Indexe im Cube angegeben werden. Der Dimensionsname
    wird als erstes Mitglied der durch Trennzeichen getrennten Zeichenfolge von Elementen angegeben.
    Wenn der Parameter pFilterParallel verwendet wird, darf die **einzelne Dimension**, die
    als ''Parallelisierungsscherber'' verwendet wird, nicht in den pFilter-Parametern erscheinen.
    Beim Einsatz der Parallelisierung über die Funktion *RunProcess* werden die in pFilterParallel
    aufgelisteten Elemente eins nach dem anderen aufgeteilt und an einen rekursiven Aufruf des
    Prozesses übergeben, wodurch sie zu pFilter hinzugefügt werden.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process could be used extensively by custom TIs in\
    \ production to clear certain data out of a cube before copying data to that cube.\n\n#\
    \ Use case: Primarily for production systems.\n# 1/ In production system this is a 'workhorse'\
    \ process called from the prolog of most custom processes prior to querying a data source\
    \ to refresh cube data.\n# 2/ During development/prototyping can be run manually to clear\
    \ out a portion of a cube.\n\n# Note:\n# Wildcards can be used or a list of cubes specified\
    \ to clear data out of multiple cubes simultaneouly. \n# If no cube (pCube) or an invalid\
    \ cube is specified, the process will abort.\n# CAUTION: If no view (pView) or filter (pFilter)\
    \ is specified, the entire cube(s) will be cleared out.\n# If a valid view is specified\
    \ the process will simply zero out that view and ignore any filter (pFilter) specified.\n\
    # If no valid view is specified then a temporary view will be built using the filter and\
    \ its data deleted.\n# The filter can handle specific element references for any number\
    \ of dimensions and elements.\n# - The pFilter parameter contains the dimension and elements\
    \ to be used for filtering.\n# - The dimension parameters do not need to be given in the\
    \ index order of dimensions in the cube.\n# - The dimension name is specified as the first\
    \ member of the delimited string of elements.\n# If using the pFilterParallel parameter\
    \ the **single dimension** used as the 'parallelization slicer' cannot appear in\n# the\
    \ pFilter parameters.\n# When using parallelization via the *RunProcess* function the elements\
    \ listed in pFilterParallel will be split one_at_a_time\n# and passed to a recursive call\
    \ of the process being added to pFilter.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pView:%pView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%,\
    \ pParallelThreads:%pParallelThreads%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%, pSuppressConsolStrings:%pSuppressConsolStrings%, pCubeLogging:%pCubeLogging%,\
    \ pTemp:%pTemp%, pSandbox:%pSandbox%';  \ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\\
    i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncDefaultView    = Expand(\
    \ '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\ncTempSub        = cDefaultView | '_Temp';\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\n# Trim delimiters\nsDelimDim           = TRIM(pDimDelim);\nsElementStartDelim\
    \  = TRIM(pEleStartDelim);\nsDelimElem          = TRIM(pEleDelim);\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\n## Default filter delimiters\nIf( pDimDelim     @= '' );\n  pDimDelim\
    \     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n  pEleStartDelim= '¦';\nEndIf;\nIf( pEleDelim\
    \     @= '' );\n  pEleDelim     = '+';\nEndIf;\n\n# Check the delimiters\nIf( Trim( pFilter\
    \ ) @<> '' );\n If( sDelimDim @= sElementStartDelim % sDelimDim @= sDelimElem % sElementStartDelim\
    \ @= sDelimElem );\n    sMessage = 'The delimiters cannot be the same.';\n    nErrors =\
    \ nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  EndIf;\n\
    EndIf;   \n\n# consolidated strings\nIf( pSuppressConsolStrings <> 0 );\n    pSuppressConsolStrings\
    \ = 1;\nEndIf;\n\n# Validate cubelogging parameter\nIf( pCubeLogging <> 0 & pCubeLogging\
    \ <> 1 & pCubeLogging <> 2);\n  sMessage = 'The cube logging parameter incorrect';\n  nErrors\
    \ = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # If no cube has been specified then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage\
    \ = 'No cube(s) specified.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate parallelization filter\nIf( Scan( pEleStartDelim,\
    \ pFilterParallel ) > 0 );\n  sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim,\
    \ pFilterParallel ) - 1 );\n  If( Scan( Lower(sDimParallel) | pEleStartDelim, Lower(pFilter)\
    \ ) > 0 );\n    sMessage = 'Parallelization dimension %sDimParallel% cannot exist in filter.';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \  EndIf;\nEndIf;\n\n# Validate Max Threads\nIf( pParallelThreads >= 1 );\n  nMaxThreads\
    \ = Round(pParallelThreads);\nElse;\n  # Single thread mode\n  nMaxThreads = 1;\nEndIf;\n\
    \n# Validate Sandbox\nIf( TRIM( pSandbox ) @<> '' );\n    If( ServerSandboxExists( pSandbox\
    \ ) = 0 );\n        SetUseActiveSandboxProperty( 0 );\n        nErrors = nErrors + 1;\n\
    \        sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\n   \
    \     LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n        ServerActiveSandboxSet(\
    \ pSandbox );\n        SetUseActiveSandboxProperty( 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty(\
    \ 0 );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop\
    \ through cubes in pCube\nsCubes = pCube;\nnCubeDelimiterIndex = 1;\n# Get 1st cube\nWhile(\
    \ nCubeDelimiterIndex <> 0 );\n\n  # Extract 1st cube > sCube\n  nCubeDelimiterIndex = Scan(\
    \ pDimDelim, sCubes );\n  If( nCubeDelimiterIndex = 0 );\n    sCube   = sCubes;\n  Else;\n\
    \    sCube   = Trim( SubSt( sCubes, 1, nCubeDelimiterIndex - 1 ) );\n    sCubes  = Trim(\
    \ Subst( sCubes, nCubeDelimiterIndex + Long(pDimDelim), Long( sCubes ) ) );\n  EndIf;\n\
    \  \n  bParallel = 0;\n  \n  # Check if sCube has wildcard\n  If( Scan( '*', sCube ) = 0);\n\
    \    # Validate cube\n    If( CubeExists(sCube) = 0 );\n      nErrors     = 1;\n      sMessage\
    \    = Expand( 'Cube %sCube% does not exist.' );\n      LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n      If( pStrictErrorHandling = 1 ); \n          ProcessQuit; \n      Else;\n \
    \         ProcessBreak;\n      EndIf;\n    Else;\n      If( Scan( pEleStartDelim, pFilterParallel\
    \ ) > 0 );\n        nDim = 1;\n        sDim = TABDIM( sCube, nDim);\n        While ( sDim\
    \ @<> '' );\n          sDim = TABDIM( sCube, nDim);\n          If ( sDim @= sDimParallel\
    \ );\n            bParallel = 1;\n            sDim = '';\n          EndIf;\n          nDim\
    \ = nDim + 1;\n        End;\n      EndIf;\n      If( bParallel = 1 );\n        sDimParallel\
    \ = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n        sElementList\
    \ = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) + 1, Long( pFilterParallel\
    \ ) );\n        If( SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\n  \
    \          sElementList = sElementList | pEleDelim;\n        EndIf;\n        ## Counting\
    \ elements in element list\n        sElementListCount = sElementList;\n        nElements\
    \ = 0;\n        While( Scan( pEleDelim, sElementListCount ) > 0 );\n          nElements\
    \ = nElements + 1;\n          sElementListCount = SubSt( sElementListCount, Scan( pEleDelim,\
    \ sElementListCount ) + 1, Long( sElementListCount ) );\n        End;\n        IF( Mod(\
    \ nElements, nMaxThreads ) = 0 );\n          nElemsPerThread = INT( nElements / nMaxThreads\
    \ );\n        ELSE;\n          nElemsPerThread = INT( nElements / nMaxThreads ) + 1;\n \
    \       ENDIF;\n        nThreadElCounter = 0;\n        While( Scan( pEleDelim, sElementList\
    \ ) > 0 );\n          sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList\
    \ ) - 1 );\n          sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList\
    \ ) + 1, Long( sElementList ) );\n          # Do recursive process call with new RunProcess\
    \ function\n          nThreadElCounter = nThreadElCounter + 1;\n          sDimDelim = If(pFilter\
    \ @= '', '', pDimDelim );\n          IF( nThreadElCounter = 1 );\n            sFilter =\
    \ Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n          ELSE;\n\
    \            sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n          ENDIF;\n \
    \         IF( nThreadElCounter >= nElemsPerThread );\n            RunProcess( cThisProcName,\
    \ 'pLogoutput', pLogoutput,\n        \t    'pCube', pCube, 'pView', pView, 'pFilter', sFilter,\
    \ 'pFilterParallel', '', \n        \t    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim,\
    \ 'pEleDelim', pEleDelim, \n        \t    'pSuppressConsolStrings', pSuppressConsolStrings,\
    \ 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n        \t  );\n \
    \       \t  nThreadElCounter = 0;\n        \t  sFilter = '';\n        \t ENDIF;\n      \
    \  End;\n        ## Process last elements - only when filter is not empty (there are still\
    \ elements) otherwise the entire cube is emptied\n        IF( sFilter @<> '' );\n      \
    \    RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n      \t    'pCube', pCube, 'pView',\
    \ pView, 'pFilter', sFilter, 'pFilterParallel', '', \n      \t    'pDimDelim', pDimDelim,\
    \ 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim, \n      \t    'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n\
    \      \t  );\n    \t  ENDIF;\n      Else;\n        ## Validate the View & filter parameter\n\
    \        If( Trim( pView ) @= '' & Trim( pFilter ) @= '' & Trim( pSandbox ) @= '' );\n \
    \         sMessage  = Expand('No view OR filter specified so the entire %sCube% cube has\
    \ been cleared.');\n\t  IF( pLogoutput = 1 );\n          \tLogOutput( 'INFO' , Expand( 'Process:%cThisProcName%\
    \ Message:%sMessage%' ) );\n\t  ENDIF;\n          CubeClearData( sCube );\n        Else;\n\
    \          # Use different view/subset for different cubes\n          sTimeStamp      =\
    \ TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n          sRandomInt      = NumberToString( INT(\
    \ RAND( ) * 1000 ));\n          cDefaultView    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%'\
    \ );\n          #cTempSub        = cDefaultView;\n          \n          If( Trim( pView\
    \ ) @= '' );\n            cView   = cDefaultView ;\n          Else;\n            cView =\
    \ Trim( pView );\n          EndIf;\n          \n          # Clear view\n          If( ViewExists(\
    \ sCube , cView ) = 0 );\n            ## Validate that a Filter has been provided so that\
    \ a view can be created.\n            If( Trim( pFilter ) @= '' );\n              sMessage\
    \ = Expand('View %cView% does not exist in the %sCube% cube AND no Filter has not been specified\
    \ in order to create a view.');\n              LogOutput( 'INFO' , Expand( cMsgErrorContent\
    \ ) );\n              #ProcessBreak;\n            EndIf;\n\n            ### Create View\
    \ using filter (temp view, therefore no need to destroy) ###\n            sProc = '}bedrock.cube.view.create';\n\
    \            nRet = ExecuteProcess( sProc,\n                    'pLogOutput', pLogOutput,\n\
    \                    'pStrictErrorHandling', pStrictErrorHandling,\n                   \
    \ 'pCube', sCube, 'pView', cView, 'pFilter', pFilter,\n                    'pSuppressZero',\
    \ 1, 'pSuppressConsol', 1, 'pSuppressRules', 1, 'pSuppressConsolStrings', pSuppressConsolStrings,\n\
    \                    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim',\
    \ pEleDelim,\n                    'pTemp', pTemp, 'pSubN', pSubN\n                   );\n\
    \n              # Validate Sandbox\n              If( TRIM( pSandbox ) @<> '' );\n     \
    \         If( ServerSandboxExists( pSandbox ) = 0 );\n                SetUseActiveSandboxProperty(\
    \ 0 );\n                nErrors = nErrors + 1;\n                sMessage = Expand('Sandbox\
    \ %pSandbox% is invalid for the current user.');\n                LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n              Else;\n                ServerActiveSandboxSet(\
    \ pSandbox );\n                SetUseActiveSandboxProperty( 1 );\n              EndIf;\n\
    \              Else;\n                 SetUseActiveSandboxProperty( 0 );\n             \
    \ EndIf;\n\n            ### Zero Out View ###\n            If ( nRet = ProcessExitNormal()\
    \ );\n              If ( pCubeLogging <= 1 );\n                sCubeLogging = CellGetS('}CubeProperties',\
    \ sCube, 'LOGGING' );\n                CubeSetLogChanges( sCube, pCubeLogging);\n      \
    \        EndIf;\n              ViewZeroOut( sCube, cView );\n              sMessage = Expand(\
    \ 'Succeeded in creating the %cView% view in the %sCube% cube and data has been cleared.'\
    \ );\n\t      IF( pLogoutput = 1 );\n              \tLogOutput( 'INFO', Expand( 'Process:%cThisProcName%\
    \ Message:%sMessage%' ) );\n\t      ENDIF;\n              If ( pCubeLogging <= 1 );\n  \
    \              CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0) );  \n            \
    \  EndIf;\n            Else;\n              nErrors = nErrors + 1;\n              sMessage\
    \ = Expand( 'Creating view by %sProc% has failed. Nothing has been cleared in the %sCube%\
    \ cube.' );\n              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  \
    \          EndIf;\n          Else;\n            If ( pCubeLogging <= 1 );\n            \
    \  sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\n              CubeSetLogChanges(\
    \ sCube, pCubeLogging);\n            EndIf;\n            ViewZeroOut( sCube, cView );\n\
    \            If ( pCubeLogging <= 1 );\n              CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0)\
    \ ); \n            EndIf;\n          Endif;\n        Endif;\n      EndIf;\n    Endif;\n\
    \  Else;\n    # Create subset of cubes using Wildcard to loop through cubes in pCube with\
    \ wildcard\n    sCubeExp = '''|sCube|''';\n    sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL(\
    \ [}Cubes] )},'|sCubeExp| ')}';\n    If( SubsetExists( '}Cubes' , cTempSub ) = 1 );\n  \
    \    # If a delimited list of cube names includes wildcards then we may have to re-use the\
    \ subset multiple times\n      SubsetMDXSet( '}Cubes' , cTempSub, sMDX );\n    Else;\n \
    \     # temp subset, therefore no need to destroy in epilog\n      SubsetCreatebyMDX( cTempSub,\
    \ sMDX, '}Cubes' , 1 );\n    EndIf;\n    \n    # Loop through cubes in subset created based\
    \ on wildcard\n    nCountCube = SubsetGetSize( '}Cubes' , cTempSub );\n    While( nCountCube\
    \ >= 1 );\n      # Use different view/subset for different cubes\n      sTimeStamp     \
    \ = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n      sRandomInt      = NumberToString( INT( RAND(\
    \ ) * 1000 ));\n      cDefaultView    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%'\
    \ );\n      sCube           = SubsetGetElementName( '}Cubes' , cTempSub, nCountCube );\n\
    \      # Validate cube name  Not necessary as derived from subset of }Cubes\n      If( CubeExists(sCube)\
    \ = 0 );\n        nErrors = 1;\n        sMessage = Expand( '%sCube% does not exist.' );\n\
    \        LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n      Else;\n        If( Scan(\
    \ pEleStartDelim, pFilterParallel ) > 0 );\n          nDim = 1;\n          sDim = TABDIM(\
    \ sCube, nDim);\n          While ( sDim @<> '' );\n            sDim = TABDIM( sCube, nDim);\n\
    \            If ( sDim @= sDimParallel );\n              bParallel = 1;\n              sDim\
    \ = '';\n            EndIf;\n            nDim = nDim + 1;\n          End;\n        EndIf;\n\
    \        If( bParallel = 1 );\n          sDimParallel = SubSt( pFilterParallel, 1, Scan(\
    \ pEleStartDelim, pFilterParallel ) - 1 );\n          sElementList = SubSt( pFilterParallel,\
    \ Scan( pEleStartDelim, pFilterParallel ) + 1, Long( pFilterParallel ) );\n          If(\
    \ SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\n              sElementList\
    \ = sElementList | pEleDelim;\n          EndIf;\n        ## Counting elements in element\
    \ list\n        sElementListCount = sElementList;\n        nElements = 0;\n        While(\
    \ Scan( pEleDelim, sElementListCount ) > 0 );\n          nElements = nElements + 1;\n  \
    \        sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount\
    \ ) + 1, Long( sElementListCount ) );\n        End;\n        IF( Mod( nElements, nMaxThreads\
    \ ) = 0 );\n          nElemsPerThread = INT( nElements / nMaxThreads );\n        ELSE;\n\
    \          nElemsPerThread = INT( nElements / nMaxThreads ) + 1;\n        ENDIF;\n     \
    \   nThreadElCounter = 0;\n          While( Scan( pEleDelim, sElementList ) > 0 );\n   \
    \         sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\n\
    \            sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList ) + 1, Long(\
    \ sElementList ) );\n            # Do recursive process call with new RunProcess function\n\
    \          nThreadElCounter = nThreadElCounter + 1;\n          sDimDelim = If(pFilter @=\
    \ '', '', pDimDelim );\n          IF( nThreadElCounter = 1 );\n            sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \          ELSE;\n            sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n  \
    \        ENDIF;\n          IF( nThreadElCounter >= nElemsPerThread );\n            RunProcess(\
    \ cThisProcName, 'pLogoutput', pLogoutput,\n        \t    'pCube', pCube, 'pView', pView,\
    \ 'pFilter', sFilter, 'pFilterParallel', '', \n        \t    'pDimDelim', pDimDelim, 'pEleStartDelim',\
    \ pEleStartDelim, 'pEleDelim', pEleDelim, \n        \t    'pSuppressConsolStrings', pSuppressConsolStrings,\
    \ 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n        \t  );\n \
    \       \t  nThreadElCounter = 0;\n        \t  sFilter = '';\n        \t ENDIF;\n      \
    \  End;\n        ## Process last elements\n        IF( sFilter @<> '' );\n          RunProcess(\
    \ cThisProcName, 'pLogoutput', pLogoutput,\n      \t    'pCube', pCube, 'pView', pView,\
    \ 'pFilter', sFilter, 'pFilterParallel', '', \n      \t    'pDimDelim', pDimDelim, 'pEleStartDelim',\
    \ pEleStartDelim, 'pEleDelim', pEleDelim, \n      \t    'pSuppressConsolStrings', pSuppressConsolStrings,\
    \ 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n      \t  );\n   \
    \ \t  ENDIF;\n        Else;\n          ## Validate the View & filter parameter\n       \
    \   If( Trim( pView ) @= '' & Trim( pFilter ) @= '' & Trim( pSandbox ) @= '' );\n      \
    \      # Clear entire cube\n            sMessage  = Expand('No view OR filter specified\
    \ so the entire %sCube% cube has been cleared.');\n\t    IF( pLogoutput = 1 );\n       \
    \     \tLogOutput( 'INFO' , Expand( 'Process:%cThisProcName% Message:%sMessage%' ) );\n\t\
    \    ENDIF;\n            CubeClearData( sCube );\n          Else;\n            # Clear view\
    \ cView\n            If( Trim( pView ) @= '' );\n              cView   = cDefaultView ;\n\
    \            Else;\n              cView = Trim( pView );\n            EndIf;\n        \n\
    \            If( ViewExists( sCube, cView ) = 0 );\n              ## Validate that a Filter\
    \ has been provided so that a view can be created.\n              If( Trim( pFilter ) @=\
    \ '' );\n                sMessage = Expand('View %cView% does not exist for %sCube% AND\
    \ no Filter has not been specified in order to create a view.');\n                LogOutput(\
    \ 'ERROR' , Expand( cMsgErrorContent ) );\n                #ProcessBreak;\n            \
    \  EndIf;\n  \n              ### Create View using filter (temp view, therefore no need\
    \ to destroy) ###\n              sProc = '}bedrock.cube.view.create';\n              nRet\
    \ = ExecuteProcess( sProc,\n                  'pLogOutput', pLogOutput,\n              \
    \    'pStrictErrorHandling', pStrictErrorHandling,\n                  'pCube', sCube, 'pView',\
    \ cView, 'pFilter', pFilter,\n                  'pSuppressZero', 1, 'pSuppressConsol', 1,\
    \ 'pSuppressRules', 1, 'pSuppressConsolStrings', pSuppressConsolStrings,\n             \
    \     'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n\
    \                  'pTemp', pTemp, 'pSubN', pSubN\n                  );\n              \
    \    \n              # Validate Sandbox\n              If( TRIM( pSandbox ) @<> '' );\n\
    \              If( ServerSandboxExists( pSandbox ) = 0 );\n                SetUseActiveSandboxProperty(\
    \ 0 );\n                nErrors = nErrors + 1;\n                sMessage = Expand('Sandbox\
    \ %pSandbox% is invalid for the current user.');\n                LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n              Else;\n                ServerActiveSandboxSet(\
    \ pSandbox );\n                SetUseActiveSandboxProperty( 1 );\n              EndIf;\n\
    \              Else;\n                 SetUseActiveSandboxProperty( 0 );\n             \
    \ EndIf;\n                  \n  \n              ### Zero Out View ###\n              IF\
    \ ( nRet = ProcessExitNormal() );\n                If ( pCubeLogging <= 1 );\n         \
    \         sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\n             \
    \     CubeSetLogChanges( sCube, pCubeLogging);\n                EndIf;\n               \
    \ ViewZeroOut( sCube, cView );\n                sMessage = Expand( 'Succeeded in creating\
    \ the %cView% view in the %sCube% cube and data has been cleared.' );\n\t\tIF( pLogoutput\
    \ = 1 );\n                    LogOutput( 'INFO', Expand( 'Process:%cThisProcName% Message:%sMessage%'\
    \ ) );\n\t\tENDIF;\n                If ( pCubeLogging <= 1 );\n                  CubeSetLogChanges(\
    \ sCube, IF(sCubeLogging@='YES',1,0) );  \n                EndIf;\n              ELSE;\n\
    \                nErrors = nErrors + 1;\n                sMessage = Expand( 'Creating view\
    \ by %sProc% has failed. Nothing has been cleared in the %sCube% cube.' );\n           \
    \     LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n              ENDIF;\n \
    \           Else;\n              If ( pCubeLogging <= 1 );\n                sCubeLogging\
    \ = CellGetS('}CubeProperties', sCube, 'LOGGING' );\n                CubeSetLogChanges(\
    \ sCube, pCubeLogging);\n              EndIf;\n              ViewZeroOut( sCube, cView );\n\
    \              If ( pCubeLogging <= 1 );\n                CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0)\
    \ ); \n              EndIf;\n            Endif;\n          EndIf;\n        EndIf;\n    \
    \    nCountCube = nCountCube - 1;\n        # Use different view/subset for different cubes\n\
    \        sTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n        sRandomInt     \
    \ = NumberToString( INT( RAND( ) * 1000 ));\n        cDefaultView    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%'\
    \ );\n        #cTempSub        = cDefaultView; \n      EndIf;\n    End;\n  EndIf;\nEnd;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully cleared data out of the %pCube% cube(s).'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Describe an IBM Turbo Integrator process for clearing specific data out of a cube
    before copying data into that cube. The process is primarily used in production systems.
    It is called from the prolog of custom processes before querying a data source to refresh
    cube data. During development or prototyping, this process can be run manually to clear
    out a portion of a cube. Wildcards can be used, or a list of cubes specified to clear data
    from multiple cubes simultaneously. If no cube (pCube) or an invalid cube is specified,
    the process will abort. CAUTION: If no view (pView) or filter (pFilter) is specified, the
    entire cube(s) will be cleared. If a valid view is specified, the process will simply zero
    out that view, ignoring any specified filter (pFilter). If no valid view is specified, a
    temporary view will be built based on the filter and its data deleted. The filter can handle
    specific element references for any number of dimensions and elements. The pFilter parameter
    includes the dimensions and elements to be used for filtering. The dimension names do not
    need to be in the index order of the dimensions in the cube. The dimension name is specified
    as the first member of the delimited string of elements. If using the pFilterParallel parameter,
    the **single dimension** used as the ''parallelization slicer'' cannot appear in the pFilter
    parameters. When using parallelization via the *RunProcess* function, the elements listed
    in pFilterParallel will be split one at a time and passed to a recursive call of the process,
    being added to pFilter.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process could be used extensively by custom TIs in\
    \ production to clear certain data out of a cube before copying data to that cube.\n\n#\
    \ Use case: Primarily for production systems.\n# 1/ In production system this is a 'workhorse'\
    \ process called from the prolog of most custom processes prior to querying a data source\
    \ to refresh cube data.\n# 2/ During development/prototyping can be run manually to clear\
    \ out a portion of a cube.\n\n# Note:\n# Wildcards can be used or a list of cubes specified\
    \ to clear data out of multiple cubes simultaneouly. \n# If no cube (pCube) or an invalid\
    \ cube is specified, the process will abort.\n# CAUTION: If no view (pView) or filter (pFilter)\
    \ is specified, the entire cube(s) will be cleared out.\n# If a valid view is specified\
    \ the process will simply zero out that view and ignore any filter (pFilter) specified.\n\
    # If no valid view is specified then a temporary view will be built using the filter and\
    \ its data deleted.\n# The filter can handle specific element references for any number\
    \ of dimensions and elements.\n# - The pFilter parameter contains the dimension and elements\
    \ to be used for filtering.\n# - The dimension parameters do not need to be given in the\
    \ index order of dimensions in the cube.\n# - The dimension name is specified as the first\
    \ member of the delimited string of elements.\n# If using the pFilterParallel parameter\
    \ the **single dimension** used as the 'parallelization slicer' cannot appear in\n# the\
    \ pFilter parameters.\n# When using parallelization via the *RunProcess* function the elements\
    \ listed in pFilterParallel will be split one_at_a_time\n# and passed to a recursive call\
    \ of the process being added to pFilter.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pView:%pView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%,\
    \ pParallelThreads:%pParallelThreads%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%, pSuppressConsolStrings:%pSuppressConsolStrings%, pCubeLogging:%pCubeLogging%,\
    \ pTemp:%pTemp%, pSandbox:%pSandbox%';  \ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\\
    i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncDefaultView    = Expand(\
    \ '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\ncTempSub        = cDefaultView | '_Temp';\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\n# Trim delimiters\nsDelimDim           = TRIM(pDimDelim);\nsElementStartDelim\
    \  = TRIM(pEleStartDelim);\nsDelimElem          = TRIM(pEleDelim);\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\n## Default filter delimiters\nIf( pDimDelim     @= '' );\n  pDimDelim\
    \     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n  pEleStartDelim= '¦';\nEndIf;\nIf( pEleDelim\
    \     @= '' );\n  pEleDelim     = '+';\nEndIf;\n\n# Check the delimiters\nIf( Trim( pFilter\
    \ ) @<> '' );\n If( sDelimDim @= sElementStartDelim % sDelimDim @= sDelimElem % sElementStartDelim\
    \ @= sDelimElem );\n    sMessage = 'The delimiters cannot be the same.';\n    nErrors =\
    \ nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  EndIf;\n\
    EndIf;   \n\n# consolidated strings\nIf( pSuppressConsolStrings <> 0 );\n    pSuppressConsolStrings\
    \ = 1;\nEndIf;\n\n# Validate cubelogging parameter\nIf( pCubeLogging <> 0 & pCubeLogging\
    \ <> 1 & pCubeLogging <> 2);\n  sMessage = 'The cube logging parameter incorrect';\n  nErrors\
    \ = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # If no cube has been specified then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage\
    \ = 'No cube(s) specified.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate parallelization filter\nIf( Scan( pEleStartDelim,\
    \ pFilterParallel ) > 0 );\n  sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim,\
    \ pFilterParallel ) - 1 );\n  If( Scan( Lower(sDimParallel) | pEleStartDelim, Lower(pFilter)\
    \ ) > 0 );\n    sMessage = 'Parallelization dimension %sDimParallel% cannot exist in filter.';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \  EndIf;\nEndIf;\n\n# Validate Max Threads\nIf( pParallelThreads >= 1 );\n  nMaxThreads\
    \ = Round(pParallelThreads);\nElse;\n  # Single thread mode\n  nMaxThreads = 1;\nEndIf;\n\
    \n# Validate Sandbox\nIf( TRIM( pSandbox ) @<> '' );\n    If( ServerSandboxExists( pSandbox\
    \ ) = 0 );\n        SetUseActiveSandboxProperty( 0 );\n        nErrors = nErrors + 1;\n\
    \        sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\n   \
    \     LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n        ServerActiveSandboxSet(\
    \ pSandbox );\n        SetUseActiveSandboxProperty( 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty(\
    \ 0 );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop\
    \ through cubes in pCube\nsCubes = pCube;\nnCubeDelimiterIndex = 1;\n# Get 1st cube\nWhile(\
    \ nCubeDelimiterIndex <> 0 );\n\n  # Extract 1st cube > sCube\n  nCubeDelimiterIndex = Scan(\
    \ pDimDelim, sCubes );\n  If( nCubeDelimiterIndex = 0 );\n    sCube   = sCubes;\n  Else;\n\
    \    sCube   = Trim( SubSt( sCubes, 1, nCubeDelimiterIndex - 1 ) );\n    sCubes  = Trim(\
    \ Subst( sCubes, nCubeDelimiterIndex + Long(pDimDelim), Long( sCubes ) ) );\n  EndIf;\n\
    \  \n  bParallel = 0;\n  \n  # Check if sCube has wildcard\n  If( Scan( '*', sCube ) = 0);\n\
    \    # Validate cube\n    If( CubeExists(sCube) = 0 );\n      nErrors     = 1;\n      sMessage\
    \    = Expand( 'Cube %sCube% does not exist.' );\n      LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n      If( pStrictErrorHandling = 1 ); \n          ProcessQuit; \n      Else;\n \
    \         ProcessBreak;\n      EndIf;\n    Else;\n      If( Scan( pEleStartDelim, pFilterParallel\
    \ ) > 0 );\n        nDim = 1;\n        sDim = TABDIM( sCube, nDim);\n        While ( sDim\
    \ @<> '' );\n          sDim = TABDIM( sCube, nDim);\n          If ( sDim @= sDimParallel\
    \ );\n            bParallel = 1;\n            sDim = '';\n          EndIf;\n          nDim\
    \ = nDim + 1;\n        End;\n      EndIf;\n      If( bParallel = 1 );\n        sDimParallel\
    \ = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n        sElementList\
    \ = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) + 1, Long( pFilterParallel\
    \ ) );\n        If( SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\n  \
    \          sElementList = sElementList | pEleDelim;\n        EndIf;\n        ## Counting\
    \ elements in element list\n        sElementListCount = sElementList;\n        nElements\
    \ = 0;\n        While( Scan( pEleDelim, sElementListCount ) > 0 );\n          nElements\
    \ = nElements + 1;\n          sElementListCount = SubSt( sElementListCount, Scan( pEleDelim,\
    \ sElementListCount ) + 1, Long( sElementListCount ) );\n        End;\n        IF( Mod(\
    \ nElements, nMaxThreads ) = 0 );\n          nElemsPerThread = INT( nElements / nMaxThreads\
    \ );\n        ELSE;\n          nElemsPerThread = INT( nElements / nMaxThreads ) + 1;\n \
    \       ENDIF;\n        nThreadElCounter = 0;\n        While( Scan( pEleDelim, sElementList\
    \ ) > 0 );\n          sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList\
    \ ) - 1 );\n          sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList\
    \ ) + 1, Long( sElementList ) );\n          # Do recursive process call with new RunProcess\
    \ function\n          nThreadElCounter = nThreadElCounter + 1;\n          sDimDelim = If(pFilter\
    \ @= '', '', pDimDelim );\n          IF( nThreadElCounter = 1 );\n            sFilter =\
    \ Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n          ELSE;\n\
    \            sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n          ENDIF;\n \
    \         IF( nThreadElCounter >= nElemsPerThread );\n            RunProcess( cThisProcName,\
    \ 'pLogoutput', pLogoutput,\n        \t    'pCube', pCube, 'pView', pView, 'pFilter', sFilter,\
    \ 'pFilterParallel', '', \n        \t    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim,\
    \ 'pEleDelim', pEleDelim, \n        \t    'pSuppressConsolStrings', pSuppressConsolStrings,\
    \ 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n        \t  );\n \
    \       \t  nThreadElCounter = 0;\n        \t  sFilter = '';\n        \t ENDIF;\n      \
    \  End;\n        ## Process last elements - only when filter is not empty (there are still\
    \ elements) otherwise the entire cube is emptied\n        IF( sFilter @<> '' );\n      \
    \    RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n      \t    'pCube', pCube, 'pView',\
    \ pView, 'pFilter', sFilter, 'pFilterParallel', '', \n      \t    'pDimDelim', pDimDelim,\
    \ 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim, \n      \t    'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n\
    \      \t  );\n    \t  ENDIF;\n      Else;\n        ## Validate the View & filter parameter\n\
    \        If( Trim( pView ) @= '' & Trim( pFilter ) @= '' & Trim( pSandbox ) @= '' );\n \
    \         sMessage  = Expand('No view OR filter specified so the entire %sCube% cube has\
    \ been cleared.');\n\t  IF( pLogoutput = 1 );\n          \tLogOutput( 'INFO' , Expand( 'Process:%cThisProcName%\
    \ Message:%sMessage%' ) );\n\t  ENDIF;\n          CubeClearData( sCube );\n        Else;\n\
    \          # Use different view/subset for different cubes\n          sTimeStamp      =\
    \ TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n          sRandomInt      = NumberToString( INT(\
    \ RAND( ) * 1000 ));\n          cDefaultView    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%'\
    \ );\n          #cTempSub        = cDefaultView;\n          \n          If( Trim( pView\
    \ ) @= '' );\n            cView   = cDefaultView ;\n          Else;\n            cView =\
    \ Trim( pView );\n          EndIf;\n          \n          # Clear view\n          If( ViewExists(\
    \ sCube , cView ) = 0 );\n            ## Validate that a Filter has been provided so that\
    \ a view can be created.\n            If( Trim( pFilter ) @= '' );\n              sMessage\
    \ = Expand('View %cView% does not exist in the %sCube% cube AND no Filter has not been specified\
    \ in order to create a view.');\n              LogOutput( 'INFO' , Expand( cMsgErrorContent\
    \ ) );\n              #ProcessBreak;\n            EndIf;\n\n            ### Create View\
    \ using filter (temp view, therefore no need to destroy) ###\n            sProc = '}bedrock.cube.view.create';\n\
    \            nRet = ExecuteProcess( sProc,\n                    'pLogOutput', pLogOutput,\n\
    \                    'pStrictErrorHandling', pStrictErrorHandling,\n                   \
    \ 'pCube', sCube, 'pView', cView, 'pFilter', pFilter,\n                    'pSuppressZero',\
    \ 1, 'pSuppressConsol', 1, 'pSuppressRules', 1, 'pSuppressConsolStrings', pSuppressConsolStrings,\n\
    \                    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim',\
    \ pEleDelim,\n                    'pTemp', pTemp, 'pSubN', pSubN\n                   );\n\
    \n              # Validate Sandbox\n              If( TRIM( pSandbox ) @<> '' );\n     \
    \         If( ServerSandboxExists( pSandbox ) = 0 );\n                SetUseActiveSandboxProperty(\
    \ 0 );\n                nErrors = nErrors + 1;\n                sMessage = Expand('Sandbox\
    \ %pSandbox% is invalid for the current user.');\n                LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n              Else;\n                ServerActiveSandboxSet(\
    \ pSandbox );\n                SetUseActiveSandboxProperty( 1 );\n              EndIf;\n\
    \              Else;\n                 SetUseActiveSandboxProperty( 0 );\n             \
    \ EndIf;\n\n            ### Zero Out View ###\n            If ( nRet = ProcessExitNormal()\
    \ );\n              If ( pCubeLogging <= 1 );\n                sCubeLogging = CellGetS('}CubeProperties',\
    \ sCube, 'LOGGING' );\n                CubeSetLogChanges( sCube, pCubeLogging);\n      \
    \        EndIf;\n              ViewZeroOut( sCube, cView );\n              sMessage = Expand(\
    \ 'Succeeded in creating the %cView% view in the %sCube% cube and data has been cleared.'\
    \ );\n\t      IF( pLogoutput = 1 );\n              \tLogOutput( 'INFO', Expand( 'Process:%cThisProcName%\
    \ Message:%sMessage%' ) );\n\t      ENDIF;\n              If ( pCubeLogging <= 1 );\n  \
    \              CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0) );  \n            \
    \  EndIf;\n            Else;\n              nErrors = nErrors + 1;\n              sMessage\
    \ = Expand( 'Creating view by %sProc% has failed. Nothing has been cleared in the %sCube%\
    \ cube.' );\n              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  \
    \          EndIf;\n          Else;\n            If ( pCubeLogging <= 1 );\n            \
    \  sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\n              CubeSetLogChanges(\
    \ sCube, pCubeLogging);\n            EndIf;\n            ViewZeroOut( sCube, cView );\n\
    \            If ( pCubeLogging <= 1 );\n              CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0)\
    \ ); \n            EndIf;\n          Endif;\n        Endif;\n      EndIf;\n    Endif;\n\
    \  Else;\n    # Create subset of cubes using Wildcard to loop through cubes in pCube with\
    \ wildcard\n    sCubeExp = '''|sCube|''';\n    sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL(\
    \ [}Cubes] )},'|sCubeExp| ')}';\n    If( SubsetExists( '}Cubes' , cTempSub ) = 1 );\n  \
    \    # If a delimited list of cube names includes wildcards then we may have to re-use the\
    \ subset multiple times\n      SubsetMDXSet( '}Cubes' , cTempSub, sMDX );\n    Else;\n \
    \     # temp subset, therefore no need to destroy in epilog\n      SubsetCreatebyMDX( cTempSub,\
    \ sMDX, '}Cubes' , 1 );\n    EndIf;\n    \n    # Loop through cubes in subset created based\
    \ on wildcard\n    nCountCube = SubsetGetSize( '}Cubes' , cTempSub );\n    While( nCountCube\
    \ >= 1 );\n      # Use different view/subset for different cubes\n      sTimeStamp     \
    \ = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n      sRandomInt      = NumberToString( INT( RAND(\
    \ ) * 1000 ));\n      cDefaultView    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%'\
    \ );\n      sCube           = SubsetGetElementName( '}Cubes' , cTempSub, nCountCube );\n\
    \      # Validate cube name  Not necessary as derived from subset of }Cubes\n      If( CubeExists(sCube)\
    \ = 0 );\n        nErrors = 1;\n        sMessage = Expand( '%sCube% does not exist.' );\n\
    \        LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n      Else;\n        If( Scan(\
    \ pEleStartDelim, pFilterParallel ) > 0 );\n          nDim = 1;\n          sDim = TABDIM(\
    \ sCube, nDim);\n          While ( sDim @<> '' );\n            sDim = TABDIM( sCube, nDim);\n\
    \            If ( sDim @= sDimParallel );\n              bParallel = 1;\n              sDim\
    \ = '';\n            EndIf;\n            nDim = nDim + 1;\n          End;\n        EndIf;\n\
    \        If( bParallel = 1 );\n          sDimParallel = SubSt( pFilterParallel, 1, Scan(\
    \ pEleStartDelim, pFilterParallel ) - 1 );\n          sElementList = SubSt( pFilterParallel,\
    \ Scan( pEleStartDelim, pFilterParallel ) + 1, Long( pFilterParallel ) );\n          If(\
    \ SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\n              sElementList\
    \ = sElementList | pEleDelim;\n          EndIf;\n        ## Counting elements in element\
    \ list\n        sElementListCount = sElementList;\n        nElements = 0;\n        While(\
    \ Scan( pEleDelim, sElementListCount ) > 0 );\n          nElements = nElements + 1;\n  \
    \        sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount\
    \ ) + 1, Long( sElementListCount ) );\n        End;\n        IF( Mod( nElements, nMaxThreads\
    \ ) = 0 );\n          nElemsPerThread = INT( nElements / nMaxThreads );\n        ELSE;\n\
    \          nElemsPerThread = INT( nElements / nMaxThreads ) + 1;\n        ENDIF;\n     \
    \   nThreadElCounter = 0;\n          While( Scan( pEleDelim, sElementList ) > 0 );\n   \
    \         sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\n\
    \            sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList ) + 1, Long(\
    \ sElementList ) );\n            # Do recursive process call with new RunProcess function\n\
    \          nThreadElCounter = nThreadElCounter + 1;\n          sDimDelim = If(pFilter @=\
    \ '', '', pDimDelim );\n          IF( nThreadElCounter = 1 );\n            sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \          ELSE;\n            sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n  \
    \        ENDIF;\n          IF( nThreadElCounter >= nElemsPerThread );\n            RunProcess(\
    \ cThisProcName, 'pLogoutput', pLogoutput,\n        \t    'pCube', pCube, 'pView', pView,\
    \ 'pFilter', sFilter, 'pFilterParallel', '', \n        \t    'pDimDelim', pDimDelim, 'pEleStartDelim',\
    \ pEleStartDelim, 'pEleDelim', pEleDelim, \n        \t    'pSuppressConsolStrings', pSuppressConsolStrings,\
    \ 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n        \t  );\n \
    \       \t  nThreadElCounter = 0;\n        \t  sFilter = '';\n        \t ENDIF;\n      \
    \  End;\n        ## Process last elements\n        IF( sFilter @<> '' );\n          RunProcess(\
    \ cThisProcName, 'pLogoutput', pLogoutput,\n      \t    'pCube', pCube, 'pView', pView,\
    \ 'pFilter', sFilter, 'pFilterParallel', '', \n      \t    'pDimDelim', pDimDelim, 'pEleStartDelim',\
    \ pEleStartDelim, 'pEleDelim', pEleDelim, \n      \t    'pSuppressConsolStrings', pSuppressConsolStrings,\
    \ 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n      \t  );\n   \
    \ \t  ENDIF;\n        Else;\n          ## Validate the View & filter parameter\n       \
    \   If( Trim( pView ) @= '' & Trim( pFilter ) @= '' & Trim( pSandbox ) @= '' );\n      \
    \      # Clear entire cube\n            sMessage  = Expand('No view OR filter specified\
    \ so the entire %sCube% cube has been cleared.');\n\t    IF( pLogoutput = 1 );\n       \
    \     \tLogOutput( 'INFO' , Expand( 'Process:%cThisProcName% Message:%sMessage%' ) );\n\t\
    \    ENDIF;\n            CubeClearData( sCube );\n          Else;\n            # Clear view\
    \ cView\n            If( Trim( pView ) @= '' );\n              cView   = cDefaultView ;\n\
    \            Else;\n              cView = Trim( pView );\n            EndIf;\n        \n\
    \            If( ViewExists( sCube, cView ) = 0 );\n              ## Validate that a Filter\
    \ has been provided so that a view can be created.\n              If( Trim( pFilter ) @=\
    \ '' );\n                sMessage = Expand('View %cView% does not exist for %sCube% AND\
    \ no Filter has not been specified in order to create a view.');\n                LogOutput(\
    \ 'ERROR' , Expand( cMsgErrorContent ) );\n                #ProcessBreak;\n            \
    \  EndIf;\n  \n              ### Create View using filter (temp view, therefore no need\
    \ to destroy) ###\n              sProc = '}bedrock.cube.view.create';\n              nRet\
    \ = ExecuteProcess( sProc,\n                  'pLogOutput', pLogOutput,\n              \
    \    'pStrictErrorHandling', pStrictErrorHandling,\n                  'pCube', sCube, 'pView',\
    \ cView, 'pFilter', pFilter,\n                  'pSuppressZero', 1, 'pSuppressConsol', 1,\
    \ 'pSuppressRules', 1, 'pSuppressConsolStrings', pSuppressConsolStrings,\n             \
    \     'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n\
    \                  'pTemp', pTemp, 'pSubN', pSubN\n                  );\n              \
    \    \n              # Validate Sandbox\n              If( TRIM( pSandbox ) @<> '' );\n\
    \              If( ServerSandboxExists( pSandbox ) = 0 );\n                SetUseActiveSandboxProperty(\
    \ 0 );\n                nErrors = nErrors + 1;\n                sMessage = Expand('Sandbox\
    \ %pSandbox% is invalid for the current user.');\n                LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n              Else;\n                ServerActiveSandboxSet(\
    \ pSandbox );\n                SetUseActiveSandboxProperty( 1 );\n              EndIf;\n\
    \              Else;\n                 SetUseActiveSandboxProperty( 0 );\n             \
    \ EndIf;\n                  \n  \n              ### Zero Out View ###\n              IF\
    \ ( nRet = ProcessExitNormal() );\n                If ( pCubeLogging <= 1 );\n         \
    \         sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\n             \
    \     CubeSetLogChanges( sCube, pCubeLogging);\n                EndIf;\n               \
    \ ViewZeroOut( sCube, cView );\n                sMessage = Expand( 'Succeeded in creating\
    \ the %cView% view in the %sCube% cube and data has been cleared.' );\n\t\tIF( pLogoutput\
    \ = 1 );\n                    LogOutput( 'INFO', Expand( 'Process:%cThisProcName% Message:%sMessage%'\
    \ ) );\n\t\tENDIF;\n                If ( pCubeLogging <= 1 );\n                  CubeSetLogChanges(\
    \ sCube, IF(sCubeLogging@='YES',1,0) );  \n                EndIf;\n              ELSE;\n\
    \                nErrors = nErrors + 1;\n                sMessage = Expand( 'Creating view\
    \ by %sProc% has failed. Nothing has been cleared in the %sCube% cube.' );\n           \
    \     LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n              ENDIF;\n \
    \           Else;\n              If ( pCubeLogging <= 1 );\n                sCubeLogging\
    \ = CellGetS('}CubeProperties', sCube, 'LOGGING' );\n                CubeSetLogChanges(\
    \ sCube, pCubeLogging);\n              EndIf;\n              ViewZeroOut( sCube, cView );\n\
    \              If ( pCubeLogging <= 1 );\n                CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0)\
    \ ); \n              EndIf;\n            Endif;\n          EndIf;\n        EndIf;\n    \
    \    nCountCube = nCountCube - 1;\n        # Use different view/subset for different cubes\n\
    \        sTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n        sRandomInt     \
    \ = NumberToString( INT( RAND( ) * 1000 ));\n        cDefaultView    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%'\
    \ );\n        #cTempSub        = cDefaultView; \n      EndIf;\n    End;\n  EndIf;\nEnd;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully cleared data out of the %pCube% cube(s).'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle eine detaillierte Beschreibung und Anleitung zur Implementierung eines
    IBM Turbo Integrator Prozesses, der Daten aus einem Element einer Dimension in ein anderes
    im selben Würfel kopiert. Dieser Prozess sollte insbesondere in Produktionsumgebungen verwendet
    werden, um beispielsweise ein Budget oder eine Forecast-Element eines Versionsdimensionsarchivs
    zu archivieren oder eine Version aus einem Vorjahr vorzufüllen. Achte darauf, dass ein gültiger
    Würfelname (pCube) und eine Elementzuordnung (pEleMapping) erforderlich sind, da ansonsten
    der Prozess abbricht. Ein Filterparameter (pFilter) kann auch verwendet werden, um nicht
    zugeordnete Dimensionen zu filtern. Die Quell- (pSrcView) und Zielansichten (pTgtView) erhalten
    temporäre Namen, wenn sie leer gelassen werden. Stelle sicher, dass alle anderen Parameter
    angemessen verwendet werden, insbesondere bei der Spezifizierung von pEleMapping und pFilter.
    Da dieser Prozess eine Ansicht als Datenquelle verwendet, sind implizite Variablen wie NValue,
    SValue und Value_is_String erforderlich. Für die Bearbeitung in Architect wird ein temporärer
    Würfel mit mindestens 24 Dimensionen als Vorschau-Datenquelle benötigt. Alternativ kann
    die Datenquelle auf ASCII gesetzt und der TI manuell nach dem Speichern bearbeitet werden,
    um die erforderlichen impliziten Ansichtsvariablen zurückzusetzen. Wenn der pFilterParallel-Parameter
    verwendet wird, sollte die einzelne Dimension, die als 'Parallelisierungsscheibe' genutzt
    wird, nicht in den pFilter- und pEleMapping-Parametern erscheinen. Bei der Parallelisierung
    über die *RunProcess*-Funktion werden die in pFilterParallel aufgeführten Elemente einzeln
    aufgeteilt und an einen rekursiven Aufruf des hinzuzufügenden Prozesses übergeben.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI is intended to copy data from one element of a\
    \ dimension to another in the same cube.\n\n# Use case: Mainly used in production environments.\n\
    # 1/ Typically, this would be used to archive a Budget or Forecast element of a version\
    \ dimension.\n# 2/ Could also be used to prepopulate a version from a prior year.\n\n# Note:\n\
    # Naturally, a valid cube name (pCube) is required. otherwise the process will abort.\n\
    # Element mapping (pEleMapping) is also required, otherwise the process will abort.\n# A\
    \ filter parameter (pFilter) can also be used to filter dimensions that have not been mapped.\n\
    # Source (pSrcView) & target (pTgtView) views will be assigned temporary names if left blank.\n\
    # All other parameters may be left as is but be sure to use them appropriately when specifying\
    \ pEleMapping & pFilter parameters.\n# - Since this TI has a view as a data source, it requires\
    \ the implicit variables NValue, SValue and Value_is_String.\n# - To edit this TI in Architect\
    \ a tmp cube with minimum 24 dims is needed as the preview data source or set the data\n\
    #   source to ASCII and manually edit the TI in notepad after saving to add back the required\
    \ implicit view variables.\n# - If using the pFilterParallel parameter the **single dimension**\
    \ used as the 'parallelization slicer' cannot appear in\n#   the pFilter and pEleMapping\
    \ parameters.\n# - When using parallelization via the *RunProcess* function the elements\
    \ listed in pFilterParallel will be split one_at_a_time\n#   and passed to a recursive call\
    \ of the process being added to pFilter.\n#EndRegion @DOC\n\nIf( pThreadControlFile @<>\
    \ '' );\n    LogOutput( 'INFO', 'Executed as subTI with Thread Control File: ' | pThreadControlFile\
    \ );\nEndIf;\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n# Target Filter Variable for shell processes\nStringGlobalVariable('sTargetFilter');\n\
    \n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\n\
    cTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo        = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pSrcView:%pSrcView%,\
    \ pTgtView:%pTgtView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%,\
    \ pEleMapping:%pEleMapping%, pMappingDelim:%pMappingDelim%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%, pFactor:%pFactor%, pSuppressConsol:%pSuppressConsol%, pSuppressConsolStrings:%pSuppressConsolStrings%,\
    \ pSuppressRules:%pSuppressRules%, pSuppressZero:%pSuppressZero%, pCumulate:%pCumulate%,\
    \ pZeroTarget:%pZeroTarget%, pZeroSource:%pZeroSource%, pTemp:%pTemp%, pCubeLogging:%pCubeLogging%,\
    \ pSandbox:%pSandbox%, pFile:%pFile%.';\ncDefaultView    = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%'\
    \ );\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );\nENDIF;\n\n#Disable logic for pCubeLogic for prararrel thread\nIF (pParallelThreads\
    \ > 0);\n  pCubeLogging = 2;\nEndif;\n\n# Variables\nnDataCount      = 0;\nnExistingSourceFlag\
    \ = 0;\nnAttrCubeFlag   = 0;\ncSuffixSource   = 'S';\ncSuffixTarget   = 'T';\ncPrefixElementAttributes\
    \ = '}ElementAttributes_';\ncDimCountMax    = 27;\nsDimCountMax    = NumberToString( cDimCountMax\
    \ );\nnFactor = If( pFactor = 0, 1, pFactor );\ncLenASCIICode = 3;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate file\
    \ delimiter & quote character\nIf( pDelim @= '' );\n    pDelim = ',';\nElse;\n    # If length\
    \ of pDelim is exactly 3 chars and each of them is decimal digit, then the pDelim is entered\
    \ as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim) = cLenASCIICode );\n      nChar\
    \ = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pDelim, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pDelim, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n       \
    \ Else;\n          nValid = 0;\n          Break;\n        EndIf;\n        nChar = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber(\
    \ pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\
    \nIf( pQuote @= '' );\n    ## Use no quote character\nElse;\n    # If length of pQuote is\
    \ exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII\
    \ code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n  \
    \    While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0',\
    \ 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n\
    \          nValid = 0;\n          Break;\n        EndIf;\n        nChar = nChar + 1;\n \
    \     End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote\
    \ ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n\
    ## File location for indirect data copy\ncDir    = '.' | sOSDelim;\ncFileName = pCube |\
    \ cTimeStamp | cRandomInt | '.csv';\ncFile   = cDir | cFileName;\ncTitleRows = 1;\ncDelimiter\
    \ = pDelim;\ncQuote = pQuote;\n\n# nMappedDimX is a binary switch used to keep track of\
    \ which dimensions have been mapped from the source to the target\nnMappedDim1 = 0;\nnMappedDim2\
    \ = 0;\nnMappedDim3 = 0;\nnMappedDim4 = 0;\nnMappedDim5 = 0;\nnMappedDim6 = 0;\nnMappedDim7\
    \ = 0;\nnMappedDim8 = 0;\nnMappedDim9 = 0;\nnMappedDim10 = 0;\nnMappedDim11 = 0;\nnMappedDim12\
    \ = 0;\nnMappedDim13 = 0;\nnMappedDim14 = 0;\nnMappedDim15 = 0;\nnMappedDim16 = 0;\nnMappedDim17\
    \ = 0;\nnMappedDim18 = 0;\nnMappedDim19 = 0;\nnMappedDim20 = 0;\nnMappedDim21 = 0;\nnMappedDim22\
    \ = 0;\nnMappedDim23 = 0;\nnMappedDim24 = 0;\nnMappedDim25 = 0;\nnMappedDim26 = 0;\nnMappedDim27\
    \ = 0;\n\n### Determine dimensions in target cube - we need to know this to test the cell\
    \ type before loading ###\nsDim1 = TabDim( pCube, 1 );\nsDim2 = TabDim( pCube, 2 );\nsDim3\
    \ = TabDim( pCube, 3 );\nsDim4 = TabDim( pCube, 4 );\nsDim5 = TabDim( pCube, 5 );\nsDim6\
    \ = TabDim( pCube, 6 );\nsDim7 = TabDim( pCube, 7 );\nsDim8 = TabDim( pCube, 8 );\nsDim9\
    \ = TabDim( pCube, 9 );\nsDim10 = TabDim( pCube, 10 );\nsDim11 = TabDim( pCube, 11 );\n\
    sDim12 = TabDim( pCube, 12 );\nsDim13 = TabDim( pCube, 13 );\nsDim14 = TabDim( pCube, 14\
    \ );\nsDim15 = TabDim( pCube, 15 );\nsDim16 = TabDim( pCube, 16 );\nsDim17 = TabDim( pCube,\
    \ 17 );\nsDim18 = TabDim( pCube, 18 );\nsDim19 = TabDim( pCube, 19 );\nsDim20 = TabDim(\
    \ pCube, 20 );\nsDim21 = TabDim( pCube, 21 );\nsDim22 = TabDim( pCube, 22 );\nsDim23 = TabDim(\
    \ pCube, 23 );\nsDim24 = TabDim( pCube, 24 );\nsDim25 = TabDim( pCube, 25 );\nsDim26 = TabDim(\
    \ pCube, 26 );\nsDim27 = TabDim( pCube, 27 );\n\n###########################\n### Validate\
    \ Parameters ###\n###########################\nnErrors = 0;\n\n## Default filter delimiters\n\
    If( pDimDelim     @= '' );\n    pDimDelim     = '&';\nEndIf;\n\nIf( pEleStartDelim@= ''\
    \ );\n    pEleStartDelim= '¦';\nEndIf;\n\nIf( pEleDelim     @= '' );\n    pEleDelim    \
    \ = '+';\nEndIf;\n\nIf( pMappingDelim     @= '' );\n    pMappingDelim     = '->';\nEndIf;\n\
    \nIf( pDecimalSeparator @= '' );\n \tpDecimalSeparator = '.';\nEndIf;\nIf ( LONG(pDecimalSeparator)\
    \ = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n\
    \    If( CODE( pDecimalSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pDecimalSeparator, nChar\
    \ ) <= CODE( '9', 1 ) );\n      nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n\
    \    EndIf;\n    nChar = nChar + 1;\n  End;\n  If ( nValid<>0 );\n    pDecimalSeparator\
    \ = CHAR(StringToNumber( pDecimalSeparator ));\n  Else;\n    pDecimalSeparator = SubSt(\
    \ Trim( pDecimalSeparator ), 1, 1 );\n  EndIf;\nEndIf;\nsDecimalSeparator = pDecimalSeparator;\n\
    \nIf( pThousandSeparator @= '' );\n \tpThousandSeparator = ',';\nEndIf;\nIf ( LONG(pThousandSeparator)\
    \ = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n\
    \    If( CODE( pThousandSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pThousandSeparator,\
    \ nChar ) <= CODE( '9', 1 ) );\n      nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n\
    \    EndIf;\n    nChar = nChar + 1;\n  End;\n  If ( nValid<>0 );\n    pThousandSeparator\
    \ = CHAR(StringToNumber( pThousandSeparator ));\n  Else;\n    pThousandSeparator = SubSt(\
    \ Trim( pThousandSeparator ), 1, 1 );\n  EndIf;\nEndIf;\nsThousandSeparator = pThousandSeparator;\n\
    \n# Validate cube\nIf( Trim( pCube ) @= '' );\n    nErrors     = 1;\n    sMessage    = 'No\
    \ cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ CubeExists( pCube ) = 0 );\n    nErrors     = nErrors + 1;\n    sMessage    = Expand(\
    \ 'Invalid source cube specified: %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Determine number of dims in target cube ###\nnCount          = 1;\n\
    While( TabDim( pCube, nCount ) @<> '' );\n    sDimension  = TabDim( pCube, nCount );\n \
    \   nCount      = nCount + 1;\nEnd;\nnDimensionCount = nCount - 1;\n\n## If dimension count\
    \ exceeds the current maximum then terminate process\nIf( nDimensionCount > cDimCountMax\
    \ );\n    nErrors     = nErrors + 1;\n    sMessage    = 'Cube has too many dimensions: %pCube%.\
    \ Max %sDimCountMax% dims catered for, TI must be altered to accommodate.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate the View parameter\n\
    If( TRIM(pSrcView) @<> '' & TRIM(pSrcView) @= TRIM(pTgtView) );\n    nErrors     = nErrors\
    \ + 1;\n    sMessage    = Expand( 'Source and Target Views can not be the same: %pSrcView%.'\
    \ ) ;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate\
    \ the View parameter\nIf( TRIM( pSrcView) @= '' );\n  cViewSource   = Expand( '%cDefaultView%_%cSuffixSource%'\
    \ ) ;\nElse ;\n  cViewSource   = pSrcView ;\n  nExistingSourceFlag = 1;\nEndIf;\n\n## Validate\
    \ the View parameter\nIf( TRIM( pTgtView ) @= '' );\n  cViewTarget   = Expand( '%cDefaultView%_%cSuffixTarget%'\
    \ ) ;\nElse ;\n  cViewTarget   = pTgtView ;\nEndIf;\n\n# Validate parallelization filter\n\
    If( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n    sDimParallel = SubSt( pFilterParallel,\
    \ 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n    If( Scan( Lower(sDimParallel) |\
    \ pEleStartDelim, Lower(pFilter) ) > 0 );\n        sMessage = 'Parallelization dimension\
    \ %sDimParallel% cannot exist in filter.';\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\n    If( Scan( Lower(sDimParallel)\
    \ | pEleStartDelim, Lower(pEleMapping) ) > 0 );\n        sMessage = 'Parallelization dimension\
    \ %sDimParallel% cannot exist in element mapping.';\n        nErrors = nErrors + 1;\n  \
    \      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n\
    # Validate Max Threads\nIf( pParallelThreads > 0 );\n  nMaxThreads = pParallelThreads;\n\
    Else;\n  nMaxThreads = 1;\nEndIf;\n\n# Validate Mapping parameter\nIf( pDimDelim @= pEleStartDelim\
    \ % pDimDelim @= pEleDelim % pEleStartDelim @= pEleDelim );\n    sMessage = 'The delimiters\
    \ cannot me the same.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate Mapping parameter\nIf( TRIM( pEleMapping )\
    \ @<> '' & TRIM( pMappingDelim) @= '');\n    nErrors = nErrors + 1;\n    sMessage = 'Mapping\
    \ Delimiter & Element Mapping can not both be empty.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndif;\n\n# Validate Sandbox\nIf( TRIM( pSandbox ) @<> '' );\n\
    \    If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty( 0\
    \ );\n        nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is invalid\
    \ for the current user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        ServerActiveSandboxSet( pSandbox );\n        SetUseActiveSandboxProperty(\
    \ 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty( 0 );\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 );\n   \
    \   ProcessQuit;\n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n########## pEleMapping\
    \ ######################################################\n### Split ElementMapping parameter\
    \ and create variables to be substituted ###\n#################################################################################################\
    \ #############\nsElementMapping     = TRIM( pEleMapping );\nsMappingDelimiter   = TRIM(\
    \ pMappingDelim );\nsElementStartDelim  = TRIM( pEleStartDelim );\nsDelimDim           =\
    \ TRIM( pDimDelim );\nsDecimalSeparator   = TRIM(pDecimalSeparator);\nsThousandSeparator\
    \  = TRIM(pThousandSeparator);\nsFilter             = TRIM( pFilter);\nsTargetFilter   \
    \    = '';\nnSuppressConsol     = pSuppressConsol;\nnChar               = 1;\nnCharCount\
    \          = LONG( sElementMapping );\n\n# If there's no element mapping then the process\
    \ can be used to multiply existing value by a factor\nIf( nCharCount > 0 );\n\n  sWord =\
    \ '';\n  sLastDelim = '';\n\n  # Add a trailing element delimiter so that the last element\
    \ is picked up\n  If( nCharCount > 0 );\n    sElementMapping = sElementMapping | sMappingDelimiter\
    \ ;\n    nCharCount      = nCharCount + LONG(sMappingDelimiter );\n  EndIf;\n\n  WHILE (nChar\
    \ <= nCharCount);\n    sChar = SUBST( sElementMapping, nChar, 1);\n\n    # Used for delimiters,\
    \ required for multiple character delimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n \
    \   # Ignore spaces\n    IF (TRIM(sChar) @<> '' );\n\n      ### Dimension Name ###\n\n \
    \     # If the delimiter is more than 1 character peek ahead the same amount\n      # Ignore\
    \ the first character\n      sDelim = sChar;\n      nCount = LONG(sElementStartDelim) -\
    \ 1;\n      If( nCount > 0 & nChar + nCount <= nCharCount );\n        # Add the extra characters\n\
    \        sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\n        # Move to\
    \ the end of the delimter\n        nAddExtra = nCount;\n      EndIf;\n\n      If( sDelim\
    \ @= sElementStartDelim );\n\n        sChar = sDelim;\n\n        If( sLastDelim @<> '' &\
    \ sLastDelim @<> sDelimDim );\n            sMessage = Expand ( 'The name of a dimension\
    \ must follow a dimension delimiter %sDelimDim%' );\n            nErrors = nErrors + 1;\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \        EndIf;\n\n        sDimension = sWord;\n\n        If( DimensionExists( sDimension\
    \ ) = 0 );\n            # The dimension does not exist in the model. Cancel process\n  \
    \          sMessage = Expand( 'Dimension: %sDimension% does not exist');\n            nErrors\
    \ = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \            #ProcessError();\n        EndIf;\n\n        # Check that the dimension is in\
    \ the cube\n         i = 1;\n         iMax = 30;\n         sDimInCube = 'No';\n        \
    \ While( i <= iMax );\n           sDimensionOfCube = TabDim( pCube, i );\n           If(sDimension\
    \ @= sDimensionOfCube);\n             sDimInCube = 'Yes';\n             # record where the\
    \ loop stops\n             nIndex = i;\n             i = 100;\n             Else;\n    \
    \         i = i + 1;\n           EndIf;\n        End;\n\n        If( sDimInCube @<> 'Yes'\
    \ );\n            # The dimension does not exist in the cube. Cancel process\n         \
    \   sMessage = Expand( 'Dimension %sDimension% does not exist in this cube');\n        \
    \    nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            #ProcessError();\n        EndIf;\n\n        ### Dimension exists so\
    \ add it to the filters\n        IF(LONG(sFilter) > 0 & sLastDelim @= '');\n          sTargetFilter\
    \ = sFilter | sDelimDim | sDimension | sElementStartDelim;\n          sFilter = sFilter\
    \ | sDelimDim | sDimension | sElementStartDelim;\n          ElseiF(LONG(sFilter) > 0 & sLastDelim@<>'');\n\
    \          sFilter = sFilter | sDelimDim | sDimension | sElementStartDelim;\n          sTargetFilter\
    \ = sTargetFilter | sDelimDim | sDimension | sElementStartDelim;\n          Else;\n    \
    \      sFilter = sDimension | sElementStartDelim;\n          sTargetFilter = sDimension\
    \ | sElementStartDelim;\n        EndIf;\n\n        #Reset the source and target elements\n\
    \        sSource = '';\n        sTarget = '';\n\n        # The variable nElementCount is\
    \ used to keep track of how many elements there are per dimension\n        # the first element\
    \ is the source\n        # the second element is the target\n        # There shouldn't be\
    \ any more than 2 elements per dimension\n\n        # A new dimension has been found so\
    \ reset the element count so\n        # the code can tell how many elements have been specified\
    \ for each dimension\n        # There should just be 2\n\n        nElementCount = 1;\n \
    \       sLastDelim = sChar;\n\n        # Clear the word\n        sWord = '';\n\n      Else;\n\
    \n        # Reset extra chars\n        nAddExtra = 0;\n\n        ### Check both dim delimiter\
    \ and element delimiter ###\n        nIsDelimiter = 0;\n\n        # Check dim delim\n  \
    \      # If the delimiter is more than 1 character peek ahead the same amount\n        #\
    \ Ignore the first character\n        sDelim = sChar;\n        nCount = LONG(sDelimDim)\
    \ - 1;\n        If( nCount > 0 & nChar + nCount <= nCharCount );\n          # Add the extra\
    \ characters\n          sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\n\
    \          # Move to the end of the delimter\n          nAddExtra = nCount;\n        EndIf;\n\
    \n        If( sDelim @= sDelimDim );\n          nIsDelimiter = 1;\n          sChar = sDelim;\n\
    \        Else;\n          # Reset extra chars\n          nAddExtra = 0;\n\n          ##\
    \ Check element delimiter\n\n          # If the delimiter is more than 1 character peek\
    \ ahead the same amount\n          # Ignore the first character\n          sDelim = sChar;\n\
    \          nCount = LONG(sMappingDelimiter) - 1;\n          If( nCount > 0 & nChar + nCount\
    \ <= nCharCount );\n            # Add the extra characters\n            sDelim = sDelim\
    \ | SUBST( sElementMapping, nChar + 1, nCount);\n            # Move to the end of the delimter\n\
    \            nAddExtra = nCount;\n          EndIf;\n\n          If( sDelim @= sMappingDelimiter\
    \  );\n            nIsDelimiter = 1;\n            sChar = sDelim;\n          Else;\n   \
    \         # Reset extra chars\n            nAddExtra = 0;\n          EndIf;\n\n        EndIf;\n\
    \n        If ( nIsDelimiter = 1 );\n\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim\
    \ );\n            sMessage = 'An element start delimiter must follow a dimension name: '\
    \ |  sChar | ' (' | NumberToString(nChar) | ')';\n            nErrors = nErrors + 1;\n \
    \           LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \          EndIf;\n\n          # an element has been found!\n          sElement = sWord;\n\
    \n          If( DIMIX( sDimension, sElement ) = 0 );\n            # The element does not\
    \ exist in the dimension. Cancel process\n            sMessage = Expand( 'Element: %sElement%\
    \ does not exist in dimension %sDimension%' );\n            nErrors = nErrors + 1;\n   \
    \         LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n          EndIf;\n\n\
    \          # Allow consolidations only if pSuppressConsol is not set to 1\n          # Consolidations\
    \ may be made allowable\n          # so that you can copy strings between c levels\n   \
    \       # or copy from a consolidated source element to an n level target element\n\n  \
    \        ### Check for errors before continuing\n          If( nErrors <> 0 );\n       \
    \       If( pStrictErrorHandling = 1 );\n                  ProcessQuit;\n              Else;\n\
    \                  ProcessBreak;\n              EndIf;\n          EndIf;\n\n          If\
    \ ( DTYPE( sDimension, sElement) @= 'C' );\n              IF( nElementCount = 1 );\n   \
    \             If( pSuppressConsol <> 1 );\n                  nSuppressConsol = 0;\n    \
    \            EndIf;\n                pSubN = 1;\n              Else;\n                sMessage\
    \ = Expand( 'Target element: %sElement% for dimension %sDimension% is consolidated' );\n\
    \                nErrors = nErrors + 1;\n                LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n                #ProcessBreak;\n              Endif;\n        \
    \  Endif;\n\n          # Add the element to the source or target depending on whether it's\
    \ the first or the second element\n          # Get principal name\n          # in case source\
    \ element and this element are using different aliases\n\n          sElement = DimensionElementPrincipalName(sDimension,sElement);\n\
    \n          # first element\n          IF(nElementCount = 1);\n\n            sSource = sElement;\n\
    \            sFilter = sFilter | sElement;\n\n          # second element\n          ElseIf(nElementCount\
    \ = 2);\n\n            sTarget = sElement;\n            sTargetFilter = sTargetFilter |\
    \ sElement;\n\n          Else;\n\n            sMessage = Expand( 'There should only be 2\
    \ elements per dimension: %sDimension% , a source and a target');\n            nErrors =\
    \ nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \           #ProcessError();\n\n          EndIf;\n\n          If(nIndex = 1);\n        \
    \    nMappedDim1 = 1;\n            sSourceDim1 = sSource;\n            sTargetDim1 = sTarget;\n\
    \          ElseIf(nIndex = 2);\n            nMappedDim2 = 1;\n            sSourceDim2 =\
    \ sSource;\n            sTargetDim2 = sTarget;\n          ElseIf(nIndex = 3);\n        \
    \    nMappedDim3 = 1;\n            sSourceDim3 = sSource;\n            sTargetDim3 = sTarget;\n\
    \          ElseIf(nIndex = 4);\n            nMappedDim4 = 1;\n            sSourceDim4 =\
    \ sSource;\n            sTargetDim4 = sTarget;\n          ElseIf(nIndex = 5);\n        \
    \    nMappedDim5 = 1;\n            sSourceDim5 = sSource;\n            sTargetDim5 = sTarget;\n\
    \          ElseIf(nIndex = 6);\n            nMappedDim6 = 1;\n            sSourceDim6 =\
    \ sSource;\n            sTargetDim6 = sTarget;\n          ElseIf(nIndex = 7);\n        \
    \    nMappedDim7 = 1;\n            sSourceDim7 = sSource;\n            sTargetDim7 = sTarget;\n\
    \          ElseIf(nIndex = 8);\n            nMappedDim8 = 1;\n            sSourceDim8 =\
    \ sSource;\n            sTargetDim8 = sTarget;\n          ElseIf(nIndex = 9);\n        \
    \    nMappedDim9 = 1;\n            sSourceDim9 = sSource;\n            sTargetDim9 = sTarget;\n\
    \          ElseIf(nIndex = 10);\n            nMappedDim10 = 1;\n            sSourceDim10\
    \ = sSource;\n            sTargetDim10 = sTarget;\n          ElseIf(nIndex = 11);\n    \
    \        nMappedDim11 = 1;\n            sSourceDim11 = sSource;\n            sTargetDim11\
    \ = sTarget;\n          ElseIf(nIndex = 12);\n            nMappedDim12 = 1;\n          \
    \  sSourceDim12 = sSource;\n            sTargetDim12 = sTarget;\n          ElseIf(nIndex\
    \ = 13);\n            nMappedDim13 = 1;\n            sSourceDim13 = sSource;\n         \
    \   sTargetDim13 = sTarget;\n          ElseIf(nIndex = 14);\n            nMappedDim14 =\
    \ 1;\n            sSourceDim14 = sSource;\n            sTargetDim14 = sTarget;\n       \
    \   ElseIf(nIndex = 15);\n            nMappedDim15 = 1;\n            sSourceDim15 = sSource;\n\
    \            sTargetDim15 = sTarget;\n          ElseIf(nIndex = 16);\n            nMappedDim16\
    \ = 1;\n            sSourceDim16 = sSource;\n            sTargetDim16 = sTarget;\n     \
    \     ElseIf(nIndex = 17);\n            nMappedDim17 = 1;\n            sSourceDim17 = sSource;\n\
    \            sTargetDim17 = sTarget;\n          ElseIf(nIndex = 18);\n            nMappedDim18\
    \ = 1;\n            sSourceDim18 = sSource;\n            sTargetDim18 = sTarget;\n     \
    \     ElseIf(nIndex = 19);\n            nMappedDim19 = 1;\n            sSourceDim19 = sSource;\n\
    \            sTargetDim19 = sTarget;\n          ElseIf(nIndex = 20);\n            nMappedDim20\
    \ = 1;\n            sSourceDim20 = sSource;\n            sTargetDim20 = sTarget;\n     \
    \     ElseIf(nIndex = 21);\n            nMappedDim21 = 1;\n            sSourceDim21 = sSource;\n\
    \            sTargetDim21 = sTarget;\n          ElseIf(nIndex = 22);\n            nMappedDim22\
    \ = 1;\n            sSourceDim22 = sSource;\n            sTargetDim22 = sTarget;\n     \
    \     ElseIf(nIndex = 23);\n            nMappedDim23 = 1;\n            sSourceDim23 = sSource;\n\
    \            sTargetDim23 = sTarget;\n          ElseIf(nIndex = 24);\n            nMappedDim24\
    \ = 1;\n            sSourceDim24 = sSource;\n            sTargetDim24 = sTarget;\n     \
    \     ElseIf(nIndex = 25);\n            nMappedDim25 = 1;\n            sSourceDim25 = sSource;\n\
    \            sTargetDim25 = sTarget;\n          ElseIf(nIndex = 26);\n            nMappedDim26\
    \ = 1;\n            sSourceDim26 = sSource;\n            sTargetDim26 = sTarget;\n     \
    \     ElseIf(nIndex = 27);\n            nMappedDim27 = 1;\n            sSourceDim27 = sSource;\n\
    \            sTargetDim27 = sTarget;\n          EndIf;\n\n          sLastDelim = sChar;\n\
    \n          # Clear the word\n          sWord = '';\n\n          nElementCount = nElementCount\
    \ + 1;\n\n        Else;\n          sWord = sWord | sChar;\n        EndIf;\n\n      EndIf;\n\
    \n    EndIf;\n\n    nChar = nChar + nAddExtra + 1;\n\n  END;\nENDIF;\n\n\n### Check that\
    \ there if a dimension is used, there is a source element and a target element\ncSourceVariableStem\
    \ = 'sSourceDim';\ncTargetVariableStem = 'sTargetDim';\ncMappedDimVariableStem = 'nMappedDim';\n\
    \nnCounter = 1;\nWHILE(nCounter <= nDimensionCount);\n\n  sMappedDimVariable = 'nMappedDim\
    \ ' | NumberToString(nCounter);\n  sDimensionUsedPadded = Expand('%' | sMappedDimVariable\
    \ | '%');\n\n  nMappedDim = StringToNumber(Trim(sDimensionUsedPadded));\n  If(nMappedDim\
    \ = 1);\n    sDim = TabDim( pCube, nCounter );\n    sSourceVariable = cSourceVariableStem\
    \ | NumberToString(nCounter);\n    sSourcePadded = Expand('%' | sSourceVariable | '%');\n\
    \    sSource = Trim(sSourcePadded);\n\n    sTargetVariable = cTargetVariableStem | NumberToString(nCounter);\n\
    \    sTargetPadded = Expand('%' | sTargetVariable | '%');\n    sTarget = Trim(sTargetPadded);\n\
    \n    If(sSource @='' % sTarget @='');\n      sMessage = 'Source and/or target element is\
    \ blank for dimension ' | sDim;\n      nErrors = nErrors + 1;\n      LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n      #ProcessError();\n    EndIf;\n\n  EndIf;\n\nnCounter\
    \ = nCounter + 1;\n\nEND;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n\
    \  DataSourceType = 'NULL';\n  If( pStrictErrorHandling = 1 );\n      ProcessQuit;\n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Branch depending on whether to do recursive\
    \ calls to self on independent threads or run all in this thread\nIf( Scan( pEleStartDelim,\
    \ pFilterParallel ) > 0 );\n  sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim,\
    \ pFilterParallel ) - 1 );\n  sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim,\
    \ pFilterParallel ) + Long( pEleStartDelim ), Long( pFilterParallel ) );\n  If( SubSt( sElementList,\
    \ Long( sElementList ), 1 ) @<> pEleDelim );\n      sElementList = sElementList | pEleDelim;\n\
    \  EndIf;\n  ## Counting elements in element list\n  sElementListCount = sElementList;\n\
    \  nElements = 0;\n  While( Scan( pEleDelim, sElementListCount ) > 0 );\n    nElements =\
    \ nElements + 1;\n    sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount\
    \ ) + Long( pEleDelim ), Long( sElementListCount ) );\n  End;\n  IF( Mod( nElements, nMaxThreads\
    \ ) = 0 );\n    nElemsPerThread = INT( nElements / nMaxThreads );\n  ELSE;\n    nElemsPerThread\
    \ = INT( nElements / nMaxThreads ) + 1;\n  ENDIF;\n  nThreadElCounter = 0;\n  While( Scan(\
    \ pEleDelim, sElementList ) > 0 );\n    sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim,\
    \ sElementList ) - 1 );\n    sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList\
    \ ) + Long( pEleDelim ), Long( sElementList ) );\n    # Do recursive process call with new\
    \ RunProcess function\n    nThreadElCounter = nThreadElCounter + 1;\n    sDimDelim = If(pFilter\
    \ @= '', '', pDimDelim );\n    IF( nThreadElCounter = 1 );\n      sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \    ELSE;\n      sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n    ENDIF;\n  \
    \  IF( nThreadElCounter >= nElemsPerThread );\n            nThreadID = INT( RAND( ) * 10000\
    \ + 1) + Numbr(cTimeStamp);\n      sThreadControlFile = GetProcessName() | '_ThreadControlFile_'\
    \ | cRandomInt | '_' | NumberToString(nThreadID) | '_' | cTimeStamp;\n      AsciiOutput(\
    \ cDir | sThreadControlFile | '.txt', '' );\n      LogOutput( 'INFO', 'Executing subTI with\
    \ Thread ID: ' | NumberToString(nThreadID) );\n      RunProcess( cThisProcName, 'pLogoutput',\
    \ pLogoutput,\n      \t'pCube', pCube, 'pSrcView', pSrcView, 'pTgtView', pTgtView,\n   \
    \   \t'pFilter', sFilter, 'pFilterParallel', '', 'pEleMapping', pEleMapping, 'pMappingDelim',\
    \ pMappingDelim,\n      \t'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim',\
    \ pEleDelim,\n      \t'pFactor', pFactor, 'pSuppressConsol', pSuppressConsol, 'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, 'pSuppressRules', pSuppressRules, 'pSuppressZero', pSuppressZero,\
    \ 'pCumulate', pCumulate,\n      \t'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource,\
    \ 'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox', pSandbox, 'pFile', pFile, 'pDecimalSeparator',\
    \ pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n        'pThreadMode', 1,\
    \ 'pThreadControlFile', sThreadControlFile\n      );\n  \t  nThreadElCounter = 0;\n  \t\
    \  sFilter = '';\n  \t  nThreadID = INT( RAND( ) * 10000 ) + 1;\n        sThreadControlFile\
    \ = GetProcessName() | '_ThreadControlFile_' | cRandomInt | '_' | NumberToString(nThreadID);\n\
    \        AsciiOutput( cDir | sThreadControlFile | '.txt', '' );\n        LogOutput( 'INFO',\
    \ 'Executing subTI with Thread ID: ' | NumberToString(nThreadID) );\n  \t ENDIF;\n  End;\n\
    \  ## Process last elements - only when filter is not empty (there are still elements)\n\
    \  IF( sFilter @<> '' );\n    RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n   \
    \ \t'pCube', pCube, 'pSrcView', pSrcView, 'pTgtView', pTgtView,\n    \t'pFilter', sFilter,\
    \ 'pFilterParallel', '', 'pEleMapping', pEleMapping, 'pMappingDelim', pMappingDelim,\n \
    \   \t'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n\
    \    \t'pFactor', pFactor, 'pSuppressConsol', pSuppressConsol, 'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, 'pSuppressRules', pSuppressRules, 'pSuppressZero', pSuppressZero,\
    \ 'pCumulate', pCumulate,\n    \t'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource,\
    \ 'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox', pSandbox, 'pFile', pFile, 'pDecimalSeparator',\
    \ pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n      'pThreadMode', 1,\
    \ 'pThreadControlFile', sThreadControlFile\n    );\n  ENDIF;\n  DataSourceType = 'NULL';\n\
    Else;\n  ### Create View of target to zero out\n  ### Check that there's something in sTargetFilter\
    \ so the cube doesn't accidentally get wiped out\n\n  If(pZeroTarget = 1 & LONG(sTargetFilter)>\
    \ 0);\n\n    sProc = '}bedrock.cube.data.clear';\n    nRet = ExecuteProcess( sProc,\n  \
    \  'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube',\
    \ pCube,\n    'pView', cViewTarget,\n    'pFilter', sTargetFilter,\n    'pDimDelim', pDimDelim,\n\
    \    'pEleStartDelim', pEleStartDelim,\n    'pEleDelim', pEleDelim,\n    'pCubeLogging',\
    \ pCubeLogging,\n    'pTemp', pTemp,\n    'pSandbox', pSandbox\n    );\n\n    IF(nRet <>\
    \ 0);\n        sMessage = 'Error clearing the target view.';\n        nErrors = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 );\n            ProcessQuit;\n        Else;\n            ProcessBreak;\n        EndIf;\n\
    \    ENDIF;\n\n  Endif;\n\n  If ( pCubeLogging <= 1 );\n    sCubeLogging = CellGetS('}CubeProperties',\
    \ pCube, 'LOGGING' );\n    CubeSetLogChanges( pCube, pCubeLogging);\n  EndIf;\n\n  If( pFile\
    \ = 0 );\n\n    ### Create View of Source ###\n\n    nRet = ExecuteProcess('}bedrock.cube.view.create',\n\
    \      'pLogOutput', pLogOutput,\n      'pStrictErrorHandling', pStrictErrorHandling,\n\
    \      'pCube', pCube,\n      'pView', cViewSource,\n      'pFilter', sFilter,\n      'pSuppressZero',\
    \ pSuppressZero,\n      'pSuppressConsol', nSuppressConsol,\n      'pSuppressRules', pSuppressRules,\n\
    \      'pSuppressConsolStrings', pSuppressConsolStrings,\n      'pDimDelim', pDimDelim,\n\
    \      'pEleStartDelim', pEleStartDelim,\n      'pEleDelim', pEleDelim ,\n      'pTemp',\
    \ pTemp,\n      'pSubN', pSubN\n      );\n\n    IF(nRet <> 0);\n          sMessage = 'Error\
    \ creating the view from the filter.';\n          nErrors = nErrors + 1;\n          LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n          If( pStrictErrorHandling = 1\
    \ );\n              ProcessQuit;\n          Else;\n              ProcessBreak;\n       \
    \   EndIf;\n    ENDIF;\n\n\n    ### Assign Datasource ###\n    DataSourceType          =\
    \ 'VIEW';\n    DatasourceNameForServer = pCube;\n    DatasourceNameForClient = pCube;\n\
    \    DatasourceCubeView      = cViewSource;\n    nThreadMode = 1;\n  Else;\n    ### Export\
    \ Data to file ###\n\n    nRet = ExecuteProcess('}bedrock.cube.data.export',\n       'pLogoutput',\
    \ pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n       'pCube', pCube,\n\
    \       'pView', cViewSource,\n       'pFilter', sFilter,\n       'pFilterParallel', '',\n\
    \       'pParallelThreads', 0,\n       'pDimDelim', pDimDelim,\n       'pEleStartDelim',\
    \ pEleStartDelim,\n       'pEleDelim', pEleDelim,\n       'pSuppressZero', pSuppressZero,\n\
    \       'pSuppressConsol', nSuppressConsol,\n       'pSuppressRules', pSuppressRules,\n\
    \       'pSuppressConsolStrings', pSuppressConsolStrings,\n       'pZeroSource', 0,\n  \
    \     'pCubeLogging', pCubeLogging,\n       'pTemp', pTemp,\n       'pFilePath', cDir,\n\
    \       'pFileName', cFileName,\n       'pDelim', cDelimiter,\n       'pDecimalSeparator',\
    \ sDecimalSeparator,\n       'pThousandSeparator', sThousandSeparator,\n       'pQuote',\
    \ cQuote,\n       'pTitleRecord', cTitleRows,\n       'pSandbox', pSandbox\n      );\n\n\
    \    IF(nRet <> 0);\n          sMessage = 'Error exporting data to file.';\n          nErrors\
    \ = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \         If( pStrictErrorHandling = 1 );\n              ProcessQuit;\n          Else;\n\
    \              ProcessBreak;\n          EndIf;\n    ENDIF;\n\n    If(FileExists(cFile) =\
    \ 0);\n      # If the file does not exist, it means that nothing got exported, so there\
    \ is nothing to import\n      If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( 'Process:%cThisProcName%\
    \ is skipping import as export file %cFile% was not found.' ) );\n      EndIf;\n      DataSourceType\
    \ = 'NULL';\n    Else;\n      ### Assign Datasource ###\n      DataSourceType          \
    \        = 'CHARACTERDELIMITED';\n      DatasourceNameForServer         = cFile;\n     \
    \ DatasourceNameForClient         = cFile;\n      DatasourceASCIIHeaderRecords    = cTitleRows;\n\
    \      DatasourceASCIIDelimiter        = cDelimiter;\n      DatasourceASCIIQuoteCharacter\
    \   = cQuote;\n    EndIf;\n\n    nThreadMode = 1;\n\n  EndIf;\n\nEndIf;\n\n### End Prolog\
    \ ###\n\n#Section Metadaten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \nIf( pFile > 0 );\n  v0 = v1; v1 = v2; v2 = v3;  v3 = v4; v4 = v5; v5 = v6; v6 = v7; v7\
    \ = v8; v8 = v9; v9 = v10; v10 = v11; v11 = v12; v12 = v13; v13 = v14; v14 = v15;\n  v15\
    \ = v16; v16 = v17; v17 = v18; v18 = v19; v19 = v20; v20 = v21; v21 = v22; v22 = v23; v23\
    \ = v24; v24 = v25; v25 = v26; v26 = v27; v27 = v28;  v28 = v29;\nEndIf;\n\nv1 = IF(nMappedDim1\
    \ = 1, IF(v1 @= sSourceDim1 % elisanc(sDim1,sSourceDim1,v1)=1, sTargetDim1, v1), v1);\n\
    v2 = IF(nMappedDim2 = 1, IF(v2 @= sSourceDim2 % elisanc(sDim2,sSourceDim2,v2)=1, sTargetDim2,\
    \ v2), v2);\nv3 = IF(nMappedDim3 = 1, IF(v3 @= sSourceDim3 % elisanc(sDim3,sSourceDim3,v3)=1,\
    \ sTargetDim3, v3), v3);\nv4 = IF(nMappedDim4 = 1, IF(v4 @= sSourceDim4 % elisanc(sDim4,sSourceDim4,v4)=1,\
    \ sTargetDim4, v4), v4);\nv5 = IF(nMappedDim5 = 1, IF(v5 @= sSourceDim5 % elisanc(sDim5,sSourceDim5,v5)=1,\
    \ sTargetDim5, v5), v5);\nv6 = IF(nMappedDim6 = 1, IF(v6 @= sSourceDim6 % elisanc(sDim6,sSourceDim6,v6)=1,\
    \ sTargetDim6, v6), v6);\nv7 = IF(nMappedDim7 = 1, IF(v7 @= sSourceDim7 % elisanc(sDim7,sSourceDim7,v7)=1,\
    \ sTargetDim7, v7), v7);\nv8 = IF(nMappedDim8 = 1, IF(v8 @= sSourceDim8 % elisanc(sDim8,sSourceDim8,v8)=1,\
    \ sTargetDim8, v8), v8);\nv9 = IF(nMappedDim9 = 1, IF(v9 @= sSourceDim9 % elisanc(sDim9,sSourceDim9,v9)=1,\
    \ sTargetDim9, v9), v9);\nv10 = IF(nMappedDim10 = 1, IF(v10 @= sSourceDim10 % elisanc(sDim10,sSourceDim10,v10)=1,\
    \ sTargetDim10, v10), v10);\nv11 = IF(nMappedDim11 = 1, IF(v11 @= sSourceDim11 % elisanc(sDim11,sSourceDim11,v11)=1,\
    \ sTargetDim11, v11), v11);\nv12 = IF(nMappedDim12 = 1, IF(v12 @= sSourceDim12 % elisanc(sDim12,sSourceDim12,v12)=1,\
    \ sTargetDim12, v12), v12);\nv13 = IF(nMappedDim13 = 1, IF(v13 @= sSourceDim13 % elisanc(sDim13,sSourceDim13,v13)=1,\
    \ sTargetDim13, v13), v13);\nv14 = IF(nMappedDim14 = 1, IF(v14 @= sSourceDim14 % elisanc(sDim14,sSourceDim14,v14)=1,\
    \ sTargetDim14, v14), v14);\nv15 = IF(nMappedDim15 = 1, IF(v15 @= sSourceDim15 % elisanc(sDim15,sSourceDim15,v15)=1,\
    \ sTargetDim15, v15), v15);\nv16 = IF(nMappedDim16 = 1, IF(v16 @= sSourceDim16 % elisanc(sDim16,sSourceDim16,v16)=1,\
    \ sTargetDim16, v16), v16);\nv17 = IF(nMappedDim17 = 1, IF(v17 @= sSourceDim17 % elisanc(sDim17,sSourceDim17,v17)=1,\
    \ sTargetDim17, v17), v17);\nv18 = IF(nMappedDim18 = 1, IF(v18 @= sSourceDim18 % elisanc(sDim18,sSourceDim18,v18)=1,\
    \ sTargetDim18, v18), v18);\nv19 = IF(nMappedDim19 = 1, IF(v19 @= sSourceDim19 % elisanc(sDim19,sSourceDim19,v19)=1,\
    \ sTargetDim19, v19), v19);\nv20 = IF(nMappedDim20 = 1, IF(v20 @= sSourceDim20 % elisanc(sDim20,sSourceDim20,v20)=1,\
    \ sTargetDim20, v20), v20);\nv21 = IF(nMappedDim21 = 1, IF(v21 @= sSourceDim21 % elisanc(sDim21,sSourceDim21,v21)=1,\
    \ sTargetDim21, v21), v21);\nv22 = IF(nMappedDim22 = 1, IF(v22 @= sSourceDim22 % elisanc(sDim22,sSourceDim22,v22)=1,\
    \ sTargetDim22, v22), v22);\nv23 = IF(nMappedDim23 = 1, IF(v23 @= sSourceDim23 % elisanc(sDim23,sSourceDim23,v23)=1,\
    \ sTargetDim23, v23), v23);\nv24 = IF(nMappedDim24 = 1, IF(v24 @= sSourceDim24 % elisanc(sDim23,sSourceDim24,v24)=1,\
    \ sTargetDim24, v24), v24);\nv25 = IF(nMappedDim25 = 1, IF(v25 @= sSourceDim25 % elisanc(sDim25,sSourceDim25,v25)=1,\
    \ sTargetDim25, v25), v25);\nv26 = IF(nMappedDim26 = 1, IF(v26 @= sSourceDim26 % elisanc(sDim26,sSourceDim26,v26)=1,\
    \ sTargetDim26, v26), v26);\nv27 = IF(nMappedDim27 = 1, IF(v27 @= sSourceDim27 % elisanc(sDim27,sSourceDim27,v27)=1,\
    \ sTargetDim27, v27), v27);\n\n\n### Write data from source version to target version ###\n\
    \n# Selects the correct CellPut formula depending upon the number of dimensions in the cube\n\
    # and whether the value is numeric or string ( max 27 dims catered for in this code )\n\
    # value type determined by element type of last dimension in cube\n# could have used Value_is_String\
    \ = 1 and NValue/SValue but this works just as well\n\n\nIf( nDimensionCount = 2 );\n  \
    \  If( CellIsUpdateable( pCube, v1, v2 ) = 1 );\n        sElType = DType( sDim2, v2 );\n\
    \        IF( SubSt( pCube, 1, 17 ) @= '}ElementSecurity_');\n            v3 = IF( v3 @=\
    \ '', 'NONE', v3 );\n            ElementSecurityPut( v3, sDim1, v1, v2 );\n        ELSEIF(\
    \ sElType @= 'AA' );\n            AttrPutS( v3, sDim1, v1, v2, 1 );\n        ELSEIF( sElType\
    \ @= 'AS' );\n            AttrPutS( v3, sDim1, v1, v2 );\n        ELSEIF( sElType @= 'AN'\
    \ );\n            AttrPutN( StringToNumberEx( v3, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor, sDim1, v1, v2 );\n        ElseIf( sElType @= 'S' );\n            CellPutS(\
    \ v3, pCube, v1, v2 );\n        Else;\n            IF( pCumulate = 1);\n               \
    \ nObal = CellGetN( pCube, v1, v2 );\n                nCbal = nObal + StringToNumberEx(\
    \ v3, sDecimalSeparator, sThousandSeparator ) * nFactor;\n            ELSE;\n          \
    \      nCbal = StringToNumberEx( v3, sDecimalSeparator, sThousandSeparator ) * nFactor;\n\
    \            Endif;\n            CellPutN( nCbal, pCube, v1, v2 );\n        EndIf;\n   \
    \ EndIf;\nElseIf( nDimensionCount = 3 );\n    If( CellIsUpdateable( pCube, v1, v2, v3 )\
    \ = 1 );\n        sElType = DType( sDim3, v3 );\n        If( sElType @<> 'S' );\n      \
    \      IF( pCumulate = 1);\n                nObal = CellGetN( pCube, v1, v2, v3 );\n   \
    \             nCbal = nObal + StringToNumberEx( v4, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n            ELSE;\n                nCbal = StringToNumberEx( v4, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n            Endif;\n            CellPutN( nCbal, pCube,\
    \ v1, v2, v3 );\n        Else;\n            CellPutS( v4, pCube, v1, v2, v3 );\n       \
    \ EndIf;\n    EndIf;\nElseIf( nDimensionCount = 4 );\n    If( CellIsUpdateable( pCube, v1,\
    \ v2, v3, v4 ) = 1 );\n        sElType = DType( sDim4, v4 );\n        If( sElType @<> 'S'\
    \ );\n            IF( pCumulate = 1);\n                nObal = CellGetN( pCube, v1, v2,\
    \ v3, v4);\n                nCbal = nObal + StringToNumberEx( v5, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n            ELSE;\n                nCbal = StringToNumberEx( v5, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n            Endif;\n            CellPutN( nCbal, pCube,\
    \ v1, v2, v3, v4);\n        Else;\n            CellPutS( v5, pCube, v1, v2, v3, v4);\n \
    \       EndIf;\n    EndIf;\nElseIf( nDimensionCount = 5 );\n    If( CellIsUpdateable( pCube,\
    \ v1, v2, v3, v4, v5 ) = 1 );\n      sElType = DType( sDim5, v5 );\n      If( sElType @<>\
    \ 'S' );\n        IF(pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4,\
    \ v5 );\n          nCbal = nObal + StringToNumberEx( v6, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v6, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2,\
    \ v3, v4, v5 );\n      Else;\n        CellPutS( v6, pCube, v1, v2, v3, v4, v5 );\n     \
    \ EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 6 );\n    If( CellIsUpdateable( pCube,\
    \ v1, v2, v3, v4, v5, v6 ) = 1 );\n      sElType = DType( sDim6, v6 );\n      If( sElType\
    \ @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3,\
    \ v4, v5, v6 );\n          nCbal = nObal + StringToNumberEx( v7, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v7, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2,\
    \ v3, v4, v5, v6 );\n      Else;\n        CellPutS( v7, pCube, v1, v2, v3, v4, v5, v6 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 7 );\n    If( CellIsUpdateable( pCube,\
    \ v1, v2, v3, v4, v5, v6, v7 ) = 1 );\n      sElType = DType( sDim7, v7 );\n      If( sElType\
    \ @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3,\
    \ v4, v5, v6, v7 );\n          nCbal = nObal + StringToNumberEx( v8, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v8,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7 );\n      Else;\n        CellPutS( v8, pCube,\
    \ v1, v2, v3, v4, v5, v6, v7 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 8\
    \ );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8 ) = 1 );\n      sElType\
    \ = DType( sDim8, v8 );\n      If( sElType @<> 'S' );\n        IF( pCumulate = 1);\n   \
    \       nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8 );\n          nCbal = nObal\
    \ + StringToNumberEx( v9, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n\
    \          nCbal = StringToNumberEx( v9, sDecimalSeparator, sThousandSeparator )* nFactor;\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8 );\n   \
    \   Else;\n        CellPutS( v9, pCube, v1, v2, v3, v4, v5, v6, v7, v8 );\n      EndIf;\n\
    \    EndIf;\n  ElseIf( nDimensionCount = 9 );\n    If( CellIsUpdateable( pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9 ) = 1 );\n      sElType = DType( sDim9, v9 );\n      If( sElType\
    \ @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3,\
    \ v4, v5, v6, v7, v8, v9 );\n          nCbal = nObal + StringToNumberEx( v10, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v10,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 );\n      Else;\n        CellPutS( v10,\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 10 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10 ) =\
    \ 1 );\n      sElType = DType( sDim10, v10 );\n      If( sElType @<> 'S' );\n        IF(\
    \ pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9,\
    \ v10 );\n          nCbal = nObal + StringToNumberEx( v11, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v11, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10 );\n      Else;\n        CellPutS( v11, pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 11 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\
    \ ) = 1 );\n      sElType = DType( sDim11, v11 );\n      If( sElType @<> 'S' );\n      \
    \  IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11 );\n          nCbal = nObal + StringToNumberEx( v12, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v12, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10, v11 );\n      Else;\n        CellPutS( v12, pCube, v1,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 12 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12 ) = 1 );\n      sElType = DType( sDim12, v12 );\n      If( sElType @<> 'S' );\n  \
    \      IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7,\
    \ v8, v9, v10, v11, v12 );\n          nCbal = nObal + StringToNumberEx( v13, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v13,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );\n      Else;\n    \
    \    CellPutS( v13, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );\n      EndIf;\n\
    \    EndIf;\n  ElseIf( nDimensionCount = 13 );\n    If( CellIsUpdateable( pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 ) = 1 );\n      sElType = DType( sDim13,\
    \ v13 );\n      If( sElType @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 );\n          nCbal = nObal\
    \ + StringToNumberEx( v14, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n\
    \          nCbal = StringToNumberEx( v14, sDecimalSeparator, sThousandSeparator ) * nFactor;\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\
    \ v11, v12, v13 );\n      Else;\n        CellPutS( v14, pCube, v1, v2, v3, v4, v5, v6, v7,\
    \ v8, v9, v10, v11, v12, v13 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 14\
    \ );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14 ) = 1 );\n      sElType = DType( sDim14, v14 );\n      If( sElType @<> 'S' );\n\
    \        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14 );\n          nCbal = nObal + StringToNumberEx( v15,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx(\
    \ v15, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 );\n      Else;\n\
    \        CellPutS( v15, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 15 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 ) = 1 );\n   \
    \   sElType = DType( sDim15, v15 );\n      If( sElType @<> 'S' );\n        IF( pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15 );\n          nCbal = nObal + StringToNumberEx( v16, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v16,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );\n  \
    \    Else;\n        CellPutS( v16, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 16 );\n \
    \   If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16 ) = 1 );\n      sElType = DType( sDim16, v16 );\n      If( sElType @<> 'S'\
    \ );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );\n          nCbal = nObal + StringToNumberEx(\
    \ v17, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v17, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16 );\n      Else;\n        CellPutS( v17, pCube, v1, v2, v3, v4, v5, v6, v7,\
    \ v8, v9, v10, v11, v12, v13, v14, v15, v16 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 17 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17 ) = 1 );\n      sElType = DType( sDim17, v17 );\n      If(\
    \ sElType @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\n          nCbal\
    \ = nObal + StringToNumberEx( v18, sDecimalSeparator, sThousandSeparator ) * nFactor;\n\
    \        ELSE;\n          nCbal = StringToNumberEx( v18, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\n      Else;\n        CellPutS(\
    \ v18, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 18 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18\
    \ ) = 1 );\n      sElType = DType( sDim18, v18 );\n      If( sElType @<> 'S' );\n      \
    \  IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );\n          nCbal = nObal + StringToNumberEx(\
    \ v19, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v19, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16, v17, v18 );\n      Else;\n        CellPutS( v19, pCube, v1, v2, v3, v4,\
    \ v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );\n      EndIf;\n   \
    \ EndIf;\n  ElseIf( nDimensionCount = 19 );\n    If( CellIsUpdateable( pCube, v1, v2, v3,\
    \ v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 ) = 1 );\n  \
    \    sElType = DType( sDim19, v19 );\n      If( sElType @<> 'S' );\n        IF( pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19 );\n          nCbal = nObal + StringToNumberEx(\
    \ v20, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v20, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16, v17, v18, v19 );\n      Else;\n        CellPutS( v20, pCube, v1, v2, v3,\
    \ v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );\n      EndIf;\n\
    \    EndIf;\n  ElseIf( nDimensionCount = 20 );\n    If( CellIsUpdateable( pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 ) =\
    \ 1 );\n      sElType = DType( sDim20, v20 );\n      If( sElType @<> 'S' );\n        IF(\
    \ pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9,\
    \ v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 );\n          nCbal = nObal + StringToNumberEx(\
    \ v21, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v21, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16, v17, v18, v19, v20 );\n      Else;\n        CellPutS( v21, pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 21 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21 ) = 1 );\n      sElType = DType( sDim21, v21 );\n      If( sElType @<> 'S'\
    \ );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );\n      \
    \    nCbal = nObal + StringToNumberEx( v22, sDecimalSeparator, sThousandSeparator ) * nFactor;\n\
    \        ELSE;\n          nCbal = StringToNumberEx( v22, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );\n      Else;\n\
    \        CellPutS( v22, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 22 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 ) = 1 );\n      sElType = DType(\
    \ sDim22, v22 );\n      If( sElType @<> 'S' );\n        IF( pCumulate = 1);\n          nObal\
    \ = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,\
    \ v17, v18, v19, v20, v21, v22 );\n          nCbal = nObal + StringToNumberEx( v23, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v23,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\
    \ v18, v19, v20, v21, v22 );\n      Else;\n        CellPutS( v23, pCube, v1, v2, v3, v4,\
    \ v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 23 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21,\n    v22, v23 ) = 1 );\n      sElType = DType( sDim23, v23 );\n      If(\
    \ sElType @<> 'S' );\n        IF( pCumulate >= 1);\n          nObal = CellGetN( pCube, v1,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20,\
    \ v21, v22, v23 );\n          nCbal = nObal + StringToNumberEx( v24, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v24,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\
    \ v18, v19, v20, v21, v22, v23 );\n      Else;\n        CellPutS( v24, pCube, v1, v2, v3,\
    \ v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\
    \ v23 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 24 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21, v22, v23, v24 ) = 1 );\n      sElType = DType( sDim24, v24 );\n      If(\
    \ sElType @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20,\
    \ v21, v22, v23, v24 );\n          nCbal = nObal + StringToNumberEx( v25, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v25,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\
    \ v18, v19, v20, v21, v22, v23, v24 );\n      Else;\n        CellPutS( v25, pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\
    \ v22, v23, v24 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 25 );\n    If(\
    \ CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25 ) = 1 );\n      sElType = DType(\
    \ sDim25, v25 );\n      If( sElType @<> 'S' );\n        IF( pCumulate = 1);\n          nObal\
    \ = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,\
    \ v17, v18, v19, v20, v21, v22, v23, v24, v25 );\n          nCbal = nObal + StringToNumberEx(\
    \ v26, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v26, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25 );\n      Else;\n        CellPutS(\
    \ v26, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\
    \ v18, v19, v20, v21, v22, v23, v24, v25 );\n      EndIf;\n    EndIf;\nElseIf( nDimensionCount\
    \ = 26 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n    v22, v23, v24, v25, v26 ) = 1 );\n\
    \      sElType = DType( sDim26, v26 );\n      If( sElType @<> 'S' );\n        IF( pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26 );\n       \
    \   nCbal = nObal + StringToNumberEx( v27, sDecimalSeparator, sThousandSeparator ) * nFactor;\n\
    \        ELSE;\n          nCbal = StringToNumberEx( v27, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\
    \ v25, v26 );\n      Else;\n        CellPutS( v27, pCube, v1, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26\
    \ );\n      EndIf;\n    EndIf;\nElseIf( nDimensionCount = 27 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21, v22, v23, v24, v25, v26, v27 ) = 1 );\n      sElType = DType( sDim27, v27\
    \ );\n      If( sElType @<> 'S' );\n        IF( pCumulate >= 1);\n          nObal = CellGetN(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21, v22, v23, v24, v25, v26, v27 );\n          nCbal = nObal + StringToNumberEx(\
    \ v28, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v28, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27 );\n      Else;\n\
    \        CellPutS( v28, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27 );\n      EndIf;\n   \
    \ EndIf;\n\n  EndIf;\n\n\n### End Data ###\n#Section Epilog\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# Zero out source cube #\nIF( pZeroSource = 1 & nErrors\
    \ = 0 );\n    sProc = '}bedrock.cube.data.clear';\n    nRet = ExecuteProcess( sProc,\n \
    \       'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pCube', pCube,\n        'pView', cViewSource,\n        'pFilter', sFilter,\n \
    \       'pDimDelim', pDimDelim,\n        'pEleStartDelim', pEleStartDelim,\n        'pEleDelim',\
    \ pEleDelim,\n        'pTemp', pTemp,\n        'pCubeLogging', pCubeLogging,\n        'pSandbox',\
    \ pSandbox\n    );\n    If(nRet <> 0);\n        sMessage = 'Error clearing the source view.';\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        ProcessError();\n    EndIf;\nEndIf;\n\n\nIf( pCubeLogging <= 1 );\n    CubeSetLogChanges(\
    \ pCube, IF(sCubeLogging@='YES',1,0) );\nEndIf;\n\n### Delete export file if used\nIf( pFile\
    \ = 1 );\n  TM1RunCmd = 'CMD.EXE /C 'DEL '' | cFile | '' '';\n  EXECUTECOMMAND ( TM1RunCmd\
    \ , 0 );\nEndIf;\n\n### Delete thread control file if used\nIf( pThreadControlFile @<> ''\
    \ );\n    LogOutput( 'INFO', 'Removing thread control file: ' | pThreadControlFile );\n\
    \    ASCIIDelete( cDir | pThreadControlFile | '.txt' );\nEndIf;\n\n### Wait for all parallel\
    \ threads to finish if using pFilterParallel\nIf( pFilterParallel @<> '' );\n    sThreadFilePattern\
    \ = GetProcessName() | '_ThreadControlFile_' | cRandomInt | '_' | '*.txt';\n    LogOutput(\
    \ 'INFO', 'Checking for: ' | sThreadFilePattern );\n    i = 1;\n    While( i < pMaxWaitSeconds\
    \ );\n        sThreadCheck = WildcardFileSearch( cDir | sThreadFilePattern, '' );\n    \
    \    If( sThreadCheck @<> '' );\n            Sleep( 1 );\n        Else;\n            Break;\n\
    \        EndIf;\n\n    i = i + 1;\n    End;\nEndIf;\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 );\n        ProcessQuit;\n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully copied data from %pSrcView% view to the\
    \ %pTgtView% view in the %pCube% cube.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProces"
- question: Develop a detailed description and guide for implementing an IBM Turbo Integrator
    process that copies data from one element of a dimension to another within the same cube.
    This process should primarily be used in production environments, for example, to archive
    a Budget or Forecast element of a version dimension or to prepopulate a version from a prior
    year. Ensure a valid cube name (pCube) and element mapping (pEleMapping) are provided; otherwise,
    the process will abort. A filter parameter (pFilter) can also be utilized to filter out
    dimensions not mapped. The source (pSrcView) and target (pTgtView) views will be assigned
    temporary names if left blank. Ensure all other parameters are used appropriately, especially
    when specifying pEleMapping and pFilter. As this process uses a view as a data source, implicit
    variables like NValue, SValue, and Value_is_String are required. For editing in Architect,
    a temporary cube with at least 24 dimensions is required as the preview data source; alternatively,
    set the data source to ASCII and manually edit the TI after saving to add back the required
    implicit view variables. If the pFilterParallel parameter is used, the single dimension
    used as the 'parallelization slicer' should not appear in the pFilter and pEleMapping parameters.
    When using parallelization via the *RunProcess* function, the elements listed in pFilterParallel
    will be split one-at-a-time and passed to a recursive call of the process being added to
    pFilter.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI is intended to copy data from one element of a\
    \ dimension to another in the same cube.\n\n# Use case: Mainly used in production environments.\n\
    # 1/ Typically, this would be used to archive a Budget or Forecast element of a version\
    \ dimension.\n# 2/ Could also be used to prepopulate a version from a prior year.\n\n# Note:\n\
    # Naturally, a valid cube name (pCube) is required. otherwise the process will abort.\n\
    # Element mapping (pEleMapping) is also required, otherwise the process will abort.\n# A\
    \ filter parameter (pFilter) can also be used to filter dimensions that have not been mapped.\n\
    # Source (pSrcView) & target (pTgtView) views will be assigned temporary names if left blank.\n\
    # All other parameters may be left as is but be sure to use them appropriately when specifying\
    \ pEleMapping & pFilter parameters.\n# - Since this TI has a view as a data source, it requires\
    \ the implicit variables NValue, SValue and Value_is_String.\n# - To edit this TI in Architect\
    \ a tmp cube with minimum 24 dims is needed as the preview data source or set the data\n\
    #   source to ASCII and manually edit the TI in notepad after saving to add back the required\
    \ implicit view variables.\n# - If using the pFilterParallel parameter the **single dimension**\
    \ used as the 'parallelization slicer' cannot appear in\n#   the pFilter and pEleMapping\
    \ parameters.\n# - When using parallelization via the *RunProcess* function the elements\
    \ listed in pFilterParallel will be split one_at_a_time\n#   and passed to a recursive call\
    \ of the process being added to pFilter.\n#EndRegion @DOC\n\nIf( pThreadControlFile @<>\
    \ '' );\n    LogOutput( 'INFO', 'Executed as subTI with Thread Control File: ' | pThreadControlFile\
    \ );\nEndIf;\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n# Target Filter Variable for shell processes\nStringGlobalVariable('sTargetFilter');\n\
    \n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\n\
    cTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo        = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pSrcView:%pSrcView%,\
    \ pTgtView:%pTgtView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%,\
    \ pEleMapping:%pEleMapping%, pMappingDelim:%pMappingDelim%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%, pFactor:%pFactor%, pSuppressConsol:%pSuppressConsol%, pSuppressConsolStrings:%pSuppressConsolStrings%,\
    \ pSuppressRules:%pSuppressRules%, pSuppressZero:%pSuppressZero%, pCumulate:%pCumulate%,\
    \ pZeroTarget:%pZeroTarget%, pZeroSource:%pZeroSource%, pTemp:%pTemp%, pCubeLogging:%pCubeLogging%,\
    \ pSandbox:%pSandbox%, pFile:%pFile%.';\ncDefaultView    = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%'\
    \ );\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );\nENDIF;\n\n#Disable logic for pCubeLogic for prararrel thread\nIF (pParallelThreads\
    \ > 0);\n  pCubeLogging = 2;\nEndif;\n\n# Variables\nnDataCount      = 0;\nnExistingSourceFlag\
    \ = 0;\nnAttrCubeFlag   = 0;\ncSuffixSource   = 'S';\ncSuffixTarget   = 'T';\ncPrefixElementAttributes\
    \ = '}ElementAttributes_';\ncDimCountMax    = 27;\nsDimCountMax    = NumberToString( cDimCountMax\
    \ );\nnFactor = If( pFactor = 0, 1, pFactor );\ncLenASCIICode = 3;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate file\
    \ delimiter & quote character\nIf( pDelim @= '' );\n    pDelim = ',';\nElse;\n    # If length\
    \ of pDelim is exactly 3 chars and each of them is decimal digit, then the pDelim is entered\
    \ as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim) = cLenASCIICode );\n      nChar\
    \ = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pDelim, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pDelim, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n       \
    \ Else;\n          nValid = 0;\n          Break;\n        EndIf;\n        nChar = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber(\
    \ pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\
    \nIf( pQuote @= '' );\n    ## Use no quote character\nElse;\n    # If length of pQuote is\
    \ exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII\
    \ code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n  \
    \    While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0',\
    \ 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n\
    \          nValid = 0;\n          Break;\n        EndIf;\n        nChar = nChar + 1;\n \
    \     End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote\
    \ ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n\
    ## File location for indirect data copy\ncDir    = '.' | sOSDelim;\ncFileName = pCube |\
    \ cTimeStamp | cRandomInt | '.csv';\ncFile   = cDir | cFileName;\ncTitleRows = 1;\ncDelimiter\
    \ = pDelim;\ncQuote = pQuote;\n\n# nMappedDimX is a binary switch used to keep track of\
    \ which dimensions have been mapped from the source to the target\nnMappedDim1 = 0;\nnMappedDim2\
    \ = 0;\nnMappedDim3 = 0;\nnMappedDim4 = 0;\nnMappedDim5 = 0;\nnMappedDim6 = 0;\nnMappedDim7\
    \ = 0;\nnMappedDim8 = 0;\nnMappedDim9 = 0;\nnMappedDim10 = 0;\nnMappedDim11 = 0;\nnMappedDim12\
    \ = 0;\nnMappedDim13 = 0;\nnMappedDim14 = 0;\nnMappedDim15 = 0;\nnMappedDim16 = 0;\nnMappedDim17\
    \ = 0;\nnMappedDim18 = 0;\nnMappedDim19 = 0;\nnMappedDim20 = 0;\nnMappedDim21 = 0;\nnMappedDim22\
    \ = 0;\nnMappedDim23 = 0;\nnMappedDim24 = 0;\nnMappedDim25 = 0;\nnMappedDim26 = 0;\nnMappedDim27\
    \ = 0;\n\n### Determine dimensions in target cube - we need to know this to test the cell\
    \ type before loading ###\nsDim1 = TabDim( pCube, 1 );\nsDim2 = TabDim( pCube, 2 );\nsDim3\
    \ = TabDim( pCube, 3 );\nsDim4 = TabDim( pCube, 4 );\nsDim5 = TabDim( pCube, 5 );\nsDim6\
    \ = TabDim( pCube, 6 );\nsDim7 = TabDim( pCube, 7 );\nsDim8 = TabDim( pCube, 8 );\nsDim9\
    \ = TabDim( pCube, 9 );\nsDim10 = TabDim( pCube, 10 );\nsDim11 = TabDim( pCube, 11 );\n\
    sDim12 = TabDim( pCube, 12 );\nsDim13 = TabDim( pCube, 13 );\nsDim14 = TabDim( pCube, 14\
    \ );\nsDim15 = TabDim( pCube, 15 );\nsDim16 = TabDim( pCube, 16 );\nsDim17 = TabDim( pCube,\
    \ 17 );\nsDim18 = TabDim( pCube, 18 );\nsDim19 = TabDim( pCube, 19 );\nsDim20 = TabDim(\
    \ pCube, 20 );\nsDim21 = TabDim( pCube, 21 );\nsDim22 = TabDim( pCube, 22 );\nsDim23 = TabDim(\
    \ pCube, 23 );\nsDim24 = TabDim( pCube, 24 );\nsDim25 = TabDim( pCube, 25 );\nsDim26 = TabDim(\
    \ pCube, 26 );\nsDim27 = TabDim( pCube, 27 );\n\n###########################\n### Validate\
    \ Parameters ###\n###########################\nnErrors = 0;\n\n## Default filter delimiters\n\
    If( pDimDelim     @= '' );\n    pDimDelim     = '&';\nEndIf;\n\nIf( pEleStartDelim@= ''\
    \ );\n    pEleStartDelim= '¦';\nEndIf;\n\nIf( pEleDelim     @= '' );\n    pEleDelim    \
    \ = '+';\nEndIf;\n\nIf( pMappingDelim     @= '' );\n    pMappingDelim     = '->';\nEndIf;\n\
    \nIf( pDecimalSeparator @= '' );\n \tpDecimalSeparator = '.';\nEndIf;\nIf ( LONG(pDecimalSeparator)\
    \ = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n\
    \    If( CODE( pDecimalSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pDecimalSeparator, nChar\
    \ ) <= CODE( '9', 1 ) );\n      nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n\
    \    EndIf;\n    nChar = nChar + 1;\n  End;\n  If ( nValid<>0 );\n    pDecimalSeparator\
    \ = CHAR(StringToNumber( pDecimalSeparator ));\n  Else;\n    pDecimalSeparator = SubSt(\
    \ Trim( pDecimalSeparator ), 1, 1 );\n  EndIf;\nEndIf;\nsDecimalSeparator = pDecimalSeparator;\n\
    \nIf( pThousandSeparator @= '' );\n \tpThousandSeparator = ',';\nEndIf;\nIf ( LONG(pThousandSeparator)\
    \ = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n\
    \    If( CODE( pThousandSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pThousandSeparator,\
    \ nChar ) <= CODE( '9', 1 ) );\n      nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n\
    \    EndIf;\n    nChar = nChar + 1;\n  End;\n  If ( nValid<>0 );\n    pThousandSeparator\
    \ = CHAR(StringToNumber( pThousandSeparator ));\n  Else;\n    pThousandSeparator = SubSt(\
    \ Trim( pThousandSeparator ), 1, 1 );\n  EndIf;\nEndIf;\nsThousandSeparator = pThousandSeparator;\n\
    \n# Validate cube\nIf( Trim( pCube ) @= '' );\n    nErrors     = 1;\n    sMessage    = 'No\
    \ cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ CubeExists( pCube ) = 0 );\n    nErrors     = nErrors + 1;\n    sMessage    = Expand(\
    \ 'Invalid source cube specified: %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Determine number of dims in target cube ###\nnCount          = 1;\n\
    While( TabDim( pCube, nCount ) @<> '' );\n    sDimension  = TabDim( pCube, nCount );\n \
    \   nCount      = nCount + 1;\nEnd;\nnDimensionCount = nCount - 1;\n\n## If dimension count\
    \ exceeds the current maximum then terminate process\nIf( nDimensionCount > cDimCountMax\
    \ );\n    nErrors     = nErrors + 1;\n    sMessage    = 'Cube has too many dimensions: %pCube%.\
    \ Max %sDimCountMax% dims catered for, TI must be altered to accommodate.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate the View parameter\n\
    If( TRIM(pSrcView) @<> '' & TRIM(pSrcView) @= TRIM(pTgtView) );\n    nErrors     = nErrors\
    \ + 1;\n    sMessage    = Expand( 'Source and Target Views can not be the same: %pSrcView%.'\
    \ ) ;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate\
    \ the View parameter\nIf( TRIM( pSrcView) @= '' );\n  cViewSource   = Expand( '%cDefaultView%_%cSuffixSource%'\
    \ ) ;\nElse ;\n  cViewSource   = pSrcView ;\n  nExistingSourceFlag = 1;\nEndIf;\n\n## Validate\
    \ the View parameter\nIf( TRIM( pTgtView ) @= '' );\n  cViewTarget   = Expand( '%cDefaultView%_%cSuffixTarget%'\
    \ ) ;\nElse ;\n  cViewTarget   = pTgtView ;\nEndIf;\n\n# Validate parallelization filter\n\
    If( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n    sDimParallel = SubSt( pFilterParallel,\
    \ 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n    If( Scan( Lower(sDimParallel) |\
    \ pEleStartDelim, Lower(pFilter) ) > 0 );\n        sMessage = 'Parallelization dimension\
    \ %sDimParallel% cannot exist in filter.';\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\n    If( Scan( Lower(sDimParallel)\
    \ | pEleStartDelim, Lower(pEleMapping) ) > 0 );\n        sMessage = 'Parallelization dimension\
    \ %sDimParallel% cannot exist in element mapping.';\n        nErrors = nErrors + 1;\n  \
    \      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n\
    # Validate Max Threads\nIf( pParallelThreads > 0 );\n  nMaxThreads = pParallelThreads;\n\
    Else;\n  nMaxThreads = 1;\nEndIf;\n\n# Validate Mapping parameter\nIf( pDimDelim @= pEleStartDelim\
    \ % pDimDelim @= pEleDelim % pEleStartDelim @= pEleDelim );\n    sMessage = 'The delimiters\
    \ cannot me the same.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate Mapping parameter\nIf( TRIM( pEleMapping )\
    \ @<> '' & TRIM( pMappingDelim) @= '');\n    nErrors = nErrors + 1;\n    sMessage = 'Mapping\
    \ Delimiter & Element Mapping can not both be empty.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndif;\n\n# Validate Sandbox\nIf( TRIM( pSandbox ) @<> '' );\n\
    \    If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty( 0\
    \ );\n        nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is invalid\
    \ for the current user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        ServerActiveSandboxSet( pSandbox );\n        SetUseActiveSandboxProperty(\
    \ 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty( 0 );\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 );\n   \
    \   ProcessQuit;\n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n########## pEleMapping\
    \ ######################################################\n### Split ElementMapping parameter\
    \ and create variables to be substituted ###\n#################################################################################################\
    \ #############\nsElementMapping     = TRIM( pEleMapping );\nsMappingDelimiter   = TRIM(\
    \ pMappingDelim );\nsElementStartDelim  = TRIM( pEleStartDelim );\nsDelimDim           =\
    \ TRIM( pDimDelim );\nsDecimalSeparator   = TRIM(pDecimalSeparator);\nsThousandSeparator\
    \  = TRIM(pThousandSeparator);\nsFilter             = TRIM( pFilter);\nsTargetFilter   \
    \    = '';\nnSuppressConsol     = pSuppressConsol;\nnChar               = 1;\nnCharCount\
    \          = LONG( sElementMapping );\n\n# If there's no element mapping then the process\
    \ can be used to multiply existing value by a factor\nIf( nCharCount > 0 );\n\n  sWord =\
    \ '';\n  sLastDelim = '';\n\n  # Add a trailing element delimiter so that the last element\
    \ is picked up\n  If( nCharCount > 0 );\n    sElementMapping = sElementMapping | sMappingDelimiter\
    \ ;\n    nCharCount      = nCharCount + LONG(sMappingDelimiter );\n  EndIf;\n\n  WHILE (nChar\
    \ <= nCharCount);\n    sChar = SUBST( sElementMapping, nChar, 1);\n\n    # Used for delimiters,\
    \ required for multiple character delimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n \
    \   # Ignore spaces\n    IF (TRIM(sChar) @<> '' );\n\n      ### Dimension Name ###\n\n \
    \     # If the delimiter is more than 1 character peek ahead the same amount\n      # Ignore\
    \ the first character\n      sDelim = sChar;\n      nCount = LONG(sElementStartDelim) -\
    \ 1;\n      If( nCount > 0 & nChar + nCount <= nCharCount );\n        # Add the extra characters\n\
    \        sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\n        # Move to\
    \ the end of the delimter\n        nAddExtra = nCount;\n      EndIf;\n\n      If( sDelim\
    \ @= sElementStartDelim );\n\n        sChar = sDelim;\n\n        If( sLastDelim @<> '' &\
    \ sLastDelim @<> sDelimDim );\n            sMessage = Expand ( 'The name of a dimension\
    \ must follow a dimension delimiter %sDelimDim%' );\n            nErrors = nErrors + 1;\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \        EndIf;\n\n        sDimension = sWord;\n\n        If( DimensionExists( sDimension\
    \ ) = 0 );\n            # The dimension does not exist in the model. Cancel process\n  \
    \          sMessage = Expand( 'Dimension: %sDimension% does not exist');\n            nErrors\
    \ = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \            #ProcessError();\n        EndIf;\n\n        # Check that the dimension is in\
    \ the cube\n         i = 1;\n         iMax = 30;\n         sDimInCube = 'No';\n        \
    \ While( i <= iMax );\n           sDimensionOfCube = TabDim( pCube, i );\n           If(sDimension\
    \ @= sDimensionOfCube);\n             sDimInCube = 'Yes';\n             # record where the\
    \ loop stops\n             nIndex = i;\n             i = 100;\n             Else;\n    \
    \         i = i + 1;\n           EndIf;\n        End;\n\n        If( sDimInCube @<> 'Yes'\
    \ );\n            # The dimension does not exist in the cube. Cancel process\n         \
    \   sMessage = Expand( 'Dimension %sDimension% does not exist in this cube');\n        \
    \    nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            #ProcessError();\n        EndIf;\n\n        ### Dimension exists so\
    \ add it to the filters\n        IF(LONG(sFilter) > 0 & sLastDelim @= '');\n          sTargetFilter\
    \ = sFilter | sDelimDim | sDimension | sElementStartDelim;\n          sFilter = sFilter\
    \ | sDelimDim | sDimension | sElementStartDelim;\n          ElseiF(LONG(sFilter) > 0 & sLastDelim@<>'');\n\
    \          sFilter = sFilter | sDelimDim | sDimension | sElementStartDelim;\n          sTargetFilter\
    \ = sTargetFilter | sDelimDim | sDimension | sElementStartDelim;\n          Else;\n    \
    \      sFilter = sDimension | sElementStartDelim;\n          sTargetFilter = sDimension\
    \ | sElementStartDelim;\n        EndIf;\n\n        #Reset the source and target elements\n\
    \        sSource = '';\n        sTarget = '';\n\n        # The variable nElementCount is\
    \ used to keep track of how many elements there are per dimension\n        # the first element\
    \ is the source\n        # the second element is the target\n        # There shouldn't be\
    \ any more than 2 elements per dimension\n\n        # A new dimension has been found so\
    \ reset the element count so\n        # the code can tell how many elements have been specified\
    \ for each dimension\n        # There should just be 2\n\n        nElementCount = 1;\n \
    \       sLastDelim = sChar;\n\n        # Clear the word\n        sWord = '';\n\n      Else;\n\
    \n        # Reset extra chars\n        nAddExtra = 0;\n\n        ### Check both dim delimiter\
    \ and element delimiter ###\n        nIsDelimiter = 0;\n\n        # Check dim delim\n  \
    \      # If the delimiter is more than 1 character peek ahead the same amount\n        #\
    \ Ignore the first character\n        sDelim = sChar;\n        nCount = LONG(sDelimDim)\
    \ - 1;\n        If( nCount > 0 & nChar + nCount <= nCharCount );\n          # Add the extra\
    \ characters\n          sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\n\
    \          # Move to the end of the delimter\n          nAddExtra = nCount;\n        EndIf;\n\
    \n        If( sDelim @= sDelimDim );\n          nIsDelimiter = 1;\n          sChar = sDelim;\n\
    \        Else;\n          # Reset extra chars\n          nAddExtra = 0;\n\n          ##\
    \ Check element delimiter\n\n          # If the delimiter is more than 1 character peek\
    \ ahead the same amount\n          # Ignore the first character\n          sDelim = sChar;\n\
    \          nCount = LONG(sMappingDelimiter) - 1;\n          If( nCount > 0 & nChar + nCount\
    \ <= nCharCount );\n            # Add the extra characters\n            sDelim = sDelim\
    \ | SUBST( sElementMapping, nChar + 1, nCount);\n            # Move to the end of the delimter\n\
    \            nAddExtra = nCount;\n          EndIf;\n\n          If( sDelim @= sMappingDelimiter\
    \  );\n            nIsDelimiter = 1;\n            sChar = sDelim;\n          Else;\n   \
    \         # Reset extra chars\n            nAddExtra = 0;\n          EndIf;\n\n        EndIf;\n\
    \n        If ( nIsDelimiter = 1 );\n\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim\
    \ );\n            sMessage = 'An element start delimiter must follow a dimension name: '\
    \ |  sChar | ' (' | NumberToString(nChar) | ')';\n            nErrors = nErrors + 1;\n \
    \           LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \          EndIf;\n\n          # an element has been found!\n          sElement = sWord;\n\
    \n          If( DIMIX( sDimension, sElement ) = 0 );\n            # The element does not\
    \ exist in the dimension. Cancel process\n            sMessage = Expand( 'Element: %sElement%\
    \ does not exist in dimension %sDimension%' );\n            nErrors = nErrors + 1;\n   \
    \         LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n          EndIf;\n\n\
    \          # Allow consolidations only if pSuppressConsol is not set to 1\n          # Consolidations\
    \ may be made allowable\n          # so that you can copy strings between c levels\n   \
    \       # or copy from a consolidated source element to an n level target element\n\n  \
    \        ### Check for errors before continuing\n          If( nErrors <> 0 );\n       \
    \       If( pStrictErrorHandling = 1 );\n                  ProcessQuit;\n              Else;\n\
    \                  ProcessBreak;\n              EndIf;\n          EndIf;\n\n          If\
    \ ( DTYPE( sDimension, sElement) @= 'C' );\n              IF( nElementCount = 1 );\n   \
    \             If( pSuppressConsol <> 1 );\n                  nSuppressConsol = 0;\n    \
    \            EndIf;\n                pSubN = 1;\n              Else;\n                sMessage\
    \ = Expand( 'Target element: %sElement% for dimension %sDimension% is consolidated' );\n\
    \                nErrors = nErrors + 1;\n                LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n                #ProcessBreak;\n              Endif;\n        \
    \  Endif;\n\n          # Add the element to the source or target depending on whether it's\
    \ the first or the second element\n          # Get principal name\n          # in case source\
    \ element and this element are using different aliases\n\n          sElement = DimensionElementPrincipalName(sDimension,sElement);\n\
    \n          # first element\n          IF(nElementCount = 1);\n\n            sSource = sElement;\n\
    \            sFilter = sFilter | sElement;\n\n          # second element\n          ElseIf(nElementCount\
    \ = 2);\n\n            sTarget = sElement;\n            sTargetFilter = sTargetFilter |\
    \ sElement;\n\n          Else;\n\n            sMessage = Expand( 'There should only be 2\
    \ elements per dimension: %sDimension% , a source and a target');\n            nErrors =\
    \ nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \           #ProcessError();\n\n          EndIf;\n\n          If(nIndex = 1);\n        \
    \    nMappedDim1 = 1;\n            sSourceDim1 = sSource;\n            sTargetDim1 = sTarget;\n\
    \          ElseIf(nIndex = 2);\n            nMappedDim2 = 1;\n            sSourceDim2 =\
    \ sSource;\n            sTargetDim2 = sTarget;\n          ElseIf(nIndex = 3);\n        \
    \    nMappedDim3 = 1;\n            sSourceDim3 = sSource;\n            sTargetDim3 = sTarget;\n\
    \          ElseIf(nIndex = 4);\n            nMappedDim4 = 1;\n            sSourceDim4 =\
    \ sSource;\n            sTargetDim4 = sTarget;\n          ElseIf(nIndex = 5);\n        \
    \    nMappedDim5 = 1;\n            sSourceDim5 = sSource;\n            sTargetDim5 = sTarget;\n\
    \          ElseIf(nIndex = 6);\n            nMappedDim6 = 1;\n            sSourceDim6 =\
    \ sSource;\n            sTargetDim6 = sTarget;\n          ElseIf(nIndex = 7);\n        \
    \    nMappedDim7 = 1;\n            sSourceDim7 = sSource;\n            sTargetDim7 = sTarget;\n\
    \          ElseIf(nIndex = 8);\n            nMappedDim8 = 1;\n            sSourceDim8 =\
    \ sSource;\n            sTargetDim8 = sTarget;\n          ElseIf(nIndex = 9);\n        \
    \    nMappedDim9 = 1;\n            sSourceDim9 = sSource;\n            sTargetDim9 = sTarget;\n\
    \          ElseIf(nIndex = 10);\n            nMappedDim10 = 1;\n            sSourceDim10\
    \ = sSource;\n            sTargetDim10 = sTarget;\n          ElseIf(nIndex = 11);\n    \
    \        nMappedDim11 = 1;\n            sSourceDim11 = sSource;\n            sTargetDim11\
    \ = sTarget;\n          ElseIf(nIndex = 12);\n            nMappedDim12 = 1;\n          \
    \  sSourceDim12 = sSource;\n            sTargetDim12 = sTarget;\n          ElseIf(nIndex\
    \ = 13);\n            nMappedDim13 = 1;\n            sSourceDim13 = sSource;\n         \
    \   sTargetDim13 = sTarget;\n          ElseIf(nIndex = 14);\n            nMappedDim14 =\
    \ 1;\n            sSourceDim14 = sSource;\n            sTargetDim14 = sTarget;\n       \
    \   ElseIf(nIndex = 15);\n            nMappedDim15 = 1;\n            sSourceDim15 = sSource;\n\
    \            sTargetDim15 = sTarget;\n          ElseIf(nIndex = 16);\n            nMappedDim16\
    \ = 1;\n            sSourceDim16 = sSource;\n            sTargetDim16 = sTarget;\n     \
    \     ElseIf(nIndex = 17);\n            nMappedDim17 = 1;\n            sSourceDim17 = sSource;\n\
    \            sTargetDim17 = sTarget;\n          ElseIf(nIndex = 18);\n            nMappedDim18\
    \ = 1;\n            sSourceDim18 = sSource;\n            sTargetDim18 = sTarget;\n     \
    \     ElseIf(nIndex = 19);\n            nMappedDim19 = 1;\n            sSourceDim19 = sSource;\n\
    \            sTargetDim19 = sTarget;\n          ElseIf(nIndex = 20);\n            nMappedDim20\
    \ = 1;\n            sSourceDim20 = sSource;\n            sTargetDim20 = sTarget;\n     \
    \     ElseIf(nIndex = 21);\n            nMappedDim21 = 1;\n            sSourceDim21 = sSource;\n\
    \            sTargetDim21 = sTarget;\n          ElseIf(nIndex = 22);\n            nMappedDim22\
    \ = 1;\n            sSourceDim22 = sSource;\n            sTargetDim22 = sTarget;\n     \
    \     ElseIf(nIndex = 23);\n            nMappedDim23 = 1;\n            sSourceDim23 = sSource;\n\
    \            sTargetDim23 = sTarget;\n          ElseIf(nIndex = 24);\n            nMappedDim24\
    \ = 1;\n            sSourceDim24 = sSource;\n            sTargetDim24 = sTarget;\n     \
    \     ElseIf(nIndex = 25);\n            nMappedDim25 = 1;\n            sSourceDim25 = sSource;\n\
    \            sTargetDim25 = sTarget;\n          ElseIf(nIndex = 26);\n            nMappedDim26\
    \ = 1;\n            sSourceDim26 = sSource;\n            sTargetDim26 = sTarget;\n     \
    \     ElseIf(nIndex = 27);\n            nMappedDim27 = 1;\n            sSourceDim27 = sSource;\n\
    \            sTargetDim27 = sTarget;\n          EndIf;\n\n          sLastDelim = sChar;\n\
    \n          # Clear the word\n          sWord = '';\n\n          nElementCount = nElementCount\
    \ + 1;\n\n        Else;\n          sWord = sWord | sChar;\n        EndIf;\n\n      EndIf;\n\
    \n    EndIf;\n\n    nChar = nChar + nAddExtra + 1;\n\n  END;\nENDIF;\n\n\n### Check that\
    \ there if a dimension is used, there is a source element and a target element\ncSourceVariableStem\
    \ = 'sSourceDim';\ncTargetVariableStem = 'sTargetDim';\ncMappedDimVariableStem = 'nMappedDim';\n\
    \nnCounter = 1;\nWHILE(nCounter <= nDimensionCount);\n\n  sMappedDimVariable = 'nMappedDim\
    \ ' | NumberToString(nCounter);\n  sDimensionUsedPadded = Expand('%' | sMappedDimVariable\
    \ | '%');\n\n  nMappedDim = StringToNumber(Trim(sDimensionUsedPadded));\n  If(nMappedDim\
    \ = 1);\n    sDim = TabDim( pCube, nCounter );\n    sSourceVariable = cSourceVariableStem\
    \ | NumberToString(nCounter);\n    sSourcePadded = Expand('%' | sSourceVariable | '%');\n\
    \    sSource = Trim(sSourcePadded);\n\n    sTargetVariable = cTargetVariableStem | NumberToString(nCounter);\n\
    \    sTargetPadded = Expand('%' | sTargetVariable | '%');\n    sTarget = Trim(sTargetPadded);\n\
    \n    If(sSource @='' % sTarget @='');\n      sMessage = 'Source and/or target element is\
    \ blank for dimension ' | sDim;\n      nErrors = nErrors + 1;\n      LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n      #ProcessError();\n    EndIf;\n\n  EndIf;\n\nnCounter\
    \ = nCounter + 1;\n\nEND;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n\
    \  DataSourceType = 'NULL';\n  If( pStrictErrorHandling = 1 );\n      ProcessQuit;\n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Branch depending on whether to do recursive\
    \ calls to self on independent threads or run all in this thread\nIf( Scan( pEleStartDelim,\
    \ pFilterParallel ) > 0 );\n  sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim,\
    \ pFilterParallel ) - 1 );\n  sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim,\
    \ pFilterParallel ) + Long( pEleStartDelim ), Long( pFilterParallel ) );\n  If( SubSt( sElementList,\
    \ Long( sElementList ), 1 ) @<> pEleDelim );\n      sElementList = sElementList | pEleDelim;\n\
    \  EndIf;\n  ## Counting elements in element list\n  sElementListCount = sElementList;\n\
    \  nElements = 0;\n  While( Scan( pEleDelim, sElementListCount ) > 0 );\n    nElements =\
    \ nElements + 1;\n    sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount\
    \ ) + Long( pEleDelim ), Long( sElementListCount ) );\n  End;\n  IF( Mod( nElements, nMaxThreads\
    \ ) = 0 );\n    nElemsPerThread = INT( nElements / nMaxThreads );\n  ELSE;\n    nElemsPerThread\
    \ = INT( nElements / nMaxThreads ) + 1;\n  ENDIF;\n  nThreadElCounter = 0;\n  While( Scan(\
    \ pEleDelim, sElementList ) > 0 );\n    sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim,\
    \ sElementList ) - 1 );\n    sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList\
    \ ) + Long( pEleDelim ), Long( sElementList ) );\n    # Do recursive process call with new\
    \ RunProcess function\n    nThreadElCounter = nThreadElCounter + 1;\n    sDimDelim = If(pFilter\
    \ @= '', '', pDimDelim );\n    IF( nThreadElCounter = 1 );\n      sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \    ELSE;\n      sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n    ENDIF;\n  \
    \  IF( nThreadElCounter >= nElemsPerThread );\n            nThreadID = INT( RAND( ) * 10000\
    \ + 1) + Numbr(cTimeStamp);\n      sThreadControlFile = GetProcessName() | '_ThreadControlFile_'\
    \ | cRandomInt | '_' | NumberToString(nThreadID) | '_' | cTimeStamp;\n      AsciiOutput(\
    \ cDir | sThreadControlFile | '.txt', '' );\n      LogOutput( 'INFO', 'Executing subTI with\
    \ Thread ID: ' | NumberToString(nThreadID) );\n      RunProcess( cThisProcName, 'pLogoutput',\
    \ pLogoutput,\n      \t'pCube', pCube, 'pSrcView', pSrcView, 'pTgtView', pTgtView,\n   \
    \   \t'pFilter', sFilter, 'pFilterParallel', '', 'pEleMapping', pEleMapping, 'pMappingDelim',\
    \ pMappingDelim,\n      \t'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim',\
    \ pEleDelim,\n      \t'pFactor', pFactor, 'pSuppressConsol', pSuppressConsol, 'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, 'pSuppressRules', pSuppressRules, 'pSuppressZero', pSuppressZero,\
    \ 'pCumulate', pCumulate,\n      \t'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource,\
    \ 'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox', pSandbox, 'pFile', pFile, 'pDecimalSeparator',\
    \ pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n        'pThreadMode', 1,\
    \ 'pThreadControlFile', sThreadControlFile\n      );\n  \t  nThreadElCounter = 0;\n  \t\
    \  sFilter = '';\n  \t  nThreadID = INT( RAND( ) * 10000 ) + 1;\n        sThreadControlFile\
    \ = GetProcessName() | '_ThreadControlFile_' | cRandomInt | '_' | NumberToString(nThreadID);\n\
    \        AsciiOutput( cDir | sThreadControlFile | '.txt', '' );\n        LogOutput( 'INFO',\
    \ 'Executing subTI with Thread ID: ' | NumberToString(nThreadID) );\n  \t ENDIF;\n  End;\n\
    \  ## Process last elements - only when filter is not empty (there are still elements)\n\
    \  IF( sFilter @<> '' );\n    RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n   \
    \ \t'pCube', pCube, 'pSrcView', pSrcView, 'pTgtView', pTgtView,\n    \t'pFilter', sFilter,\
    \ 'pFilterParallel', '', 'pEleMapping', pEleMapping, 'pMappingDelim', pMappingDelim,\n \
    \   \t'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n\
    \    \t'pFactor', pFactor, 'pSuppressConsol', pSuppressConsol, 'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, 'pSuppressRules', pSuppressRules, 'pSuppressZero', pSuppressZero,\
    \ 'pCumulate', pCumulate,\n    \t'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource,\
    \ 'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox', pSandbox, 'pFile', pFile, 'pDecimalSeparator',\
    \ pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n      'pThreadMode', 1,\
    \ 'pThreadControlFile', sThreadControlFile\n    );\n  ENDIF;\n  DataSourceType = 'NULL';\n\
    Else;\n  ### Create View of target to zero out\n  ### Check that there's something in sTargetFilter\
    \ so the cube doesn't accidentally get wiped out\n\n  If(pZeroTarget = 1 & LONG(sTargetFilter)>\
    \ 0);\n\n    sProc = '}bedrock.cube.data.clear';\n    nRet = ExecuteProcess( sProc,\n  \
    \  'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube',\
    \ pCube,\n    'pView', cViewTarget,\n    'pFilter', sTargetFilter,\n    'pDimDelim', pDimDelim,\n\
    \    'pEleStartDelim', pEleStartDelim,\n    'pEleDelim', pEleDelim,\n    'pCubeLogging',\
    \ pCubeLogging,\n    'pTemp', pTemp,\n    'pSandbox', pSandbox\n    );\n\n    IF(nRet <>\
    \ 0);\n        sMessage = 'Error clearing the target view.';\n        nErrors = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 );\n            ProcessQuit;\n        Else;\n            ProcessBreak;\n        EndIf;\n\
    \    ENDIF;\n\n  Endif;\n\n  If ( pCubeLogging <= 1 );\n    sCubeLogging = CellGetS('}CubeProperties',\
    \ pCube, 'LOGGING' );\n    CubeSetLogChanges( pCube, pCubeLogging);\n  EndIf;\n\n  If( pFile\
    \ = 0 );\n\n    ### Create View of Source ###\n\n    nRet = ExecuteProcess('}bedrock.cube.view.create',\n\
    \      'pLogOutput', pLogOutput,\n      'pStrictErrorHandling', pStrictErrorHandling,\n\
    \      'pCube', pCube,\n      'pView', cViewSource,\n      'pFilter', sFilter,\n      'pSuppressZero',\
    \ pSuppressZero,\n      'pSuppressConsol', nSuppressConsol,\n      'pSuppressRules', pSuppressRules,\n\
    \      'pSuppressConsolStrings', pSuppressConsolStrings,\n      'pDimDelim', pDimDelim,\n\
    \      'pEleStartDelim', pEleStartDelim,\n      'pEleDelim', pEleDelim ,\n      'pTemp',\
    \ pTemp,\n      'pSubN', pSubN\n      );\n\n    IF(nRet <> 0);\n          sMessage = 'Error\
    \ creating the view from the filter.';\n          nErrors = nErrors + 1;\n          LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n          If( pStrictErrorHandling = 1\
    \ );\n              ProcessQuit;\n          Else;\n              ProcessBreak;\n       \
    \   EndIf;\n    ENDIF;\n\n\n    ### Assign Datasource ###\n    DataSourceType          =\
    \ 'VIEW';\n    DatasourceNameForServer = pCube;\n    DatasourceNameForClient = pCube;\n\
    \    DatasourceCubeView      = cViewSource;\n    nThreadMode = 1;\n  Else;\n    ### Export\
    \ Data to file ###\n\n    nRet = ExecuteProcess('}bedrock.cube.data.export',\n       'pLogoutput',\
    \ pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n       'pCube', pCube,\n\
    \       'pView', cViewSource,\n       'pFilter', sFilter,\n       'pFilterParallel', '',\n\
    \       'pParallelThreads', 0,\n       'pDimDelim', pDimDelim,\n       'pEleStartDelim',\
    \ pEleStartDelim,\n       'pEleDelim', pEleDelim,\n       'pSuppressZero', pSuppressZero,\n\
    \       'pSuppressConsol', nSuppressConsol,\n       'pSuppressRules', pSuppressRules,\n\
    \       'pSuppressConsolStrings', pSuppressConsolStrings,\n       'pZeroSource', 0,\n  \
    \     'pCubeLogging', pCubeLogging,\n       'pTemp', pTemp,\n       'pFilePath', cDir,\n\
    \       'pFileName', cFileName,\n       'pDelim', cDelimiter,\n       'pDecimalSeparator',\
    \ sDecimalSeparator,\n       'pThousandSeparator', sThousandSeparator,\n       'pQuote',\
    \ cQuote,\n       'pTitleRecord', cTitleRows,\n       'pSandbox', pSandbox\n      );\n\n\
    \    IF(nRet <> 0);\n          sMessage = 'Error exporting data to file.';\n          nErrors\
    \ = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \         If( pStrictErrorHandling = 1 );\n              ProcessQuit;\n          Else;\n\
    \              ProcessBreak;\n          EndIf;\n    ENDIF;\n\n    If(FileExists(cFile) =\
    \ 0);\n      # If the file does not exist, it means that nothing got exported, so there\
    \ is nothing to import\n      If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( 'Process:%cThisProcName%\
    \ is skipping import as export file %cFile% was not found.' ) );\n      EndIf;\n      DataSourceType\
    \ = 'NULL';\n    Else;\n      ### Assign Datasource ###\n      DataSourceType          \
    \        = 'CHARACTERDELIMITED';\n      DatasourceNameForServer         = cFile;\n     \
    \ DatasourceNameForClient         = cFile;\n      DatasourceASCIIHeaderRecords    = cTitleRows;\n\
    \      DatasourceASCIIDelimiter        = cDelimiter;\n      DatasourceASCIIQuoteCharacter\
    \   = cQuote;\n    EndIf;\n\n    nThreadMode = 1;\n\n  EndIf;\n\nEndIf;\n\n### End Prolog\
    \ ###\n\n#Section Metadaten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \nIf( pFile > 0 );\n  v0 = v1; v1 = v2; v2 = v3;  v3 = v4; v4 = v5; v5 = v6; v6 = v7; v7\
    \ = v8; v8 = v9; v9 = v10; v10 = v11; v11 = v12; v12 = v13; v13 = v14; v14 = v15;\n  v15\
    \ = v16; v16 = v17; v17 = v18; v18 = v19; v19 = v20; v20 = v21; v21 = v22; v22 = v23; v23\
    \ = v24; v24 = v25; v25 = v26; v26 = v27; v27 = v28;  v28 = v29;\nEndIf;\n\nv1 = IF(nMappedDim1\
    \ = 1, IF(v1 @= sSourceDim1 % elisanc(sDim1,sSourceDim1,v1)=1, sTargetDim1, v1), v1);\n\
    v2 = IF(nMappedDim2 = 1, IF(v2 @= sSourceDim2 % elisanc(sDim2,sSourceDim2,v2)=1, sTargetDim2,\
    \ v2), v2);\nv3 = IF(nMappedDim3 = 1, IF(v3 @= sSourceDim3 % elisanc(sDim3,sSourceDim3,v3)=1,\
    \ sTargetDim3, v3), v3);\nv4 = IF(nMappedDim4 = 1, IF(v4 @= sSourceDim4 % elisanc(sDim4,sSourceDim4,v4)=1,\
    \ sTargetDim4, v4), v4);\nv5 = IF(nMappedDim5 = 1, IF(v5 @= sSourceDim5 % elisanc(sDim5,sSourceDim5,v5)=1,\
    \ sTargetDim5, v5), v5);\nv6 = IF(nMappedDim6 = 1, IF(v6 @= sSourceDim6 % elisanc(sDim6,sSourceDim6,v6)=1,\
    \ sTargetDim6, v6), v6);\nv7 = IF(nMappedDim7 = 1, IF(v7 @= sSourceDim7 % elisanc(sDim7,sSourceDim7,v7)=1,\
    \ sTargetDim7, v7), v7);\nv8 = IF(nMappedDim8 = 1, IF(v8 @= sSourceDim8 % elisanc(sDim8,sSourceDim8,v8)=1,\
    \ sTargetDim8, v8), v8);\nv9 = IF(nMappedDim9 = 1, IF(v9 @= sSourceDim9 % elisanc(sDim9,sSourceDim9,v9)=1,\
    \ sTargetDim9, v9), v9);\nv10 = IF(nMappedDim10 = 1, IF(v10 @= sSourceDim10 % elisanc(sDim10,sSourceDim10,v10)=1,\
    \ sTargetDim10, v10), v10);\nv11 = IF(nMappedDim11 = 1, IF(v11 @= sSourceDim11 % elisanc(sDim11,sSourceDim11,v11)=1,\
    \ sTargetDim11, v11), v11);\nv12 = IF(nMappedDim12 = 1, IF(v12 @= sSourceDim12 % elisanc(sDim12,sSourceDim12,v12)=1,\
    \ sTargetDim12, v12), v12);\nv13 = IF(nMappedDim13 = 1, IF(v13 @= sSourceDim13 % elisanc(sDim13,sSourceDim13,v13)=1,\
    \ sTargetDim13, v13), v13);\nv14 = IF(nMappedDim14 = 1, IF(v14 @= sSourceDim14 % elisanc(sDim14,sSourceDim14,v14)=1,\
    \ sTargetDim14, v14), v14);\nv15 = IF(nMappedDim15 = 1, IF(v15 @= sSourceDim15 % elisanc(sDim15,sSourceDim15,v15)=1,\
    \ sTargetDim15, v15), v15);\nv16 = IF(nMappedDim16 = 1, IF(v16 @= sSourceDim16 % elisanc(sDim16,sSourceDim16,v16)=1,\
    \ sTargetDim16, v16), v16);\nv17 = IF(nMappedDim17 = 1, IF(v17 @= sSourceDim17 % elisanc(sDim17,sSourceDim17,v17)=1,\
    \ sTargetDim17, v17), v17);\nv18 = IF(nMappedDim18 = 1, IF(v18 @= sSourceDim18 % elisanc(sDim18,sSourceDim18,v18)=1,\
    \ sTargetDim18, v18), v18);\nv19 = IF(nMappedDim19 = 1, IF(v19 @= sSourceDim19 % elisanc(sDim19,sSourceDim19,v19)=1,\
    \ sTargetDim19, v19), v19);\nv20 = IF(nMappedDim20 = 1, IF(v20 @= sSourceDim20 % elisanc(sDim20,sSourceDim20,v20)=1,\
    \ sTargetDim20, v20), v20);\nv21 = IF(nMappedDim21 = 1, IF(v21 @= sSourceDim21 % elisanc(sDim21,sSourceDim21,v21)=1,\
    \ sTargetDim21, v21), v21);\nv22 = IF(nMappedDim22 = 1, IF(v22 @= sSourceDim22 % elisanc(sDim22,sSourceDim22,v22)=1,\
    \ sTargetDim22, v22), v22);\nv23 = IF(nMappedDim23 = 1, IF(v23 @= sSourceDim23 % elisanc(sDim23,sSourceDim23,v23)=1,\
    \ sTargetDim23, v23), v23);\nv24 = IF(nMappedDim24 = 1, IF(v24 @= sSourceDim24 % elisanc(sDim23,sSourceDim24,v24)=1,\
    \ sTargetDim24, v24), v24);\nv25 = IF(nMappedDim25 = 1, IF(v25 @= sSourceDim25 % elisanc(sDim25,sSourceDim25,v25)=1,\
    \ sTargetDim25, v25), v25);\nv26 = IF(nMappedDim26 = 1, IF(v26 @= sSourceDim26 % elisanc(sDim26,sSourceDim26,v26)=1,\
    \ sTargetDim26, v26), v26);\nv27 = IF(nMappedDim27 = 1, IF(v27 @= sSourceDim27 % elisanc(sDim27,sSourceDim27,v27)=1,\
    \ sTargetDim27, v27), v27);\n\n\n### Write data from source version to target version ###\n\
    \n# Selects the correct CellPut formula depending upon the number of dimensions in the cube\n\
    # and whether the value is numeric or string ( max 27 dims catered for in this code )\n\
    # value type determined by element type of last dimension in cube\n# could have used Value_is_String\
    \ = 1 and NValue/SValue but this works just as well\n\n\nIf( nDimensionCount = 2 );\n  \
    \  If( CellIsUpdateable( pCube, v1, v2 ) = 1 );\n        sElType = DType( sDim2, v2 );\n\
    \        IF( SubSt( pCube, 1, 17 ) @= '}ElementSecurity_');\n            v3 = IF( v3 @=\
    \ '', 'NONE', v3 );\n            ElementSecurityPut( v3, sDim1, v1, v2 );\n        ELSEIF(\
    \ sElType @= 'AA' );\n            AttrPutS( v3, sDim1, v1, v2, 1 );\n        ELSEIF( sElType\
    \ @= 'AS' );\n            AttrPutS( v3, sDim1, v1, v2 );\n        ELSEIF( sElType @= 'AN'\
    \ );\n            AttrPutN( StringToNumberEx( v3, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor, sDim1, v1, v2 );\n        ElseIf( sElType @= 'S' );\n            CellPutS(\
    \ v3, pCube, v1, v2 );\n        Else;\n            IF( pCumulate = 1);\n               \
    \ nObal = CellGetN( pCube, v1, v2 );\n                nCbal = nObal + StringToNumberEx(\
    \ v3, sDecimalSeparator, sThousandSeparator ) * nFactor;\n            ELSE;\n          \
    \      nCbal = StringToNumberEx( v3, sDecimalSeparator, sThousandSeparator ) * nFactor;\n\
    \            Endif;\n            CellPutN( nCbal, pCube, v1, v2 );\n        EndIf;\n   \
    \ EndIf;\nElseIf( nDimensionCount = 3 );\n    If( CellIsUpdateable( pCube, v1, v2, v3 )\
    \ = 1 );\n        sElType = DType( sDim3, v3 );\n        If( sElType @<> 'S' );\n      \
    \      IF( pCumulate = 1);\n                nObal = CellGetN( pCube, v1, v2, v3 );\n   \
    \             nCbal = nObal + StringToNumberEx( v4, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n            ELSE;\n                nCbal = StringToNumberEx( v4, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n            Endif;\n            CellPutN( nCbal, pCube,\
    \ v1, v2, v3 );\n        Else;\n            CellPutS( v4, pCube, v1, v2, v3 );\n       \
    \ EndIf;\n    EndIf;\nElseIf( nDimensionCount = 4 );\n    If( CellIsUpdateable( pCube, v1,\
    \ v2, v3, v4 ) = 1 );\n        sElType = DType( sDim4, v4 );\n        If( sElType @<> 'S'\
    \ );\n            IF( pCumulate = 1);\n                nObal = CellGetN( pCube, v1, v2,\
    \ v3, v4);\n                nCbal = nObal + StringToNumberEx( v5, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n            ELSE;\n                nCbal = StringToNumberEx( v5, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n            Endif;\n            CellPutN( nCbal, pCube,\
    \ v1, v2, v3, v4);\n        Else;\n            CellPutS( v5, pCube, v1, v2, v3, v4);\n \
    \       EndIf;\n    EndIf;\nElseIf( nDimensionCount = 5 );\n    If( CellIsUpdateable( pCube,\
    \ v1, v2, v3, v4, v5 ) = 1 );\n      sElType = DType( sDim5, v5 );\n      If( sElType @<>\
    \ 'S' );\n        IF(pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4,\
    \ v5 );\n          nCbal = nObal + StringToNumberEx( v6, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v6, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2,\
    \ v3, v4, v5 );\n      Else;\n        CellPutS( v6, pCube, v1, v2, v3, v4, v5 );\n     \
    \ EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 6 );\n    If( CellIsUpdateable( pCube,\
    \ v1, v2, v3, v4, v5, v6 ) = 1 );\n      sElType = DType( sDim6, v6 );\n      If( sElType\
    \ @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3,\
    \ v4, v5, v6 );\n          nCbal = nObal + StringToNumberEx( v7, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v7, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2,\
    \ v3, v4, v5, v6 );\n      Else;\n        CellPutS( v7, pCube, v1, v2, v3, v4, v5, v6 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 7 );\n    If( CellIsUpdateable( pCube,\
    \ v1, v2, v3, v4, v5, v6, v7 ) = 1 );\n      sElType = DType( sDim7, v7 );\n      If( sElType\
    \ @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3,\
    \ v4, v5, v6, v7 );\n          nCbal = nObal + StringToNumberEx( v8, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v8,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7 );\n      Else;\n        CellPutS( v8, pCube,\
    \ v1, v2, v3, v4, v5, v6, v7 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 8\
    \ );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8 ) = 1 );\n      sElType\
    \ = DType( sDim8, v8 );\n      If( sElType @<> 'S' );\n        IF( pCumulate = 1);\n   \
    \       nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8 );\n          nCbal = nObal\
    \ + StringToNumberEx( v9, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n\
    \          nCbal = StringToNumberEx( v9, sDecimalSeparator, sThousandSeparator )* nFactor;\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8 );\n   \
    \   Else;\n        CellPutS( v9, pCube, v1, v2, v3, v4, v5, v6, v7, v8 );\n      EndIf;\n\
    \    EndIf;\n  ElseIf( nDimensionCount = 9 );\n    If( CellIsUpdateable( pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9 ) = 1 );\n      sElType = DType( sDim9, v9 );\n      If( sElType\
    \ @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3,\
    \ v4, v5, v6, v7, v8, v9 );\n          nCbal = nObal + StringToNumberEx( v10, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v10,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 );\n      Else;\n        CellPutS( v10,\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 10 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10 ) =\
    \ 1 );\n      sElType = DType( sDim10, v10 );\n      If( sElType @<> 'S' );\n        IF(\
    \ pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9,\
    \ v10 );\n          nCbal = nObal + StringToNumberEx( v11, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v11, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10 );\n      Else;\n        CellPutS( v11, pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 11 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\
    \ ) = 1 );\n      sElType = DType( sDim11, v11 );\n      If( sElType @<> 'S' );\n      \
    \  IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11 );\n          nCbal = nObal + StringToNumberEx( v12, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v12, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10, v11 );\n      Else;\n        CellPutS( v12, pCube, v1,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 12 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12 ) = 1 );\n      sElType = DType( sDim12, v12 );\n      If( sElType @<> 'S' );\n  \
    \      IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7,\
    \ v8, v9, v10, v11, v12 );\n          nCbal = nObal + StringToNumberEx( v13, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v13,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );\n      Else;\n    \
    \    CellPutS( v13, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );\n      EndIf;\n\
    \    EndIf;\n  ElseIf( nDimensionCount = 13 );\n    If( CellIsUpdateable( pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 ) = 1 );\n      sElType = DType( sDim13,\
    \ v13 );\n      If( sElType @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 );\n          nCbal = nObal\
    \ + StringToNumberEx( v14, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n\
    \          nCbal = StringToNumberEx( v14, sDecimalSeparator, sThousandSeparator ) * nFactor;\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10,\
    \ v11, v12, v13 );\n      Else;\n        CellPutS( v14, pCube, v1, v2, v3, v4, v5, v6, v7,\
    \ v8, v9, v10, v11, v12, v13 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 14\
    \ );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14 ) = 1 );\n      sElType = DType( sDim14, v14 );\n      If( sElType @<> 'S' );\n\
    \        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14 );\n          nCbal = nObal + StringToNumberEx( v15,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx(\
    \ v15, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 );\n      Else;\n\
    \        CellPutS( v15, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 15 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 ) = 1 );\n   \
    \   sElType = DType( sDim15, v15 );\n      If( sElType @<> 'S' );\n        IF( pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15 );\n          nCbal = nObal + StringToNumberEx( v16, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v16,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );\n  \
    \    Else;\n        CellPutS( v16, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 16 );\n \
    \   If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16 ) = 1 );\n      sElType = DType( sDim16, v16 );\n      If( sElType @<> 'S'\
    \ );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );\n          nCbal = nObal + StringToNumberEx(\
    \ v17, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v17, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16 );\n      Else;\n        CellPutS( v17, pCube, v1, v2, v3, v4, v5, v6, v7,\
    \ v8, v9, v10, v11, v12, v13, v14, v15, v16 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 17 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17 ) = 1 );\n      sElType = DType( sDim17, v17 );\n      If(\
    \ sElType @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\n          nCbal\
    \ = nObal + StringToNumberEx( v18, sDecimalSeparator, sThousandSeparator ) * nFactor;\n\
    \        ELSE;\n          nCbal = StringToNumberEx( v18, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\n      Else;\n        CellPutS(\
    \ v18, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 18 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18\
    \ ) = 1 );\n      sElType = DType( sDim18, v18 );\n      If( sElType @<> 'S' );\n      \
    \  IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );\n          nCbal = nObal + StringToNumberEx(\
    \ v19, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v19, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16, v17, v18 );\n      Else;\n        CellPutS( v19, pCube, v1, v2, v3, v4,\
    \ v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );\n      EndIf;\n   \
    \ EndIf;\n  ElseIf( nDimensionCount = 19 );\n    If( CellIsUpdateable( pCube, v1, v2, v3,\
    \ v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 ) = 1 );\n  \
    \    sElType = DType( sDim19, v19 );\n      If( sElType @<> 'S' );\n        IF( pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19 );\n          nCbal = nObal + StringToNumberEx(\
    \ v20, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v20, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16, v17, v18, v19 );\n      Else;\n        CellPutS( v20, pCube, v1, v2, v3,\
    \ v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );\n      EndIf;\n\
    \    EndIf;\n  ElseIf( nDimensionCount = 20 );\n    If( CellIsUpdateable( pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 ) =\
    \ 1 );\n      sElType = DType( sDim20, v20 );\n      If( sElType @<> 'S' );\n        IF(\
    \ pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9,\
    \ v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 );\n          nCbal = nObal + StringToNumberEx(\
    \ v21, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v21, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16, v17, v18, v19, v20 );\n      Else;\n        CellPutS( v21, pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 21 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21 ) = 1 );\n      sElType = DType( sDim21, v21 );\n      If( sElType @<> 'S'\
    \ );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );\n      \
    \    nCbal = nObal + StringToNumberEx( v22, sDecimalSeparator, sThousandSeparator ) * nFactor;\n\
    \        ELSE;\n          nCbal = StringToNumberEx( v22, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );\n      Else;\n\
    \        CellPutS( v22, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 22 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 ) = 1 );\n      sElType = DType(\
    \ sDim22, v22 );\n      If( sElType @<> 'S' );\n        IF( pCumulate = 1);\n          nObal\
    \ = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,\
    \ v17, v18, v19, v20, v21, v22 );\n          nCbal = nObal + StringToNumberEx( v23, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v23,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\
    \ v18, v19, v20, v21, v22 );\n      Else;\n        CellPutS( v23, pCube, v1, v2, v3, v4,\
    \ v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 23 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21,\n    v22, v23 ) = 1 );\n      sElType = DType( sDim23, v23 );\n      If(\
    \ sElType @<> 'S' );\n        IF( pCumulate >= 1);\n          nObal = CellGetN( pCube, v1,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20,\
    \ v21, v22, v23 );\n          nCbal = nObal + StringToNumberEx( v24, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v24,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\
    \ v18, v19, v20, v21, v22, v23 );\n      Else;\n        CellPutS( v24, pCube, v1, v2, v3,\
    \ v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\
    \ v23 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 24 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21, v22, v23, v24 ) = 1 );\n      sElType = DType( sDim24, v24 );\n      If(\
    \ sElType @<> 'S' );\n        IF( pCumulate = 1);\n          nObal = CellGetN( pCube, v1,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20,\
    \ v21, v22, v23, v24 );\n          nCbal = nObal + StringToNumberEx( v25, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal = StringToNumberEx( v25,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n        CellPutN(\
    \ nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\
    \ v18, v19, v20, v21, v22, v23, v24 );\n      Else;\n        CellPutS( v25, pCube, v1, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\
    \ v22, v23, v24 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 25 );\n    If(\
    \ CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25 ) = 1 );\n      sElType = DType(\
    \ sDim25, v25 );\n      If( sElType @<> 'S' );\n        IF( pCumulate = 1);\n          nObal\
    \ = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16,\
    \ v17, v18, v19, v20, v21, v22, v23, v24, v25 );\n          nCbal = nObal + StringToNumberEx(\
    \ v26, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v26, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25 );\n      Else;\n        CellPutS(\
    \ v26, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17,\
    \ v18, v19, v20, v21, v22, v23, v24, v25 );\n      EndIf;\n    EndIf;\nElseIf( nDimensionCount\
    \ = 26 );\n    If( CellIsUpdateable( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n    v22, v23, v24, v25, v26 ) = 1 );\n\
    \      sElType = DType( sDim26, v26 );\n      If( sElType @<> 'S' );\n        IF( pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26 );\n       \
    \   nCbal = nObal + StringToNumberEx( v27, sDecimalSeparator, sThousandSeparator ) * nFactor;\n\
    \        ELSE;\n          nCbal = StringToNumberEx( v27, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        Endif;\n        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24,\
    \ v25, v26 );\n      Else;\n        CellPutS( v27, pCube, v1, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26\
    \ );\n      EndIf;\n    EndIf;\nElseIf( nDimensionCount = 27 );\n    If( CellIsUpdateable(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21, v22, v23, v24, v25, v26, v27 ) = 1 );\n      sElType = DType( sDim27, v27\
    \ );\n      If( sElType @<> 'S' );\n        IF( pCumulate >= 1);\n          nObal = CellGetN(\
    \ pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21, v22, v23, v24, v25, v26, v27 );\n          nCbal = nObal + StringToNumberEx(\
    \ v28, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        ELSE;\n          nCbal\
    \ = StringToNumberEx( v28, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13,\
    \ v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27 );\n      Else;\n\
    \        CellPutS( v28, pCube, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27 );\n      EndIf;\n   \
    \ EndIf;\n\n  EndIf;\n\n\n### End Data ###\n#Section Epilog\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# Zero out source cube #\nIF( pZeroSource = 1 & nErrors\
    \ = 0 );\n    sProc = '}bedrock.cube.data.clear';\n    nRet = ExecuteProcess( sProc,\n \
    \       'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pCube', pCube,\n        'pView', cViewSource,\n        'pFilter', sFilter,\n \
    \       'pDimDelim', pDimDelim,\n        'pEleStartDelim', pEleStartDelim,\n        'pEleDelim',\
    \ pEleDelim,\n        'pTemp', pTemp,\n        'pCubeLogging', pCubeLogging,\n        'pSandbox',\
    \ pSandbox\n    );\n    If(nRet <> 0);\n        sMessage = 'Error clearing the source view.';\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        ProcessError();\n    EndIf;\nEndIf;\n\n\nIf( pCubeLogging <= 1 );\n    CubeSetLogChanges(\
    \ pCube, IF(sCubeLogging@='YES',1,0) );\nEndIf;\n\n### Delete export file if used\nIf( pFile\
    \ = 1 );\n  TM1RunCmd = 'CMD.EXE /C 'DEL '' | cFile | '' '';\n  EXECUTECOMMAND ( TM1RunCmd\
    \ , 0 );\nEndIf;\n\n### Delete thread control file if used\nIf( pThreadControlFile @<> ''\
    \ );\n    LogOutput( 'INFO', 'Removing thread control file: ' | pThreadControlFile );\n\
    \    ASCIIDelete( cDir | pThreadControlFile | '.txt' );\nEndIf;\n\n### Wait for all parallel\
    \ threads to finish if using pFilterParallel\nIf( pFilterParallel @<> '' );\n    sThreadFilePattern\
    \ = GetProcessName() | '_ThreadControlFile_' | cRandomInt | '_' | '*.txt';\n    LogOutput(\
    \ 'INFO', 'Checking for: ' | sThreadFilePattern );\n    i = 1;\n    While( i < pMaxWaitSeconds\
    \ );\n        sThreadCheck = WildcardFileSearch( cDir | sThreadFilePattern, '' );\n    \
    \    If( sThreadCheck @<> '' );\n            Sleep( 1 );\n        Else;\n            Break;\n\
    \        EndIf;\n\n    i = i + 1;\n    End;\nEndIf;\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 );\n        ProcessQuit;\n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully copied data from %pSrcView% view to the\
    \ %pTgtView% view in the %pCube% cube.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProces"
- question: Entwickle einen Turbo Integrator Prozess, der verwendet wird, um Daten von einem
    Quellwürfel zu einem anderen Zielwürfel zu kopieren. Der Prozess wird hauptsächlich in Produktionsumgebungen
    eingesetzt, um beispielsweise einen Berichtswürfel zu befüllen oder Daten von einem Würfel
    zu einem anderen zu archivieren. Beachte, dass der Zielwürfel möglicherweise eine andere
    Anzahl an Dimensionen als der Quellwürfel aufweist. Wo Ziel- und Quellwürfel dieselben Dimensionen
    teilen, wird der Prozess die Dimensionen entsprechend abgleichen, auch wenn sich ihre Position
    im Würfel unterscheidet. Für jede Dimension, die im Ziel- aber nicht im Quellwürfel vorhanden
    ist, muss ein Eingabeelement mit dem Parameter pMappingToNewDims angegeben werden. Der Prozesss
    kann maximal 27 Dimensionen im Zielwürfel unterstützen. Werte aller N-Level-Elemente in
    den Quell-Dimensionen, die nicht im Ziel vorhanden sind, werden akkumuliert. Verwende den
    Parameter pFilter, um die Quellwürfel basierend auf Dimensionen und Elementen zu filtern.
    Parallelisierung kann über den Parameter pFilterParallel erreicht werden, wobei Elemente
    einzeln an rekursive Aufrufe des Prozesses weitergegeben werden. Ein Beispiel wäre das Kopieren
    von tatsächlichen Verkaufsdaten von 2011 vom Verkaufswürfel in den Hauptbuchwürfel, wobei
    spezielle Kriterien verwendet werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This is the process used to copy data from a source cube\
    \ to a different target cube.\n\n# Use case: Mainly used in production environments.\n#\
    \ 1. This process could be used to populate a Reporting cube.\n# 2. The process could be\
    \ used to archive data from one cube to another one for any use.\n\n# Note:\n# * The target\
    \ cube may have a different number of dimensions as the source cube.\n# * Where the target\
    \ and source cubes share the same dimensions, the process will match the dimensions even\
    \ if their position in the cube is different.\n# * An input element must be specified for\
    \ each dimension which is in the target but not in the source using the parameter pMappingToNewDims.\n\
    # * The format of parameter pMappingToNewDims using default delimiters & and : is DimInTargetButNotSource1:ElementOfDim\
    \ & DimInTargetButNotSource2:ElementOfDim.\n# * The input element must be an N level unless\
    \ pSuppressConsol is set to 0.\n# * The maximum number of dimensions catered for in the\
    \ target cube is 27. (In principle adding support for cubes with higher dimensionality is\
    \ not difficult). \n\n# For dimensions in the source but not the target, the process will\
    \ accumulate the values of all n level elements \n# (or all n level elements specified by\
    \ the pFilter parameter).\n# The pFilter parameter contains the dimensions and elements\
    \ to be used for filtering the source cube.\n# The format of the pFilter parameter is as\
    \ follows, using default delimiters & + : Dim1: Elem1 + Elem2 & Dim2: Elem3 + Elem4.\n#\
    \ The dimension parameters do not need to be given in the index order of dimensions in the\
    \ cube.\n# The dimension name is specified as the first member of the delimited string of\
    \ elements.\n# If consolidations are skipped the N level children of any consolidated filter\
    \ elements will be used.\n# Spaces are ignored so use them to make your filter more readable.\n\
    # If using the pFilterParallel parameter the **single dimension** used as the 'parallelization\
    \ slicer' cannot appear in\n# the pFilter parameters.\n# When using parallelization via\
    \ the *RunProcess* function the elements listed in pFilterParallel will be split one_at_a_time\n\
    # and passed to a recursive call of the process being added to pFilter.\n\n# An example:\n\
    # To copy the 2011 Actual Sales data from the Sales cube to the General Ledger cube set\
    \ pFilter to Year: 2011 & Version: Actual.\n# Say the General Ledger cube has an Account\
    \ dimension but the Sales cube doesn't and the Account for sales is 9999 (an n level element).\n\
    # Set the pMappingToNewDims parameter to Account:9999.\n# This will copy all Actual 2011\
    \ Sales to Account 9999 in the General Ledger.\n# If only sales for Company X are to be\
    \ copied, set pFilter to Year: 2011 & Version: Actual & Company:X.\n# If sales from other\
    \ companies are already in the General Ledger set pZeroTarget to 0 to add Company X's data\
    \ to the existing data.\n# Setting pZeroTarget to 1 will clear our data in the target cube\
    \ for the elements specified in the\n# pMappingToNewDims parameter and the pFilter parameter\
    \ for dimensions that are in the target.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\n\n### Constants ###\ncThisProcName       =\
    \ GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now,\
    \ '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = '%cThisProcName% : %sMessage% : %cUserName%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pSrcCube:%pSrcCube%, pFilter:%pFilter%,\
    \ pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%, pTgtCube:%pTgtCube%,\
    \ pMappingToNewDims:%pMappingToNewDims%, pSuppressConsol:%pSuppressConsol%, pSuppressConsolStrings:%pSuppressConsolStrings%,\
    \ pSuppressRules:%pSuppressRules%, pSuppressZero:%pSuppressZero%, pZeroTarget:%pZeroTarget%,\
    \ pZeroSource:%pZeroSource%, pFactor:%pFactor%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%, pTemp:%pTemp%, pCubeLogging:%pCubeLogging%, pSandbox:%pSandbox%,\
    \ pFile:%pFile%, pThreadMode:%pThreadMode%.'; \n\nsDelimDim           = TRIM(pDimDelim);\n\
    sElementStartDelim  = TRIM(pElEStartDelim);\nsDelimElem          = TRIM(pEleDelim);\nnErrors\
    \             = 0;\ncLenASCIICode       = 3;\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n# Make sure pFactor\
    \ not zero\nnFactor             = If( pFactor = 0, 1, pFactor );\n\nsView              \
    \ = cThisProcName | cTimeStamp | cRandomInt;\nsSubset             = sView;\nsTargetView\
    \         = 'Target '| sView;\nsTargetSubset       = sTargetView;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## File location\
    \ for indirect data copy\ncDir    = '.' | sOSDelim;\ncFileName = pSrcCube | cTimeStamp |\
    \ cRandomInt | '.csv';\ncFile   = cDir | cFileName;\ncTitleRows = 1;\n\n# Validate file\
    \ delimiter & quote character\nIf( pDelim @= '' );\n    pDelim = ',';\nElse;\n    # If length\
    \ of pDelim is exactly 3 chars and each of them is decimal digit, then the pDelim is entered\
    \ as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim) = cLenASCIICode );\n      nChar\
    \ = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pDelim, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pDelim, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n       \
    \ Else;\n          nValid = 0;\n          Break;\n        EndIf;\n        nChar = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber(\
    \ pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\
    cDelimiter = pDelim;\n\nIf( pQuote @= '' );\n    ## Use no quote character\nElse;\n    #\
    \ If length of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote\
    \ is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n\
    \      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar\
    \ ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n\
    \        Else;\n          nValid = 0;\n          Break;\n        EndIf;\n        nChar =\
    \ nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber(\
    \ pQuote ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\
    cQuote = pQuote;\n\n#Region ## Check Parameters ###\n\n## Default filter delimiters\nIf(\
    \ pDimDelim     @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n\
    \    pEleStartDelim= '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\n\
    EndIf;\n\nIf( pDecimalSeparator @= '' );\n \tpDecimalSeparator = '.';\nEndIf;\nIf ( LONG(pDecimalSeparator)\
    \ = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n\
    \    If( CODE( pDecimalSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pDecimalSeparator, nChar\
    \ ) <= CODE( '9', 1 ) );\n      nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n\
    \    EndIf;\n    nChar = nChar + 1;\n  End;\n  If ( nValid<>0 );\n    pDecimalSeparator\
    \ = CHAR(StringToNumber( pDecimalSeparator ));\n  Else;\n    pDecimalSeparator = SubSt(\
    \ Trim( pDecimalSeparator ), 1, 1 );\n  EndIf;\nEndIf;\nsDecimalSeparator = pDecimalSeparator;\n\
    \nIf( pThousandSeparator @= '' );\n \tpThousandSeparator = ',';\nEndIf;\nIf ( LONG(pThousandSeparator)\
    \ = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n\
    \    If( CODE( pThousandSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pThousandSeparator,\
    \ nChar ) <= CODE( '9', 1 ) );\n      nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n\
    \    EndIf;\n    nChar = nChar + 1;\n  End;\n  If ( nValid<>0 );\n    pThousandSeparator\
    \ = CHAR(StringToNumber( pThousandSeparator ));\n  Else;\n    pThousandSeparator = SubSt(\
    \ Trim( pThousandSeparator ), 1, 1 );\n  EndIf;\nEndIf;\nsThousandSeparator = pThousandSeparator;\n\
    \n# If specified source cube doesn't exist then terminate process\nIf( CubeExists(   pSrcCube\
    \   ) = 0 );\n    nErrors = nErrors + 1;\n  sMessage = Expand( 'Invalid source cube specified:\
    \ %pSrcCube%.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # If specified target cube doesn't exist then terminate process\nIf( CubeExists(   pTgtCube\
    \   ) = 0 );\n  nErrors = nErrors + 1;\n  sMessage = Expand( 'Invalid target cube specified:\
    \ %pTgtCube%.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate parallelization filter\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n\
    \    sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) -\
    \ 1 );\n    If( Scan( Lower(sDimParallel) | pEleStartDelim, Lower(pFilter) ) > 0 );\n  \
    \      sMessage = 'Parallelization dimension %sDimParallel% cannot exist in filter.';\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\nEndIf;\n\n# Validate Max Threads\nIf( pParallelThreads > 0 );\n  nMaxThreads\
    \ = pParallelThreads;\nElse;\n  nMaxThreads = 1;\nEndIf;\n\n# Validate Sandbox\nIf( TRIM(\
    \ pSandbox ) @<> '' );\n    If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty(\
    \ 0 );\n        nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is\
    \ invalid for the current user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        ServerActiveSandboxSet( pSandbox );\n        SetUseActiveSandboxProperty(\
    \ 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty( 0 );\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n#EndRegion\n#Region\
    \ \n## Set variables =0 or '' #################################################################################################\
    \ ########################\n### Placeholders for mappped dimensions\nnMappedDim1 = 0;\n\
    nMappedDim2 = 0;\nnMappedDim3 = 0;\nnMappedDim4 = 0;\nnMappedDim5 = 0;\nnMappedDim6 = 0;\n\
    nMappedDim7 = 0;\nnMappedDim8 = 0;\nnMappedDim9 = 0;\nnMappedDim10 = 0;\nnMappedDim11 =\
    \ 0;\nnMappedDim12 = 0;\nnMappedDim13 = 0;\nnMappedDim14 = 0;\nnMappedDim15 = 0;\nnMappedDim16\
    \ = 0;\nnMappedDim17 = 0;\nnMappedDim18 = 0;\nnMappedDim19 = 0;\nnMappedDim20 = 0;\nnMappedDim21\
    \ = 0;\nnMappedDim22 = 0;\nnMappedDim23 = 0;\nnMappedDim24 = 0;\nnMappedDim25 = 0;\nnMappedDim26\
    \ = 0;\nnMappedDim27 = 0;\n\nsMappedV1 = '';\nsMappedV2 = '';\nsMappedV3 = '';\nsMappedV4\
    \ = '';\nsMappedV5 = '';\nsMappedV6 = '';\nsMappedV7 = '';\nsMappedV8 = '';\nsMappedV9 =\
    \ '';\nsMappedV10 = '';\nsMappedV11 = '';\nsMappedV12 = '';\nsMappedV13 = '';\nsMappedV14\
    \ = '';\nsMappedV15 = '';\nsMappedV16 = '';\nsMappedV17 = '';\nsMappedV18 = '';\nsMappedV19\
    \ = '';\nsMappedV20 = '';\nsMappedV21 = '';\nsMappedV22 = '';\nsMappedV23 = '';\nsMappedV24\
    \ = '';\nsMappedV25 = '';\nsMappedV26 = '';\nsMappedV27 = '';\nsMappedV28 = '';\n\n### Placeholders\
    \ for new dimensions\nnNewDim1 = 0;\nnNewDim2 = 0;\nnNewDim3 = 0;\nnNewDim4 = 0;\nnNewDim5\
    \ = 0;\nnNewDim6 = 0;\nnNewDim7 = 0;\nnNewDim8 = 0;\nnNewDim9 = 0;\nnNewDim10 = 0;\nnNewDim11\
    \ = 0;\nnNewDim12 = 0;\nnNewDim13 = 0;\nnNewDim14 = 0;\nnNewDim15 = 0;\nnNewDim16 = 0;\n\
    nNewDim17 = 0;\nnNewDim18 = 0;\nnNewDim19 = 0;\nnNewDim20 = 0;\nnNewDim21 = 0;\nnNewDim22\
    \ = 0;\nnNewDim23 = 0;\nnNewDim24 = 0;\nnNewDim25 = 0;\nnNewDim26 = 0;\nnNewDim27 = 0;\n\
    \nsNewV1 = '';\nsNewV2 = '';\nsNewV3 = '';\nsNewV4 = '';\nsNewV5 = '';\nsNewV6 = '';\nsNewV7\
    \ = '';\nsNewV8 = '';\nsNewV9 = '';\nsNewV10 = '';\nsNewV11 = '';\nsNewV12 = '';\nsNewV13\
    \ = '';\nsNewV14 = '';\nsNewV15 = '';\nsNewV16 = '';\nsNewV17 = '';\nsNewV18 = '';\nsNewV19\
    \ = '';\nsNewV20 = '';\nsNewV21 = '';\nsNewV22 = '';\nsNewV23 = '';\nsNewV24 = '';\nsNewV25\
    \ = '';\nsNewV26 = '';\nsNewV27 = '';\n\n### Determine dimensions in target cube, we need\
    \ to know this to test cell type before loading ###\n# only numbers get converted from strings\
    \ to numbers\nsDim1 = TabDim( pTgtCube, 1 );\nsDim2 = TabDim( pTgtCube, 2 );\nsDim3 = TabDim(\
    \ pTgtCube, 3 );\nsDim4 = TabDim( pTgtCube, 4 );\nsDim5 = TabDim( pTgtCube, 5 );\nsDim6\
    \ = TabDim( pTgtCube, 6 );\nsDim7 = TabDim( pTgtCube, 7 );\nsDim8 = TabDim( pTgtCube, 8\
    \ );\nsDim9 = TabDim( pTgtCube, 9 );\nsDim10 = TabDim( pTgtCube, 10 );\nsDim11 = TabDim(\
    \ pTgtCube, 11 );\nsDim12 = TabDim( pTgtCube, 12 );\nsDim13 = TabDim( pTgtCube, 13 );\n\
    sDim14 = TabDim( pTgtCube, 14 );\nsDim15 = TabDim( pTgtCube, 15 );\nsDim16 = TabDim( pTgtCube,\
    \ 16 );\nsDim17 = TabDim( pTgtCube, 17 );\nsDim18 = TabDim( pTgtCube, 18 );\nsDim19 = TabDim(\
    \ pTgtCube, 19 );\nsDim20 = TabDim( pTgtCube, 20 );\nsDim21 = TabDim( pTgtCube, 21 );\n\
    sDim22 = TabDim( pTgtCube, 22 );\nsDim23 = TabDim( pTgtCube, 23 );\nsDim24 = TabDim( pTgtCube,\
    \ 24 );\nsDim25 = TabDim( pTgtCube, 25 );\nsDim26 = TabDim( pTgtCube, 26 );\nsDim27 = TabDim(\
    \ pTgtCube, 27 );\n#EndRegion\nsTgtDimString = '^^'|sDim1|'^^'|sDim2|'^^'|sDim3|'^^'|sDim4|'^^'|sDim5|'^^'|sDim6|'^^'|sDim7|'^^'|sDim8|'^^'|sDim9|'^^'|sDim10|'^^'\n\
    \                    |sDim11|'^^'|sDim12|'^^'|sDim13|'^^'|sDim14|'^^'|sDim15|'^^'|sDim16|'^^'|sDim17|'^^'|sDim18|'^^'|sDim19|'^^'|sDim20|'^^'\n\
    \                    |sDim21|'^^'|sDim22|'^^'|sDim23|'^^'|sDim24|'^^'|sDim25|'^^'|sDim26|'^^'|sDim27|'^^';\n\
    \n### We have to remove spaces from the search string before going to include the string\
    \ in searching loop\nsTgtDimString = UPPER( sTgtDimString );\nnSPIndex = SCAN( ' ', sTgtDimString\
    \ );\nWhile ( nSPIndex <> 0);\n  sTgtDimString = DELET( sTgtDimString, nSPIndex, 1 );\n\
    \  nSPIndex = SCAN( ' ', sTgtDimString );\nEnd;\n\n###########################################\n\
    #Region ### MAPPING Target DIMENSIONS #####\n###########################################\n\
    nSourceIndex = 1;\nWhile( TabDim( pSrcCube, nSourceIndex ) @<> '' );\n  sSourceDim = TabDim(\
    \ pSrcCube, nSourceIndex);\n    # reset target index if another source dimension has been\
    \ found\n    nTargetIndex = 1;\n    WHILE(TabDim( pTgtCube, nTargetIndex ) @<> '');\n  \
    \    sTargetDim = TabDim( pTgtCube, nTargetIndex );\n      If(sSourceDim @= sTargetDim);\n\
    \          If( pFile = 0 );\n            If(nTargetIndex = 1);\n              nMappedDim1\
    \ = 1;\n              sMappedV1  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex\
    \ = 2);\n              nMappedDim2 = 1;\n              sMappedV2  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 3);\n              nMappedDim3 = 1;\n              sMappedV3\
    \  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 4);\n      \
    \        nMappedDim4 = 1;\n              sMappedV4  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 5);\n              nMappedDim5 = 1;\n              sMappedV5\
    \  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 6);\n      \
    \        nMappedDim6 = 1;\n              sMappedV6  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 7);\n              nMappedDim7 = 1;\n              sMappedV7\
    \  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 8);\n      \
    \        nMappedDim8 = 1;\n              sMappedV8  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 9);\n              nMappedDim9 = 1;\n              sMappedV9\
    \  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 10);\n     \
    \         nMappedDim10 = 1;\n              sMappedV10  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 11);\n              nMappedDim11 = 1;\n             \
    \ sMappedV11  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 12);\n\
    \              nMappedDim12 = 1;\n              sMappedV12  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 13);\n              nMappedDim13 = 1;\n             \
    \ sMappedV13  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 14);\n\
    \              nMappedDim14 = 1;\n              sMappedV14  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 15);\n              nMappedDim15 = 1;\n             \
    \ sMappedV15  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 16);\n\
    \              nMappedDim16 = 1;\n              sMappedV16  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 17);\n              nMappedDim17 = 1;\n             \
    \ sMappedV17  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 18);\n\
    \              nMappedDim18 = 1;\n              sMappedV18  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 19);\n              nMappedDim19 = 1;\n             \
    \ sMappedV19  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 20);\n\
    \              nMappedDim20 = 1;\n              sMappedV20  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 21);\n              nMappedDim21 = 1;\n             \
    \ sMappedV21  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 22);\n\
    \              nMappedDim22 = 1;\n              sMappedV22  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 23);\n              nMappedDim23 = 1;\n             \
    \ sMappedV23  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 24);\n\
    \              nMappedDim24 = 1;\n              sMappedV24  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 25);\n              nMappedDim25 = 1;\n             \
    \ sMappedV25  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 26);\n\
    \              nMappedDim26 = 1;\n              sMappedV26  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 27);\n              nMappedDim27 = 1;\n             \
    \ sMappedV27  = 'V' | NumberToString(nSourceIndex);\n            EndIf;\n          ElseIf(\
    \ pFile > 0 );\n            ## If using source file first variable holds tha cube name,\
    \ so all the other ones have the index increased by 1\n            If(nTargetIndex = 1);\n\
    \              nMappedDim1 = 1;\n              sMappedV1  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 2);\n              nMappedDim2 = 1;\n       \
    \       sMappedV2  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 3);\n              nMappedDim3 = 1;\n              sMappedV3  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 4);\n              nMappedDim4 = 1;\n       \
    \       sMappedV4  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 5);\n              nMappedDim5 = 1;\n              sMappedV5  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 6);\n              nMappedDim6 = 1;\n       \
    \       sMappedV6  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 7);\n              nMappedDim7 = 1;\n              sMappedV7  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 8);\n              nMappedDim8 = 1;\n       \
    \       sMappedV8  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 9);\n              nMappedDim9 = 1;\n              sMappedV9  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 10);\n              nMappedDim10 = 1;\n     \
    \         sMappedV10  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 11);\n              nMappedDim11 = 1;\n              sMappedV11  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 12);\n              nMappedDim12 = 1;\n     \
    \         sMappedV12  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 13);\n              nMappedDim13 = 1;\n              sMappedV13  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 14);\n              nMappedDim14 = 1;\n     \
    \         sMappedV14  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 15);\n              nMappedDim15 = 1;\n              sMappedV15  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 16);\n              nMappedDim16 = 1;\n     \
    \         sMappedV16  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 17);\n              nMappedDim17 = 1;\n              sMappedV17  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 18);\n              nMappedDim18 = 1;\n     \
    \         sMappedV18  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 19);\n              nMappedDim19 = 1;\n              sMappedV19  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 20);\n              nMappedDim20 = 1;\n     \
    \         sMappedV20  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 21);\n              nMappedDim21 = 1;\n              sMappedV21  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 22);\n              nMappedDim22 = 1;\n     \
    \         sMappedV22  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 23);\n              nMappedDim23 = 1;\n              sMappedV23  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 24);\n              nMappedDim24 = 1;\n     \
    \         sMappedV24  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 25);\n              nMappedDim25 = 1;\n              sMappedV25  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 26);\n              nMappedDim26 = 1;\n     \
    \         sMappedV26  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 27);\n              nMappedDim27 = 1;\n              sMappedV27  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            EndIf;\n          EndIf;\n\n      EndIf;\n\n      nTargetIndex = nTargetIndex\
    \ + 1;\n\n    END;\n\n  nSourceIndex = nSourceIndex + 1;\n\nEND;\n\n# The last variable\
    \ in the data source holds the values\n# which need to be mapped to the last variable in\
    \ the target\n\nIf( pFile = 0 );\n  If(nTargetIndex = 1);\n    nMappedDim1 = 1;\n    sMappedV1\
    \  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex = 2);\n    nMappedDim2 =\
    \ 1;\n    sMappedV2  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex = 3);\n\
    \    nMappedDim3 = 1;\n    sMappedV3  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 4);\n    nMappedDim4 = 1;\n    sMappedV4  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 5);\n    nMappedDim5 = 1;\n    sMappedV5  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 6);\n    nMappedDim6 = 1;\n    sMappedV6  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 7);\n    nMappedDim7 = 1;\n    sMappedV7  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 8);\n    nMappedDim8 = 1;\n    sMappedV8  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 9);\n    nMappedDim9 = 1;\n    sMappedV9  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 10);\n    nMappedDim10 = 1;\n    sMappedV10  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 11);\n    nMappedDim11 = 1;\n    sMappedV11  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 12);\n    nMappedDim12 = 1;\n    sMappedV12  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 13);\n    nMappedDim13 = 1;\n    sMappedV13  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 14);\n    nMappedDim14 = 1;\n    sMappedV14  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 15);\n    nMappedDim15 = 1;\n    sMappedV15  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 16);\n    nMappedDim16 = 1;\n    sMappedV16  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 17);\n    nMappedDim17 = 1;\n    sMappedV17  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 18);\n    nMappedDim18 = 1;\n    sMappedV18  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 19);\n    nMappedDim19 = 1;\n    sMappedV19  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 20);\n    nMappedDim20 = 1;\n    sMappedV20  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 21);\n    nMappedDim21 = 1;\n    sMappedV21  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 22);\n    nMappedDim22 = 1;\n    sMappedV22  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 23);\n    nMappedDim23 = 1;\n    sMappedV23  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 24);\n    nMappedDim24 = 1;\n    sMappedV24  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 25);\n    nMappedDim25 = 1;\n    sMappedV25  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 26);\n    nMappedDim26 = 1;\n    sMappedV26  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 27);\n    nMappedDim27 = 1;\n    sMappedV27  = 'V' | NumberToString(nSourceIndex);\n\
    \  \n  # a cube with 27 dimensions uses V28 to hold the values\n  ElseIf(nTargetIndex =\
    \ 28);\n    nMappedDim28 = 1;\n    sMapped28  = 'V' | NumberToString(nSourceIndex);\n  EndIf;\n\
    ElseIf( pFile > 0 );\n  If(nTargetIndex = 1);\n    nMappedDim1 = 1;\n    sMappedV1  = 'V'\
    \ | NumberToString(nSourceIndex + 1);\n  ElseIf(nTargetIndex = 2);\n    nMappedDim2 = 1;\n\
    \    sMappedV2  = 'V' | NumberToString(nSourceIndex + 1);\n  ElseIf(nTargetIndex = 3);\n\
    \    nMappedDim3 = 1;\n    sMappedV3  = 'V' | NumberToString(nSourceIndex + 1);\n  ElseIf(nTargetIndex\
    \ = 4);\n    nMappedDim4 = 1;\n    sMappedV4  = 'V' | NumberToString(nSourceIndex + 1);\n\
    \  ElseIf(nTargetIndex = 5);\n    nMappedDim5 = 1;\n    sMappedV5  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 6);\n    nMappedDim6 = 1;\n    sMappedV6  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 7);\n    nMappedDim7 = 1;\n    sMappedV7  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 8);\n    nMappedDim8 = 1;\n    sMappedV8  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 9);\n    nMappedDim9 = 1;\n    sMappedV9  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 10);\n    nMappedDim10 = 1;\n    sMappedV10  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 11);\n    nMappedDim11 = 1;\n    sMappedV11  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 12);\n    nMappedDim12 = 1;\n    sMappedV12  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 13);\n    nMappedDim13 = 1;\n    sMappedV13  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 14);\n    nMappedDim14 = 1;\n    sMappedV14  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 15);\n    nMappedDim15 = 1;\n    sMappedV15  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 16);\n    nMappedDim16 = 1;\n    sMappedV16  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 17);\n    nMappedDim17 = 1;\n    sMappedV17  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 18);\n    nMappedDim18 = 1;\n    sMappedV18  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 19);\n    nMappedDim19 = 1;\n    sMappedV19  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 20);\n    nMappedDim20 = 1;\n    sMappedV20  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 21);\n    nMappedDim21 = 1;\n    sMappedV21  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 22);\n    nMappedDim22 = 1;\n    sMappedV22  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 23);\n    nMappedDim23 = 1;\n    sMappedV23  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 24);\n    nMappedDim24 = 1;\n    sMappedV24  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 25);\n    nMappedDim25 = 1;\n    sMappedV25  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 26);\n    nMappedDim26 = 1;\n    sMappedV26  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 27);\n    nMappedDim27 = 1;\n    sMappedV27  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  \n  # a cube with 27 dimensions uses V29 to hold the values if export file is\
    \ used as source\n  ElseIf(nTargetIndex = 28);\n    nMappedDim28 = 1;\n    sMapped28  =\
    \ 'V' | NumberToString(nSourceIndex + 1);\n  EndIf;\nEndIf;\n#EndRegion\n\n###########################################\n\
    ### SPLIT MAPPING TO NEW DIMS PARAMETER ###\n###########################################\n\
    \n# now deduct 1 to set these indices to the number of dimensions in each cube\nnSourceDimensionCount\
    \       = nSourceIndex - 1;\nnTargetCubeDimensionCount   = nTargetIndex - 1;\n# default\
    \ dimension count is for target\nnDimensionCount = nTargetIndex - 1;\n\nsElementMapping\
    \ = TRIM( pMappingToNewDims );\nnChar = 1;\nnCharCount = LONG( sElementMapping );\n\nsTargetFilter\
    \ = '';\nsWord = '';\nsLastDelim = '';\nnIndex = 1;\n\n# Add a trailing element delimiter\
    \ so that the last element is picked up\nIf( nCharCount > 0 );\n  sElementMapping = sElementMapping\
    \ | sDelimDim;\n  nCharCount = nCharCount + LONG(sDelimDim);\nEndIf;\n\nWHILE (nChar <=\
    \ nCharCount);\n    sChar = SUBST( sElementMapping, nChar, 1);\n\n    # Used for delimiters,\
    \ required for multiple character delimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n \
    \   # Ignore spaces\n    IF (TRIM(sChar) @<> '' );\n\n      ### Dimension Name ###\n\n \
    \     # If the delimiter is more than 1 character peek ahead the same amount\n      # Ignore\
    \ the first character\n      sDelim = sChar;\n      nCount = LONG(sElementStartDelim) -\
    \ 1;\n      If( nCount > 0 & nChar + nCount <= nCharCount );\n        # Add the extra characters\n\
    \        sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\n        # Move to\
    \ the end of the delimter\n        nAddExtra = nCount;\n      EndIf;\n\n      If( sDelim\
    \ @= sElementStartDelim );\n\n        sChar = sDelim;\n\n        If( sLastDelim @<> '' &\
    \ sLastDelim @<> sDelimDim );\n            sMessage = 'In pMappingToNewDims the name of\
    \ a dimension must follow a dimension delimiter (' | sDelimDim | ')';\n            nErrors\
    \ = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \            #ProcessError();\n        EndIf;\n\n        # Found a dimension\n        sDimension\
    \ = sWord;\n\n        If( DimensionExists( sDimension ) = 0 );\n            # The dimension\
    \ does not exist in the model. Cancel process\n            sMessage = 'In pMappingToNewDims\
    \ - Dimension: ' | sDimension | ' does not exist';\n            nErrors = nErrors + 1;\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \        EndIf;\n\n        # Find the index of the dimension is in the Target cube\n   \
    \     nTargetIndexCounter = 1;\n\n        WHILE(nTargetIndexCounter <= nTargetCubeDimensionCount\
    \ );\n          sNthDimension = TabDim( pTgtCube, nTargetIndexCounter );\n\n          If(sDimension\
    \ @= sNthDimension);\n            nTargetIndex = nTargetIndexCounter;\n            nTargetIndexCounter\
    \ = 1000;\n          EndIf;\n\n          nTargetIndexCounter = nTargetIndexCounter + 1;\n\
    \        END;\n        \n        #Add to the Target filter\n        IF(sTargetFilter@='');\n\
    \          sTargetFilter=sDimension;          \n        Else;\n          sTargetFilter=sTargetFilter|sDelimDim|sDimension;\n\
    \        Endif;  \n          \n        sLastDelim = sChar;\n        # Clear the word\n \
    \       sWord = '';\n\n      Else;\n\n        # Reset extra chars\n        nAddExtra = 0;\n\
    \n        ### Check both dim delimiter and element delimiter ###\n        nIsDelimiter =\
    \ 0;\n\n        ## Check dimension delimiter first\n        # If the delimiter is more than\
    \ 1 character peek ahead the same amount\n        # Ignore the first character\n       \
    \ sDelim = sChar;\n        nCount = LONG(sDelimDim) - 1;\n        If( nCount > 0 & nChar\
    \ + nCount <= nCharCount );\n          # Add the extra characters\n          sDelim = sDelim\
    \ | SUBST( sElementMapping, nChar + 1, nCount);\n          # Move to the end of the delimter\n\
    \          nAddExtra = nCount;\n        EndIf;\n\n        If( sDelim @= sDelimDim );\n \
    \         nIsDelimiter = 1;\n          sChar = sDelim;\n        EndIf;\n\n        If ( nIsDelimiter\
    \ = 1 );\n\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim );\n            sMessage\
    \ = 'In pMappingToNewDims - an element delimiter must follow a dimension name: ' |  sChar\
    \ | ' (' | NumberToString(nChar) | ')';\n            nErrors = nErrors + 1;\n          \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \          EndIf;\n\n          # an element has been found\n          sElement = sWord;\n\
    \n          If( DIMIX( sDimension, sElement ) = 0 );\n              # The element does not\
    \ exist in the dimension. Cancel process\n              sMessage = 'In pMappingToNewDims\
    \ - Element: ' | sElement | ' in dimension ' | sDimension | ' does not exist';\n       \
    \       nErrors = nErrors + 1;\n              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n              #ProcessError();\n          EndIf;\n\n          # Allow consolidations\
    \ only if pSuppressConsol is set to 0\n\n          If ( DTYPE( sDimension, sElement) @=\
    \ 'C' );\n            sMessage = Expand( 'In pMappingToNewDims - Target element: %sElement%\
    \ for dimension %sDimension% is consolidated' );\n            nErrors = nErrors + 1;\n \
    \           LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \          Endif;  \n          \n\n          # Add the element to the source or target depending\
    \ on whether it's the first or the second element\n          # Get principal name\n    \
    \      # in case source element and this element are using different aliases\n\n       \
    \   sElement = DimensionElementPrincipalName(sDimension,sElement);\n\n          ### Update\
    \ the variable for InputElement Target Dim ######################################\n    \
    \      If(nTargetIndex = 1);\n            nNewDim1 = 1;\n            sNewV1 = sElement;\n\
    \          ElseIf(nTargetIndex = 2);\n            nNewDim2 = 1;\n            sNewV2 = sElement;\n\
    \          ElseIf(nTargetIndex = 3);\n            nNewDim3 = 1;\n            sNewV3 = sElement;\n\
    \          ElseIf(nTargetIndex = 4);\n            nNewDim4 = 1;\n            sNewV4 = sElement;\n\
    \          ElseIf(nTargetIndex = 5);\n            nNewDim5 = 1;\n            sNewV5 = sElement;\n\
    \          ElseIf(nTargetIndex = 6);\n            nNewDim6 = 1;\n            sNewV6 = sElement;\n\
    \          ElseIf(nTargetIndex = 7);\n            nNewDim7 = 1;\n            sNewV7 = sElement;\n\
    \          ElseIf(nTargetIndex = 8);\n            nNewDim8 = 1;\n            sNewV8 = sElement;\n\
    \          ElseIf(nTargetIndex = 9);\n            nNewDim9 = 1;\n            sNewV9 = sElement;\n\
    \          ElseIf(nTargetIndex = 10);\n            nNewDim10 = 1;\n            sNewV10 =\
    \ sElement;\n          ElseIf(nTargetIndex = 11);\n            nNewDim11 = 1;\n        \
    \    sNewV11 = sElement;\n          ElseIf(nTargetIndex = 12);\n            nNewDim12 =\
    \ 1;\n            sNewV12 = sElement;\n          ElseIf(nTargetIndex = 13);\n          \
    \  nNewDim13 = 1;\n            sNewV13 = sElement;\n          ElseIf(nTargetIndex = 14);\n\
    \            nNewDim14 = 1;\n            sNewV14 = sElement;\n          ElseIf(nTargetIndex\
    \ = 15);\n            nNewDim15 = 1;\n            sNewV15 = sElement;\n          ElseIf(nTargetIndex\
    \ = 16);\n            nNewDim16 = 1;\n            sNewV16 = sElement;\n          ElseIf(nTargetIndex\
    \ = 17);\n            nNewDim17 = 1;\n            sNewV17 = sElement;\n          ElseIf(nTargetIndex\
    \ = 18);\n            nNewDim18 = 1;\n            sNewV18 = sElement;\n          ElseIf(nTargetIndex\
    \ = 19);\n            nNewDim19 = 1;\n            sNewV19 = sElement;\n          ElseIf(nTargetIndex\
    \ = 20);\n            nNewDim20 = 1;\n            sNewV20 = sElement;\n          ElseIf(nTargetIndex\
    \ = 21);\n            nNewDim21 = 1;\n            sNewV21 = sElement;\n          ElseIf(nTargetIndex\
    \ = 22);\n            nNewDim22 = 1;\n            sNewV22 = sElement;\n          ElseIf(nTargetIndex\
    \ = 23);\n            nNewDim23 = 1;\n            sNewV23 = sElement;\n          ElseIf(nTargetIndex\
    \ = 24);\n            nNewDim24 = 1;\n            sNewV24 = sElement;\n          ElseIf(nTargetIndex\
    \ = 25);\n            nNewDim25 = 1;\n            sNewV25 = sElement;\n          ElseIf(nTargetIndex\
    \ = 26);\n            nNewDim26 = 1;\n            sNewV26 = sElement;\n          ElseIf(nTargetIndex\
    \ = 27);\n            nNewDim27 = 1;\n            sNewV27 = sElement;\n          EndIf;\n\
    \n          #Add to the Target filter\n          sTargetFilter=sTargetFilter|sElementStartDelim|sElement;\n\
    \          \n          # Clear the word\n          sWord = '';\n          sLastDelim = sChar;\n\
    \ \n        Else;\n          sWord = sWord | sChar;\n        EndIf;\n\n      EndIf;\n\n\
    \    EndIf;\n\n    nChar = nChar + nAddExtra + 1;\n\nEND;\n\n# Check that an input element\
    \ or variable has been specified for all dimensions in the target cube\n\nnIndexInTarget\
    \ = 1;\nWHILE(nIndexInTarget <= nTargetCubeDimensionCount);\n      \n      sMapped   = Expand('%nMappedDim'|\
    \ NumberToString(nIndexInTarget) |'%'); \n      sMapped   = Subst( sMapped , Scan( '.' ,\
    \ sMapped )-1 , 99);\n      nMapped   = StringToNumber( Trim( sMapped ) );\n      sNew \
    \     = Expand('%nNewDim'| NumberToString(nIndexInTarget) |'%'); \n      sNew      = Subst(\
    \ sNew , Scan( '.' , sNew )-1 , 99);\n      nNew      = StringToNumber( Trim( sNew ) );\n\
    \      \n      If(nMapped = 0 & nNew = 0 );\n            # there's no input element and\
    \ this dimension is not in the source\n            nErrors         = nErrors + 1;\n    \
    \        sTargetDimName  = TabDim( pTgtCube,  nIndexInTarget );\n            sMessage  \
    \      = 'Dimension ' | sTargetDimName | ' is missing an input element in pMappingToNewDims';\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            If( pStrictErrorHandling\
    \ = 1 ); \n                ProcessQuit; \n            Else;\n                ProcessBreak;\n\
    \            EndIf;\n       EndIf;\n       \n       nIndexInTarget = nIndexInTarget + 1;\n\
    END;\n\n\n############################# Clear out target ################################\n\
    \n# Target is cleared for the elements specified in pMappingToNewDims\n# and for the parts\
    \ of pFilter for dimensions in the target\n# This code works through pFilter looking for\
    \ the parts relating to the target cube\n# the code which finds individual elements has\
    \ been left in\n# so that it can be changed later to deal with consolidated elements\n\n\
    sFilter = TRIM( pFilter );\nnChar = 1;\nnCharCount = LONG( sFilter );\nsWord = '';\nsLastDelim\
    \ = '';\n\n# Add a trailing element delimiter so that the last Dimension:Element/s clause\
    \ is picked up\nIf( nCharCount > 0 );\n  sFilter = sFilter | sDelimElem;\n  nCharCount =\
    \ nCharCount + LONG(sDelimElem);\nEndIf;\n\nWHILE (nChar <= nCharCount);\n\n    sChar =\
    \ SUBST( sFilter, nChar, 1);\n\n    # Used for delimiters, required for multiple character\
    \ dilimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n    # Ignore spaces\n    IF (TRIM(sChar)\
    \ @<> '' );\n\n      ### Dimension Name ###\n\n      # If the delimiter is more than 1 character\
    \ peek ahead the same amount\n      # Ignore the first character\n      sDelim = sChar;\n\
    \      nCount = LONG(sElementStartDelim) - 1;\n      If( nCount > 0 & nChar + nCount <=\
    \ nCharCount );\n        # Add the extra characters\n        sDelim = sDelim | SUBST( sFilter,\
    \ nChar + 1, nCount);\n        # Move to the end of the delimter\n        nAddExtra = nCount;\n\
    \      EndIf;\n\n      If( sDelim @= sElementStartDelim );\n\n        sChar = sDelim;\n\n\
    \        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );\n          sMessage = 'In pFilter\
    \ - the name of a dimension must follow a dimension delimiter (' | sDelimDim | ')';\n  \
    \        nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n          #ProcessError();\n        EndIf;\n\n        # Found a dimension!\n   \
    \     sDimension = UPPER( sWord );\n        nDimInTgt=0;\n        # See if the dimension\
    \ is in the target cube\n        IF(scan('^^'|sDimension|'^^', sTgtDimString)>0);\n    \
    \      If(sTargetFilter@='');\n            sTargetFilter = sDimension;\n          Else;\
    \  \n            sTargetFilter = sTargetFilter | sDelimDim | sDimension;\n          endif;\n\
    \          nDimInTgt=1;\n        Endif;  \n\n        sLastDelim = sChar;\n        # Clear\
    \ the word\n        sWord = '';\n        #reset element count\n        nElementCount = 1;\n\
    \n      Else;\n\n        # Reset extra chars\n        nAddExtra = 0;\n\n        ### Check\
    \ both both dim delimiter and element delimiter ###\n        nIsDelimiter = 0;\n\n     \
    \   ## Check dimension delimiter first\n        # If the delimiter is more than 1 character\
    \ peek ahead the same amount\n        # Ignore the first character\n        sDelim = sChar;\n\
    \        nCount = LONG(sDelimDim) - 1;\n        If( nCount > 0 & nChar + nCount <= nCharCount\
    \ );\n          # Add the extra characters\n          sDelim = sDelim | SUBST( sFilter,\
    \ nChar + 1, nCount);\n          # Move to the end of the delimter\n          nAddExtra\
    \ = nCount;\n        EndIf;\n\n        If( sDelim @= sDelimDim );\n          nIsDelimiter\
    \ = 1;\n          sChar = sDelim;\n        Else;\n          # Reset extra chars\n      \
    \    nAddExtra = 0;\n\n          ## Check element delimiter\n\n          # If the delimiter\
    \ is more than 1 character peek ahead the same amount\n          # Ignore the first character\n\
    \          sDelim = sChar;\n          nCount = LONG(sDelimElem) - 1;\n          If( nCount\
    \ > 0 & nChar + nCount <= nCharCount );\n            # Add the extra characters\n      \
    \      sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n            # Move to the\
    \ end of the delimter\n            nAddExtra = nCount;\n          EndIf;\n\n          If(\
    \ sDelim @= sDelimElem );\n            nIsDelimiter = 1;\n            sChar = sDelim;\n\
    \          Else;\n            # Reset extra chars\n            nAddExtra = 0;\n        \
    \  EndIf;\n\n        EndIf;\n\n        If ( nIsDelimiter = 1 );\n\n          If( sLastDelim\
    \ @= '' % sLastDelim @= sDelimDim );\n            sMessage = 'In pFilter - an element delimiter\
    \ must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';\n     \
    \       nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            #ProcessError();\n          EndIf;\n\n          # Found an element\n\
    \          sElement = sWord;\n\n          IF(DIMIX(sDimension, sElement) > 0 & nDimInTgt=1);\n\
    \              # first element\n              IF(nElementCount = 1);\n                sTargetFilter\
    \ = sTargetFilter | sElementStartDelim | sElement;\n              # later elements\n   \
    \           Else;\n                sTargetFilter = sTargetFilter | sDelimElem | sElement;\n\
    \              EndIf;\n          EndIf;\n\n          nElementCount = nElementCount + 1;\n\
    \          sLastDelim = sChar;\n\n          # Clear the word\n          sWord = '';\n  \
    \      Else;\n          sWord = sWord | sChar;\n        EndIf;\n\n      EndIf;\n\n    EndIf;\n\
    \n    nChar = nChar + nAddExtra + 1;\n\nEND;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Branch depending on whether to do recursive\
    \ calls to self on independent threads or run all in this thread\nIf( Scan( pEleStartDelim,\
    \ pFilterParallel ) > 0 );\n  sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim,\
    \ pFilterParallel ) - 1 );\n  sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim,\
    \ pFilterParallel ) + 1, Long( pFilterParallel ) );\n  If( SubSt( sElementList, Long( sElementList\
    \ ), 1 ) @<> pEleDelim );\n      sElementList = sElementList | pEleDelim;\n  EndIf;\n  ##\
    \ Counting elements in element list\n  sElementListCount = sElementList;\n  nElements =\
    \ 0;\n  While( Scan( pEleDelim, sElementListCount ) > 0 );\n    nElements = nElements +\
    \ 1;\n    sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount\
    \ ) + 1, Long( sElementListCount ) );\n  End;\n  IF( Mod( nElements, nMaxThreads ) = 0 );\n\
    \    nElemsPerThread = INT( nElements / nMaxThreads );\n  ELSE;\n    nElemsPerThread = INT(\
    \ nElements / nMaxThreads ) + 1;\n  ENDIF;\n  nThreadElCounter = 0;\n  While( Scan( pEleDelim,\
    \ sElementList ) > 0 );\n      sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList\
    \ ) - 1 );\n      sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList ) +\
    \ 1, Long( sElementList ) );\n      # Do recursive process call with new RunProcess function\n\
    \      nThreadElCounter = nThreadElCounter + 1;\n      sDimDelim = If(pFilter @= '', '',\
    \ pDimDelim );\n      IF( nThreadElCounter = 1 );\n        sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \      ELSE;\n        sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n      ENDIF;\n\
    \      IF( nThreadElCounter >= nElemsPerThread );\n        RunProcess( cThisProcName, 'pLogoutput',\
    \ pLogoutput,\n        \t'pSrcCube', pSrcCube, 'pFilter', sFilter, 'pFilterParallel', '',\
    \ 'pTgtCube', pTgtCube, 'pMappingToNewDims', pMappingToNewDims,\n        \t'pSuppressConsol',\
    \ pSuppressConsol, 'pSuppressConsolStrings', pSuppressConsolStrings, 'pSuppressRules', pSuppressRules,\
    \ 'pSuppressZero', pSuppressZero, 'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource,\n\
    \          'pFactor', pFactor, 'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim,\
    \ 'pEleDelim', pEleDelim,\n          'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox',\
    \ pSandbox, 'pFile', pFile, 'pThreadMode', 1\n        );\n    \t  nThreadElCounter = 0;\n\
    \    \t  sFilter = '';\n    \t ENDIF;\n  End;\n  ## Process last elements - only when filter\
    \ is not empty (there are still elements)\n  IF( sFilter @<> '' );\n    RunProcess( cThisProcName,\
    \ 'pLogoutput', pLogoutput,\n    \t'pSrcCube', pSrcCube, 'pFilter', sFilter, 'pFilterParallel',\
    \ '', 'pTgtCube', pTgtCube, 'pMappingToNewDims', pMappingToNewDims,\n    \t'pSuppressConsol',\
    \ pSuppressConsol, 'pSuppressConsolStrings', pSuppressConsolStrings, 'pSuppressRules', pSuppressRules,\
    \ 'pSuppressZero', pSuppressZero, 'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource,\n\
    \      'pFactor', pFactor, 'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim',\
    \ pEleDelim,\n      'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox', pSandbox,\
    \ 'pFile', pFile, 'pThreadMode', 1\n    );\n  ENDIF;      \n  DataSourceType = 'NULL';\n\
    Else;\n  # Clear out target view\n  If(pZeroTarget = 1 & LONG(sTargetFilter)>= 0 & nErrors\
    \ = 0);\n      ###### Create View of target to clear out ###\n      # Create View of target\
    \ ###\n      nRet = ExecuteProcess('}bedrock.cube.view.create',\n          'pLogOutput',\
    \ pLogOutput,\n          'pStrictErrorHandling', pStrictErrorHandling,\n          'pCube',\
    \ pTgtCube,\n          'pView', sTargetView ,\n          'pFilter', sTargetFilter,\n   \
    \       'pSuppressZero', pSuppressZero,\n          'pSuppressConsol', pSuppressConsol,\n\
    \          'pSuppressRules', pSuppressRules,\n          'pSuppressConsolStrings', pSuppressConsolStrings,\
    \ \n          'pDimDelim', pDimDelim,\n          'pEleStartDelim', pEleStartDelim,\n   \
    \       'pEleDelim', pEleDelim ,\n          'pTemp', pTemp\n          );\n  \n      IF(nRet\
    \ <> 0);\n          sMessage = 'Error creating the view from the filter.';\n          nErrors\
    \ = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \         If( pStrictErrorHandling = 1 ); \n              ProcessQuit; \n          Else;\n\
    \              ProcessBreak;\n          EndIf;\n      ENDIF;\n  \n      nRet = ExecuteProcess(\
    \ '}bedrock.cube.data.clear',\n          'pLogOutput', pLogOutput,\n          'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n          'pCube', pTgtCube,\n          'pView', sTargetView,\n\
    \          'pFilter', sTargetFilter,\n          'pDimDelim', pDimDelim,\n          'pEleStartDelim',\
    \ pEleStartDelim,\n          'pEleDelim', pEleDelim,\n          'pTemp', pTemp,\n      \
    \    'pCubeLogging', pCubeLogging,\n          'pSandbox', pSandbox\n          );\n  \n \
    \     IF(nRet <> 0);\n          sMessage = 'Error clearing the target view.';\n        \
    \  nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit; \n      \
    \    Else;\n              ProcessBreak;\n          EndIf;\n      ENDIF;\n  \n  Endif;\n\
    \  \n  If( pFile = 0 );\n    ### Create View of Source ###\n    IF(pSuppressConsol = 0 &\
    \ pSuppressConsolStrings = 1);\n      pSubN=1;\n    else;\n      pSubN=0;\n    Endif;  \n\
    \    \n    nRet = ExecuteProcess('}bedrock.cube.view.create',\n      'pLogOutput', pLogOutput,\n\
    \      'pStrictErrorHandling', pStrictErrorHandling,\n      'pCube', pSrcCube,\n      'pView',\
    \ sView,\n      'pFilter', pFilter,\n      'pSuppressZero', pSuppressZero,\n      'pSuppressConsol',\
    \ pSuppressConsol,\n      'pSuppressRules', pSuppressRules,\n      'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, \n      'pDimDelim', pDimDelim,\n      'pEleStartDelim', pEleStartDelim,\n\
    \      'pEleDelim', pEleDelim ,\n      'pTemp', pTemp,\n      'pSubN', pSubN\n      );\n\
    \    \n    IF(nRet <> 0);\n          sMessage = 'Error creating the view from the filter.';\n\
    \          nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit; \n      \
    \    Else;\n              ProcessBreak;\n          EndIf;\n    ENDIF;\n  \n  ElseIf( pFile\
    \ > 0 );\n    ### Export to File in case of Copy Data Via File ###\n    IF(pSuppressConsol\
    \ = 0);\n      pSubN=1;\n    else;\n      pSubN=0;\n    Endif;  \n    \n    nRet = ExecuteProcess('}bedrock.cube.data.export',\n\
    \       'pLogoutput', pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n\
    \       'pCube', pSrcCube,\n       'pView', sView,\n       'pFilter', pFilter,\n       'pFilterParallel',\
    \ '',\n       'pParallelThreads', 0,\n       'pDimDelim', pDimDelim,\n       'pEleStartDelim',\
    \ pEleStartDelim,\n       'pEleDelim', pEleDelim,\n       'pSuppressZero', pSuppressZero,\n\
    \       'pSuppressConsol', pSuppressConsol,\n       'pSuppressRules', pSuppressRules,\n\
    \       'pSuppressConsolStrings', pSuppressConsolStrings, \n       'pZeroSource', 0,\n \
    \      'pCubeLogging', pCubeLogging,\n       'pTemp', pTemp,\n       'pFilePath', cDir,\n\
    \       'pFileName', cFileName,\n       'pDelim', cDelimiter,\n       'pDecimalSeparator',\
    \ sDecimalSeparator,\n       'pThousandSeparator', sThousandSeparator,\n       'pQuote',\
    \ cQuote,\n       'pTitleRecord', cTitleRows,\n       'pSandbox', pSandbox,\n       'pSubN',\
    \ pSubN\n      );\n    \n    IF(nRet <> 0);\n          sMessage = 'Error exporting data\
    \ to file.';\n          nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit;\
    \ \n          Else;\n              ProcessBreak;\n          EndIf;\n    ENDIF;\n  ENDIF;\n\
    \  \n  If ( pCubeLogging <= 1 );\n    sCubeLogging = CellGetS('}CubeProperties', pTgtCube,\
    \ 'LOGGING' );\n    CubeSetLogChanges( pTgtCube, pCubeLogging);\n  EndIf;\n  \n  ### Assign\
    \ Datasource ###\n  If( pFile = 0 );\n    DataSourceType          = 'VIEW';\n    DatasourceNameForServer\
    \ = pSrcCube;\n    DatasourceNameForClient = pSrcCube;\n    DatasourceCubeView      = sView;\n\
    \  ElseIf( pFile > 0 );\n    DataSourceType                  = 'CHARACTERDELIMITED';\n \
    \   DatasourceNameForServer         = cFile;\n    DatasourceNameForClient         = cFile;\n\
    \    DatasourceASCIIHeaderRecords    = cTitleRows;\n    DatasourceASCIIDelimiter       \
    \ = cDelimiter;\n    DatasourceASCIIQuoteCharacter   = cQuote;\n  EndIf;\nEndIf;\n\n###\
    \ End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n  # The exapand function gives the value of the variable passed to it\n\
    \  # So if the say the third dimension in the source cube is the first dimension in the\
    \ target cube\n  # the string variable Source Variable for Target varialbe V1 is set on\
    \ the prolog to V3 (see Mapped part)\n  # which means Expand(%V3%) gives the value of V3\n\
    \  # and Target sV1 will equal V3\nIf( pFile = 0 );  \n  sV1 =IF(nMappedDim1=1,  Expand('%'|sMappedV1|'%'),\
    \ IF(nNewDim1=1, sNewV1,V1));\n  sV2 =IF(nMappedDim2=1,  Expand('%'|sMappedV2|'%'), IF(nNewDim2=1,\
    \ sNewV2,V2));\n  sV3 =IF(nMappedDim3=1,  Expand('%'|sMappedV3|'%'), IF(nNewDim3=1, sNewV3,V3));\n\
    \  sV4 =IF(nMappedDim4=1,  Expand('%'|sMappedV4|'%'), IF(nNewDim4=1, sNewV4,V4));\n  sV5\
    \ =IF(nMappedDim5=1,  Expand('%'|sMappedV5|'%'), IF(nNewDim5=1, sNewV5,V5));\n  sV6 =IF(nMappedDim6=1,\
    \  Expand('%'|sMappedV6|'%'), IF(nNewDim6=1, sNewV6,V6));\n  sV7 =IF(nMappedDim7=1,  Expand('%'|sMappedV7|'%'),\
    \ IF(nNewDim7=1, sNewV7,V7));\n  sV8 =IF(nMappedDim8=1,  Expand('%'|sMappedV8|'%'), IF(nNewDim8=1,\
    \ sNewV8,V8));\n  sV9 =IF(nMappedDim9=1,  Expand('%'|sMappedV9|'%'), IF(nNewDim9=1, sNewV9,V9));\n\
    \  sV10=IF(nMappedDim10=1, Expand('%'|sMappedV10|'%'),IF(nNewDim10=1,sNewV10,V10));\n  sV11=IF(nMappedDim11=1,\
    \ Expand('%'|sMappedV11|'%'),IF(nNewDim11=1,sNewV11,V11));\n  sV12=IF(nMappedDim12=1, Expand('%'|sMappedV12|'%'),IF(nNewDim12=1,sNewV12,V12));\
    \  \n  sV13=IF(nMappedDim13=1, Expand('%'|sMappedV13|'%'),IF(nNewDim13=1,sNewV13,V13));\
    \  \n  sV14=IF(nMappedDim14=1, Expand('%'|sMappedV14|'%'),IF(nNewDim14=1,sNewV14,V14));\
    \   \n  sV15=IF(nMappedDim15=1, Expand('%'|sMappedV15|'%'),IF(nNewDim15=1,sNewV15,V15));\
    \  \n  sV16=IF(nMappedDim16=1, Expand('%'|sMappedV16|'%'),IF(nNewDim16=1,sNewV16,V16));\
    \  \n  sV17=IF(nMappedDim17=1, Expand('%'|sMappedV17|'%'),IF(nNewDim17=1,sNewV17,V17));\
    \  \n  sV18=IF(nMappedDim18=1, Expand('%'|sMappedV18|'%'),IF(nNewDim18=1,sNewV18,V18));\
    \  \n  sV19=IF(nMappedDim19=1, Expand('%'|sMappedV19|'%'),IF(nNewDim19=1,sNewV19,V19));\
    \  \n  sV20=IF(nMappedDim20=1, Expand('%'|sMappedV20|'%'),IF(nNewDim20=1,sNewV20,V20));\
    \  \n  sV21=IF(nMappedDim21=1, Expand('%'|sMappedV21|'%'),IF(nNewDim21=1,sNewV21,V21));\
    \  \n  sV22=IF(nMappedDim22=1, Expand('%'|sMappedV22|'%'),IF(nNewDim22=1,sNewV22,V22));\
    \  \n  sV23=IF(nMappedDim23=1, Expand('%'|sMappedV23|'%'),IF(nNewDim23=1,sNewV23,V23));\
    \  \n  sV24=IF(nMappedDim24=1, Expand('%'|sMappedV24|'%'),IF(nNewDim24=1,sNewV24,V24));\
    \  \n  sV25=IF(nMappedDim25=1, Expand('%'|sMappedV25|'%'),IF(nNewDim25=1,sNewV25,V25));\
    \  \n  sV26=IF(nMappedDim26=1, Expand('%'|sMappedV26|'%'),IF(nNewDim26=1,sNewV26,V26));\
    \  \n  sV27=IF(nMappedDim27=1, Expand('%'|sMappedV27|'%'),IF(nNewDim27=1,sNewV27,V27));\n\
    \  sV28=IF(nMappedDim28=1, Expand('%'|sMappedV28|'%'),V28);  \nElseIf( pFile > 0 );\n  sV1\
    \ =IF(nMappedDim1=1,  Expand('%'|sMappedV1|'%'), IF(nNewDim1=1, sNewV1,V2));\n  sV2 =IF(nMappedDim2=1,\
    \  Expand('%'|sMappedV2|'%'), IF(nNewDim2=1, sNewV2,V3));\n  sV3 =IF(nMappedDim3=1,  Expand('%'|sMappedV3|'%'),\
    \ IF(nNewDim3=1, sNewV3,V4));\n  sV4 =IF(nMappedDim4=1,  Expand('%'|sMappedV4|'%'), IF(nNewDim4=1,\
    \ sNewV4,V5));\n  sV5 =IF(nMappedDim5=1,  Expand('%'|sMappedV5|'%'), IF(nNewDim5=1, sNewV5,V6));\n\
    \  sV6 =IF(nMappedDim6=1,  Expand('%'|sMappedV6|'%'), IF(nNewDim6=1, sNewV6,V7));\n  sV7\
    \ =IF(nMappedDim7=1,  Expand('%'|sMappedV7|'%'), IF(nNewDim7=1, sNewV7,V8));\n  sV8 =IF(nMappedDim8=1,\
    \  Expand('%'|sMappedV8|'%'), IF(nNewDim8=1, sNewV8,V9));\n  sV9 =IF(nMappedDim9=1,  Expand('%'|sMappedV9|'%'),\
    \ IF(nNewDim9=1, sNewV9,V10));\n  sV10=IF(nMappedDim10=1, Expand('%'|sMappedV10|'%'),IF(nNewDim10=1,sNewV10,V11));\n\
    \  sV11=IF(nMappedDim11=1, Expand('%'|sMappedV11|'%'),IF(nNewDim11=1,sNewV11,V12));\n  sV12=IF(nMappedDim12=1,\
    \ Expand('%'|sMappedV12|'%'),IF(nNewDim12=1,sNewV12,V13));  \n  sV13=IF(nMappedDim13=1,\
    \ Expand('%'|sMappedV13|'%'),IF(nNewDim13=1,sNewV13,V14));  \n  sV14=IF(nMappedDim14=1,\
    \ Expand('%'|sMappedV14|'%'),IF(nNewDim14=1,sNewV14,V15));   \n  sV15=IF(nMappedDim15=1,\
    \ Expand('%'|sMappedV15|'%'),IF(nNewDim15=1,sNewV15,V16));  \n  sV16=IF(nMappedDim16=1,\
    \ Expand('%'|sMappedV16|'%'),IF(nNewDim16=1,sNewV16,V17));  \n  sV17=IF(nMappedDim17=1,\
    \ Expand('%'|sMappedV17|'%'),IF(nNewDim17=1,sNewV17,V18));  \n  sV18=IF(nMappedDim18=1,\
    \ Expand('%'|sMappedV18|'%'),IF(nNewDim18=1,sNewV18,V19));  \n  sV19=IF(nMappedDim19=1,\
    \ Expand('%'|sMappedV19|'%'),IF(nNewDim19=1,sNewV19,V20));  \n  sV20=IF(nMappedDim20=1,\
    \ Expand('%'|sMappedV20|'%'),IF(nNewDim20=1,sNewV20,V21));  \n  sV21=IF(nMappedDim21=1,\
    \ Expand('%'|sMappedV21|'%'),IF(nNewDim21=1,sNewV21,V22));  \n  sV22=IF(nMappedDim22=1,\
    \ Expand('%'|sMappedV22|'%'),IF(nNewDim22=1,sNewV22,V23));  \n  sV23=IF(nMappedDim23=1,\
    \ Expand('%'|sMappedV23|'%'),IF(nNewDim23=1,sNewV23,V24));  \n  sV24=IF(nMappedDim24=1,\
    \ Expand('%'|sMappedV24|'%'),IF(nNewDim24=1,sNewV24,V25));  \n  sV25=IF(nMappedDim25=1,\
    \ Expand('%'|sMappedV25|'%'),IF(nNewDim25=1,sNewV25,V26));  \n  sV26=IF(nMappedDim26=1,\
    \ Expand('%'|sMappedV26|'%'),IF(nNewDim26=1,sNewV26,V27));  \n  sV27=IF(nMappedDim27=1,\
    \ Expand('%'|sMappedV27|'%'),IF(nNewDim27=1,sNewV27,V28));\n  sV28=IF(nMappedDim28=1, Expand('%'|sMappedV28|'%'),V29);\n\
    EndIf;\n    \n##########################################################################################################\n\
    ### Write data from source file to target cube ###########################################################\n\
    \n  If( nDimensionCount = 2 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2 ) = 1 );\n\
    \      sElType = DType( sDim2, sV2 );\n      IF( SubSt( pTgtCube, 1, 17 ) @= '}ElementSecurity_');\n\
    \        sV3 = IF( sV3 @= '', 'NONE', sV3 );\n        ElementSecurityPut( sV3, sDim1, sV1,\
    \ sV2 );\n      ELSEIF( sElType @= 'AA' );\n        AttrPutS( sV3, sDim1, sV1, sV2, 1 );\n\
    \      ELSEIF( sElType @= 'AS' );\n        AttrPutS( sV3, sDim1, sV1, sV2 );\n      ELSEIF(\
    \ sElType @= 'AN' );\n        AttrPutN( StringToNumberEx( sV3, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor, sDim1, sV1, sV2 );\n      ElseIf( sElType @= 'S' );\n        CellPutS( sV3,\
    \ pTgtCube, sV1, sV2 );\n      Else;\n        nObal = CellGetN( pTgtCube, sV1, sV2 );\n\
    \        nCbal = nObal + StringToNumberEx( sV3, sDecimalSeparator, sThousandSeparator )\
    \ * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2 );\n      EndIf;\n    EndIf;\n\
    \  ElseIf( nDimensionCount = 3 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3 ) =\
    \ 1 );\n      sElType = DType( sDim3, sV3 );\n      If( sElType @<> 'S' );\n        nObal\
    \ = CellGetN( pTgtCube, sV1, sV2, sV3 );\n        nCbal = nObal + StringToNumberEx( sV4,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3 );\n      Else;\n        CellPutS( sV4, pTgtCube, sV1, sV2, sV3 );\n   \
    \   EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 4 );\n    If( CellIsUpdateable( pTgtCube,\
    \ sV1, sV2, sV3, sV4 ) = 1 );\n      sElType = DType( sDim4, sV4 );\n      If( sElType @<>\
    \ 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4);\n        nCbal = nObal\
    \ + StringToNumberEx( sV5, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN(\
    \ nCbal, pTgtCube, sV1, sV2, sV3, sV4);\n      Else;\n        CellPutS( sV5, pTgtCube, sV1,\
    \ sV2, sV3, sV4);\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 5 );\n    If( CellIsUpdateable(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5 ) = 1 );\n      sElType = DType( sDim5, sV5 );\n   \
    \   If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5\
    \ );\n        nCbal = nObal + StringToNumberEx( sV6, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5 );\n      Else;\n\
    \        CellPutS( sV6, pTgtCube, sV1, sV2, sV3, sV4, sV5 );\n      EndIf;\n    EndIf;\n\
    \  ElseIf( nDimensionCount = 6 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6 ) = 1 );\n      sElType = DType( sDim6, sV6 );\n      If( sElType @<> 'S' );\n\
    \        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6 );\n        nCbal = nObal\
    \ + StringToNumberEx( sV7, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN(\
    \ nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6 );\n      Else;\n        CellPutS( sV7,\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 7 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7 ) = 1 );\n\
    \      sElType = DType( sDim7, sV7 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV8, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7 );\n      Else;\n        CellPutS( sV8, pTgtCube, sV1,\
    \ sV2, sV3, sV4, sV5, sV6, sV7 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount =\
    \ 8 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 ) = 1\
    \ );\n      sElType = DType( sDim8, sV8 );\n      If( sElType @<> 'S' );\n        nObal\
    \ = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 );\n        nCbal = nObal\
    \ + StringToNumberEx( sV9, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN(\
    \ nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 );\n      Else;\n        CellPutS(\
    \ sV9, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 );\n      EndIf;\n    EndIf;\n \
    \ ElseIf( nDimensionCount = 9 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9 ) = 1 );\n      sElType = DType( sDim9, sV9 );\n      If( sElType\
    \ @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9 );\n        nCbal = nObal + StringToNumberEx( sV10, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9 );\n      Else;\n        CellPutS( sV10, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7,\
    \ sV8, sV9 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 10 );\n    If( CellIsUpdateable(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 ) = 1 );\n      sElType =\
    \ DType( sDim10, sV10 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV11, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 );\n      Else;\n        CellPutS( sV11,\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 );\n      EndIf;\n    EndIf;\n\
    \  ElseIf( nDimensionCount = 11 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11 ) = 1 );\n      sElType = DType( sDim11, sV11 );\n\
    \      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5,\
    \ sV6, sV7, sV8, sV9, sV10, sV11 );\n        nCbal = nObal + StringToNumberEx( sV12, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11 );\n      Else;\n        CellPutS( sV12, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11 );\n      EndIf;\n    EndIf;\n\
    \  ElseIf( nDimensionCount = 12 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12 ) = 1 );\n      sElType = DType( sDim12, sV12\
    \ );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV13, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12 );\n      Else;\n      \
    \  CellPutS( sV13, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 13 );\n    If( CellIsUpdateable(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13 ) = 1 );\n\
    \      sElType = DType( sDim13, sV13 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13 );\n   \
    \     nCbal = nObal + StringToNumberEx( sV14, sDecimalSeparator, sThousandSeparator ) *\
    \ nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13 );\n      Else;\n        CellPutS( sV14, pTgtCube, sV1, sV2, sV3,\
    \ sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13 );\n      EndIf;\n    EndIf;\n  ElseIf(\
    \ nDimensionCount = 14 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5,\
    \ sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14 ) = 1 );\n      sElType = DType( sDim14,\
    \ sV14 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3,\
    \ sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14 );\n        nCbal = nObal +\
    \ StringToNumberEx( sV15, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN(\
    \ nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13,\
    \ sV14 );\n      Else;\n        CellPutS( sV15, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6,\
    \ sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 15 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15 ) = 1 );\n      sElType = DType( sDim15, sV15 );\n\
    \      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5,\
    \ sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV16, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15 );\n \
    \     Else;\n        CellPutS( sV16, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 16 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15, sV16 ) = 1 );\n      sElType = DType( sDim16, sV16\
    \ );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16 );\n        nCbal =\
    \ nObal + StringToNumberEx( sV17, sDecimalSeparator, sThousandSeparator ) * nFactor;\n \
    \       CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11,\
    \ sV12, sV13, sV14, sV15, sV16 );\n      Else;\n        CellPutS( sV17, pTgtCube, sV1, sV2,\
    \ sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16 );\n     \
    \ EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 17 );\n    If( CellIsUpdateable( pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17 ) = 1 );\n      sElType = DType( sDim17, sV17 );\n      If( sElType @<> 'S' );\n\
    \        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10,\
    \ sV11, sV12, sV13, sV14, sV15, sV16, sV17 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV18, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17 );\n      Else;\n        CellPutS( sV18, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6,\
    \ sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17 );\n      EndIf;\n    EndIf;\n\
    \  ElseIf( nDimensionCount = 18 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18 ) = 1 );\n\
    \      sElType = DType( sDim18, sV18 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18 );\n        nCbal = nObal + StringToNumberEx( sV19, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18 );\n   \
    \   Else;\n        CellPutS( sV19, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18 );\n      EndIf;\n    EndIf;\n  ElseIf(\
    \ nDimensionCount = 19 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5,\
    \ sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19 ) = 1 );\n\
    \      sElType = DType( sDim19, sV19 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18, sV19 );\n        nCbal = nObal + StringToNumberEx( sV20, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19 );\n\
    \      Else;\n        CellPutS( sV20, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19 );\n      EndIf;\n   \
    \ EndIf;\n  ElseIf( nDimensionCount = 20 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2,\
    \ sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18,\
    \ sV19, sV20 ) = 1 );\n      sElType = DType( sDim20, sV20 );\n      If( sElType @<> 'S'\
    \ );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10,\
    \ sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20 );\n        nCbal = nObal +\
    \ StringToNumberEx( sV21, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN(\
    \ nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13,\
    \ sV14, sV15, sV16, sV17, sV18, sV19, sV20 );\n      Else;\n        CellPutS( sV21, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17, sV18, sV19, sV20 );\n      EndIf;\n    EndIf;  \n  ElseIf( nDimensionCount = 21\
    \ );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10,\
    \ sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21 ) = 1 );\n      sElType\
    \ = DType( sDim21, sV21 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17, sV18, sV19, sV20, sV21 );\n        nCbal = nObal + StringToNumberEx( sV22, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21 );\n      Else;\n        CellPutS( sV22, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6,\
    \ sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21\
    \ );\n      EndIf;\n    EndIf;  \n  ElseIf( nDimensionCount = 22 );\n    If( CellIsUpdateable(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18, sV19, sV20, sV21, sV22 ) = 1 );\n      sElType = DType( sDim22, sV22\
    \ );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22 );\n        nCbal = nObal + StringToNumberEx( sV23, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22 );\n\
    \      Else;\n        CellPutS( sV23, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 23 );\n    If( CellIsUpdateable(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23 ) = 1 );\n      sElType = DType( sDim23,\
    \ sV23 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3,\
    \ sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19,\
    \ sV20, sV21, sV22, sV23 );\n        nCbal = nObal + StringToNumberEx( sV24, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23 );\n      Else;\n        CellPutS( sV24, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23 );\n      EndIf;\n    EndIf; \n  ElseIf( nDimensionCount = 24 );\n  \
    \  If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11,\
    \ sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 ) = 1 );\n\
    \      sElType = DType( sDim24, sV24 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV25, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 );\n      Else;\n        CellPutS( sV25,\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 );\n      EndIf;\n    EndIf;    \
    \ \n  ElseIf( nDimensionCount = 25 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3,\
    \ sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19,\
    \ sV20, sV21, sV22, sV23, sV24, sV25 ) = 1 );\n      sElType = DType( sDim25, sV25 );\n\
    \      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5,\
    \ sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23, sV24, sV25 );\n        nCbal = nObal + StringToNumberEx( sV26, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23, sV24, sV25 );\n      Else;\n        CellPutS( sV26, pTgtCube, sV1, sV2,\
    \ sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18,\
    \ sV19, sV20, sV21, sV22, sV23, sV24, sV25 );\n      EndIf;\n    EndIf;  \n  ElseIf( nDimensionCount\
    \ = 26 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24,\
    \ sV25, sV26 ) = 1 );\n      sElType = DType( sDim26, sV26 );\n      If( sElType @<> 'S'\
    \ );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10,\
    \ sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25,\
    \ sV26 );\n        nCbal = nObal + StringToNumberEx( sV27, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23,\
    \ sV24, sV25, sV26 );\n      Else;\n        CellPutS( sV27, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23, sV24, sV25, sV26 );\n      EndIf;\n    EndIf;   \n  ElseIf( nDimensionCount\
    \ = 27 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24,\
    \ sV25, sV26, sV27 ) = 1 );\n      sElType = DType( sDim27, sV27 );\n      If( sElType @<>\
    \ 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24,\
    \ sV25, sV26, sV27 );\n        nCbal = nObal + StringToNumberEx( sV28, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23, sV24, sV25, sV26, sV27 );\n      Else;\n        CellPutS( sV28, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25, sV26, sV27 );\n      EndIf;\n  \
    \  EndIf;     \n  \n  EndIf;\n \n### End Data ###\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n## Zero Source\nIf( pZeroSource =\
    \ 1 & nErrors = 0  );\n    If ( pCubeLogging <= 1 );\n        CubeSetLogChanges( pSrcCube,\
    \ pCubeLogging);\n    EndIf;\n        ViewZeroOut( pSrcCube, sView );\n    If ( pCubeLogging\
    \ <= 1 );\n        CubeSetLogChanges( pSrcCube, IF(CellGetS('}CubeProperties', pSrcCube,\
    \ 'LOGGING' ) @= 'YES',1,0) );\n    EndIf;\nEndIf;\n\n## Switch back logging on Tgt Cube\n\
    If ( pCubeLogging <= 1 );\n    CubeSetLogChanges( pTgtCube, IF(sCubeLogging @='YES',1,0)\
    \ );\nEndIf;\n\n### Delete export file if used\nIf( pFile = 1 );\n  TM1RunCmd = 'CMD.EXE\
    \ /C 'DEL '' | cFile | '' '';\n  EXECUTECOMMAND ( TM1RunCmd , 0 );\nEndIf;\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully copied data from\
    \ %pSrcCube% cube to the %pTgtCube% cube.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('I"
- question: Develop a Turbo Integrator Process that used to copy data from a source cube to
    a different target cube. The process is mainly used in production environments, for instance,
    to populate a reporting cube or to archive data from one cube to another. Note that the
    target cube may have a different number of dimensions than the source cube. Where target
    and source cubes share dimensions, the process will match them even if their positions differ
    in the cube. For each dimension present in the target but not in the source, an input element
    must be specified using the pMappingToNewDims parameter. The process can accommodate up
    to 27 dimensions in the target cube. Values of all N-level elements in source dimensions
    that are not in the target will be accumulated. Use the pFilter parameter to filter source
    cubes based on dimensions and elements. Parallelization can be achieved through the pFilterParallel
    parameter, with elements being passed one at a time to recursive calls of the process. An
    example use case would be copying the 2011 Actual Sales data from the Sales cube to the
    General Ledger cube with specific criteria.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This is the process used to copy data from a source cube\
    \ to a different target cube.\n\n# Use case: Mainly used in production environments.\n#\
    \ 1. This process could be used to populate a Reporting cube.\n# 2. The process could be\
    \ used to archive data from one cube to another one for any use.\n\n# Note:\n# * The target\
    \ cube may have a different number of dimensions as the source cube.\n# * Where the target\
    \ and source cubes share the same dimensions, the process will match the dimensions even\
    \ if their position in the cube is different.\n# * An input element must be specified for\
    \ each dimension which is in the target but not in the source using the parameter pMappingToNewDims.\n\
    # * The format of parameter pMappingToNewDims using default delimiters & and : is DimInTargetButNotSource1:ElementOfDim\
    \ & DimInTargetButNotSource2:ElementOfDim.\n# * The input element must be an N level unless\
    \ pSuppressConsol is set to 0.\n# * The maximum number of dimensions catered for in the\
    \ target cube is 27. (In principle adding support for cubes with higher dimensionality is\
    \ not difficult). \n\n# For dimensions in the source but not the target, the process will\
    \ accumulate the values of all n level elements \n# (or all n level elements specified by\
    \ the pFilter parameter).\n# The pFilter parameter contains the dimensions and elements\
    \ to be used for filtering the source cube.\n# The format of the pFilter parameter is as\
    \ follows, using default delimiters & + : Dim1: Elem1 + Elem2 & Dim2: Elem3 + Elem4.\n#\
    \ The dimension parameters do not need to be given in the index order of dimensions in the\
    \ cube.\n# The dimension name is specified as the first member of the delimited string of\
    \ elements.\n# If consolidations are skipped the N level children of any consolidated filter\
    \ elements will be used.\n# Spaces are ignored so use them to make your filter more readable.\n\
    # If using the pFilterParallel parameter the **single dimension** used as the 'parallelization\
    \ slicer' cannot appear in\n# the pFilter parameters.\n# When using parallelization via\
    \ the *RunProcess* function the elements listed in pFilterParallel will be split one_at_a_time\n\
    # and passed to a recursive call of the process being added to pFilter.\n\n# An example:\n\
    # To copy the 2011 Actual Sales data from the Sales cube to the General Ledger cube set\
    \ pFilter to Year: 2011 & Version: Actual.\n# Say the General Ledger cube has an Account\
    \ dimension but the Sales cube doesn't and the Account for sales is 9999 (an n level element).\n\
    # Set the pMappingToNewDims parameter to Account:9999.\n# This will copy all Actual 2011\
    \ Sales to Account 9999 in the General Ledger.\n# If only sales for Company X are to be\
    \ copied, set pFilter to Year: 2011 & Version: Actual & Company:X.\n# If sales from other\
    \ companies are already in the General Ledger set pZeroTarget to 0 to add Company X's data\
    \ to the existing data.\n# Setting pZeroTarget to 1 will clear our data in the target cube\
    \ for the elements specified in the\n# pMappingToNewDims parameter and the pFilter parameter\
    \ for dimensions that are in the target.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\n\n### Constants ###\ncThisProcName       =\
    \ GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now,\
    \ '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = '%cThisProcName% : %sMessage% : %cUserName%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pSrcCube:%pSrcCube%, pFilter:%pFilter%,\
    \ pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%, pTgtCube:%pTgtCube%,\
    \ pMappingToNewDims:%pMappingToNewDims%, pSuppressConsol:%pSuppressConsol%, pSuppressConsolStrings:%pSuppressConsolStrings%,\
    \ pSuppressRules:%pSuppressRules%, pSuppressZero:%pSuppressZero%, pZeroTarget:%pZeroTarget%,\
    \ pZeroSource:%pZeroSource%, pFactor:%pFactor%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%, pTemp:%pTemp%, pCubeLogging:%pCubeLogging%, pSandbox:%pSandbox%,\
    \ pFile:%pFile%, pThreadMode:%pThreadMode%.'; \n\nsDelimDim           = TRIM(pDimDelim);\n\
    sElementStartDelim  = TRIM(pElEStartDelim);\nsDelimElem          = TRIM(pEleDelim);\nnErrors\
    \             = 0;\ncLenASCIICode       = 3;\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n# Make sure pFactor\
    \ not zero\nnFactor             = If( pFactor = 0, 1, pFactor );\n\nsView              \
    \ = cThisProcName | cTimeStamp | cRandomInt;\nsSubset             = sView;\nsTargetView\
    \         = 'Target '| sView;\nsTargetSubset       = sTargetView;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## File location\
    \ for indirect data copy\ncDir    = '.' | sOSDelim;\ncFileName = pSrcCube | cTimeStamp |\
    \ cRandomInt | '.csv';\ncFile   = cDir | cFileName;\ncTitleRows = 1;\n\n# Validate file\
    \ delimiter & quote character\nIf( pDelim @= '' );\n    pDelim = ',';\nElse;\n    # If length\
    \ of pDelim is exactly 3 chars and each of them is decimal digit, then the pDelim is entered\
    \ as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim) = cLenASCIICode );\n      nChar\
    \ = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pDelim, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pDelim, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n       \
    \ Else;\n          nValid = 0;\n          Break;\n        EndIf;\n        nChar = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber(\
    \ pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\
    cDelimiter = pDelim;\n\nIf( pQuote @= '' );\n    ## Use no quote character\nElse;\n    #\
    \ If length of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote\
    \ is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n\
    \      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar\
    \ ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n\
    \        Else;\n          nValid = 0;\n          Break;\n        EndIf;\n        nChar =\
    \ nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber(\
    \ pQuote ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\
    cQuote = pQuote;\n\n#Region ## Check Parameters ###\n\n## Default filter delimiters\nIf(\
    \ pDimDelim     @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n\
    \    pEleStartDelim= '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\n\
    EndIf;\n\nIf( pDecimalSeparator @= '' );\n \tpDecimalSeparator = '.';\nEndIf;\nIf ( LONG(pDecimalSeparator)\
    \ = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n\
    \    If( CODE( pDecimalSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pDecimalSeparator, nChar\
    \ ) <= CODE( '9', 1 ) );\n      nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n\
    \    EndIf;\n    nChar = nChar + 1;\n  End;\n  If ( nValid<>0 );\n    pDecimalSeparator\
    \ = CHAR(StringToNumber( pDecimalSeparator ));\n  Else;\n    pDecimalSeparator = SubSt(\
    \ Trim( pDecimalSeparator ), 1, 1 );\n  EndIf;\nEndIf;\nsDecimalSeparator = pDecimalSeparator;\n\
    \nIf( pThousandSeparator @= '' );\n \tpThousandSeparator = ',';\nEndIf;\nIf ( LONG(pThousandSeparator)\
    \ = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n\
    \    If( CODE( pThousandSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pThousandSeparator,\
    \ nChar ) <= CODE( '9', 1 ) );\n      nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n\
    \    EndIf;\n    nChar = nChar + 1;\n  End;\n  If ( nValid<>0 );\n    pThousandSeparator\
    \ = CHAR(StringToNumber( pThousandSeparator ));\n  Else;\n    pThousandSeparator = SubSt(\
    \ Trim( pThousandSeparator ), 1, 1 );\n  EndIf;\nEndIf;\nsThousandSeparator = pThousandSeparator;\n\
    \n# If specified source cube doesn't exist then terminate process\nIf( CubeExists(   pSrcCube\
    \   ) = 0 );\n    nErrors = nErrors + 1;\n  sMessage = Expand( 'Invalid source cube specified:\
    \ %pSrcCube%.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # If specified target cube doesn't exist then terminate process\nIf( CubeExists(   pTgtCube\
    \   ) = 0 );\n  nErrors = nErrors + 1;\n  sMessage = Expand( 'Invalid target cube specified:\
    \ %pTgtCube%.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate parallelization filter\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n\
    \    sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) -\
    \ 1 );\n    If( Scan( Lower(sDimParallel) | pEleStartDelim, Lower(pFilter) ) > 0 );\n  \
    \      sMessage = 'Parallelization dimension %sDimParallel% cannot exist in filter.';\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\nEndIf;\n\n# Validate Max Threads\nIf( pParallelThreads > 0 );\n  nMaxThreads\
    \ = pParallelThreads;\nElse;\n  nMaxThreads = 1;\nEndIf;\n\n# Validate Sandbox\nIf( TRIM(\
    \ pSandbox ) @<> '' );\n    If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty(\
    \ 0 );\n        nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is\
    \ invalid for the current user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        ServerActiveSandboxSet( pSandbox );\n        SetUseActiveSandboxProperty(\
    \ 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty( 0 );\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n#EndRegion\n#Region\
    \ \n## Set variables =0 or '' #################################################################################################\
    \ ########################\n### Placeholders for mappped dimensions\nnMappedDim1 = 0;\n\
    nMappedDim2 = 0;\nnMappedDim3 = 0;\nnMappedDim4 = 0;\nnMappedDim5 = 0;\nnMappedDim6 = 0;\n\
    nMappedDim7 = 0;\nnMappedDim8 = 0;\nnMappedDim9 = 0;\nnMappedDim10 = 0;\nnMappedDim11 =\
    \ 0;\nnMappedDim12 = 0;\nnMappedDim13 = 0;\nnMappedDim14 = 0;\nnMappedDim15 = 0;\nnMappedDim16\
    \ = 0;\nnMappedDim17 = 0;\nnMappedDim18 = 0;\nnMappedDim19 = 0;\nnMappedDim20 = 0;\nnMappedDim21\
    \ = 0;\nnMappedDim22 = 0;\nnMappedDim23 = 0;\nnMappedDim24 = 0;\nnMappedDim25 = 0;\nnMappedDim26\
    \ = 0;\nnMappedDim27 = 0;\n\nsMappedV1 = '';\nsMappedV2 = '';\nsMappedV3 = '';\nsMappedV4\
    \ = '';\nsMappedV5 = '';\nsMappedV6 = '';\nsMappedV7 = '';\nsMappedV8 = '';\nsMappedV9 =\
    \ '';\nsMappedV10 = '';\nsMappedV11 = '';\nsMappedV12 = '';\nsMappedV13 = '';\nsMappedV14\
    \ = '';\nsMappedV15 = '';\nsMappedV16 = '';\nsMappedV17 = '';\nsMappedV18 = '';\nsMappedV19\
    \ = '';\nsMappedV20 = '';\nsMappedV21 = '';\nsMappedV22 = '';\nsMappedV23 = '';\nsMappedV24\
    \ = '';\nsMappedV25 = '';\nsMappedV26 = '';\nsMappedV27 = '';\nsMappedV28 = '';\n\n### Placeholders\
    \ for new dimensions\nnNewDim1 = 0;\nnNewDim2 = 0;\nnNewDim3 = 0;\nnNewDim4 = 0;\nnNewDim5\
    \ = 0;\nnNewDim6 = 0;\nnNewDim7 = 0;\nnNewDim8 = 0;\nnNewDim9 = 0;\nnNewDim10 = 0;\nnNewDim11\
    \ = 0;\nnNewDim12 = 0;\nnNewDim13 = 0;\nnNewDim14 = 0;\nnNewDim15 = 0;\nnNewDim16 = 0;\n\
    nNewDim17 = 0;\nnNewDim18 = 0;\nnNewDim19 = 0;\nnNewDim20 = 0;\nnNewDim21 = 0;\nnNewDim22\
    \ = 0;\nnNewDim23 = 0;\nnNewDim24 = 0;\nnNewDim25 = 0;\nnNewDim26 = 0;\nnNewDim27 = 0;\n\
    \nsNewV1 = '';\nsNewV2 = '';\nsNewV3 = '';\nsNewV4 = '';\nsNewV5 = '';\nsNewV6 = '';\nsNewV7\
    \ = '';\nsNewV8 = '';\nsNewV9 = '';\nsNewV10 = '';\nsNewV11 = '';\nsNewV12 = '';\nsNewV13\
    \ = '';\nsNewV14 = '';\nsNewV15 = '';\nsNewV16 = '';\nsNewV17 = '';\nsNewV18 = '';\nsNewV19\
    \ = '';\nsNewV20 = '';\nsNewV21 = '';\nsNewV22 = '';\nsNewV23 = '';\nsNewV24 = '';\nsNewV25\
    \ = '';\nsNewV26 = '';\nsNewV27 = '';\n\n### Determine dimensions in target cube, we need\
    \ to know this to test cell type before loading ###\n# only numbers get converted from strings\
    \ to numbers\nsDim1 = TabDim( pTgtCube, 1 );\nsDim2 = TabDim( pTgtCube, 2 );\nsDim3 = TabDim(\
    \ pTgtCube, 3 );\nsDim4 = TabDim( pTgtCube, 4 );\nsDim5 = TabDim( pTgtCube, 5 );\nsDim6\
    \ = TabDim( pTgtCube, 6 );\nsDim7 = TabDim( pTgtCube, 7 );\nsDim8 = TabDim( pTgtCube, 8\
    \ );\nsDim9 = TabDim( pTgtCube, 9 );\nsDim10 = TabDim( pTgtCube, 10 );\nsDim11 = TabDim(\
    \ pTgtCube, 11 );\nsDim12 = TabDim( pTgtCube, 12 );\nsDim13 = TabDim( pTgtCube, 13 );\n\
    sDim14 = TabDim( pTgtCube, 14 );\nsDim15 = TabDim( pTgtCube, 15 );\nsDim16 = TabDim( pTgtCube,\
    \ 16 );\nsDim17 = TabDim( pTgtCube, 17 );\nsDim18 = TabDim( pTgtCube, 18 );\nsDim19 = TabDim(\
    \ pTgtCube, 19 );\nsDim20 = TabDim( pTgtCube, 20 );\nsDim21 = TabDim( pTgtCube, 21 );\n\
    sDim22 = TabDim( pTgtCube, 22 );\nsDim23 = TabDim( pTgtCube, 23 );\nsDim24 = TabDim( pTgtCube,\
    \ 24 );\nsDim25 = TabDim( pTgtCube, 25 );\nsDim26 = TabDim( pTgtCube, 26 );\nsDim27 = TabDim(\
    \ pTgtCube, 27 );\n#EndRegion\nsTgtDimString = '^^'|sDim1|'^^'|sDim2|'^^'|sDim3|'^^'|sDim4|'^^'|sDim5|'^^'|sDim6|'^^'|sDim7|'^^'|sDim8|'^^'|sDim9|'^^'|sDim10|'^^'\n\
    \                    |sDim11|'^^'|sDim12|'^^'|sDim13|'^^'|sDim14|'^^'|sDim15|'^^'|sDim16|'^^'|sDim17|'^^'|sDim18|'^^'|sDim19|'^^'|sDim20|'^^'\n\
    \                    |sDim21|'^^'|sDim22|'^^'|sDim23|'^^'|sDim24|'^^'|sDim25|'^^'|sDim26|'^^'|sDim27|'^^';\n\
    \n### We have to remove spaces from the search string before going to include the string\
    \ in searching loop\nsTgtDimString = UPPER( sTgtDimString );\nnSPIndex = SCAN( ' ', sTgtDimString\
    \ );\nWhile ( nSPIndex <> 0);\n  sTgtDimString = DELET( sTgtDimString, nSPIndex, 1 );\n\
    \  nSPIndex = SCAN( ' ', sTgtDimString );\nEnd;\n\n###########################################\n\
    #Region ### MAPPING Target DIMENSIONS #####\n###########################################\n\
    nSourceIndex = 1;\nWhile( TabDim( pSrcCube, nSourceIndex ) @<> '' );\n  sSourceDim = TabDim(\
    \ pSrcCube, nSourceIndex);\n    # reset target index if another source dimension has been\
    \ found\n    nTargetIndex = 1;\n    WHILE(TabDim( pTgtCube, nTargetIndex ) @<> '');\n  \
    \    sTargetDim = TabDim( pTgtCube, nTargetIndex );\n      If(sSourceDim @= sTargetDim);\n\
    \          If( pFile = 0 );\n            If(nTargetIndex = 1);\n              nMappedDim1\
    \ = 1;\n              sMappedV1  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex\
    \ = 2);\n              nMappedDim2 = 1;\n              sMappedV2  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 3);\n              nMappedDim3 = 1;\n              sMappedV3\
    \  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 4);\n      \
    \        nMappedDim4 = 1;\n              sMappedV4  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 5);\n              nMappedDim5 = 1;\n              sMappedV5\
    \  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 6);\n      \
    \        nMappedDim6 = 1;\n              sMappedV6  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 7);\n              nMappedDim7 = 1;\n              sMappedV7\
    \  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 8);\n      \
    \        nMappedDim8 = 1;\n              sMappedV8  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 9);\n              nMappedDim9 = 1;\n              sMappedV9\
    \  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 10);\n     \
    \         nMappedDim10 = 1;\n              sMappedV10  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 11);\n              nMappedDim11 = 1;\n             \
    \ sMappedV11  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 12);\n\
    \              nMappedDim12 = 1;\n              sMappedV12  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 13);\n              nMappedDim13 = 1;\n             \
    \ sMappedV13  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 14);\n\
    \              nMappedDim14 = 1;\n              sMappedV14  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 15);\n              nMappedDim15 = 1;\n             \
    \ sMappedV15  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 16);\n\
    \              nMappedDim16 = 1;\n              sMappedV16  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 17);\n              nMappedDim17 = 1;\n             \
    \ sMappedV17  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 18);\n\
    \              nMappedDim18 = 1;\n              sMappedV18  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 19);\n              nMappedDim19 = 1;\n             \
    \ sMappedV19  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 20);\n\
    \              nMappedDim20 = 1;\n              sMappedV20  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 21);\n              nMappedDim21 = 1;\n             \
    \ sMappedV21  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 22);\n\
    \              nMappedDim22 = 1;\n              sMappedV22  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 23);\n              nMappedDim23 = 1;\n             \
    \ sMappedV23  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 24);\n\
    \              nMappedDim24 = 1;\n              sMappedV24  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 25);\n              nMappedDim25 = 1;\n             \
    \ sMappedV25  = 'V' | NumberToString(nSourceIndex);\n            ElseIf(nTargetIndex = 26);\n\
    \              nMappedDim26 = 1;\n              sMappedV26  = 'V' | NumberToString(nSourceIndex);\n\
    \            ElseIf(nTargetIndex = 27);\n              nMappedDim27 = 1;\n             \
    \ sMappedV27  = 'V' | NumberToString(nSourceIndex);\n            EndIf;\n          ElseIf(\
    \ pFile > 0 );\n            ## If using source file first variable holds tha cube name,\
    \ so all the other ones have the index increased by 1\n            If(nTargetIndex = 1);\n\
    \              nMappedDim1 = 1;\n              sMappedV1  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 2);\n              nMappedDim2 = 1;\n       \
    \       sMappedV2  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 3);\n              nMappedDim3 = 1;\n              sMappedV3  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 4);\n              nMappedDim4 = 1;\n       \
    \       sMappedV4  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 5);\n              nMappedDim5 = 1;\n              sMappedV5  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 6);\n              nMappedDim6 = 1;\n       \
    \       sMappedV6  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 7);\n              nMappedDim7 = 1;\n              sMappedV7  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 8);\n              nMappedDim8 = 1;\n       \
    \       sMappedV8  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 9);\n              nMappedDim9 = 1;\n              sMappedV9  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 10);\n              nMappedDim10 = 1;\n     \
    \         sMappedV10  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 11);\n              nMappedDim11 = 1;\n              sMappedV11  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 12);\n              nMappedDim12 = 1;\n     \
    \         sMappedV12  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 13);\n              nMappedDim13 = 1;\n              sMappedV13  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 14);\n              nMappedDim14 = 1;\n     \
    \         sMappedV14  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 15);\n              nMappedDim15 = 1;\n              sMappedV15  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 16);\n              nMappedDim16 = 1;\n     \
    \         sMappedV16  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 17);\n              nMappedDim17 = 1;\n              sMappedV17  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 18);\n              nMappedDim18 = 1;\n     \
    \         sMappedV18  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 19);\n              nMappedDim19 = 1;\n              sMappedV19  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 20);\n              nMappedDim20 = 1;\n     \
    \         sMappedV20  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 21);\n              nMappedDim21 = 1;\n              sMappedV21  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 22);\n              nMappedDim22 = 1;\n     \
    \         sMappedV22  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 23);\n              nMappedDim23 = 1;\n              sMappedV23  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 24);\n              nMappedDim24 = 1;\n     \
    \         sMappedV24  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 25);\n              nMappedDim25 = 1;\n              sMappedV25  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            ElseIf(nTargetIndex = 26);\n              nMappedDim26 = 1;\n     \
    \         sMappedV26  = 'V' | NumberToString(nSourceIndex + 1);\n            ElseIf(nTargetIndex\
    \ = 27);\n              nMappedDim27 = 1;\n              sMappedV27  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n            EndIf;\n          EndIf;\n\n      EndIf;\n\n      nTargetIndex = nTargetIndex\
    \ + 1;\n\n    END;\n\n  nSourceIndex = nSourceIndex + 1;\n\nEND;\n\n# The last variable\
    \ in the data source holds the values\n# which need to be mapped to the last variable in\
    \ the target\n\nIf( pFile = 0 );\n  If(nTargetIndex = 1);\n    nMappedDim1 = 1;\n    sMappedV1\
    \  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex = 2);\n    nMappedDim2 =\
    \ 1;\n    sMappedV2  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex = 3);\n\
    \    nMappedDim3 = 1;\n    sMappedV3  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 4);\n    nMappedDim4 = 1;\n    sMappedV4  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 5);\n    nMappedDim5 = 1;\n    sMappedV5  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 6);\n    nMappedDim6 = 1;\n    sMappedV6  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 7);\n    nMappedDim7 = 1;\n    sMappedV7  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 8);\n    nMappedDim8 = 1;\n    sMappedV8  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 9);\n    nMappedDim9 = 1;\n    sMappedV9  = 'V' | NumberToString(nSourceIndex);\n  ElseIf(nTargetIndex\
    \ = 10);\n    nMappedDim10 = 1;\n    sMappedV10  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 11);\n    nMappedDim11 = 1;\n    sMappedV11  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 12);\n    nMappedDim12 = 1;\n    sMappedV12  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 13);\n    nMappedDim13 = 1;\n    sMappedV13  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 14);\n    nMappedDim14 = 1;\n    sMappedV14  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 15);\n    nMappedDim15 = 1;\n    sMappedV15  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 16);\n    nMappedDim16 = 1;\n    sMappedV16  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 17);\n    nMappedDim17 = 1;\n    sMappedV17  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 18);\n    nMappedDim18 = 1;\n    sMappedV18  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 19);\n    nMappedDim19 = 1;\n    sMappedV19  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 20);\n    nMappedDim20 = 1;\n    sMappedV20  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 21);\n    nMappedDim21 = 1;\n    sMappedV21  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 22);\n    nMappedDim22 = 1;\n    sMappedV22  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 23);\n    nMappedDim23 = 1;\n    sMappedV23  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 24);\n    nMappedDim24 = 1;\n    sMappedV24  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 25);\n    nMappedDim25 = 1;\n    sMappedV25  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 26);\n    nMappedDim26 = 1;\n    sMappedV26  = 'V' | NumberToString(nSourceIndex);\n\
    \  ElseIf(nTargetIndex = 27);\n    nMappedDim27 = 1;\n    sMappedV27  = 'V' | NumberToString(nSourceIndex);\n\
    \  \n  # a cube with 27 dimensions uses V28 to hold the values\n  ElseIf(nTargetIndex =\
    \ 28);\n    nMappedDim28 = 1;\n    sMapped28  = 'V' | NumberToString(nSourceIndex);\n  EndIf;\n\
    ElseIf( pFile > 0 );\n  If(nTargetIndex = 1);\n    nMappedDim1 = 1;\n    sMappedV1  = 'V'\
    \ | NumberToString(nSourceIndex + 1);\n  ElseIf(nTargetIndex = 2);\n    nMappedDim2 = 1;\n\
    \    sMappedV2  = 'V' | NumberToString(nSourceIndex + 1);\n  ElseIf(nTargetIndex = 3);\n\
    \    nMappedDim3 = 1;\n    sMappedV3  = 'V' | NumberToString(nSourceIndex + 1);\n  ElseIf(nTargetIndex\
    \ = 4);\n    nMappedDim4 = 1;\n    sMappedV4  = 'V' | NumberToString(nSourceIndex + 1);\n\
    \  ElseIf(nTargetIndex = 5);\n    nMappedDim5 = 1;\n    sMappedV5  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 6);\n    nMappedDim6 = 1;\n    sMappedV6  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 7);\n    nMappedDim7 = 1;\n    sMappedV7  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 8);\n    nMappedDim8 = 1;\n    sMappedV8  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 9);\n    nMappedDim9 = 1;\n    sMappedV9  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 10);\n    nMappedDim10 = 1;\n    sMappedV10  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 11);\n    nMappedDim11 = 1;\n    sMappedV11  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 12);\n    nMappedDim12 = 1;\n    sMappedV12  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 13);\n    nMappedDim13 = 1;\n    sMappedV13  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 14);\n    nMappedDim14 = 1;\n    sMappedV14  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 15);\n    nMappedDim15 = 1;\n    sMappedV15  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 16);\n    nMappedDim16 = 1;\n    sMappedV16  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 17);\n    nMappedDim17 = 1;\n    sMappedV17  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 18);\n    nMappedDim18 = 1;\n    sMappedV18  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 19);\n    nMappedDim19 = 1;\n    sMappedV19  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 20);\n    nMappedDim20 = 1;\n    sMappedV20  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 21);\n    nMappedDim21 = 1;\n    sMappedV21  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 22);\n    nMappedDim22 = 1;\n    sMappedV22  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 23);\n    nMappedDim23 = 1;\n    sMappedV23  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 24);\n    nMappedDim24 = 1;\n    sMappedV24  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 25);\n    nMappedDim25 = 1;\n    sMappedV25  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 26);\n    nMappedDim26 = 1;\n    sMappedV26  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  ElseIf(nTargetIndex = 27);\n    nMappedDim27 = 1;\n    sMappedV27  = 'V' | NumberToString(nSourceIndex\
    \ + 1);\n  \n  # a cube with 27 dimensions uses V29 to hold the values if export file is\
    \ used as source\n  ElseIf(nTargetIndex = 28);\n    nMappedDim28 = 1;\n    sMapped28  =\
    \ 'V' | NumberToString(nSourceIndex + 1);\n  EndIf;\nEndIf;\n#EndRegion\n\n###########################################\n\
    ### SPLIT MAPPING TO NEW DIMS PARAMETER ###\n###########################################\n\
    \n# now deduct 1 to set these indices to the number of dimensions in each cube\nnSourceDimensionCount\
    \       = nSourceIndex - 1;\nnTargetCubeDimensionCount   = nTargetIndex - 1;\n# default\
    \ dimension count is for target\nnDimensionCount = nTargetIndex - 1;\n\nsElementMapping\
    \ = TRIM( pMappingToNewDims );\nnChar = 1;\nnCharCount = LONG( sElementMapping );\n\nsTargetFilter\
    \ = '';\nsWord = '';\nsLastDelim = '';\nnIndex = 1;\n\n# Add a trailing element delimiter\
    \ so that the last element is picked up\nIf( nCharCount > 0 );\n  sElementMapping = sElementMapping\
    \ | sDelimDim;\n  nCharCount = nCharCount + LONG(sDelimDim);\nEndIf;\n\nWHILE (nChar <=\
    \ nCharCount);\n    sChar = SUBST( sElementMapping, nChar, 1);\n\n    # Used for delimiters,\
    \ required for multiple character delimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n \
    \   # Ignore spaces\n    IF (TRIM(sChar) @<> '' );\n\n      ### Dimension Name ###\n\n \
    \     # If the delimiter is more than 1 character peek ahead the same amount\n      # Ignore\
    \ the first character\n      sDelim = sChar;\n      nCount = LONG(sElementStartDelim) -\
    \ 1;\n      If( nCount > 0 & nChar + nCount <= nCharCount );\n        # Add the extra characters\n\
    \        sDelim = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\n        # Move to\
    \ the end of the delimter\n        nAddExtra = nCount;\n      EndIf;\n\n      If( sDelim\
    \ @= sElementStartDelim );\n\n        sChar = sDelim;\n\n        If( sLastDelim @<> '' &\
    \ sLastDelim @<> sDelimDim );\n            sMessage = 'In pMappingToNewDims the name of\
    \ a dimension must follow a dimension delimiter (' | sDelimDim | ')';\n            nErrors\
    \ = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \            #ProcessError();\n        EndIf;\n\n        # Found a dimension\n        sDimension\
    \ = sWord;\n\n        If( DimensionExists( sDimension ) = 0 );\n            # The dimension\
    \ does not exist in the model. Cancel process\n            sMessage = 'In pMappingToNewDims\
    \ - Dimension: ' | sDimension | ' does not exist';\n            nErrors = nErrors + 1;\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \        EndIf;\n\n        # Find the index of the dimension is in the Target cube\n   \
    \     nTargetIndexCounter = 1;\n\n        WHILE(nTargetIndexCounter <= nTargetCubeDimensionCount\
    \ );\n          sNthDimension = TabDim( pTgtCube, nTargetIndexCounter );\n\n          If(sDimension\
    \ @= sNthDimension);\n            nTargetIndex = nTargetIndexCounter;\n            nTargetIndexCounter\
    \ = 1000;\n          EndIf;\n\n          nTargetIndexCounter = nTargetIndexCounter + 1;\n\
    \        END;\n        \n        #Add to the Target filter\n        IF(sTargetFilter@='');\n\
    \          sTargetFilter=sDimension;          \n        Else;\n          sTargetFilter=sTargetFilter|sDelimDim|sDimension;\n\
    \        Endif;  \n          \n        sLastDelim = sChar;\n        # Clear the word\n \
    \       sWord = '';\n\n      Else;\n\n        # Reset extra chars\n        nAddExtra = 0;\n\
    \n        ### Check both dim delimiter and element delimiter ###\n        nIsDelimiter =\
    \ 0;\n\n        ## Check dimension delimiter first\n        # If the delimiter is more than\
    \ 1 character peek ahead the same amount\n        # Ignore the first character\n       \
    \ sDelim = sChar;\n        nCount = LONG(sDelimDim) - 1;\n        If( nCount > 0 & nChar\
    \ + nCount <= nCharCount );\n          # Add the extra characters\n          sDelim = sDelim\
    \ | SUBST( sElementMapping, nChar + 1, nCount);\n          # Move to the end of the delimter\n\
    \          nAddExtra = nCount;\n        EndIf;\n\n        If( sDelim @= sDelimDim );\n \
    \         nIsDelimiter = 1;\n          sChar = sDelim;\n        EndIf;\n\n        If ( nIsDelimiter\
    \ = 1 );\n\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim );\n            sMessage\
    \ = 'In pMappingToNewDims - an element delimiter must follow a dimension name: ' |  sChar\
    \ | ' (' | NumberToString(nChar) | ')';\n            nErrors = nErrors + 1;\n          \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \          EndIf;\n\n          # an element has been found\n          sElement = sWord;\n\
    \n          If( DIMIX( sDimension, sElement ) = 0 );\n              # The element does not\
    \ exist in the dimension. Cancel process\n              sMessage = 'In pMappingToNewDims\
    \ - Element: ' | sElement | ' in dimension ' | sDimension | ' does not exist';\n       \
    \       nErrors = nErrors + 1;\n              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n              #ProcessError();\n          EndIf;\n\n          # Allow consolidations\
    \ only if pSuppressConsol is set to 0\n\n          If ( DTYPE( sDimension, sElement) @=\
    \ 'C' );\n            sMessage = Expand( 'In pMappingToNewDims - Target element: %sElement%\
    \ for dimension %sDimension% is consolidated' );\n            nErrors = nErrors + 1;\n \
    \           LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \          Endif;  \n          \n\n          # Add the element to the source or target depending\
    \ on whether it's the first or the second element\n          # Get principal name\n    \
    \      # in case source element and this element are using different aliases\n\n       \
    \   sElement = DimensionElementPrincipalName(sDimension,sElement);\n\n          ### Update\
    \ the variable for InputElement Target Dim ######################################\n    \
    \      If(nTargetIndex = 1);\n            nNewDim1 = 1;\n            sNewV1 = sElement;\n\
    \          ElseIf(nTargetIndex = 2);\n            nNewDim2 = 1;\n            sNewV2 = sElement;\n\
    \          ElseIf(nTargetIndex = 3);\n            nNewDim3 = 1;\n            sNewV3 = sElement;\n\
    \          ElseIf(nTargetIndex = 4);\n            nNewDim4 = 1;\n            sNewV4 = sElement;\n\
    \          ElseIf(nTargetIndex = 5);\n            nNewDim5 = 1;\n            sNewV5 = sElement;\n\
    \          ElseIf(nTargetIndex = 6);\n            nNewDim6 = 1;\n            sNewV6 = sElement;\n\
    \          ElseIf(nTargetIndex = 7);\n            nNewDim7 = 1;\n            sNewV7 = sElement;\n\
    \          ElseIf(nTargetIndex = 8);\n            nNewDim8 = 1;\n            sNewV8 = sElement;\n\
    \          ElseIf(nTargetIndex = 9);\n            nNewDim9 = 1;\n            sNewV9 = sElement;\n\
    \          ElseIf(nTargetIndex = 10);\n            nNewDim10 = 1;\n            sNewV10 =\
    \ sElement;\n          ElseIf(nTargetIndex = 11);\n            nNewDim11 = 1;\n        \
    \    sNewV11 = sElement;\n          ElseIf(nTargetIndex = 12);\n            nNewDim12 =\
    \ 1;\n            sNewV12 = sElement;\n          ElseIf(nTargetIndex = 13);\n          \
    \  nNewDim13 = 1;\n            sNewV13 = sElement;\n          ElseIf(nTargetIndex = 14);\n\
    \            nNewDim14 = 1;\n            sNewV14 = sElement;\n          ElseIf(nTargetIndex\
    \ = 15);\n            nNewDim15 = 1;\n            sNewV15 = sElement;\n          ElseIf(nTargetIndex\
    \ = 16);\n            nNewDim16 = 1;\n            sNewV16 = sElement;\n          ElseIf(nTargetIndex\
    \ = 17);\n            nNewDim17 = 1;\n            sNewV17 = sElement;\n          ElseIf(nTargetIndex\
    \ = 18);\n            nNewDim18 = 1;\n            sNewV18 = sElement;\n          ElseIf(nTargetIndex\
    \ = 19);\n            nNewDim19 = 1;\n            sNewV19 = sElement;\n          ElseIf(nTargetIndex\
    \ = 20);\n            nNewDim20 = 1;\n            sNewV20 = sElement;\n          ElseIf(nTargetIndex\
    \ = 21);\n            nNewDim21 = 1;\n            sNewV21 = sElement;\n          ElseIf(nTargetIndex\
    \ = 22);\n            nNewDim22 = 1;\n            sNewV22 = sElement;\n          ElseIf(nTargetIndex\
    \ = 23);\n            nNewDim23 = 1;\n            sNewV23 = sElement;\n          ElseIf(nTargetIndex\
    \ = 24);\n            nNewDim24 = 1;\n            sNewV24 = sElement;\n          ElseIf(nTargetIndex\
    \ = 25);\n            nNewDim25 = 1;\n            sNewV25 = sElement;\n          ElseIf(nTargetIndex\
    \ = 26);\n            nNewDim26 = 1;\n            sNewV26 = sElement;\n          ElseIf(nTargetIndex\
    \ = 27);\n            nNewDim27 = 1;\n            sNewV27 = sElement;\n          EndIf;\n\
    \n          #Add to the Target filter\n          sTargetFilter=sTargetFilter|sElementStartDelim|sElement;\n\
    \          \n          # Clear the word\n          sWord = '';\n          sLastDelim = sChar;\n\
    \ \n        Else;\n          sWord = sWord | sChar;\n        EndIf;\n\n      EndIf;\n\n\
    \    EndIf;\n\n    nChar = nChar + nAddExtra + 1;\n\nEND;\n\n# Check that an input element\
    \ or variable has been specified for all dimensions in the target cube\n\nnIndexInTarget\
    \ = 1;\nWHILE(nIndexInTarget <= nTargetCubeDimensionCount);\n      \n      sMapped   = Expand('%nMappedDim'|\
    \ NumberToString(nIndexInTarget) |'%'); \n      sMapped   = Subst( sMapped , Scan( '.' ,\
    \ sMapped )-1 , 99);\n      nMapped   = StringToNumber( Trim( sMapped ) );\n      sNew \
    \     = Expand('%nNewDim'| NumberToString(nIndexInTarget) |'%'); \n      sNew      = Subst(\
    \ sNew , Scan( '.' , sNew )-1 , 99);\n      nNew      = StringToNumber( Trim( sNew ) );\n\
    \      \n      If(nMapped = 0 & nNew = 0 );\n            # there's no input element and\
    \ this dimension is not in the source\n            nErrors         = nErrors + 1;\n    \
    \        sTargetDimName  = TabDim( pTgtCube,  nIndexInTarget );\n            sMessage  \
    \      = 'Dimension ' | sTargetDimName | ' is missing an input element in pMappingToNewDims';\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            If( pStrictErrorHandling\
    \ = 1 ); \n                ProcessQuit; \n            Else;\n                ProcessBreak;\n\
    \            EndIf;\n       EndIf;\n       \n       nIndexInTarget = nIndexInTarget + 1;\n\
    END;\n\n\n############################# Clear out target ################################\n\
    \n# Target is cleared for the elements specified in pMappingToNewDims\n# and for the parts\
    \ of pFilter for dimensions in the target\n# This code works through pFilter looking for\
    \ the parts relating to the target cube\n# the code which finds individual elements has\
    \ been left in\n# so that it can be changed later to deal with consolidated elements\n\n\
    sFilter = TRIM( pFilter );\nnChar = 1;\nnCharCount = LONG( sFilter );\nsWord = '';\nsLastDelim\
    \ = '';\n\n# Add a trailing element delimiter so that the last Dimension:Element/s clause\
    \ is picked up\nIf( nCharCount > 0 );\n  sFilter = sFilter | sDelimElem;\n  nCharCount =\
    \ nCharCount + LONG(sDelimElem);\nEndIf;\n\nWHILE (nChar <= nCharCount);\n\n    sChar =\
    \ SUBST( sFilter, nChar, 1);\n\n    # Used for delimiters, required for multiple character\
    \ dilimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n    # Ignore spaces\n    IF (TRIM(sChar)\
    \ @<> '' );\n\n      ### Dimension Name ###\n\n      # If the delimiter is more than 1 character\
    \ peek ahead the same amount\n      # Ignore the first character\n      sDelim = sChar;\n\
    \      nCount = LONG(sElementStartDelim) - 1;\n      If( nCount > 0 & nChar + nCount <=\
    \ nCharCount );\n        # Add the extra characters\n        sDelim = sDelim | SUBST( sFilter,\
    \ nChar + 1, nCount);\n        # Move to the end of the delimter\n        nAddExtra = nCount;\n\
    \      EndIf;\n\n      If( sDelim @= sElementStartDelim );\n\n        sChar = sDelim;\n\n\
    \        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );\n          sMessage = 'In pFilter\
    \ - the name of a dimension must follow a dimension delimiter (' | sDelimDim | ')';\n  \
    \        nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n          #ProcessError();\n        EndIf;\n\n        # Found a dimension!\n   \
    \     sDimension = UPPER( sWord );\n        nDimInTgt=0;\n        # See if the dimension\
    \ is in the target cube\n        IF(scan('^^'|sDimension|'^^', sTgtDimString)>0);\n    \
    \      If(sTargetFilter@='');\n            sTargetFilter = sDimension;\n          Else;\
    \  \n            sTargetFilter = sTargetFilter | sDelimDim | sDimension;\n          endif;\n\
    \          nDimInTgt=1;\n        Endif;  \n\n        sLastDelim = sChar;\n        # Clear\
    \ the word\n        sWord = '';\n        #reset element count\n        nElementCount = 1;\n\
    \n      Else;\n\n        # Reset extra chars\n        nAddExtra = 0;\n\n        ### Check\
    \ both both dim delimiter and element delimiter ###\n        nIsDelimiter = 0;\n\n     \
    \   ## Check dimension delimiter first\n        # If the delimiter is more than 1 character\
    \ peek ahead the same amount\n        # Ignore the first character\n        sDelim = sChar;\n\
    \        nCount = LONG(sDelimDim) - 1;\n        If( nCount > 0 & nChar + nCount <= nCharCount\
    \ );\n          # Add the extra characters\n          sDelim = sDelim | SUBST( sFilter,\
    \ nChar + 1, nCount);\n          # Move to the end of the delimter\n          nAddExtra\
    \ = nCount;\n        EndIf;\n\n        If( sDelim @= sDelimDim );\n          nIsDelimiter\
    \ = 1;\n          sChar = sDelim;\n        Else;\n          # Reset extra chars\n      \
    \    nAddExtra = 0;\n\n          ## Check element delimiter\n\n          # If the delimiter\
    \ is more than 1 character peek ahead the same amount\n          # Ignore the first character\n\
    \          sDelim = sChar;\n          nCount = LONG(sDelimElem) - 1;\n          If( nCount\
    \ > 0 & nChar + nCount <= nCharCount );\n            # Add the extra characters\n      \
    \      sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n            # Move to the\
    \ end of the delimter\n            nAddExtra = nCount;\n          EndIf;\n\n          If(\
    \ sDelim @= sDelimElem );\n            nIsDelimiter = 1;\n            sChar = sDelim;\n\
    \          Else;\n            # Reset extra chars\n            nAddExtra = 0;\n        \
    \  EndIf;\n\n        EndIf;\n\n        If ( nIsDelimiter = 1 );\n\n          If( sLastDelim\
    \ @= '' % sLastDelim @= sDelimDim );\n            sMessage = 'In pFilter - an element delimiter\
    \ must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';\n     \
    \       nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            #ProcessError();\n          EndIf;\n\n          # Found an element\n\
    \          sElement = sWord;\n\n          IF(DIMIX(sDimension, sElement) > 0 & nDimInTgt=1);\n\
    \              # first element\n              IF(nElementCount = 1);\n                sTargetFilter\
    \ = sTargetFilter | sElementStartDelim | sElement;\n              # later elements\n   \
    \           Else;\n                sTargetFilter = sTargetFilter | sDelimElem | sElement;\n\
    \              EndIf;\n          EndIf;\n\n          nElementCount = nElementCount + 1;\n\
    \          sLastDelim = sChar;\n\n          # Clear the word\n          sWord = '';\n  \
    \      Else;\n          sWord = sWord | sChar;\n        EndIf;\n\n      EndIf;\n\n    EndIf;\n\
    \n    nChar = nChar + nAddExtra + 1;\n\nEND;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Branch depending on whether to do recursive\
    \ calls to self on independent threads or run all in this thread\nIf( Scan( pEleStartDelim,\
    \ pFilterParallel ) > 0 );\n  sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim,\
    \ pFilterParallel ) - 1 );\n  sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim,\
    \ pFilterParallel ) + 1, Long( pFilterParallel ) );\n  If( SubSt( sElementList, Long( sElementList\
    \ ), 1 ) @<> pEleDelim );\n      sElementList = sElementList | pEleDelim;\n  EndIf;\n  ##\
    \ Counting elements in element list\n  sElementListCount = sElementList;\n  nElements =\
    \ 0;\n  While( Scan( pEleDelim, sElementListCount ) > 0 );\n    nElements = nElements +\
    \ 1;\n    sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount\
    \ ) + 1, Long( sElementListCount ) );\n  End;\n  IF( Mod( nElements, nMaxThreads ) = 0 );\n\
    \    nElemsPerThread = INT( nElements / nMaxThreads );\n  ELSE;\n    nElemsPerThread = INT(\
    \ nElements / nMaxThreads ) + 1;\n  ENDIF;\n  nThreadElCounter = 0;\n  While( Scan( pEleDelim,\
    \ sElementList ) > 0 );\n      sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList\
    \ ) - 1 );\n      sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList ) +\
    \ 1, Long( sElementList ) );\n      # Do recursive process call with new RunProcess function\n\
    \      nThreadElCounter = nThreadElCounter + 1;\n      sDimDelim = If(pFilter @= '', '',\
    \ pDimDelim );\n      IF( nThreadElCounter = 1 );\n        sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \      ELSE;\n        sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n      ENDIF;\n\
    \      IF( nThreadElCounter >= nElemsPerThread );\n        RunProcess( cThisProcName, 'pLogoutput',\
    \ pLogoutput,\n        \t'pSrcCube', pSrcCube, 'pFilter', sFilter, 'pFilterParallel', '',\
    \ 'pTgtCube', pTgtCube, 'pMappingToNewDims', pMappingToNewDims,\n        \t'pSuppressConsol',\
    \ pSuppressConsol, 'pSuppressConsolStrings', pSuppressConsolStrings, 'pSuppressRules', pSuppressRules,\
    \ 'pSuppressZero', pSuppressZero, 'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource,\n\
    \          'pFactor', pFactor, 'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim,\
    \ 'pEleDelim', pEleDelim,\n          'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox',\
    \ pSandbox, 'pFile', pFile, 'pThreadMode', 1\n        );\n    \t  nThreadElCounter = 0;\n\
    \    \t  sFilter = '';\n    \t ENDIF;\n  End;\n  ## Process last elements - only when filter\
    \ is not empty (there are still elements)\n  IF( sFilter @<> '' );\n    RunProcess( cThisProcName,\
    \ 'pLogoutput', pLogoutput,\n    \t'pSrcCube', pSrcCube, 'pFilter', sFilter, 'pFilterParallel',\
    \ '', 'pTgtCube', pTgtCube, 'pMappingToNewDims', pMappingToNewDims,\n    \t'pSuppressConsol',\
    \ pSuppressConsol, 'pSuppressConsolStrings', pSuppressConsolStrings, 'pSuppressRules', pSuppressRules,\
    \ 'pSuppressZero', pSuppressZero, 'pZeroTarget', pZeroTarget, 'pZeroSource', pZeroSource,\n\
    \      'pFactor', pFactor, 'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim',\
    \ pEleDelim,\n      'pTemp', pTemp, 'pCubeLogging', pCubeLogging, 'pSandbox', pSandbox,\
    \ 'pFile', pFile, 'pThreadMode', 1\n    );\n  ENDIF;      \n  DataSourceType = 'NULL';\n\
    Else;\n  # Clear out target view\n  If(pZeroTarget = 1 & LONG(sTargetFilter)>= 0 & nErrors\
    \ = 0);\n      ###### Create View of target to clear out ###\n      # Create View of target\
    \ ###\n      nRet = ExecuteProcess('}bedrock.cube.view.create',\n          'pLogOutput',\
    \ pLogOutput,\n          'pStrictErrorHandling', pStrictErrorHandling,\n          'pCube',\
    \ pTgtCube,\n          'pView', sTargetView ,\n          'pFilter', sTargetFilter,\n   \
    \       'pSuppressZero', pSuppressZero,\n          'pSuppressConsol', pSuppressConsol,\n\
    \          'pSuppressRules', pSuppressRules,\n          'pSuppressConsolStrings', pSuppressConsolStrings,\
    \ \n          'pDimDelim', pDimDelim,\n          'pEleStartDelim', pEleStartDelim,\n   \
    \       'pEleDelim', pEleDelim ,\n          'pTemp', pTemp\n          );\n  \n      IF(nRet\
    \ <> 0);\n          sMessage = 'Error creating the view from the filter.';\n          nErrors\
    \ = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \         If( pStrictErrorHandling = 1 ); \n              ProcessQuit; \n          Else;\n\
    \              ProcessBreak;\n          EndIf;\n      ENDIF;\n  \n      nRet = ExecuteProcess(\
    \ '}bedrock.cube.data.clear',\n          'pLogOutput', pLogOutput,\n          'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n          'pCube', pTgtCube,\n          'pView', sTargetView,\n\
    \          'pFilter', sTargetFilter,\n          'pDimDelim', pDimDelim,\n          'pEleStartDelim',\
    \ pEleStartDelim,\n          'pEleDelim', pEleDelim,\n          'pTemp', pTemp,\n      \
    \    'pCubeLogging', pCubeLogging,\n          'pSandbox', pSandbox\n          );\n  \n \
    \     IF(nRet <> 0);\n          sMessage = 'Error clearing the target view.';\n        \
    \  nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit; \n      \
    \    Else;\n              ProcessBreak;\n          EndIf;\n      ENDIF;\n  \n  Endif;\n\
    \  \n  If( pFile = 0 );\n    ### Create View of Source ###\n    IF(pSuppressConsol = 0 &\
    \ pSuppressConsolStrings = 1);\n      pSubN=1;\n    else;\n      pSubN=0;\n    Endif;  \n\
    \    \n    nRet = ExecuteProcess('}bedrock.cube.view.create',\n      'pLogOutput', pLogOutput,\n\
    \      'pStrictErrorHandling', pStrictErrorHandling,\n      'pCube', pSrcCube,\n      'pView',\
    \ sView,\n      'pFilter', pFilter,\n      'pSuppressZero', pSuppressZero,\n      'pSuppressConsol',\
    \ pSuppressConsol,\n      'pSuppressRules', pSuppressRules,\n      'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, \n      'pDimDelim', pDimDelim,\n      'pEleStartDelim', pEleStartDelim,\n\
    \      'pEleDelim', pEleDelim ,\n      'pTemp', pTemp,\n      'pSubN', pSubN\n      );\n\
    \    \n    IF(nRet <> 0);\n          sMessage = 'Error creating the view from the filter.';\n\
    \          nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit; \n      \
    \    Else;\n              ProcessBreak;\n          EndIf;\n    ENDIF;\n  \n  ElseIf( pFile\
    \ > 0 );\n    ### Export to File in case of Copy Data Via File ###\n    IF(pSuppressConsol\
    \ = 0);\n      pSubN=1;\n    else;\n      pSubN=0;\n    Endif;  \n    \n    nRet = ExecuteProcess('}bedrock.cube.data.export',\n\
    \       'pLogoutput', pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n\
    \       'pCube', pSrcCube,\n       'pView', sView,\n       'pFilter', pFilter,\n       'pFilterParallel',\
    \ '',\n       'pParallelThreads', 0,\n       'pDimDelim', pDimDelim,\n       'pEleStartDelim',\
    \ pEleStartDelim,\n       'pEleDelim', pEleDelim,\n       'pSuppressZero', pSuppressZero,\n\
    \       'pSuppressConsol', pSuppressConsol,\n       'pSuppressRules', pSuppressRules,\n\
    \       'pSuppressConsolStrings', pSuppressConsolStrings, \n       'pZeroSource', 0,\n \
    \      'pCubeLogging', pCubeLogging,\n       'pTemp', pTemp,\n       'pFilePath', cDir,\n\
    \       'pFileName', cFileName,\n       'pDelim', cDelimiter,\n       'pDecimalSeparator',\
    \ sDecimalSeparator,\n       'pThousandSeparator', sThousandSeparator,\n       'pQuote',\
    \ cQuote,\n       'pTitleRecord', cTitleRows,\n       'pSandbox', pSandbox,\n       'pSubN',\
    \ pSubN\n      );\n    \n    IF(nRet <> 0);\n          sMessage = 'Error exporting data\
    \ to file.';\n          nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit;\
    \ \n          Else;\n              ProcessBreak;\n          EndIf;\n    ENDIF;\n  ENDIF;\n\
    \  \n  If ( pCubeLogging <= 1 );\n    sCubeLogging = CellGetS('}CubeProperties', pTgtCube,\
    \ 'LOGGING' );\n    CubeSetLogChanges( pTgtCube, pCubeLogging);\n  EndIf;\n  \n  ### Assign\
    \ Datasource ###\n  If( pFile = 0 );\n    DataSourceType          = 'VIEW';\n    DatasourceNameForServer\
    \ = pSrcCube;\n    DatasourceNameForClient = pSrcCube;\n    DatasourceCubeView      = sView;\n\
    \  ElseIf( pFile > 0 );\n    DataSourceType                  = 'CHARACTERDELIMITED';\n \
    \   DatasourceNameForServer         = cFile;\n    DatasourceNameForClient         = cFile;\n\
    \    DatasourceASCIIHeaderRecords    = cTitleRows;\n    DatasourceASCIIDelimiter       \
    \ = cDelimiter;\n    DatasourceASCIIQuoteCharacter   = cQuote;\n  EndIf;\nEndIf;\n\n###\
    \ End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n  # The exapand function gives the value of the variable passed to it\n\
    \  # So if the say the third dimension in the source cube is the first dimension in the\
    \ target cube\n  # the string variable Source Variable for Target varialbe V1 is set on\
    \ the prolog to V3 (see Mapped part)\n  # which means Expand(%V3%) gives the value of V3\n\
    \  # and Target sV1 will equal V3\nIf( pFile = 0 );  \n  sV1 =IF(nMappedDim1=1,  Expand('%'|sMappedV1|'%'),\
    \ IF(nNewDim1=1, sNewV1,V1));\n  sV2 =IF(nMappedDim2=1,  Expand('%'|sMappedV2|'%'), IF(nNewDim2=1,\
    \ sNewV2,V2));\n  sV3 =IF(nMappedDim3=1,  Expand('%'|sMappedV3|'%'), IF(nNewDim3=1, sNewV3,V3));\n\
    \  sV4 =IF(nMappedDim4=1,  Expand('%'|sMappedV4|'%'), IF(nNewDim4=1, sNewV4,V4));\n  sV5\
    \ =IF(nMappedDim5=1,  Expand('%'|sMappedV5|'%'), IF(nNewDim5=1, sNewV5,V5));\n  sV6 =IF(nMappedDim6=1,\
    \  Expand('%'|sMappedV6|'%'), IF(nNewDim6=1, sNewV6,V6));\n  sV7 =IF(nMappedDim7=1,  Expand('%'|sMappedV7|'%'),\
    \ IF(nNewDim7=1, sNewV7,V7));\n  sV8 =IF(nMappedDim8=1,  Expand('%'|sMappedV8|'%'), IF(nNewDim8=1,\
    \ sNewV8,V8));\n  sV9 =IF(nMappedDim9=1,  Expand('%'|sMappedV9|'%'), IF(nNewDim9=1, sNewV9,V9));\n\
    \  sV10=IF(nMappedDim10=1, Expand('%'|sMappedV10|'%'),IF(nNewDim10=1,sNewV10,V10));\n  sV11=IF(nMappedDim11=1,\
    \ Expand('%'|sMappedV11|'%'),IF(nNewDim11=1,sNewV11,V11));\n  sV12=IF(nMappedDim12=1, Expand('%'|sMappedV12|'%'),IF(nNewDim12=1,sNewV12,V12));\
    \  \n  sV13=IF(nMappedDim13=1, Expand('%'|sMappedV13|'%'),IF(nNewDim13=1,sNewV13,V13));\
    \  \n  sV14=IF(nMappedDim14=1, Expand('%'|sMappedV14|'%'),IF(nNewDim14=1,sNewV14,V14));\
    \   \n  sV15=IF(nMappedDim15=1, Expand('%'|sMappedV15|'%'),IF(nNewDim15=1,sNewV15,V15));\
    \  \n  sV16=IF(nMappedDim16=1, Expand('%'|sMappedV16|'%'),IF(nNewDim16=1,sNewV16,V16));\
    \  \n  sV17=IF(nMappedDim17=1, Expand('%'|sMappedV17|'%'),IF(nNewDim17=1,sNewV17,V17));\
    \  \n  sV18=IF(nMappedDim18=1, Expand('%'|sMappedV18|'%'),IF(nNewDim18=1,sNewV18,V18));\
    \  \n  sV19=IF(nMappedDim19=1, Expand('%'|sMappedV19|'%'),IF(nNewDim19=1,sNewV19,V19));\
    \  \n  sV20=IF(nMappedDim20=1, Expand('%'|sMappedV20|'%'),IF(nNewDim20=1,sNewV20,V20));\
    \  \n  sV21=IF(nMappedDim21=1, Expand('%'|sMappedV21|'%'),IF(nNewDim21=1,sNewV21,V21));\
    \  \n  sV22=IF(nMappedDim22=1, Expand('%'|sMappedV22|'%'),IF(nNewDim22=1,sNewV22,V22));\
    \  \n  sV23=IF(nMappedDim23=1, Expand('%'|sMappedV23|'%'),IF(nNewDim23=1,sNewV23,V23));\
    \  \n  sV24=IF(nMappedDim24=1, Expand('%'|sMappedV24|'%'),IF(nNewDim24=1,sNewV24,V24));\
    \  \n  sV25=IF(nMappedDim25=1, Expand('%'|sMappedV25|'%'),IF(nNewDim25=1,sNewV25,V25));\
    \  \n  sV26=IF(nMappedDim26=1, Expand('%'|sMappedV26|'%'),IF(nNewDim26=1,sNewV26,V26));\
    \  \n  sV27=IF(nMappedDim27=1, Expand('%'|sMappedV27|'%'),IF(nNewDim27=1,sNewV27,V27));\n\
    \  sV28=IF(nMappedDim28=1, Expand('%'|sMappedV28|'%'),V28);  \nElseIf( pFile > 0 );\n  sV1\
    \ =IF(nMappedDim1=1,  Expand('%'|sMappedV1|'%'), IF(nNewDim1=1, sNewV1,V2));\n  sV2 =IF(nMappedDim2=1,\
    \  Expand('%'|sMappedV2|'%'), IF(nNewDim2=1, sNewV2,V3));\n  sV3 =IF(nMappedDim3=1,  Expand('%'|sMappedV3|'%'),\
    \ IF(nNewDim3=1, sNewV3,V4));\n  sV4 =IF(nMappedDim4=1,  Expand('%'|sMappedV4|'%'), IF(nNewDim4=1,\
    \ sNewV4,V5));\n  sV5 =IF(nMappedDim5=1,  Expand('%'|sMappedV5|'%'), IF(nNewDim5=1, sNewV5,V6));\n\
    \  sV6 =IF(nMappedDim6=1,  Expand('%'|sMappedV6|'%'), IF(nNewDim6=1, sNewV6,V7));\n  sV7\
    \ =IF(nMappedDim7=1,  Expand('%'|sMappedV7|'%'), IF(nNewDim7=1, sNewV7,V8));\n  sV8 =IF(nMappedDim8=1,\
    \  Expand('%'|sMappedV8|'%'), IF(nNewDim8=1, sNewV8,V9));\n  sV9 =IF(nMappedDim9=1,  Expand('%'|sMappedV9|'%'),\
    \ IF(nNewDim9=1, sNewV9,V10));\n  sV10=IF(nMappedDim10=1, Expand('%'|sMappedV10|'%'),IF(nNewDim10=1,sNewV10,V11));\n\
    \  sV11=IF(nMappedDim11=1, Expand('%'|sMappedV11|'%'),IF(nNewDim11=1,sNewV11,V12));\n  sV12=IF(nMappedDim12=1,\
    \ Expand('%'|sMappedV12|'%'),IF(nNewDim12=1,sNewV12,V13));  \n  sV13=IF(nMappedDim13=1,\
    \ Expand('%'|sMappedV13|'%'),IF(nNewDim13=1,sNewV13,V14));  \n  sV14=IF(nMappedDim14=1,\
    \ Expand('%'|sMappedV14|'%'),IF(nNewDim14=1,sNewV14,V15));   \n  sV15=IF(nMappedDim15=1,\
    \ Expand('%'|sMappedV15|'%'),IF(nNewDim15=1,sNewV15,V16));  \n  sV16=IF(nMappedDim16=1,\
    \ Expand('%'|sMappedV16|'%'),IF(nNewDim16=1,sNewV16,V17));  \n  sV17=IF(nMappedDim17=1,\
    \ Expand('%'|sMappedV17|'%'),IF(nNewDim17=1,sNewV17,V18));  \n  sV18=IF(nMappedDim18=1,\
    \ Expand('%'|sMappedV18|'%'),IF(nNewDim18=1,sNewV18,V19));  \n  sV19=IF(nMappedDim19=1,\
    \ Expand('%'|sMappedV19|'%'),IF(nNewDim19=1,sNewV19,V20));  \n  sV20=IF(nMappedDim20=1,\
    \ Expand('%'|sMappedV20|'%'),IF(nNewDim20=1,sNewV20,V21));  \n  sV21=IF(nMappedDim21=1,\
    \ Expand('%'|sMappedV21|'%'),IF(nNewDim21=1,sNewV21,V22));  \n  sV22=IF(nMappedDim22=1,\
    \ Expand('%'|sMappedV22|'%'),IF(nNewDim22=1,sNewV22,V23));  \n  sV23=IF(nMappedDim23=1,\
    \ Expand('%'|sMappedV23|'%'),IF(nNewDim23=1,sNewV23,V24));  \n  sV24=IF(nMappedDim24=1,\
    \ Expand('%'|sMappedV24|'%'),IF(nNewDim24=1,sNewV24,V25));  \n  sV25=IF(nMappedDim25=1,\
    \ Expand('%'|sMappedV25|'%'),IF(nNewDim25=1,sNewV25,V26));  \n  sV26=IF(nMappedDim26=1,\
    \ Expand('%'|sMappedV26|'%'),IF(nNewDim26=1,sNewV26,V27));  \n  sV27=IF(nMappedDim27=1,\
    \ Expand('%'|sMappedV27|'%'),IF(nNewDim27=1,sNewV27,V28));\n  sV28=IF(nMappedDim28=1, Expand('%'|sMappedV28|'%'),V29);\n\
    EndIf;\n    \n##########################################################################################################\n\
    ### Write data from source file to target cube ###########################################################\n\
    \n  If( nDimensionCount = 2 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2 ) = 1 );\n\
    \      sElType = DType( sDim2, sV2 );\n      IF( SubSt( pTgtCube, 1, 17 ) @= '}ElementSecurity_');\n\
    \        sV3 = IF( sV3 @= '', 'NONE', sV3 );\n        ElementSecurityPut( sV3, sDim1, sV1,\
    \ sV2 );\n      ELSEIF( sElType @= 'AA' );\n        AttrPutS( sV3, sDim1, sV1, sV2, 1 );\n\
    \      ELSEIF( sElType @= 'AS' );\n        AttrPutS( sV3, sDim1, sV1, sV2 );\n      ELSEIF(\
    \ sElType @= 'AN' );\n        AttrPutN( StringToNumberEx( sV3, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor, sDim1, sV1, sV2 );\n      ElseIf( sElType @= 'S' );\n        CellPutS( sV3,\
    \ pTgtCube, sV1, sV2 );\n      Else;\n        nObal = CellGetN( pTgtCube, sV1, sV2 );\n\
    \        nCbal = nObal + StringToNumberEx( sV3, sDecimalSeparator, sThousandSeparator )\
    \ * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2 );\n      EndIf;\n    EndIf;\n\
    \  ElseIf( nDimensionCount = 3 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3 ) =\
    \ 1 );\n      sElType = DType( sDim3, sV3 );\n      If( sElType @<> 'S' );\n        nObal\
    \ = CellGetN( pTgtCube, sV1, sV2, sV3 );\n        nCbal = nObal + StringToNumberEx( sV4,\
    \ sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3 );\n      Else;\n        CellPutS( sV4, pTgtCube, sV1, sV2, sV3 );\n   \
    \   EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 4 );\n    If( CellIsUpdateable( pTgtCube,\
    \ sV1, sV2, sV3, sV4 ) = 1 );\n      sElType = DType( sDim4, sV4 );\n      If( sElType @<>\
    \ 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4);\n        nCbal = nObal\
    \ + StringToNumberEx( sV5, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN(\
    \ nCbal, pTgtCube, sV1, sV2, sV3, sV4);\n      Else;\n        CellPutS( sV5, pTgtCube, sV1,\
    \ sV2, sV3, sV4);\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 5 );\n    If( CellIsUpdateable(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5 ) = 1 );\n      sElType = DType( sDim5, sV5 );\n   \
    \   If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5\
    \ );\n        nCbal = nObal + StringToNumberEx( sV6, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5 );\n      Else;\n\
    \        CellPutS( sV6, pTgtCube, sV1, sV2, sV3, sV4, sV5 );\n      EndIf;\n    EndIf;\n\
    \  ElseIf( nDimensionCount = 6 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6 ) = 1 );\n      sElType = DType( sDim6, sV6 );\n      If( sElType @<> 'S' );\n\
    \        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6 );\n        nCbal = nObal\
    \ + StringToNumberEx( sV7, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN(\
    \ nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6 );\n      Else;\n        CellPutS( sV7,\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 7 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7 ) = 1 );\n\
    \      sElType = DType( sDim7, sV7 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV8, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7 );\n      Else;\n        CellPutS( sV8, pTgtCube, sV1,\
    \ sV2, sV3, sV4, sV5, sV6, sV7 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount =\
    \ 8 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 ) = 1\
    \ );\n      sElType = DType( sDim8, sV8 );\n      If( sElType @<> 'S' );\n        nObal\
    \ = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 );\n        nCbal = nObal\
    \ + StringToNumberEx( sV9, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN(\
    \ nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 );\n      Else;\n        CellPutS(\
    \ sV9, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8 );\n      EndIf;\n    EndIf;\n \
    \ ElseIf( nDimensionCount = 9 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9 ) = 1 );\n      sElType = DType( sDim9, sV9 );\n      If( sElType\
    \ @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9 );\n        nCbal = nObal + StringToNumberEx( sV10, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9 );\n      Else;\n        CellPutS( sV10, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7,\
    \ sV8, sV9 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 10 );\n    If( CellIsUpdateable(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 ) = 1 );\n      sElType =\
    \ DType( sDim10, sV10 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV11, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 );\n      Else;\n        CellPutS( sV11,\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10 );\n      EndIf;\n    EndIf;\n\
    \  ElseIf( nDimensionCount = 11 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11 ) = 1 );\n      sElType = DType( sDim11, sV11 );\n\
    \      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5,\
    \ sV6, sV7, sV8, sV9, sV10, sV11 );\n        nCbal = nObal + StringToNumberEx( sV12, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11 );\n      Else;\n        CellPutS( sV12, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11 );\n      EndIf;\n    EndIf;\n\
    \  ElseIf( nDimensionCount = 12 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12 ) = 1 );\n      sElType = DType( sDim12, sV12\
    \ );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV13, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12 );\n      Else;\n      \
    \  CellPutS( sV13, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 13 );\n    If( CellIsUpdateable(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13 ) = 1 );\n\
    \      sElType = DType( sDim13, sV13 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13 );\n   \
    \     nCbal = nObal + StringToNumberEx( sV14, sDecimalSeparator, sThousandSeparator ) *\
    \ nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13 );\n      Else;\n        CellPutS( sV14, pTgtCube, sV1, sV2, sV3,\
    \ sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13 );\n      EndIf;\n    EndIf;\n  ElseIf(\
    \ nDimensionCount = 14 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5,\
    \ sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14 ) = 1 );\n      sElType = DType( sDim14,\
    \ sV14 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3,\
    \ sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14 );\n        nCbal = nObal +\
    \ StringToNumberEx( sV15, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN(\
    \ nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13,\
    \ sV14 );\n      Else;\n        CellPutS( sV15, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6,\
    \ sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 15 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15 ) = 1 );\n      sElType = DType( sDim15, sV15 );\n\
    \      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5,\
    \ sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV16, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15 );\n \
    \     Else;\n        CellPutS( sV16, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 16 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15, sV16 ) = 1 );\n      sElType = DType( sDim16, sV16\
    \ );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16 );\n        nCbal =\
    \ nObal + StringToNumberEx( sV17, sDecimalSeparator, sThousandSeparator ) * nFactor;\n \
    \       CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11,\
    \ sV12, sV13, sV14, sV15, sV16 );\n      Else;\n        CellPutS( sV17, pTgtCube, sV1, sV2,\
    \ sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16 );\n     \
    \ EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 17 );\n    If( CellIsUpdateable( pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17 ) = 1 );\n      sElType = DType( sDim17, sV17 );\n      If( sElType @<> 'S' );\n\
    \        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10,\
    \ sV11, sV12, sV13, sV14, sV15, sV16, sV17 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV18, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17 );\n      Else;\n        CellPutS( sV18, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6,\
    \ sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17 );\n      EndIf;\n    EndIf;\n\
    \  ElseIf( nDimensionCount = 18 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18 ) = 1 );\n\
    \      sElType = DType( sDim18, sV18 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18 );\n        nCbal = nObal + StringToNumberEx( sV19, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18 );\n   \
    \   Else;\n        CellPutS( sV19, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18 );\n      EndIf;\n    EndIf;\n  ElseIf(\
    \ nDimensionCount = 19 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5,\
    \ sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19 ) = 1 );\n\
    \      sElType = DType( sDim19, sV19 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18, sV19 );\n        nCbal = nObal + StringToNumberEx( sV20, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19 );\n\
    \      Else;\n        CellPutS( sV20, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19 );\n      EndIf;\n   \
    \ EndIf;\n  ElseIf( nDimensionCount = 20 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2,\
    \ sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18,\
    \ sV19, sV20 ) = 1 );\n      sElType = DType( sDim20, sV20 );\n      If( sElType @<> 'S'\
    \ );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10,\
    \ sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20 );\n        nCbal = nObal +\
    \ StringToNumberEx( sV21, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN(\
    \ nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13,\
    \ sV14, sV15, sV16, sV17, sV18, sV19, sV20 );\n      Else;\n        CellPutS( sV21, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17, sV18, sV19, sV20 );\n      EndIf;\n    EndIf;  \n  ElseIf( nDimensionCount = 21\
    \ );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10,\
    \ sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21 ) = 1 );\n      sElType\
    \ = DType( sDim21, sV21 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17, sV18, sV19, sV20, sV21 );\n        nCbal = nObal + StringToNumberEx( sV22, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21 );\n      Else;\n        CellPutS( sV22, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6,\
    \ sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21\
    \ );\n      EndIf;\n    EndIf;  \n  ElseIf( nDimensionCount = 22 );\n    If( CellIsUpdateable(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18, sV19, sV20, sV21, sV22 ) = 1 );\n      sElType = DType( sDim22, sV22\
    \ );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22 );\n        nCbal = nObal + StringToNumberEx( sV23, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22 );\n\
    \      Else;\n        CellPutS( sV23, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 23 );\n    If( CellIsUpdateable(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23 ) = 1 );\n      sElType = DType( sDim23,\
    \ sV23 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3,\
    \ sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19,\
    \ sV20, sV21, sV22, sV23 );\n        nCbal = nObal + StringToNumberEx( sV24, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23 );\n      Else;\n        CellPutS( sV24, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23 );\n      EndIf;\n    EndIf; \n  ElseIf( nDimensionCount = 24 );\n  \
    \  If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11,\
    \ sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 ) = 1 );\n\
    \      sElType = DType( sDim24, sV24 );\n      If( sElType @<> 'S' );\n        nObal = CellGetN(\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 );\n        nCbal = nObal + StringToNumberEx(\
    \ sV25, sDecimalSeparator, sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 );\n      Else;\n        CellPutS( sV25,\
    \ pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15,\
    \ sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24 );\n      EndIf;\n    EndIf;    \
    \ \n  ElseIf( nDimensionCount = 25 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3,\
    \ sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19,\
    \ sV20, sV21, sV22, sV23, sV24, sV25 ) = 1 );\n      sElType = DType( sDim25, sV25 );\n\
    \      If( sElType @<> 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5,\
    \ sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23, sV24, sV25 );\n        nCbal = nObal + StringToNumberEx( sV26, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23, sV24, sV25 );\n      Else;\n        CellPutS( sV26, pTgtCube, sV1, sV2,\
    \ sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18,\
    \ sV19, sV20, sV21, sV22, sV23, sV24, sV25 );\n      EndIf;\n    EndIf;  \n  ElseIf( nDimensionCount\
    \ = 26 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24,\
    \ sV25, sV26 ) = 1 );\n      sElType = DType( sDim26, sV26 );\n      If( sElType @<> 'S'\
    \ );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10,\
    \ sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25,\
    \ sV26 );\n        nCbal = nObal + StringToNumberEx( sV27, sDecimalSeparator, sThousandSeparator\
    \ ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8,\
    \ sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23,\
    \ sV24, sV25, sV26 );\n      Else;\n        CellPutS( sV27, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23, sV24, sV25, sV26 );\n      EndIf;\n    EndIf;   \n  ElseIf( nDimensionCount\
    \ = 27 );\n    If( CellIsUpdateable( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24,\
    \ sV25, sV26, sV27 ) = 1 );\n      sElType = DType( sDim27, sV27 );\n      If( sElType @<>\
    \ 'S' );\n        nObal = CellGetN( pTgtCube, sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9,\
    \ sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24,\
    \ sV25, sV26, sV27 );\n        nCbal = nObal + StringToNumberEx( sV28, sDecimalSeparator,\
    \ sThousandSeparator ) * nFactor;\n        CellPutN( nCbal, pTgtCube, sV1, sV2, sV3, sV4,\
    \ sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16, sV17, sV18, sV19, sV20,\
    \ sV21, sV22, sV23, sV24, sV25, sV26, sV27 );\n      Else;\n        CellPutS( sV28, pTgtCube,\
    \ sV1, sV2, sV3, sV4, sV5, sV6, sV7, sV8, sV9, sV10, sV11, sV12, sV13, sV14, sV15, sV16,\
    \ sV17, sV18, sV19, sV20, sV21, sV22, sV23, sV24, sV25, sV26, sV27 );\n      EndIf;\n  \
    \  EndIf;     \n  \n  EndIf;\n \n### End Data ###\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n## Zero Source\nIf( pZeroSource =\
    \ 1 & nErrors = 0  );\n    If ( pCubeLogging <= 1 );\n        CubeSetLogChanges( pSrcCube,\
    \ pCubeLogging);\n    EndIf;\n        ViewZeroOut( pSrcCube, sView );\n    If ( pCubeLogging\
    \ <= 1 );\n        CubeSetLogChanges( pSrcCube, IF(CellGetS('}CubeProperties', pSrcCube,\
    \ 'LOGGING' ) @= 'YES',1,0) );\n    EndIf;\nEndIf;\n\n## Switch back logging on Tgt Cube\n\
    If ( pCubeLogging <= 1 );\n    CubeSetLogChanges( pTgtCube, IF(sCubeLogging @='YES',1,0)\
    \ );\nEndIf;\n\n### Delete export file if used\nIf( pFile = 1 );\n  TM1RunCmd = 'CMD.EXE\
    \ /C 'DEL '' | cFile | '' '';\n  EXECUTECOMMAND ( TM1RunCmd , 0 );\nEndIf;\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully copied data from\
    \ %pSrcCube% cube to the %pTgtCube% cube.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('I"
- question: 'Der vorgestellte Turbo Integrator Prozess dient dazu, Daten aus einem angegebenen
    Würfel in eine Flatfile für einen bestimmten "Ausschnitt" (beliebige Dimension/Element-Kombination)
    zu exportieren. Dieser Prozess kann sowohl für die Entwicklung/Prototypen als auch in Produktionsumgebungen
    verwendet werden. Die Hauptanwendungsfälle umfassen: den Export von Daten zur Einbindung
    in ein anderes TM1-Modell, um die Möglichkeit von Sperren zu eliminieren, sowie den Export
    von Daten zur Verarbeitung in einem ERP-System. Einige Hinweise sind zu beachten: Ein gültiger
    Würfelname (pCube) ist erforderlich, sonst wird der Prozess abgebrochen. Alle anderen Parameter
    sind optional, jedoch sollte der Filter (pFilter) angegeben werden, um die Dateigröße zu
    beschränken. Der Standard-Ausgabepfad entspricht dem des Fehlerdateipfades. Da dieser TI
    eine Ansicht als Datenquelle nutzt, sind implizite Variablen wie NValue, SValue und Value_is_String
    erforderlich. Um diesen TI im Architect zu bearbeiten, wird empfohlen, einen temporären
    Würfel mit mindestens 24 Dimensionen als Voransichtsdatenquelle zu verwenden oder die Datenquelle
    auf ASCII zu setzen und die TI-Datei manuell im Editor zu bearbeiten, um die notwendigen
    impliziten Ansichtsvariablen hinzuzufügen. Wenn der Parameter pFilterParallel verwendet
    wird, darf die Dimension, die als "Parallelisierungsschicht" dient, nicht im pFilter-Parameter
    vorkommen. Bei der Parallelisierung mittels der *RunProcess*-Funktion werden die im pFilterParallel
    aufgeführten Elemente einzeln in rekursive Aufrufe des Prozesses übergeben und zum pFilter
    hinzugefügt. Der Dateiname wird mit dem jeweiligen Elementnamen erweitert. Eine Warnung
    ist zu erteilen: Da die *RunProcess*-Funktion derzeit keine Möglichkeit hat, den Zustand
    des aufgerufenen Prozesses zu überprüfen, kann dies dazu führen, dass TM1 alle verfügbaren
    Serverressourcen nutzt, wenn mehr Prozesse als verfügbare CPU-Kerne freigegeben werden.
    Dies kann zu Leistungsproblemen führen. Achten Sie darauf, dass die Anzahl der als Slicer-Elemente
    im pFilterParallel aufgeführten Elemente die verfügbare Anzahl an Kernen nicht überschreitet.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI is designed to export data in a given cube to\
    \ a flat file for a given 'slice' (any dimension/element combination).\n#\n# Use case: Intended\
    \ for development/prototyping or in Production environment.\n# 1. Export data for import\
    \ into another TM1 model to eliminate possibility of locking.\n# 2. Export data for import\
    \ into ERP system.\n#\n# Note:\n# * Naturally, a valid cube name (pCube) is mandatory otherwise\
    \ the process will abort.\n# * All other parameters are optional, however, the filter (pFilter)\
    \ should be specified to limit the size of the file.\n# * The default output path is the\
    \ same as the error file path.\n# * As this TI has a view as a data source it requires the\
    \ implicit variables NValue, SValue and Value_is_String\n# * To edit this TI in Architect\
    \ a tmp cube with minimum 24 dims is needed as the preview data source or set the data\n\
    #   source to ASCII and manually edit the TI in notepad after saving to add back the required\
    \ implicit view variables\n# * If using the pFilterParallel parameter the **single dimension**\
    \ used as the 'parallelization slicer' cannot appear in\n#   the pFilter parameter\n# *\
    \ When using parallelization via the *RunProcess* function the elements listed in pFilterParallel\
    \ will be split one_at_a_time\n#   and passed to a recursive call of the process being added\
    \ to pFilter. Each element name will also be appended to the filename\n#\n# Warning:\n#\
    \ As the *RunProcess* function currently has no mechanism to check for the state of the\
    \ called process if more processes are\n# released than available CPU cores on the server\
    \ then this could lead to TM1 consuming all available server resources and a\n# associated\
    \ performance issue. Be careful that the number of slicer elements listed in pFilterParallel\
    \ should not exceed the\n# number of available cores.\n#EndRegion @DOC\n\n##Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    StringGlobalVariable('sBedrockViewCreateParsedFilter');\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp        = TimSt( Now,\
    \ '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pCube:%pCube%, pView:%pView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%,\
    \ pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%, pSuppressZero:%pSuppressZero%,\
    \ pSuppressConsol:%pSuppressConsol%, pSuppressRules:%pSuppressRules%, pZeroSource:%pZeroSource%,\
    \ pCubeLogging:%pCubeLogging%, pTemp:%pTemp%, pFilePath:%pFilePath%, pFileName:%pFileName%,\
    \ pDelim:%pDelim%, pQuote:%pQuote%, pTitleRecord:%pTitleRecord%, pSandbox:%pSandbox%, pSuppressConsolStrings:%pSuppressConsolStrings%.';\n\
    cDefaultView      = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\ncLenASCIICode\
    \     = 3;\n\npFieldDelim       = TRIM(pDelim);\npDimDelim         = TRIM(pDimDelim);\n\
    pEleStartDelim    = TRIM(pEleStartDelim);\npEleDelim         = TRIM(pEleDelim);\npDecimalSeparator\
    \ = TRIM(pDecimalSeparator);\npThousandSeparator= TRIM(pThousandSeparator);\nnDataCount\
    \        = 0;\nnErrors           = 0;\n\n## Default filter delimiters\nIf( pDimDelim   \
    \  @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n    pEleStartDelim=\
    \ '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\nEndIf;\nIf( pDecimalSeparator\
    \ @= '' );\n \tpDecimalSeparator = '.';\nEndIf;\nIf( pThousandSeparator @= '' );\n \tpThousandSeparator\
    \ = ',';\nEndIf;\nsDelimDim = pDimDelim;\nsElementStartDelim = pEleStartDelim;\nsDelimelem\
    \ = pEleDelim;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );\nENDIF;\n\n### Validate Parameters ###\n\n# If no cube has been\
    \ specified then terminate process\nIf( Trim( pCube ) @= '' );\n    sMessage = 'No cube\
    \ specified.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage = Expand( 'Cube: %pCube% does not\
    \ exist.' );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate the View parameter\nIf( TRIM(pView) @= '' );\n    cView =\
    \ cDefaultView ;\nElse ;\n    cView = pView ;\nEndIf;\ncSubset = cView;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate file\
    \ path\nIf(Trim( pFilePath ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\nEndIf;\n\
    If( SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\n    pFilePath = SubSt( pFilePath,\
    \ 1, Long( pFilePath ) -1 );\nEndIf;\nIf(  FileExists( pFilePath ) = 0 );\n    sMessage\
    \ = Expand('Invalid export directory: %pFilePath%');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npFilePath = pFilePath | sOSDelim;\n\
    \n# Validate file name\nIf( pFileName @= '' );\n    sBaseFileName = Expand('%pCube%_Export');\n\
    \    sExt = '.csv';\n    pFileName = sBaseFileName | '.csv';\nElse;\n    # determine file\
    \ extension. If no file extension entered then use .csv as default\n    If( Scan( '.', pFileName\
    \ ) = 0 );\n        sExt = '.csv';\n        sBaseFileName = pFileName;\n    Else;\n    \
    \    sExt = SubSt( pFileName, Scan( '.', pFileName ), Long( pFileName ) );\n        sBaseFileName\
    \ = SubSt( pFileName, 1, Scan( '.', pFileName ) - 1 );\n    EndIf;\n    pFileName = sBaseFileName\
    \ | sExt;\nEndIf;\ncExportFile = pFilePath | pFileName;\n\n# Validate parallelization filter\n\
    If( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n    sDimParallel = SubSt( pFilterParallel,\
    \ 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n    If( Scan( Lower(sDimParallel) |\
    \ pEleStartDelim, Lower(pFilter) ) > 0 );\n        sMessage = 'Parallelization dimension\
    \ %sDimParallel% cannot exist in filter.';\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n# Validate Max Threads\n\
    If( pParallelThreads > 0 );\n  nMaxThreads = pParallelThreads;\nElse;\n  nMaxThreads = 1;\n\
    EndIf;\n\n# Validate file delimiter & quote character\nIf( pFieldDelim @= '' );\n    pFieldDelim\
    \ = ',';\nElse;\n    # If length of pFieldDelim is exactly 3 chars and each of them is decimal\
    \ digit, then the pFieldDelim is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pFieldDelim)\
    \ = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n      \
    \  If( CODE( pFieldDelim, nChar ) >= CODE( '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE(\
    \ '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n          Break;\n\
    \        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0\
    \ );\n      pFieldDelim=CHAR(StringToNumber( pFieldDelim ));\n    Else;\n      pFieldDelim\
    \ = SubSt( Trim( pFieldDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\nIf( pQuote @= '' );\n   \
    \ ## Use no quote character\nElse;\n    # If length of pQuote is exactly 3 chars and each\
    \ of them is decimal digit, then the pQuote is entered as ASCII code\n    nValid = 0;\n\
    \    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode\
    \ );\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE(\
    \ '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n          Break;\n\
    \        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0\
    \ );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote = SubSt( Trim(\
    \ pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\nIf ( LONG(pDecimalSeparator) = cLenASCIICode\
    \ );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n    If( CODE( pDecimalSeparator,\
    \ nChar ) >= CODE( '0', 1 ) & CODE( pDecimalSeparator, nChar ) <= CODE( '9', 1 ) );\n  \
    \    nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n    EndIf;\n    nChar = nChar\
    \ + 1;\n  End;\n  If ( nValid<>0 );\n    pDecimalSeparator = CHAR(StringToNumber( pDecimalSeparator\
    \ ));\n  Else;\n    pDecimalSeparator = SubSt( Trim( pDecimalSeparator ), 1, 1 );\n  EndIf;\n\
    EndIf;\nsDecimalSeparator = pDecimalSeparator;\n\nIf ( LONG(pThousandSeparator) = cLenASCIICode\
    \ );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n    If( CODE( pThousandSeparator,\
    \ nChar ) >= CODE( '0', 1 ) & CODE( pThousandSeparator, nChar ) <= CODE( '9', 1 ) );\n \
    \     nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n    EndIf;\n    nChar = nChar\
    \ + 1;\n  End;\n  If ( nValid<>0 );\n    pThousandSeparator = CHAR(StringToNumber( pThousandSeparator\
    \ ));\n  Else;\n    pThousandSeparator = SubSt( Trim( pThousandSeparator ), 1, 1 );\n  EndIf;\n\
    EndIf;\nsThousandSeparator = pThousandSeparator;\n\n# Validate Sandbox\nIf( TRIM( pSandbox\
    \ ) @<> '' );\n    If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty(\
    \ 0 );\n        nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is\
    \ invalid for the current user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        ServerActiveSandboxSet( pSandbox );\n        SetUseActiveSandboxProperty(\
    \ 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty( 0 );\nEndIf;\n\n# Validate Character\
    \ Set\nIf(Trim( pCharacterSet ) @= '' );\n  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n# Jump\
    \ to Epilog if any errors so far\nIF ( nErrors > 0 );\n    DataSourceType = 'NULL';\n  \
    \  If( pStrictErrorHandling = 1 );\n        ProcessQuit;\n    Else;\n        ProcessBreak;\n\
    \    EndIf;\nENDIF;\n\n# Branch depending on whether to do recursive calls to self on independent\
    \ threads or run all in this thread\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n\
    \  sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1\
    \ );\n  sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) +\
    \ 1, Long( pFilterParallel ) );\n  If( SubSt( sElementList, Long( sElementList ), 1 ) @<>\
    \ pEleDelim );\n      sElementList = sElementList | pEleDelim;\n  EndIf;\n  ## Counting\
    \ elements in element list\n  sElementListCount = sElementList;\n  nElements = 0;\n  While(\
    \ Scan( pEleDelim, sElementListCount ) > 0 );\n    nElements = nElements + 1;\n    sElementListCount\
    \ = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount ) + 1, Long( sElementListCount\
    \ ) );\n  End;\n  IF( Mod( nElements, nMaxThreads ) = 0 );\n    nElemsPerThread = INT( nElements\
    \ \\ nMaxThreads );\n  ELSE;\n    nElemsPerThread = INT( nElements \\ nMaxThreads ) + 1;\n\
    \  ENDIF;\n  nThreadElCounter = 0;\n  While( Scan( pEleDelim, sElementList ) > 0 );\n  \
    \    sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\n     \
    \ sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList ) + 1, Long( sElementList\
    \ ) );\n      # Do recursive process call with new RunProcess function\n      nThreadElCounter\
    \ = nThreadElCounter + 1;\n      sDimDelim = If(pFilter @= '', '', pDimDelim );\n      IF(\
    \ nThreadElCounter = 1 );\n        sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \        sFileName = Expand('%sBaseFileName%_%sDimParallel%_%sSlicerEle%');\n      ELSE;\n\
    \        sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n        sFileName = Expand('%sFileName%+%sSlicerEle%');\n\
    \      ENDIF;\n      IF( nThreadElCounter >= nElemsPerThread );\n        sFileName = Expand('%sFileName%%sExt%');\n\
    \        RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n        \t'pCube', pCube,\
    \ 'pView', '',\n        \t'pFilter', sFilter, 'pFilterParallel', '',\n        \t'pDimDelim',\
    \ pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n        \t'pSuppressZero',\
    \ pSuppressZero, 'pSuppressConsol', pSuppressConsol, 'pSuppressRules', pSuppressRules,\n\
    \        \t'pZeroSource', pZeroSource, 'pCubeLogging', pCubeLogging,\n        \t'pTemp',\
    \ pTemp, 'pFilePath', pFilePath, 'pFileName', sFileName,\n        \t'pDelim', pFieldDelim,\
    \ 'pDecimalSeparator', pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n  \
    \        'pQuote', pQuote, 'pTitleRecord', pTitleRecord, 'pSandbox', pSandbox, 'pSuppressConsolStrings',\
    \ pSuppressConsolStrings\n        );\n    \t  nThreadElCounter = 0;\n    \t  sFilter = '';\n\
    \    \t  sFileName = '';\n    \t ENDIF;\n  End;\n  ## Process last elements - only when\
    \ filter is not empty (there are still elements)\n  IF( sFilter @<> '' );\n    sFileName\
    \ = Expand('%sFileName%%sExt%');\n    RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n\
    \    \t'pCube', pCube, 'pView', '',\n    \t'pFilter', sFilter, 'pFilterParallel', '',\n\
    \    \t'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n\
    \    \t'pSuppressZero', pSuppressZero, 'pSuppressConsol', pSuppressConsol, 'pSuppressRules',\
    \ pSuppressRules,\n    \t'pZeroSource', pZeroSource, 'pCubeLogging', pCubeLogging,\n   \
    \ \t'pTemp', pTemp, 'pFilePath', pFilePath, 'pFileName', sFileName,\n    \t'pDelim', pFieldDelim,\
    \ 'pDecimalSeparator', pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n  \
    \    'pQuote', pQuote, 'pTitleRecord', pTitleRecord, 'pSandbox', pSandbox, 'pSuppressConsolStrings',\
    \ pSuppressConsolStrings\n    );\n  ENDIF;\n  DataSourceType = 'NULL';\n  nParallelRun =\
    \ 1;\nElse;\n  # No parallelization is being used. Proceed as normal and do everything internally\n\
    \n  # Determine number of dims in source cube & create strings to expand on title and rows\n\
    \  nCount = 1;\n  nDimensionIndex = 0;\n\n  ## Skip cube name from export\n  IF (pCubeNameExport\
    \ = 0);\n    sTitle = '';\n    sRow = '';\n\n    While( TabDim( pCube, nCount ) @<> '' );\n\
    \        sDimension = TabDim( pCube, nCount );\n\n        ## Determine title string for\
    \ the source cube\n        sTitle = sTitle|'%pQuote%'|sDimension|'%pQuote%%pFieldDelim%';\n\
    \        # Determine row string for the source cube\n        sRow = sRow|'%pQuote%%V'| numbertostring(nCount)\
    \ |'%%pQuote%%pFieldDelim%';\n\n        nCount = nCount + 1;\n    End;\n    nDimensionCount\
    \ = nCount - 1;\n\n    # Finish off the strings\n    sTitle = sTitle|'%pQuote%Value%pQuote%';\n\
    \    sRow = sRow|'%pQuote%%sValue%%pQuote%';\n\n  ELSE;\n    sTitle = '%pQuote%Cube%pQuote%';\n\
    \    sRow = '%pQuote%%pCube%%pQuote%';\n\n    While( TabDim( pCube, nCount ) @<> '' );\n\
    \        sDimension = TabDim( pCube, nCount );\n\n        ## Determine title string for\
    \ the source cube\n        sTitle = sTitle|'%pFieldDelim%%pQuote%'|sDimension|'%pQuote%';\n\
    \        # Determine row string for the source cube\n        sRow = sRow|'%pFieldDelim%%pQuote%%V'|\
    \ numbertostring(nCount) |'%%pQuote%';\n\n        nCount = nCount + 1;\n    End;\n    nDimensionCount\
    \ = nCount - 1;\n\n    # Finish off the strings\n    sTitle = sTitle|'%pFieldDelim%%pQuote%Value%pQuote%';\n\
    \    sRow = sRow|'%pFieldDelim%%pQuote%%sValue%%pQuote%';\n  ENDIF;\n\n  # Create Processing\
    \ View for source version\n  nRet = ExecuteProcess('}bedrock.cube.view.create',\n      \
    \    'pLogOutput', pLogOutput,\n          'pStrictErrorHandling', pStrictErrorHandling,\n\
    \          'pCube', pCube,\n          'pView', cView,\n          'pFilter', pFilter,\n \
    \         'pSuppressZero', pSuppressZero,\n          'pSuppressConsol', pSuppressConsol,\n\
    \          'pSuppressRules', pSuppressRules,\n          'pSuppressConsolStrings', pSuppressConsolStrings,\n\
    \          'pDimDelim', pDimDelim,\n          'pEleStartDelim', pEleStartDelim,\n      \
    \    'pEleDelim', pEleDelim,\n          'pTemp', pTemp,\n          'pSubN', pSubN\n    \
    \      );\n\n    # Validate Sandbox\n    If( TRIM( pSandbox ) @<> '' );\n      If( ServerSandboxExists(\
    \ pSandbox ) = 0 );\n          SetUseActiveSandboxProperty( 0 );\n          nErrors = nErrors\
    \ + 1;\n          sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\n\
    \          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      Else;\n     \
    \     ServerActiveSandboxSet( pSandbox );\n          SetUseActiveSandboxProperty( 1 );\n\
    \      EndIf;\n    Else;\n      SetUseActiveSandboxProperty( 0 );\n    EndIf;\n\n\n  IF(\
    \ nRet <> ProcessExitNormal() );\n      sMessage = 'Error creating the view from the filter.';\n\
    \      nErrors = nErrors + 1;\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n      If( pStrictErrorHandling = 1 );\n          ProcessQuit;\n      Else;\n   \
    \       ProcessBreak;\n      EndIf;\n  ENDIF;\n\n  sParsedFilter = sBedrockViewCreateParsedFilter;\n\
    \  sFilterRow = '%pQuote%%pCube%%pQuote%%pFieldDelim%%pQuote%Filter%pQuote%%pFieldDelim%%pQuote%%sParsedFilter%%pQuote%%pFieldDelim%%pQuote%%pDimDelim%%pQuote%%pFieldDelim%%pQuote%%pEleStartDelim%%pQuote%%pFieldDelim%%pQuote%%pEleDelim%%pQuote%';\n\
    \n  # Assign Datasource\n  DataSourceType          = 'VIEW';\n  DatasourceNameForServer\
    \ = pCube;\n  DatasourceNameForClient = pCube;\n  DatasourceCubeView      = cView;\n  DatasourceAsciiDelimiter=\
    \ pFieldDelim;\n  DatasourceAsciiQuoteCharacter = '';\n  nParallelRun = 0;\nEndIf;\n\n###\
    \ End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n# Set the output character set\nSetOutputCharacterSet( cExportFile,\
    \ pCharacterSet );\n\n### Data Count ###\nnDataCount = nDataCount + 1;\n\n# Output the title\
    \ string\nIF( nDataCount = 1 & pTitleRecord >= 1 );\n    TextOutput( cExportFile, Expand(sTitle)\
    \ );\nEndif;\n\n### Export filter into the 1st record of the file, it will be used from\
    \ import process to zero out the corresponding slice, if specified\nIF( nDataCount = 1 &\
    \ pTitleRecord = 2 );\n    TextOutput( cExportFile, Expand(sFilterRow) );\nEndif;\n\n###\
    \ Export data from source version to file ###\nIf( value_is_string = 0 );\n    sValue =\
    \ NumberToStringEx( nValue, '#,0.#############', sDecimalSeparator, sThousandSeparator );\n\
    EndIf;\n\n# Selects the correct TextOutput formula depending upon the number of dimensions\
    \ in the cube\nIF(SCAN( CHAR( 10 ), sValue ) > 0 );\n    sValueCleaned = '';\n    nNoChar\
    \ = 1;\n    nLimit = LONG( sValue );\n    WHILE( nNoChar <= nLimit ) ;\n        sChar =\
    \ SUBST(  sValue, nNoChar, 1 );\n        IF( CODE( sChar, 1 ) <> 10 );\n            sValueCleaned\
    \ = sValueCleaned | sChar ;\n        ELSE;\n            sValueCleaned = sValueCleaned |\
    \ ' ';\n        ENDIF;\n        nNoChar = nNoChar + 1;\n    END;\n    sValue = sValueCleaned;\n\
    ENDIF;\n\n# Output data\nTextOutput( cExportFile, Expand(sRow) );\n\n### End Data ###\n\
    #Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Delete source data ###\nIf( pZeroSource = 1 & nErrors = 0 & nParallelRun = 0 );\n\
    \    If ( pCubeLogging <= 1 );\n      sCubeLogging = CellGetS('}CubeProperties', pCube,\
    \ 'LOGGING' );\n      CubeSetLogChanges( pCube, pCubeLogging);\n    EndIf;\n    ViewZeroOut(\
    \ pCube, cView );\n    If ( pCubeLogging <= 1 );\n      CubeSetLogChanges( pCube, IF(sCubeLogging@='YES',1,0)\
    \ );\n    EndIf;\nEndIf;\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 );\n        ProcessQuit;\n    EndIf;\nElse;\n    sDataCount\
    \ = NUMBERTOSTRING (nDataCount);\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ exported %sDataCount% records from %pCube% based on filter %pFilter%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\n    EndIf;\n\
    \nEndIf ;\n\n### End Epilog ###"
- question: 'The described Turbo Integrator process is designed to export data from a specified
    cube to a flat file for a given "slice" (any dimension/element combination). This process
    can be used both in development/prototyping and production environments. The main use cases
    include: exporting data for import into another TM1 model to eliminate the possibility of
    locking, and exporting data for import into an ERP system. Some notes to keep in mind: A
    valid cube name (pCube) is mandatory, otherwise the process will abort. All other parameters
    are optional, but the filter (pFilter) should be specified to limit the file size. The default
    output path is the same as the error file path. As this TI uses a view as a data source,
    it requires implicit variables such as NValue, SValue, and Value_is_String. To edit this
    TI in Architect, it is recommended to use a temporary cube with a minimum of 24 dimensions
    as the preview data source or set the data source to ASCII and manually edit the TI file
    in a text editor to add back the necessary implicit view variables. If using the pFilterParallel
    parameter, the single dimension used as the "parallelization slicer" cannot appear in the
    pFilter parameter. When using parallelization via the *RunProcess* function, elements listed
    in pFilterParallel will be split one at a time and passed to a recursive call of the process
    being added to pFilter. The filename will be appended with each element name. A warning
    to issue: As the *RunProcess* function currently has no mechanism to check the state of
    the called process, it can lead to TM1 consuming all available server resources if more
    processes are released than available CPU cores, potentially causing performance issues.
    Ensure the number of slicer elements listed in pFilterParallel does not exceed the number
    of available cores.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI is designed to export data in a given cube to\
    \ a flat file for a given 'slice' (any dimension/element combination).\n#\n# Use case: Intended\
    \ for development/prototyping or in Production environment.\n# 1. Export data for import\
    \ into another TM1 model to eliminate possibility of locking.\n# 2. Export data for import\
    \ into ERP system.\n#\n# Note:\n# * Naturally, a valid cube name (pCube) is mandatory otherwise\
    \ the process will abort.\n# * All other parameters are optional, however, the filter (pFilter)\
    \ should be specified to limit the size of the file.\n# * The default output path is the\
    \ same as the error file path.\n# * As this TI has a view as a data source it requires the\
    \ implicit variables NValue, SValue and Value_is_String\n# * To edit this TI in Architect\
    \ a tmp cube with minimum 24 dims is needed as the preview data source or set the data\n\
    #   source to ASCII and manually edit the TI in notepad after saving to add back the required\
    \ implicit view variables\n# * If using the pFilterParallel parameter the **single dimension**\
    \ used as the 'parallelization slicer' cannot appear in\n#   the pFilter parameter\n# *\
    \ When using parallelization via the *RunProcess* function the elements listed in pFilterParallel\
    \ will be split one_at_a_time\n#   and passed to a recursive call of the process being added\
    \ to pFilter. Each element name will also be appended to the filename\n#\n# Warning:\n#\
    \ As the *RunProcess* function currently has no mechanism to check for the state of the\
    \ called process if more processes are\n# released than available CPU cores on the server\
    \ then this could lead to TM1 consuming all available server resources and a\n# associated\
    \ performance issue. Be careful that the number of slicer elements listed in pFilterParallel\
    \ should not exceed the\n# number of available cores.\n#EndRegion @DOC\n\n##Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    StringGlobalVariable('sBedrockViewCreateParsedFilter');\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp        = TimSt( Now,\
    \ '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pCube:%pCube%, pView:%pView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%,\
    \ pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%, pSuppressZero:%pSuppressZero%,\
    \ pSuppressConsol:%pSuppressConsol%, pSuppressRules:%pSuppressRules%, pZeroSource:%pZeroSource%,\
    \ pCubeLogging:%pCubeLogging%, pTemp:%pTemp%, pFilePath:%pFilePath%, pFileName:%pFileName%,\
    \ pDelim:%pDelim%, pQuote:%pQuote%, pTitleRecord:%pTitleRecord%, pSandbox:%pSandbox%, pSuppressConsolStrings:%pSuppressConsolStrings%.';\n\
    cDefaultView      = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\ncLenASCIICode\
    \     = 3;\n\npFieldDelim       = TRIM(pDelim);\npDimDelim         = TRIM(pDimDelim);\n\
    pEleStartDelim    = TRIM(pEleStartDelim);\npEleDelim         = TRIM(pEleDelim);\npDecimalSeparator\
    \ = TRIM(pDecimalSeparator);\npThousandSeparator= TRIM(pThousandSeparator);\nnDataCount\
    \        = 0;\nnErrors           = 0;\n\n## Default filter delimiters\nIf( pDimDelim   \
    \  @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n    pEleStartDelim=\
    \ '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\nEndIf;\nIf( pDecimalSeparator\
    \ @= '' );\n \tpDecimalSeparator = '.';\nEndIf;\nIf( pThousandSeparator @= '' );\n \tpThousandSeparator\
    \ = ',';\nEndIf;\nsDelimDim = pDimDelim;\nsElementStartDelim = pEleStartDelim;\nsDelimelem\
    \ = pEleDelim;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );\nENDIF;\n\n### Validate Parameters ###\n\n# If no cube has been\
    \ specified then terminate process\nIf( Trim( pCube ) @= '' );\n    sMessage = 'No cube\
    \ specified.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage = Expand( 'Cube: %pCube% does not\
    \ exist.' );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate the View parameter\nIf( TRIM(pView) @= '' );\n    cView =\
    \ cDefaultView ;\nElse ;\n    cView = pView ;\nEndIf;\ncSubset = cView;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate file\
    \ path\nIf(Trim( pFilePath ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\nEndIf;\n\
    If( SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\n    pFilePath = SubSt( pFilePath,\
    \ 1, Long( pFilePath ) -1 );\nEndIf;\nIf(  FileExists( pFilePath ) = 0 );\n    sMessage\
    \ = Expand('Invalid export directory: %pFilePath%');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npFilePath = pFilePath | sOSDelim;\n\
    \n# Validate file name\nIf( pFileName @= '' );\n    sBaseFileName = Expand('%pCube%_Export');\n\
    \    sExt = '.csv';\n    pFileName = sBaseFileName | '.csv';\nElse;\n    # determine file\
    \ extension. If no file extension entered then use .csv as default\n    If( Scan( '.', pFileName\
    \ ) = 0 );\n        sExt = '.csv';\n        sBaseFileName = pFileName;\n    Else;\n    \
    \    sExt = SubSt( pFileName, Scan( '.', pFileName ), Long( pFileName ) );\n        sBaseFileName\
    \ = SubSt( pFileName, 1, Scan( '.', pFileName ) - 1 );\n    EndIf;\n    pFileName = sBaseFileName\
    \ | sExt;\nEndIf;\ncExportFile = pFilePath | pFileName;\n\n# Validate parallelization filter\n\
    If( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n    sDimParallel = SubSt( pFilterParallel,\
    \ 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n    If( Scan( Lower(sDimParallel) |\
    \ pEleStartDelim, Lower(pFilter) ) > 0 );\n        sMessage = 'Parallelization dimension\
    \ %sDimParallel% cannot exist in filter.';\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n# Validate Max Threads\n\
    If( pParallelThreads > 0 );\n  nMaxThreads = pParallelThreads;\nElse;\n  nMaxThreads = 1;\n\
    EndIf;\n\n# Validate file delimiter & quote character\nIf( pFieldDelim @= '' );\n    pFieldDelim\
    \ = ',';\nElse;\n    # If length of pFieldDelim is exactly 3 chars and each of them is decimal\
    \ digit, then the pFieldDelim is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pFieldDelim)\
    \ = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n      \
    \  If( CODE( pFieldDelim, nChar ) >= CODE( '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE(\
    \ '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n          Break;\n\
    \        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0\
    \ );\n      pFieldDelim=CHAR(StringToNumber( pFieldDelim ));\n    Else;\n      pFieldDelim\
    \ = SubSt( Trim( pFieldDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\nIf( pQuote @= '' );\n   \
    \ ## Use no quote character\nElse;\n    # If length of pQuote is exactly 3 chars and each\
    \ of them is decimal digit, then the pQuote is entered as ASCII code\n    nValid = 0;\n\
    \    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode\
    \ );\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE(\
    \ '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n          Break;\n\
    \        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0\
    \ );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote = SubSt( Trim(\
    \ pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\nIf ( LONG(pDecimalSeparator) = cLenASCIICode\
    \ );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n    If( CODE( pDecimalSeparator,\
    \ nChar ) >= CODE( '0', 1 ) & CODE( pDecimalSeparator, nChar ) <= CODE( '9', 1 ) );\n  \
    \    nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n    EndIf;\n    nChar = nChar\
    \ + 1;\n  End;\n  If ( nValid<>0 );\n    pDecimalSeparator = CHAR(StringToNumber( pDecimalSeparator\
    \ ));\n  Else;\n    pDecimalSeparator = SubSt( Trim( pDecimalSeparator ), 1, 1 );\n  EndIf;\n\
    EndIf;\nsDecimalSeparator = pDecimalSeparator;\n\nIf ( LONG(pThousandSeparator) = cLenASCIICode\
    \ );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n    If( CODE( pThousandSeparator,\
    \ nChar ) >= CODE( '0', 1 ) & CODE( pThousandSeparator, nChar ) <= CODE( '9', 1 ) );\n \
    \     nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n    EndIf;\n    nChar = nChar\
    \ + 1;\n  End;\n  If ( nValid<>0 );\n    pThousandSeparator = CHAR(StringToNumber( pThousandSeparator\
    \ ));\n  Else;\n    pThousandSeparator = SubSt( Trim( pThousandSeparator ), 1, 1 );\n  EndIf;\n\
    EndIf;\nsThousandSeparator = pThousandSeparator;\n\n# Validate Sandbox\nIf( TRIM( pSandbox\
    \ ) @<> '' );\n    If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty(\
    \ 0 );\n        nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is\
    \ invalid for the current user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        ServerActiveSandboxSet( pSandbox );\n        SetUseActiveSandboxProperty(\
    \ 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty( 0 );\nEndIf;\n\n# Validate Character\
    \ Set\nIf(Trim( pCharacterSet ) @= '' );\n  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n# Jump\
    \ to Epilog if any errors so far\nIF ( nErrors > 0 );\n    DataSourceType = 'NULL';\n  \
    \  If( pStrictErrorHandling = 1 );\n        ProcessQuit;\n    Else;\n        ProcessBreak;\n\
    \    EndIf;\nENDIF;\n\n# Branch depending on whether to do recursive calls to self on independent\
    \ threads or run all in this thread\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n\
    \  sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1\
    \ );\n  sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) +\
    \ 1, Long( pFilterParallel ) );\n  If( SubSt( sElementList, Long( sElementList ), 1 ) @<>\
    \ pEleDelim );\n      sElementList = sElementList | pEleDelim;\n  EndIf;\n  ## Counting\
    \ elements in element list\n  sElementListCount = sElementList;\n  nElements = 0;\n  While(\
    \ Scan( pEleDelim, sElementListCount ) > 0 );\n    nElements = nElements + 1;\n    sElementListCount\
    \ = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount ) + 1, Long( sElementListCount\
    \ ) );\n  End;\n  IF( Mod( nElements, nMaxThreads ) = 0 );\n    nElemsPerThread = INT( nElements\
    \ \\ nMaxThreads );\n  ELSE;\n    nElemsPerThread = INT( nElements \\ nMaxThreads ) + 1;\n\
    \  ENDIF;\n  nThreadElCounter = 0;\n  While( Scan( pEleDelim, sElementList ) > 0 );\n  \
    \    sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\n     \
    \ sElementList = SubSt( sElementList, Scan( pEleDelim, sElementList ) + 1, Long( sElementList\
    \ ) );\n      # Do recursive process call with new RunProcess function\n      nThreadElCounter\
    \ = nThreadElCounter + 1;\n      sDimDelim = If(pFilter @= '', '', pDimDelim );\n      IF(\
    \ nThreadElCounter = 1 );\n        sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \        sFileName = Expand('%sBaseFileName%_%sDimParallel%_%sSlicerEle%');\n      ELSE;\n\
    \        sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n        sFileName = Expand('%sFileName%+%sSlicerEle%');\n\
    \      ENDIF;\n      IF( nThreadElCounter >= nElemsPerThread );\n        sFileName = Expand('%sFileName%%sExt%');\n\
    \        RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n        \t'pCube', pCube,\
    \ 'pView', '',\n        \t'pFilter', sFilter, 'pFilterParallel', '',\n        \t'pDimDelim',\
    \ pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n        \t'pSuppressZero',\
    \ pSuppressZero, 'pSuppressConsol', pSuppressConsol, 'pSuppressRules', pSuppressRules,\n\
    \        \t'pZeroSource', pZeroSource, 'pCubeLogging', pCubeLogging,\n        \t'pTemp',\
    \ pTemp, 'pFilePath', pFilePath, 'pFileName', sFileName,\n        \t'pDelim', pFieldDelim,\
    \ 'pDecimalSeparator', pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n  \
    \        'pQuote', pQuote, 'pTitleRecord', pTitleRecord, 'pSandbox', pSandbox, 'pSuppressConsolStrings',\
    \ pSuppressConsolStrings\n        );\n    \t  nThreadElCounter = 0;\n    \t  sFilter = '';\n\
    \    \t  sFileName = '';\n    \t ENDIF;\n  End;\n  ## Process last elements - only when\
    \ filter is not empty (there are still elements)\n  IF( sFilter @<> '' );\n    sFileName\
    \ = Expand('%sFileName%%sExt%');\n    RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n\
    \    \t'pCube', pCube, 'pView', '',\n    \t'pFilter', sFilter, 'pFilterParallel', '',\n\
    \    \t'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n\
    \    \t'pSuppressZero', pSuppressZero, 'pSuppressConsol', pSuppressConsol, 'pSuppressRules',\
    \ pSuppressRules,\n    \t'pZeroSource', pZeroSource, 'pCubeLogging', pCubeLogging,\n   \
    \ \t'pTemp', pTemp, 'pFilePath', pFilePath, 'pFileName', sFileName,\n    \t'pDelim', pFieldDelim,\
    \ 'pDecimalSeparator', pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n  \
    \    'pQuote', pQuote, 'pTitleRecord', pTitleRecord, 'pSandbox', pSandbox, 'pSuppressConsolStrings',\
    \ pSuppressConsolStrings\n    );\n  ENDIF;\n  DataSourceType = 'NULL';\n  nParallelRun =\
    \ 1;\nElse;\n  # No parallelization is being used. Proceed as normal and do everything internally\n\
    \n  # Determine number of dims in source cube & create strings to expand on title and rows\n\
    \  nCount = 1;\n  nDimensionIndex = 0;\n\n  ## Skip cube name from export\n  IF (pCubeNameExport\
    \ = 0);\n    sTitle = '';\n    sRow = '';\n\n    While( TabDim( pCube, nCount ) @<> '' );\n\
    \        sDimension = TabDim( pCube, nCount );\n\n        ## Determine title string for\
    \ the source cube\n        sTitle = sTitle|'%pQuote%'|sDimension|'%pQuote%%pFieldDelim%';\n\
    \        # Determine row string for the source cube\n        sRow = sRow|'%pQuote%%V'| numbertostring(nCount)\
    \ |'%%pQuote%%pFieldDelim%';\n\n        nCount = nCount + 1;\n    End;\n    nDimensionCount\
    \ = nCount - 1;\n\n    # Finish off the strings\n    sTitle = sTitle|'%pQuote%Value%pQuote%';\n\
    \    sRow = sRow|'%pQuote%%sValue%%pQuote%';\n\n  ELSE;\n    sTitle = '%pQuote%Cube%pQuote%';\n\
    \    sRow = '%pQuote%%pCube%%pQuote%';\n\n    While( TabDim( pCube, nCount ) @<> '' );\n\
    \        sDimension = TabDim( pCube, nCount );\n\n        ## Determine title string for\
    \ the source cube\n        sTitle = sTitle|'%pFieldDelim%%pQuote%'|sDimension|'%pQuote%';\n\
    \        # Determine row string for the source cube\n        sRow = sRow|'%pFieldDelim%%pQuote%%V'|\
    \ numbertostring(nCount) |'%%pQuote%';\n\n        nCount = nCount + 1;\n    End;\n    nDimensionCount\
    \ = nCount - 1;\n\n    # Finish off the strings\n    sTitle = sTitle|'%pFieldDelim%%pQuote%Value%pQuote%';\n\
    \    sRow = sRow|'%pFieldDelim%%pQuote%%sValue%%pQuote%';\n  ENDIF;\n\n  # Create Processing\
    \ View for source version\n  nRet = ExecuteProcess('}bedrock.cube.view.create',\n      \
    \    'pLogOutput', pLogOutput,\n          'pStrictErrorHandling', pStrictErrorHandling,\n\
    \          'pCube', pCube,\n          'pView', cView,\n          'pFilter', pFilter,\n \
    \         'pSuppressZero', pSuppressZero,\n          'pSuppressConsol', pSuppressConsol,\n\
    \          'pSuppressRules', pSuppressRules,\n          'pSuppressConsolStrings', pSuppressConsolStrings,\n\
    \          'pDimDelim', pDimDelim,\n          'pEleStartDelim', pEleStartDelim,\n      \
    \    'pEleDelim', pEleDelim,\n          'pTemp', pTemp,\n          'pSubN', pSubN\n    \
    \      );\n\n    # Validate Sandbox\n    If( TRIM( pSandbox ) @<> '' );\n      If( ServerSandboxExists(\
    \ pSandbox ) = 0 );\n          SetUseActiveSandboxProperty( 0 );\n          nErrors = nErrors\
    \ + 1;\n          sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\n\
    \          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      Else;\n     \
    \     ServerActiveSandboxSet( pSandbox );\n          SetUseActiveSandboxProperty( 1 );\n\
    \      EndIf;\n    Else;\n      SetUseActiveSandboxProperty( 0 );\n    EndIf;\n\n\n  IF(\
    \ nRet <> ProcessExitNormal() );\n      sMessage = 'Error creating the view from the filter.';\n\
    \      nErrors = nErrors + 1;\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n      If( pStrictErrorHandling = 1 );\n          ProcessQuit;\n      Else;\n   \
    \       ProcessBreak;\n      EndIf;\n  ENDIF;\n\n  sParsedFilter = sBedrockViewCreateParsedFilter;\n\
    \  sFilterRow = '%pQuote%%pCube%%pQuote%%pFieldDelim%%pQuote%Filter%pQuote%%pFieldDelim%%pQuote%%sParsedFilter%%pQuote%%pFieldDelim%%pQuote%%pDimDelim%%pQuote%%pFieldDelim%%pQuote%%pEleStartDelim%%pQuote%%pFieldDelim%%pQuote%%pEleDelim%%pQuote%';\n\
    \n  # Assign Datasource\n  DataSourceType          = 'VIEW';\n  DatasourceNameForServer\
    \ = pCube;\n  DatasourceNameForClient = pCube;\n  DatasourceCubeView      = cView;\n  DatasourceAsciiDelimiter=\
    \ pFieldDelim;\n  DatasourceAsciiQuoteCharacter = '';\n  nParallelRun = 0;\nEndIf;\n\n###\
    \ End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n# Set the output character set\nSetOutputCharacterSet( cExportFile,\
    \ pCharacterSet );\n\n### Data Count ###\nnDataCount = nDataCount + 1;\n\n# Output the title\
    \ string\nIF( nDataCount = 1 & pTitleRecord >= 1 );\n    TextOutput( cExportFile, Expand(sTitle)\
    \ );\nEndif;\n\n### Export filter into the 1st record of the file, it will be used from\
    \ import process to zero out the corresponding slice, if specified\nIF( nDataCount = 1 &\
    \ pTitleRecord = 2 );\n    TextOutput( cExportFile, Expand(sFilterRow) );\nEndif;\n\n###\
    \ Export data from source version to file ###\nIf( value_is_string = 0 );\n    sValue =\
    \ NumberToStringEx( nValue, '#,0.#############', sDecimalSeparator, sThousandSeparator );\n\
    EndIf;\n\n# Selects the correct TextOutput formula depending upon the number of dimensions\
    \ in the cube\nIF(SCAN( CHAR( 10 ), sValue ) > 0 );\n    sValueCleaned = '';\n    nNoChar\
    \ = 1;\n    nLimit = LONG( sValue );\n    WHILE( nNoChar <= nLimit ) ;\n        sChar =\
    \ SUBST(  sValue, nNoChar, 1 );\n        IF( CODE( sChar, 1 ) <> 10 );\n            sValueCleaned\
    \ = sValueCleaned | sChar ;\n        ELSE;\n            sValueCleaned = sValueCleaned |\
    \ ' ';\n        ENDIF;\n        nNoChar = nNoChar + 1;\n    END;\n    sValue = sValueCleaned;\n\
    ENDIF;\n\n# Output data\nTextOutput( cExportFile, Expand(sRow) );\n\n### End Data ###\n\
    #Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Delete source data ###\nIf( pZeroSource = 1 & nErrors = 0 & nParallelRun = 0 );\n\
    \    If ( pCubeLogging <= 1 );\n      sCubeLogging = CellGetS('}CubeProperties', pCube,\
    \ 'LOGGING' );\n      CubeSetLogChanges( pCube, pCubeLogging);\n    EndIf;\n    ViewZeroOut(\
    \ pCube, cView );\n    If ( pCubeLogging <= 1 );\n      CubeSetLogChanges( pCube, IF(sCubeLogging@='YES',1,0)\
    \ );\n    EndIf;\nEndIf;\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 );\n        ProcessQuit;\n    EndIf;\nElse;\n    sDataCount\
    \ = NUMBERTOSTRING (nDataCount);\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ exported %sDataCount% records from %pCube% based on filter %pFilter%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\n    EndIf;\n\
    \nEndIf ;\n\n### End Epilog ###"
- question: 'Dieser Turbo Integrator Prozess lädt eine CSV-Datei in den Ziel-Cube. Einsatzbereiche
    sind die Entwicklung, das Prototyping oder die Produktion. Der Prozess importiert Daten
    aus einem anderen TM1 Modell und um Sperren zu vermeiden, kann es sinnvoller sein, die Daten
    zu exportieren und dann in einen anderen Cube zu importieren, anstatt direkt zu kopieren.
    Hinweis: Ein gültiger Ziel-Cube-Name (pCube) ist obligatorisch, andernfalls wird der Prozess
    abgebrochen. Eine Elementzuordnung für neue Dimensionen (pMappingToNewDims) ist ebenfalls
    erforderlich, wenn der Ziel-Cube mehr Dimensionen als die Quelle hat, ansonsten wird der
    Prozess abgebrochen. Der Standard-Eingabepfad entspricht dem Fehlerdateipfad, wenn nichts
    anderes angegeben ist. Wenn der Dateiname leer ist, sucht der Prozess nach einer Datei namens
    pCube_Export.csv. Das erwartete Dateiformat entspricht dem Standard-CMA-Export: v1 gibt
    den Cubenamen an, nachfolgende Felder spezifizieren die Cube-Adresse (einzelne Elementnamen).
    vN gibt den Zellendatenwert an, der geladen werden soll, mit der Möglichkeit für Dateien
    mit Kopfzeilen. Format der Filterzeile für Zero out: v1 gibt den Quellen-Cubenamen an, v2
    muss ''Filter'' sein, v3 gibt den Filter an, der zum Nullen verwendet wird. Bitte beachten
    Sie, wenn der Ziel-Cube zusätzliche Dimensionen hat, wird dies der endgültige Filter, der
    verwendet wird, wenn pMappingToNewDims nicht angegeben ist. Alle Elemente in zusätzlichen
    Dimensionen werden gelöscht. v4 gibt das Dimensions-Trennzeichen im Filter an. v5 gibt das
    Element-Start-Trennzeichen im Filter an. v6 gibt das Element-Trennzeichen im Filter an.
    Hinweis zum Nullen: Wenn der Parameter pMappingToNewDims angegeben ist, wird er dem Filter
    in der Datei hinzugefügt, um den zu löschenden Cube-Ausschnitt zu begrenzen. Wenn pDim angegeben
    ist, wird das Quell-Element mit dem Ziel-Element ersetzt, sollte es in der Filterzeichenfolge
    enthalten sein. In beiden Fällen müssen die Trennzeichen in der Quelldatei mit denen übereinstimmen,
    die als Parameter dieses Prozesses übergeben werden.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will load a csv text file to the target cube.\n\
    \n# Use case: Intended for development/prototyping or in Production environment.\n#1/ Import\
    \ data from another TM1 model.\n#2/ To eliminate possibility of locking it is sometimes\
    \ better to export and import when needing to copy data from one cube to another.\n\n# Note:\n\
    # Naturally, a valid target cube name (pCube) is mandatory otherwise the process will abort.\n\
    # Element mapping for new dimensions (pMappingToNewDims ) is also required when the target\
    \ cube has more dimensions than the source, otherwise the process will abort.\n# The default\
    \ input path is the same as the error file path if not specified.\n# If the file name is\
    \ left blank, the process will look for a file called pCube_Export.csv.\n\n# Format:\n#\
    \ The assumed file format is as per standard CMA export:\n# - v1 specIfies cube name, subsequent\
    \ fields specify cube address ( individual element names ).\n# - vN specIfies cell data\
    \ value to load. With provision for files with header rows.\n# Format of filter row for\
    \ Zero out:\n# - v1 specifies source cube name\n# - v2 must be equal to 'Filter'.\n# - v3\
    \ specifies the filter to be used to zero out. Please note if target cube has additional\
    \ dimensions this is the final filter used if pMappingToNewDims is not speficied. All the\
    \ elements in additional dimensions will be cleaned \n# - v4 specifies the dimension delimiter\
    \ used in filter\n# - v5 specifies the element start delimiter used in filter\n# - v6 specifies\
    \ the element delimiter used in filter\n# Note about the Zero out:\n# if pMappingToNewDims\
    \ parameter is specified, it will be concatenated to the filter in the file to restict the\
    \ cube slice to be zeroed out. Similarly, if pDim is specified the source element is substituted\
    \ with the targed one, sould it be in the filter string\n# in both cases the delimiters\
    \ in the source file must match the delimiters passed in parameters of this process.\n#EndRegion\
    \ @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pSrcDir:%pSrcDir%, pSrcFile:%pSrcFile%, pCube:%pCube%, pDim:%pDim%,\
    \ pSrcEle:%pSrcEle%, pTgtEle:%pTgtEle%, pTitleRows:%pTitleRows%, pDelim:%pDelim%, pQuote:%pQuote%,\
    \ pCumulate:%pCumulate%, pCubeLogging:%pCubeLogging%, pSandbox:%pSandbox%, pZeroFilter:%pZeroFilter%,\
    \ pMappingToNewDims:%pMappingToNewDims%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%.';   \ncMinLenASCIICode = 2;\ncMaxLenASCIICode = 3;\n\npDelimiter\
    \        = TRIM(pDelim);\nsDelimDim           = TRIM(pDimDelim);\nsElementStartDelim  =\
    \ TRIM(pElEStartDelim);\nsDelimElem          = TRIM(pEleDelim);\npDecimalSeparator   = TRIM(pDecimalSeparator);\n\
    pThousandSeparator  = TRIM(pThousandSeparator);\n\n## LogOutput parameters\nIf( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnRecordProcessedCount\
    \   = 0;\nnRecordPostedCount      = 0;\nnErrors                 = 0;\n\n\n### Validate Parameters\
    \ ###\npSourceDir    = TRIM(pSrcDir);\npSourceFile   = TRIM(pSrcFile);\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate source\
    \ directory\nIf(Trim( pSourceDir ) @= '' );\n    pSourceDir = GetProcessErrorFileDirectory;\n\
    EndIf;\n\nIf( SubSt( pSourceDir, Long( pSourceDir ), 1 ) @= sOSDelim );\n  pSourceDir =\
    \ SubSt( pSourceDir, 1, Long( pSourceDir ) - 1 );\nEndIf;\n\nIf( FileExists( pSourceDir\
    \ ) = 0 );\n  sMessage = 'Invalid source directory specified: folder does not exist.';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\nIf( pSourceFile @= '' );\n    pSourceFile = Expand('%pCube%_Export.csv');\nEndIf;\n\
    \nsFile = pSourceDir | sOSDelim | pSourceFile;\n# Validate source file\nIf( FileExists(\
    \ sFile ) = 0 );\n  sMessage = 'Invalid source file specified: file does not exist in directory:'\
    \ | sFile;\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Automatic file deletion\nIf( pFileDelete <> 1 );\n    pFileDelete =\
    \ 0;\nEndIf;\n\n# Skip invalid records\nIf( pSkipInvalidRecords <> 1 );\n    pSkipInvalidRecords\
    \ = 0;\nEndIf;\n\n## Validate cube\nIf( Trim( pCube ) @= '' );\n  sMessage = 'No target\
    \ cube specified.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n  sMessage = 'Invalid target cube specified:\
    \ ' | pCube;\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate file delimiter & quote character\nIf( pDelimiter @= '' );\n\
    \    pDelimiter = ',';\nElse;\n    # If length of pDelimiter is between 2 and 3 chars and\
    \ each of them is decimal digit, then the pDelimiter is entered as ASCII code\n    If (\
    \ LONG(pDelimiter) <= cMaxLenASCIICode & LONG(pDelimiter) >= cMinLenASCIICode  );\n    \
    \  nValid = 1;\n      nChar = 1;\n      While ( nChar <= LONG(pDelimiter) );\n        If(\
    \ CODE( pDelimiter, nChar ) < CODE( '0', 1 ) % CODE( pDelimiter, nChar ) > CODE( '9', 1\
    \ ) );\n          nValid = 0;\n          Break;\n        EndIf;\n        nChar = nChar +\
    \ 1;\n      End;\n      If ( nValid<>0 );\n        pDelimiter=CHAR(StringToNumber( pDelimiter\
    \ ));\n      EndIf;\n    EndIf;\nEndIf;\n\nIf( pQuote @= '' );\n    ## Use no quote character\
    \ \nElse;\n    # If length of pQuote is between 2 and 3 chars and each of them is decimal\
    \ digit, then the pQuote is entered as ASCII code\n    If ( LONG(pQuote) <= cMaxLenASCIICode\
    \ & LONG(pQuote) >= cMinLenASCIICode);\n      nValid = 1;\n      nChar = 1;\n      While\
    \ ( nChar <= LONG(pQuote) );\n        If( CODE( pQuote, nChar ) < CODE( '0', 1 ) % CODE(\
    \ pQuote, nChar ) > CODE( '9', 1 ) );\n          nValid = 0;\n          Break;\n       \
    \ EndIf;\n        nChar = nChar + 1;\n      End;\n      If ( nValid<>0 );\n        pQuote=CHAR(StringToNumber(\
    \ pQuote ));\n      EndIf;\n    EndIf;\nEndIf;\n\nIf ( LONG(pDecimalSeparator) <= cMaxLenASCIICode\
    \ & LONG(pDecimalSeparator) >= cMinLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While\
    \ ( nChar <= LONG(pDecimalSeparator) );\n    If( CODE( pDecimalSeparator, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pDecimalSeparator, nChar ) <= CODE( '9', 1 ) );\n      nValid = 1;\n\
    \    Else;\n      nValid = 0;\n      Break;\n    EndIf;\n    nChar = nChar + 1;\n  End;\n\
    \  If ( nValid<>0 );\n    pDecimalSeparator = CHAR(StringToNumber( pDecimalSeparator ));\n\
    \  Else;\n    pDecimalSeparator = SubSt( Trim( pDecimalSeparator ), 1, 1 );\n  EndIf;\n\
    EndIf;\nsDecimalSeparator = pDecimalSeparator;\n\nIf ( LONG(pThousandSeparator) <= cMaxLenASCIICode\
    \ & LONG(pThousandSeparator) >= cMinLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While\
    \ ( nChar <= LONG(pThousandSeparator) );\n    If( CODE( pThousandSeparator, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pThousandSeparator, nChar ) <= CODE( '9', 1 ) );\n      nValid = 1;\n\
    \    Else;\n      nValid = 0;\n      Break;\n    EndIf;\n    nChar = nChar + 1;\n  End;\n\
    \  If ( nValid<>0 );\n    pThousandSeparator = CHAR(StringToNumber( pThousandSeparator ));\n\
    \  Else;\n    pThousandSeparator = SubSt( Trim( pThousandSeparator ), 1, 1 );\n  EndIf;\n\
    EndIf;\nsThousandSeparator = pThousandSeparator;\n\n# Validate Sandbox\nIf( TRIM( pSandbox\
    \ ) @<> '' );\n    If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty(\
    \ 0 );\n        nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is\
    \ invalid for the current user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        ServerActiveSandboxSet( pSandbox );\n        SetUseActiveSandboxProperty(\
    \ 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty( 0 );\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate Dimension\n\
    pDimension      = TRIM( pDim);\npSourceElement  = TRIM(pSrcEle);\npTargetElement  = TRIM(pTgtEle);\n\
    \nIf( pDimension @<> '');\n    \n  If( DimensionExists( pDimension ) = 0 );\n    sMessage\
    \ = 'Invalid dimension specified: ' | pDimension;\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  EndIf;\n\n  # Validate Source Element\n\
    \  If( pSourceElement @= '' );\n    sMessage = 'Error: The Source Element parameter is blank.';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \  EndIf;\n\n  If( DimIx( pDimension, pSourceElement ) = 0 );\n    sMessage = 'Invalid source\
    \ element, ' | pSourceElement | ' specified for ' | pDimension | ' dimension.';\n    nErrors\
    \ = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  EndIf;\n\
    \  sSourceElement = DimensionElementPrincipalName( pDimension, pSourceElement);\n\n  # Validate\
    \ Target Element\n  If( pTargetElement @= '' );\n    sMessage = 'Error: The Target Element\
    \ parameter is blank.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n  ElseIf( DimIx( pDimension, pTargetElement ) = 0 );\n    sMessage\
    \ = 'Invalid target element, ' | pTargetElement | ' specified for ' | pDimension | ' dimension.';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \  EndIf;\n  sTargetElement = DimensionElementPrincipalName( pDimension, pTargetElement);\n\
    \nENDIF;\n\n## Validate delimiter\n\nIf( pDelimiter @= '' );\n  sMessage = 'Error: The file\
    \ delimiter parameter is blank.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( Long( pDelimiter ) > 1 );\n  sMessage = 'Invalid\
    \ delimiter specified: ' | pDelimiter | ' field delimiter must be single character or 2-3\
    \ symbols number representing ASCII code.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate quote character\nIf( Long( pQuote\
    \ ) > 1 );\n  sMessage = 'Invalid string qualIfier: ' | pQuote | ' quote character must\
    \ be single character or empty string or 2-3 symbols number representing ASCII code.';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Determine\
    \ number of dims in target cube ###\nnCount = 1;\nnSubstututeDimensionIndex = 0;\nWhile(\
    \ \nTabDim( pCube, nCount ) @<> '' );\n  sDimension = TabDim( pCube, nCount );\n  If( sDimension\
    \ @= pDimension );\n    nSubstututeDimensionIndex = nCount;\n  EndIf;\n  nCount = nCount\
    \ + 1;\nEnd;\nnDimensionCount = nCount - 1;\n\n## Validate the dimension is part of the\
    \ cube.\nIf( pDimension @= '');\n  ## CONTINUE;\nELSEIf( nSubstututeDimensionIndex = 0 );\n\
    \    sMessage = 'Specified dimension: ' | pDimension | ' is not a component of the cube:\
    \ ' | pCube;\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nENDIF;\n\n        ## Default filter delimiters\n        If( pDimDelim     @= ''\
    \ );\n            pDimDelim     = '&';\n        EndIf;\n        If( pEleStartDelim@= ''\
    \ );\n            pEleStartDelim= '¦';\n        EndIf;\n        If( pEleDelim     @= ''\
    \ );\n            pEleDelim     = '+';\n        EndIf;\n        \n\nIf( nDimensionCount\
    \ > 27 );\n  sMessage = 'Cube has too many dimensions: ' | pCube | ' max 27 dimensions.';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Determine\
    \ dimensions in target cube, we need to know this to test cell type before loading ###\n\
    sDim1  = TabDim( pCube, 1 );\nsDim2  = TabDim( pCube, 2 );\nsDim3  = TabDim( pCube, 3 );\n\
    sDim4  = TabDim( pCube, 4 );\nsDim5  = TabDim( pCube, 5 );\nsDim6  = TabDim( pCube, 6 );\n\
    sDim7  = TabDim( pCube, 7 );\nsDim8  = TabDim( pCube, 8 );\nsDim9  = TabDim( pCube, 9 );\n\
    sDim10 = TabDim( pCube, 10 );\nsDim11 = TabDim( pCube, 11 );\nsDim12 = TabDim( pCube, 12\
    \ );\nsDim13 = TabDim( pCube, 13 );\nsDim14 = TabDim( pCube, 14 );\nsDim15 = TabDim( pCube,\
    \ 15 );\nsDim16 = TabDim( pCube, 16 );\nsDim17 = TabDim( pCube, 17 );\nsDim18 = TabDim(\
    \ pCube, 18 );\nsDim19 = TabDim( pCube, 19 );\nsDim20 = TabDim( pCube, 20 );\nsDim21 = TabDim(\
    \ pCube, 21 );\nsDim22 = TabDim( pCube, 22 );\nsDim23 = TabDim( pCube, 23 );\nsDim24 = TabDim(\
    \ pCube, 24 );\nsDim25 = TabDim( pCube, 25 );\nsDim26 = TabDim( pCube, 26 );\nsDim27 = TabDim(\
    \ pCube, 27 );\n\n### Placeholders for mappped dimensions and for new dimensions\n\nnMappedDim1\
    \ = 0;\tsMappedV1 = '';\t\tnNewDim1 = 0;\t  sNewV1 = '';\nnMappedDim2 = 0;\tsMappedV2 =\
    \ '';\t\tnNewDim2 = 0;\t  sNewV2 = '';\nnMappedDim3 = 0;\tsMappedV3 = '';\t\tnNewDim3 =\
    \ 0;\t  sNewV3 = '';\nnMappedDim4 = 0;\tsMappedV4 = '';\t\tnNewDim4 = 0;\t  sNewV4 = '';\n\
    nMappedDim5 = 0;\tsMappedV5 = '';\t\tnNewDim5 = 0;\t  sNewV5 = '';\nnMappedDim6 = 0;\tsMappedV6\
    \ = '';\t\tnNewDim6 = 0;\t  sNewV6 = '';\nnMappedDim7 = 0;\tsMappedV7 = '';\t\tnNewDim7\
    \ = 0;\t  sNewV7 = '';\nnMappedDim8 = 0;\tsMappedV8 = '';\t\tnNewDim8 = 0;\t  sNewV8 = '';\n\
    nMappedDim9 = 0;\tsMappedV9 = '';\t\tnNewDim9 = 0;\t  sNewV9 = '';\nnMappedDim10 = 0;\t\
    sMappedV10 = '';\tnNewDim10 = 0;\tsNewV10 = '';\nnMappedDim11 = 0;\tsMappedV11 = '';\tnNewDim11\
    \ = 0;\tsNewV11 = '';\nnMappedDim12 = 0;\tsMappedV12 = '';\tnNewDim12 = 0;\tsNewV12 = '';\n\
    nMappedDim13 = 0;\tsMappedV13 = '';\tnNewDim13 = 0;\tsNewV13 = '';\nnMappedDim14 = 0;\t\
    sMappedV14 = '';\tnNewDim14 = 0;\tsNewV14 = '';\nnMappedDim15 = 0;\tsMappedV15 = '';\tnNewDim15\
    \ = 0;\tsNewV15 = '';\nnMappedDim16 = 0;\tsMappedV16 = '';\tnNewDim16 = 0;\tsNewV16 = '';\n\
    nMappedDim17 = 0;\tsMappedV17 = '';\tnNewDim17 = 0;\tsNewV17 = '';\nnMappedDim18 = 0;\t\
    sMappedV18 = '';\tnNewDim18 = 0;\tsNewV18 = '';\nnMappedDim19 = 0;\tsMappedV19 = '';\tnNewDim19\
    \ = 0;\tsNewV19 = '';\nnMappedDim20 = 0;\tsMappedV20 = '';\tnNewDim20 = 0;\tsNewV20 = '';\n\
    nMappedDim21 = 0;\tsMappedV21 = '';\tnNewDim21 = 0;\tsNewV21 = '';\nnMappedDim22 = 0;\t\
    sMappedV22 = '';\tnNewDim22 = 0;\tsNewV22 = '';\nnMappedDim23 = 0;\tsMappedV23 = '';\tnNewDim23\
    \ = 0;\tsNewV23 = '';\nnMappedDim24 = 0;\tsMappedV24 = '';\tnNewDim24 = 0;\tsNewV24 = '';\n\
    nMappedDim25 = 0;\tsMappedV25 = '';\tnNewDim25 = 0;\tsNewV25 = '';\nnMappedDim26 = 0;\t\
    sMappedV26 = '';\tnNewDim26 = 0;\tsNewV26 = '';\nnMappedDim27 = 0;\tsMappedV27 = '';\tnNewDim27\
    \ = 0;\tsNewV27 = '';\n                  sMappedV28 = '';\n\n###########################################\n\
    ### SPLIT MAPPING TO NEW DIMS PARAMETER ###\n###########################################\n\
    \nnTargetCubeDimensionCount   = nDimensionCount;\n\nsElementMapping = TRIM( pMappingToNewDims\
    \ );\nnChar = 1;\nnCharCount = LONG( sElementMapping );\n\nsTargetFilter = '';\nsWord =\
    \ '';\nsLastDelim = '';\nnIndex = 1;\n\n# Add a trailing element delimiter so that the last\
    \ element is picked up\nIf( nCharCount > 0 );\n  sElementMapping = sElementMapping | sDelimDim;\n\
    \  nCharCount = nCharCount + LONG(sDelimDim);\nEndIf;\n\nWHILE (nChar <= nCharCount);\n\
    \    sChar = SUBST( sElementMapping, nChar, 1);\n\n    # Used for delimiters, required for\
    \ multiple character delimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n    # Ignore spaces\n\
    \    IF (TRIM(sChar) @<> '' );\n\n      ### Dimension Name ###\n\n      # If the delimiter\
    \ is more than 1 character peek ahead the same amount\n      # Ignore the first character\n\
    \      sDelim = sChar;\n      nCount = LONG(sElementStartDelim) - 1;\n      If( nCount >\
    \ 0 & nChar + nCount <= nCharCount );\n        # Add the extra characters\n        sDelim\
    \ = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\n        # Move to the end of the\
    \ delimter\n\n      EndIf;\n\n      If( sDelim @= sElementStartDelim );\n        nAddExtra\
    \ = nCount;\n        sChar = sDelim;\n\n        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim\
    \ );\n            sMessage = 'In pMappingToNewDims the name of a dimension must follow a\
    \ dimension delimiter (' | sDelimDim | ')';\n            nErrors = nErrors + 1;\n      \
    \      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \        EndIf;\n\n        # Found a dimension\n        sDimension = sWord;\n\n        If(\
    \ DimensionExists( sDimension ) = 0 );\n            # The dimension does not exist in the\
    \ model. Cancel process\n            sMessage = 'In pMappingToNewDims - Dimension: ' | sDimension\
    \ | ' does not exist';\n            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n            #ProcessError();\n        EndIf;\n        \n\
    \        ### Determine the dimension is a member of the cube ###\n        nMapCount = 1;\n\
    \        nMapDimensionIndex = 0;\n        While( TabDim( pCube, nMapCount ) @<> '' );\n\
    \            sMapCubeDimName = TabDim( pCube, nMapCount );\n            If( sDimension @=\
    \ sMapCubeDimName );\n                nMapDimensionIndex = nMapCount;\n            EndIf;\n\
    \            nMapCount = nMapCount + 1;\n        End;\n\n        If( nMapDimensionIndex\
    \ = 0 );\n            # The dimension does not exist in the cube. Cancel process\n     \
    \       sMessage = 'Dimension: ' | sDimension | ' is not a member of: '| pCube | ' cube.';\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n  \
    \          Else;\n                ProcessBreak;\n            EndIf;\n        EndIf;\n\n\
    \        # Find the index of the dimension is in the Target cube\n        nTargetIndexCounter\
    \ = 1;\n\n        WHILE(nTargetIndexCounter <= nTargetCubeDimensionCount );\n          sNthDimension\
    \ = TabDim( pCube, nTargetIndexCounter );\n\n          If(sDimension @= sNthDimension);\n\
    \            nTargetIndex = nTargetIndexCounter;\n            nTargetIndexCounter = 1000;\n\
    \          EndIf;\n\n          nTargetIndexCounter = nTargetIndexCounter + 1;\n        END;\n\
    \        \n        #Add to the Target filter\n        If(sTargetFilter@='');\n         \
    \ sTargetFilter=sDimension;          \n        Else;\n          sTargetFilter=sTargetFilter|sDelimDim|sDimension;\n\
    \        Endif;  \n          \n        sLastDelim = sChar;\n        # Clear the word\n \
    \       sWord = '';\n\n      Else;\n\n        # Reset extra chars\n        nAddExtra = 0;\n\
    \n        ### Check both dim delimiter and element delimiter ###\n        nIsDelimiter =\
    \ 0;\n\n        ## Check dimension delimiter first\n        # If the delimiter is more than\
    \ 1 character peek ahead the same amount\n        # Ignore the first character\n       \
    \ sDelim = sChar;\n        nCount = LONG(sDelimDim) - 1;\n        If( nCount > 0 & nChar\
    \ + nCount <= nCharCount );\n          # Add the extra characters\n          sDelim = sDelim\
    \ | SUBST( sElementMapping, nChar + 1, nCount);\n          # Move to the end of the delimter\n\
    \          \n        EndIf;\n\n        If( sDelim @= sDelimDim );\n          nIsDelimiter\
    \ = 1;\n          sChar = sDelim;\n          nAddExtra = nCount;\n        EndIf;\n\n   \
    \     If ( nIsDelimiter = 1 );\n\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim\
    \ );\n            sMessage = 'In pMappingToNewDims - an element delimiter must follow a\
    \ dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';\n            nErrors\
    \ = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \            #ProcessError();\n          EndIf;\n\n          # an element has been found\n\
    \          sElement = sWord;\n\n          If( DimIx( sDimension, sElement ) = 0 );\n   \
    \           # The element does not exist in the dimension. Cancel process\n            \
    \  sMessage = 'In pMappingToNewDims - Element: ' | sElement | ' in dimension ' | sDimension\
    \ | ' does not exist';\n              nErrors = nErrors + 1;\n              LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n              #ProcessError();\n          EndIf;\n\n  \
    \        # Allow consolidations only if pSuppressConsol is set to 0\n\n          If ( DTYPE(\
    \ sDimension, sElement) @= 'C' );\n            sMessage = Expand( 'In pMappingToNewDims\
    \ - Target element: %sElement% for dimension %sDimension% is consolidated' );\n        \
    \    nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            #ProcessError();\n          Endif;  \n          \n\n          # Add\
    \ the element to the source or target depending on whether it's the first or the second\
    \ element\n          # Get principal name\n          # in case source element and this element\
    \ are using different aliases\n\n          sElement = DimensionElementPrincipalName(sDimension,sElement);\n\
    \n          ### Update the variable for InputElement Target Dim ######################################\n\
    \          If(nTargetIndex = 1);\n            nNewDim1 = 1;\n            sNewV1 = sElement;\n\
    \          ElseIf(nTargetIndex = 2);\n            nNewDim2 = 1;\n            sNewV2 = sElement;\n\
    \          ElseIf(nTargetIndex = 3);\n            nNewDim3 = 1;\n            sNewV3 = sElement;\n\
    \          ElseIf(nTargetIndex = 4);\n            nNewDim4 = 1;\n            sNewV4 = sElement;\n\
    \          ElseIf(nTargetIndex = 5);\n            nNewDim5 = 1;\n            sNewV5 = sElement;\n\
    \          ElseIf(nTargetIndex = 6);\n            nNewDim6 = 1;\n            sNewV6 = sElement;\n\
    \          ElseIf(nTargetIndex = 7);\n            nNewDim7 = 1;\n            sNewV7 = sElement;\n\
    \          ElseIf(nTargetIndex = 8);\n            nNewDim8 = 1;\n            sNewV8 = sElement;\n\
    \          ElseIf(nTargetIndex = 9);\n            nNewDim9 = 1;\n            sNewV9 = sElement;\n\
    \          ElseIf(nTargetIndex = 10);\n            nNewDim10 = 1;\n            sNewV10 =\
    \ sElement;\n          ElseIf(nTargetIndex = 11);\n            nNewDim11 = 1;\n        \
    \    sNewV11 = sElement;\n          ElseIf(nTargetIndex = 12);\n            nNewDim12 =\
    \ 1;\n            sNewV12 = sElement;\n          ElseIf(nTargetIndex = 13);\n          \
    \  nNewDim13 = 1;\n            sNewV13 = sElement;\n          ElseIf(nTargetIndex = 14);\n\
    \            nNewDim14 = 1;\n            sNewV14 = sElement;\n          ElseIf(nTargetIndex\
    \ = 15);\n            nNewDim15 = 1;\n            sNewV15 = sElement;\n          ElseIf(nTargetIndex\
    \ = 16);\n            nNewDim16 = 1;\n            sNewV16 = sElement;\n          ElseIf(nTargetIndex\
    \ = 17);\n            nNewDim17 = 1;\n            sNewV17 = sElement;\n          ElseIf(nTargetIndex\
    \ = 18);\n            nNewDim18 = 1;\n            sNewV18 = sElement;\n          ElseIf(nTargetIndex\
    \ = 19);\n            nNewDim19 = 1;\n            sNewV19 = sElement;\n          ElseIf(nTargetIndex\
    \ = 20);\n            nNewDim20 = 1;\n            sNewV20 = sElement;\n          ElseIf(nTargetIndex\
    \ = 21);\n            nNewDim21 = 1;\n            sNewV21 = sElement;\n          ElseIf(nTargetIndex\
    \ = 22);\n            nNewDim22 = 1;\n            sNewV22 = sElement;\n          ElseIf(nTargetIndex\
    \ = 23);\n            nNewDim23 = 1;\n            sNewV23 = sElement;\n          ElseIf(nTargetIndex\
    \ = 24);\n            nNewDim24 = 1;\n            sNewV24 = sElement;\n          ElseIf(nTargetIndex\
    \ = 25);\n            nNewDim25 = 1;\n            sNewV25 = sElement;\n          ElseIf(nTargetIndex\
    \ = 26);\n            nNewDim26 = 1;\n            sNewV26 = sElement;\n          ElseIf(nTargetIndex\
    \ = 27);\n            nNewDim27 = 1;\n            sNewV27 = sElement;\n          EndIf;\n\
    \n          #Add to the Target filter - no need to manage element separators, since just\
    \ one target element is possible in mapping\n          sTargetFilter=sTargetFilter|sElementStartDelim|sElement;\n\
    \          \n          # Clear the word\n          sWord = '';\n          sLastDelim = sChar;\n\
    \ \n        Else;\n          sWord = sWord | sChar;\n        EndIf;\n\n      EndIf;\n\n\
    \    EndIf;\n\n    nChar = nChar + nAddExtra + 1;\n\nEND;\n\n\n###########################################\n\
    #Region ### MAPPING Target DIMENSIONS #####\n\n## Source index starting from 2, since first\
    \ columns holds the export cube name\nnSourceIndex = 2;\nnTargetIndex = 1;\nWHILE(TabDim(\
    \ pCube, nTargetIndex ) @<> '');\n  sTargetDim = TabDim( pCube, nTargetIndex );\n  \n  If(nTargetIndex\
    \ = 1);\n    If( nNewDim1 = 0 );\n      nMappedDim1 = 1;\n      sMappedV1  = 'V' | NumberToString(nSourceIndex);\n\
    \      nSourceIndex = nSourceIndex + 1;\n    Else;\n      \n    EndIf;\n  ElseIf(nTargetIndex\
    \ = 2 & nNewDim2 = 0);\n    nMappedDim2 = 1;\n    sMappedV2  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 3 & nNewDim3 = 0);\n    nMappedDim3\
    \ = 1;\n    sMappedV3  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 4 & nNewDim4 = 0);\n    nMappedDim4 = 1;\n    sMappedV4\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 5 & nNewDim5 = 0);\n    nMappedDim5 = 1;\n    sMappedV5  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 6 & nNewDim6 = 0);\n    nMappedDim6\
    \ = 1;\n    sMappedV6  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 7 & nNewDim7 = 0);\n      nMappedDim7 = 1;\n      sMappedV7\
    \  = 'V' | NumberToString(nSourceIndex);\n      nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 8 & nNewDim8 = 0);\n    nMappedDim8 = 1;\n    sMappedV8  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 9 & nNewDim9 = 0);\n    nMappedDim9\
    \ = 1;\n    sMappedV9  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 10 & nNewDim10 = 0);\n    nMappedDim10 = 1;\n    sMappedV10\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 11 & nNewDim11 = 0);\n    nMappedDim11 = 1;\n    sMappedV11  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 12 & nNewDim12 = 0 );\n \
    \   nMappedDim12 = 1;\n    sMappedV12  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex\
    \ = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 13 & nNewDim13 = 0 );\n    nMappedDim13 =\
    \ 1;\n    sMappedV13  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 14 & nNewDim14 = 0 );\n    nMappedDim14 = 1;\n    sMappedV14\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 15 & nNewDim15 = 0 );\n    nMappedDim15 = 1;\n    sMappedV15  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 16 & nNewDim16 = 0 );\n \
    \   nMappedDim16 = 1;\n    sMappedV16  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex\
    \ = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 17 & nNewDim17 = 0 );\n    nMappedDim17 =\
    \ 1;\n    sMappedV17  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 18 & nNewDim18 = 0 );\n    nMappedDim18 = 1;\n    sMappedV18\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 19 & nNewDim19 = 0 );\n    nMappedDim19 = 1;\n    sMappedV19  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 20 & nNewDim20 = 0 );\n \
    \   nMappedDim20 = 1;\n    sMappedV20  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex\
    \ = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 21 & nNewDim21 = 0 );\n    nMappedDim21 =\
    \ 1;\n    sMappedV21  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 22 & nNewDim22 = 0 );\n    nMappedDim22 = 1;\n    sMappedV22\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 23 & nNewDim23 = 0 );\n    nMappedDim23 = 1;\n    sMappedV23  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 24 & nNewDim24 = 0 );\n \
    \   nMappedDim24 = 1;\n    sMappedV24  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex\
    \ = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 25 & nNewDim25 = 0 );\n    nMappedDim25 =\
    \ 1;\n    sMappedV25  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 26 & nNewDim26 = 0 );\n    nMappedDim26 = 1;\n    sMappedV26\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 27 & nNewDim27 = 0 );\n    nMappedDim27 = 1;\n    sMappedV27  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  EndIf;\n\n  nTargetIndex = nTargetIndex + 1;\n\n\
    END;\n\n# The last variable in the data source holds the values\n# which need to be mapped\
    \ to the last variable in the target\n\nIf(nTargetIndex = 1 & nNewDim1 = 0);\n  nMappedDim1\
    \ = 1;\n  sMappedV1  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex\
    \ + 1;\nElseIf(nTargetIndex = 2 & nNewDim2 = 0);\n  nMappedDim2 = 1;\n  sMappedV2  = 'V'\
    \ | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 3 & nNewDim3 = 0);\n  nMappedDim3 = 1;\n  sMappedV3  = 'V' | NumberToString(nSourceIndex);\n\
    \  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex = 4 & nNewDim4 = 0);\n  nMappedDim4\
    \ = 1;\n  sMappedV4  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex\
    \ + 1;\nElseIf(nTargetIndex = 5 & nNewDim5 = 0);\n  nMappedDim5 = 1;\n  sMappedV5  = 'V'\
    \ | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 6 & nNewDim6 = 0);\n  nMappedDim6 = 1;\n  sMappedV6  = 'V' | NumberToString(nSourceIndex);\n\
    \  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex = 7 & nNewDim7 = 0);\n  nMappedDim7\
    \ = 1;\n  sMappedV7  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex\
    \ + 1;\nElseIf(nTargetIndex = 8 & nNewDim8 = 0);\n  nMappedDim8 = 1;\n  sMappedV8  = 'V'\
    \ | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 9 & nNewDim9 = 0);\n  nMappedDim9 = 1;\n  sMappedV9  = 'V' | NumberToString(nSourceIndex);\n\
    \  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex = 10 & nNewDim10 = 0);\n  nMappedDim10\
    \ = 1;\n  sMappedV10  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex\
    \ + 1;\nElseIf(nTargetIndex = 11 & nNewDim11 = 0);\n  nMappedDim11 = 1;\n  sMappedV11  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 12);\n  nMappedDim12 = 1;\n  sMappedV12  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 13);\n  nMappedDim13 = 1;\n  sMappedV13  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 14);\n  nMappedDim14 = 1;\n  sMappedV14  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 15);\n  nMappedDim15 = 1;\n  sMappedV15  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 16);\n  nMappedDim16 = 1;\n  sMappedV16  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 17);\n  nMappedDim17 = 1;\n  sMappedV17  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 18);\n  nMappedDim18 = 1;\n  sMappedV18  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 19);\n  nMappedDim19 = 1;\n  sMappedV19  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 20);\n  nMappedDim20 = 1;\n  sMappedV20  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 21);\n  nMappedDim21 = 1;\n  sMappedV21  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 22);\n  nMappedDim22 = 1;\n  sMappedV22  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 23);\n  nMappedDim23 = 1;\n  sMappedV23  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 24);\n  nMappedDim24 = 1;\n  sMappedV24  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 25);\n  nMappedDim25 = 1;\n  sMappedV25  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 26);\n  nMappedDim26 = 1;\n  sMappedV26  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 27);\n  nMappedDim27 = 1;\n  sMappedV27  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\n\n# a cube with\
    \ 27 dimensions uses V28 to hold the values\nElseIf(nTargetIndex = 28);\n  nMappedDim28\
    \ = 1;\n  sMapped28  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex\
    \ + 1;\nEndIf;\n\n# Check that an input element or variable has been specified for all dimensions\
    \ in the target cube\n\nnIndexInTarget = 1;\nWHILE(nIndexInTarget <= nTargetCubeDimensionCount);\n\
    \      \n      sMapped   = Expand('%nMappedDim'| NumberToString(nIndexInTarget) |'%'); \n\
    \      sMapped   = Subst( sMapped , Scan( '.' , sMapped )-1 , 99);\n      nMapped   = StringToNumber(\
    \ Trim( sMapped ) );\n      sNew      = Expand('%nNewDim'| NumberToString(nIndexInTarget)\
    \ |'%'); \n      sNew      = Subst( sNew , Scan( '.' , sNew )-1 , 99);\n      nNew     \
    \ = StringToNumber( Trim( sNew ) );\n      \n      If(nMapped = 0 & nNew = 0 );\n      \
    \      # there's no input element and this dimension is not in the source\n            nErrors\
    \         = nErrors + 1;\n            sTargetDimName  = TabDim( pCube,  nIndexInTarget );\n\
    \            sMessage        = 'Dimension ' | sTargetDimName | ' is missing an input element\
    \ in pMappingToNewDims';\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n  \
    \          Else;\n                ProcessBreak;\n            EndIf;\n       EndIf;\n   \
    \    \n       nIndexInTarget = nIndexInTarget + 1;\nEND;\n#EndRegion ### MAPPING Target\
    \ DIMENSIONS #####\n##############################################\n\n#CubeLogging\nIf (\
    \ pCubeLogging <= 1 );\n  sCubeLogging = CellGetS('}CubeProperties', pCube, 'LOGGING' );\n\
    \  CubeSetLogChanges( pCube, pCubeLogging);\nEndIf;\n\n### Assign Datasource ###\nDataSourceType\
    \                  = 'CHARACTERDELIMITED';\nDatasourceNameForServer         = sFile;\nDatasourceNameForClient\
    \         = sFile;\nDatasourceASCIIHeaderRecords    = pTitleRows;\nDatasourceASCIIDelimiter\
    \        = pDelimiter;\nDatasourceASCIIQuoteCharacter   = pQuote;\nSetInputCharacterSet\
    \ (pCharacterSet);\n\n### End Prolog ###\n#Section Metadaten\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# It would be too exhaustive to error trap elements\
    \ not existing in dimension for each possible number of dimensions\n# If an incorrect source\
    \ file is specfied for a target cube then the TI will error with standard TI error messages.\n\
    # Note: that the assumed file format is standard .cma cube export of Cube, d1, d2, dn, value\n\
    # This is equivalent to using the Bedrock.Cube.ExportToFile TI.\n\n## Increase Record count\n\
    nRecordProcessedCount = nRecordProcessedCount + 1;\n\n### Zero out Target view using filter\
    \ in the 1st record of the data source, if requested\nIf( nRecordProcessedCount = 1 );\n\
    \  If( pZeroFilter = 2 );\n    sRowIsFilter = v2;\n    sImportedFilter = v3;\n    sImportedDelimDim\
    \ = v4;\n    sImportedElementStartDelim = v5;\n    sImportedDelimElem = v6;\n    ### Check\
    \ Filter row\n    If(sRowIsFilter @<> 'Filter');\n        sMessage = 'Filter row in source\
    \ file not having the expected format.';\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 );\
    \ \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n        EndIf;\n\
    \    ENDIF;\n    ### Check delimiters are the same when using any mapping. This because\
    \ filter from the file and mappings form the params will be concatenated / substituted\n\
    \    If((sElementMapping @<> '' % pDimension @<>'') & (sDelimDim @<> sImportedDelimDim %\
    \ sElementStartDelim @<> sImportedElementStartDelim % sDelimElem @<> sImportedDelimElem));\n\
    \        sMessage = 'Error zeroing out target slice corresponding to the filter plus new\
    \ mapped dimensions: delimiters in source file do not match with the ones in parameters.';\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n\
    \            ProcessBreak;\n        EndIf;\n    ENDIF;\n    \n    ### Check filter in source\
    \ file and validate its dimensions\n    sFilter = TRIM( sImportedFilter );\n    nChar =\
    \ 1;\n    nCharCount = LONG( sFilter );\n    sWord = '';\n    sLastDelim = '';\n    nIndex\
    \ = 1;\n    # Add a trailing element delimiter so that the last element is picked up\n \
    \   If( nCharCount > 0 );\n      sFilter = sFilter | sDelimElem;\n      nCharCount = nCharCount\
    \ + LONG(sDelimElem);\n    EndIf;\n    \n    WHILE (nChar <= nCharCount);\n        sChar\
    \ = SUBST( sFilter, nChar, 1);\n    \n        # Used for delimiters, required for multiple\
    \ character delimiters\n        sDelim = '';\n        nAddExtra = 0;\n    \n        # Ignore\
    \ spaces\n        IF (TRIM(sChar) @<> '' );\n    \n          ### Dimension Name ###\n  \
    \  \n          # If the delimiter is more than 1 character peek ahead the same amount\n\
    \          # Ignore the first character\n          sDelim = sChar;\n          nCount = LONG(sElementStartDelim)\
    \ - 1;\n          If( nCount > 0 & nChar + nCount <= nCharCount );\n            # Add the\
    \ extra characters\n            sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n\
    \            # Move to the end of the delimter\n            nAddExtra = nCount;\n      \
    \    EndIf;\n    \n          If( sDelim @= sElementStartDelim );\n    \n            sChar\
    \ = sDelim;\n    \n            If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );\n   \
    \             sMessage = 'The name of a dimension must follow a dimension delimiter (' |\
    \ sDelimDim | ')';\n                nErrors = nErrors + 1;\n                LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n            EndIf;\n    \n            sDimension = sWord;\n\
    \            \n            If( DimensionExists( sDimension ) = 0 );\n                # The\
    \ dimension does not exist in the model. Cancel process\n                sMessage = 'Dimension:\
    \ ' | sDimension | ' does not exist';\n                nErrors = nErrors + 1;\n        \
    \        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            EndIf;\n\
    \    \n            ### Determine the dimension is a member of the cube ###\n           \
    \ nCount = 1;\n            nDimensionIndex = 0;\n            While( TabDim( pCube, nCount\
    \ ) @<> '' );\n                sCubeDimName = TabDim( pCube, nCount );\n               \
    \ If( sDimension @= sCubeDimName );\n                    nDimensionIndex = nCount;\n   \
    \             EndIf;\n                nCount = nCount + 1;\n            End;\n    \n   \
    \         If( nDimensionIndex = 0 );\n                # The dimension does not exist in\
    \ the cube. Cancel process\n                sMessage = 'Dimension: ' | sDimension | ' is\
    \ not a member of: '| pCube | ' cube.';\n                nErrors = nErrors + 1;\n      \
    \          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            EndIf;\n\
    \    \n\n    \n            nIndex = 1;\n            sLastDelim = sChar;\n            # Clear\
    \ the word\n            sWord = '';\n          Else;\n    \n            # Reset extra chars\n\
    \            nAddExtra = 0;\n    \n            ### Check both both dim delimiter and element\
    \ delimiter ###\n            nIsDelimiter = 0;\n    \n            ## Check dimension delimiter\
    \ first\n            # If the delimiter is more than 1 character peek ahead the same amount\n\
    \            # Ignore the first character\n            sDelim = sChar;\n            nCount\
    \ = LONG(sDelimDim) - 1;\n            If( nCount > 0 & nChar + nCount <= nCharCount );\n\
    \              # Add the extra characters\n              sDelim = sDelim | SUBST( sFilter,\
    \ nChar + 1, nCount);\n              # Move to the end of the delimter\n              nAddExtra\
    \ = nCount;\n            EndIf;\n    \n            If( sDelim @= sDelimDim );\n        \
    \      nIsDelimiter = 1;\n              sChar = sDelim;\n            Else;\n           \
    \   # Reset extra chars\n              nAddExtra = 0;\n    \n              ## Check element\
    \ delimiter\n    \n              # If the delimiter is more than 1 character peek ahead\
    \ the same amount\n              # Ignore the first character\n              sDelim = sChar;\n\
    \              nCount = LONG(sDelimElem) - 1;\n              If( nCount > 0 & nChar + nCount\
    \ <= nCharCount );\n                # Add the extra characters\n                sDelim =\
    \ sDelim | SUBST( sFilter, nChar + 1, nCount);\n                # Move to the end of the\
    \ delimter\n                nAddExtra = nCount;\n              EndIf;\n    \n          \
    \    If( sDelim @= sDelimElem );\n                nIsDelimiter = 1;\n                sChar\
    \ = sDelim;\n              Else;\n                # Reset extra chars\n                nAddExtra\
    \ = 0;\n              EndIf;\n    \n            EndIf;\n    \n            If ( nIsDelimiter\
    \ = 1 );\n    \n              If( sLastDelim @= '' % sLastDelim @= sDelimDim );\n      \
    \          sMessage = 'An element delimiter must follow a dimension name: ' |  sChar | '\
    \ (' | NumberToString(nChar) | ')';\n                nErrors = nErrors + 1;\n          \
    \      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                #ProcessError();\n\
    \              EndIf;\n    \n              sElement = sWord;\n    \n              If( DimIx(\
    \ sDimension, sElement ) = 0 );\n                  # The element does not exist in the dimension.\
    \ Cancel process\n                  sMessage = 'Element: ' | sElement | ' in dimension '\
    \ | sDimension | ' does not exist';\n                  nErrors = nErrors + 1;\n        \
    \          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                  #ProcessError();\n\
    \              EndIf;\n    \n              nIndex = nIndex + 1;\n              sLastDelim\
    \ = sChar;\n    \n              # Clear the word\n              sWord = '';\n          \
    \  Else;\n              sWord = sWord | sChar;\n            EndIf;\n    \n          EndIf;\n\
    \    \n        EndIf;\n    \n        nChar = nChar + nAddExtra + 1;\n    END;\n\n    ###\
    \ Check for errors before continuing\n    If( nErrors <> 0 );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;\n    EndIf;\n    \n    If( sTargetFilter @= '' );\n      sTargetFilter = sImportedFilter;\n\
    \    Else;\n      sTargetFilter = sTargetFilter | sDelimDim | sImportedFilter;\n    EndIf;\n\
    \    ### Determine target dimension substitution in data clear filter\n    If( pDimension\
    \ @<>'');\n      If( sTargetFilter @= '' );\n        sTargetFilter = pDimension | sElementStartDelim\
    \ | sTargetElement;\n      Else;\n        ### Remove spaces from the string, then remove\
    \ source element from the filter if present\n        sTargetFilter = UPPER( sTargetFilter\
    \ );\n        nSPIndex = SCAN( ' ', sTargetFilter );\n        While ( nSPIndex <> 0);\n\
    \          sTargetFilter = DELET( sTargetFilter, nSPIndex, 1 );\n          nSPIndex = SCAN(\
    \ ' ', sTargetFilter );\n        End;\n        sRemoveString = UPPER( sDelimDim | pDimension\
    \ | sElementStartDelim | pSrcEle );\n        nRemoveIndex = SCAN( sRemoveString, sTargetFilter\
    \ );\n        If( nRemoveIndex <> 0 );\n          sTargetFilter = DELET( sTargetFilter,\
    \ nRemoveIndex, Long(sRemoveString) );\n        EndIf;\n        sRemoveString2 = UPPER(\
    \ pDimension | sElementStartDelim | pSrcEle | sDelimDim );\n        nRemoveIndex = SCAN(\
    \ sRemoveString2, sTargetFilter );\n        If( nRemoveIndex <> 0 );\n          sTargetFilter\
    \ = DELET( sTargetFilter, nRemoveIndex, Long(sRemoveString2) );\n        EndIf;\n      \
    \  sRemoveString3 = UPPER( sDelimDim | pDimension | sElementStartDelim | sSourceElement\
    \ );\n        nRemoveIndex = SCAN( sRemoveString3, sTargetFilter );\n        If( nRemoveIndex\
    \ <> 0 );\n          sTargetFilter = DELET( sTargetFilter, nRemoveIndex, Long(sRemoveString3)\
    \ );\n        EndIf;\n        sRemoveString4 = UPPER( pDimension | sElementStartDelim |\
    \ sSourceElement | sDelimDim );\n        nRemoveIndex = SCAN( sRemoveString4, sTargetFilter\
    \ );\n        If( nRemoveIndex <> 0 );\n          sTargetFilter = DELET( sTargetFilter,\
    \ nRemoveIndex, Long(sRemoveString4) );\n        EndIf;\n        ## Add target element to\
    \ the filter\n        sTargetFilter = sTargetFilter | sDelimDim | pDimension | sElementStartDelim\
    \ | sTargetElement;\n      EndIf;\n    Endif;\n    \n    nRet = ExecuteProcess('}bedrock.cube.data.clear',\n\
    \       'pLogOutput', pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n\
    \       'pCube', pCube,\n       'pView', '',\n       'pFilter', sTargetFilter,\n       'pFilterParallel',\
    \ '',\n       'pParallelThreads', 0,\n       'pDimDelim', sImportedDelimDim,\n       'pEleStartDelim',\
    \ sImportedElementStartDelim,\n       'pEleDelim', sImportedDelimElem,\n       'pCubeLogging',\
    \ pCubeLogging,\n       'pTemp', 1,\n       'pSandbox', pSandbox\n      );\n  \n    If(nRet\
    \ <> 0);\n        sMessage = 'Error zeroing out target slice corresponding to the filter.';\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n\
    \            ProcessBreak;\n        EndIf;\n    ENDIF;\n  ENDIF;\n  If( pZeroFilter > 0\
    \ );\n    ItemSkip;\n  ENDIF;\nEndif;\n\n### Determine target dimension SubStitution ###\n\
    If( pDimension @<>'');\n  \n  If(sSourceElement@<>Expand('%v'|numbertostring(nSubstututeDimensionIndex+1)|'%'));\n\
    \   # leave variable as is\n  Else; \n  \n    v2 = If(nSubstututeDimensionIndex = 1, sTargetElement,\
    \ v2);\n    v3 = If(nSubstututeDimensionIndex = 2, sTargetElement, v3);\n    v4 = If(nSubstututeDimensionIndex\
    \ = 3, sTargetElement, v4);\n    v5 = If(nSubstututeDimensionIndex = 4, sTargetElement,\
    \ v5);\n    v6 = If(nSubstututeDimensionIndex = 5, sTargetElement, v6);\n    v7 = If(nSubstututeDimensionIndex\
    \ = 6, sTargetElement, v7);\n    v8 = If(nSubstututeDimensionIndex = 7, sTargetElement,\
    \ v8);\n    v9 = If(nSubstututeDimensionIndex = 8, sTargetElement, v9);\n    v10 = If(nSubstututeDimensionIndex\
    \ = 9, sTargetElement, v10);\n    v11 = If(nSubstututeDimensionIndex = 10, sTargetElement,\
    \ v11);\n    v12 = If(nSubstututeDimensionIndex = 11, sTargetElement, v12);\n    v13 = If(nSubstututeDimensionIndex\
    \ = 12, sTargetElement, v13);\n    v14 = If(nSubstututeDimensionIndex = 13, sTargetElement,\
    \ v14);\n    v15 = If(nSubstututeDimensionIndex = 14, sTargetElement, v15);\n    v16 = If(nSubstututeDimensionIndex\
    \ = 15, sTargetElement, v16);\n    v17 = If(nSubstututeDimensionIndex = 16, sTargetElement,\
    \ v17);\n    v18 = If(nSubstututeDimensionIndex = 17, sTargetElement, v18);\n    v19 = If(nSubstututeDimensionIndex\
    \ = 18, sTargetElement, v19);\n    v20 = If(nSubstututeDimensionIndex = 19, sTargetElement,\
    \ v20);\n    v21 = If(nSubstututeDimensionIndex = 20, sTargetElement, v21);\n    v22 = If(nSubstututeDimensionIndex\
    \ = 21, sTargetElement, v22);\n    v23 = If(nSubstututeDimensionIndex = 22, sTargetElement,\
    \ v23);\n    v24 = If(nSubstututeDimensionIndex = 23, sTargetElement, v24);\n    v25 = If(nSubstututeDimensionIndex\
    \ = 24, sTargetElement, v25);\n    v26 = If(nSubstututeDimensionIndex = 25, sTargetElement,\
    \ v26);\n    v27 = If(nSubstututeDimensionIndex = 26, sTargetElement, v27);\n  EndIf;\n\n\
    Endif;\n\n### Determine dimension Mapping SubStitution ###\nsV2 =If(nMappedDim1=1,  Expand('%'|sMappedV1|'%'),\
    \ If(nNewDim1=1, sNewV1,V1));\nsV3 =If(nMappedDim2=1,  Expand('%'|sMappedV2|'%'), If(nNewDim2=1,\
    \ sNewV2,V2));\nsV4 =If(nMappedDim3=1,  Expand('%'|sMappedV3|'%'), If(nNewDim3=1, sNewV3,V3));\n\
    sV5 =If(nMappedDim4=1,  Expand('%'|sMappedV4|'%'), If(nNewDim4=1, sNewV4,V4));\nsV6 =If(nMappedDim5=1,\
    \  Expand('%'|sMappedV5|'%'), If(nNewDim5=1, sNewV5,V5));\nsV7 =If(nMappedDim6=1,  Expand('%'|sMappedV6|'%'),\
    \ If(nNewDim6=1, sNewV6,V6));\nsV8 =If(nMappedDim7=1,  Expand('%'|sMappedV7|'%'), If(nNewDim7=1,\
    \ sNewV7,V7));\nsV9 =If(nMappedDim8=1,  Expand('%'|sMappedV8|'%'), If(nNewDim8=1, sNewV8,V8));\n\
    sV10 =If(nMappedDim9=1,  Expand('%'|sMappedV9|'%'), If(nNewDim9=1, sNewV9,V9));\nsV11=If(nMappedDim10=1,\
    \ Expand('%'|sMappedV10|'%'),If(nNewDim10=1,sNewV10,V10));\nsV12=If(nMappedDim11=1, Expand('%'|sMappedV11|'%'),If(nNewDim11=1,sNewV11,V11));\n\
    sV13=If(nMappedDim12=1, Expand('%'|sMappedV12|'%'),If(nNewDim12=1,sNewV12,V12));  \nsV14=If(nMappedDim13=1,\
    \ Expand('%'|sMappedV13|'%'),If(nNewDim13=1,sNewV13,V13));  \nsV15=If(nMappedDim14=1, Expand('%'|sMappedV14|'%'),If(nNewDim14=1,sNewV14,V14));\
    \   \nsV16=If(nMappedDim15=1, Expand('%'|sMappedV15|'%'),If(nNewDim15=1,sNewV15,V15)); \
    \ \nsV17=If(nMappedDim16=1, Expand('%'|sMappedV16|'%'),If(nNewDim16=1,sNewV16,V16));  \n\
    sV18=If(nMappedDim17=1, Expand('%'|sMappedV17|'%'),If(nNewDim17=1,sNewV17,V17));  \nsV19=If(nMappedDim18=1,\
    \ Expand('%'|sMappedV18|'%'),If(nNewDim18=1,sNewV18,V18));  \nsV20=If(nMappedDim19=1, Expand('%'|sMappedV19|'%'),If(nNewDim19=1,sNewV19,V19));\
    \  \nsV21=If(nMappedDim20=1, Expand('%'|sMappedV20|'%'),If(nNewDim20=1,sNewV20,V20));  \n\
    sV22=If(nMappedDim21=1, Expand('%'|sMappedV21|'%'),If(nNewDim21=1,sNewV21,V21));  \nsV23=If(nMappedDim22=1,\
    \ Expand('%'|sMappedV22|'%'),If(nNewDim22=1,sNewV22,V22));  \nsV24=If(nMappedDim23=1, Expand('%'|sMappedV23|'%'),If(nNewDim23=1,sNewV23,V23));\
    \  \nsV25=If(nMappedDim24=1, Expand('%'|sMappedV24|'%'),If(nNewDim24=1,sNewV24,V24));  \n\
    sV26=If(nMappedDim25=1, Expand('%'|sMappedV25|'%'),If(nNewDim25=1,sNewV25,V25));  \nsV27=If(nMappedDim26=1,\
    \ Expand('%'|sMappedV26|'%'),If(nNewDim26=1,sNewV26,V26));  \nsV28=If(nMappedDim27=1, Expand('%'|sMappedV27|'%'),If(nNewDim27=1,sNewV27,V27));\n\
    sV29=If(nMappedDim28=1, Expand('%'|sMappedV28|'%'),V28);  \n  \nV1 = V1;\nV2 = sV2; \nV3\
    \ = sV3; \nV4 = sV4; \nV5 = sV5; \nV6 = sV6; \nV7 = sV7; \nV8 = sV8; \nV9 = sV9; \nV10=\
    \ sV10;\nV11= sV11;\nV12= sV12;\nV13= sV13;\nV14= sV14;\nV15= sV15;\nV16= sV16;\nV17= sV17;\n\
    V18= sV18;\nV19= sV19;\nV20= sV20;\nV21= sV21;\nV22= sV22;\nV23= sV23;\nV24= sV24;\nV25=\
    \ sV25;\nV26= sV26;\nV27= sV27;\nV28= sV28;\nV29= sV29;\n \nIf( pSkipInvalidRecords < 1\
    \ );\n  ## Do not check for a valid datapoint (any element that doesn't exist will generate\
    \ error message on CellPut attempt)\nElse;\n  ## Allow records that do not have a valid\
    \ datapoint to be skipped.\n  If( nDimensionCount >= 2 & (DimIx( sDim1, v2 ) = 0 % DimIx(\
    \ sDim2, v3 ) = 0 ) );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 3 & DimIx(\
    \ sDim3, v4 ) = 0 );\n      ItemSkip;\n  EndIf;\n\n  If( nDimensionCount >= 4 & DimIx( sDim4,\
    \ v5 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 5 & DimIx( sDim5,\
    \ v6 ) = 0 );\n      ItemSkip;\n  EndIf;\n\n  If( nDimensionCount >= 6 & DimIx( sDim6, v7\
    \ ) = 0 );\n      ItemSkip;\n  EndIf;\n\n  If( nDimensionCount >= 7 & DimIx( sDim7, v8 )\
    \ = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 8 & DimIx( sDim8, v9 )\
    \ = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 9 & DimIx( sDim9, v10\
    \ ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 10 & DimIx( sDim10,\
    \ v11 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 11 & DimIx( sDim11,\
    \ v12 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 12 & DimIx( sDim12,\
    \ v13 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 13 & DimIx( sDim13,\
    \ v14 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 14 & DimIx( sDim14,\
    \ v15 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 15 & DimIx( sDim15,\
    \ v16 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 16 & DimIx( sDim16,\
    \ v17 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 17 & DimIx( sDim17,\
    \ v18 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 18 & DimIx( sDim18,\
    \ v19 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 19 & DimIx( sDim19,\
    \ v20 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 20 & DimIx( sDim20,\
    \ v21 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 21 & DimIx( sDim21,\
    \ v22 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 22 & DimIx( sDim22,\
    \ v23 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 23 & DimIx( sDim23,\
    \ v24 ) = 0 );\n      ItemSkip;\n  EndIf;\n\n  If( nDimensionCount >= 24 & DimIx( sDim24,\
    \ v25 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 25 & DimIx( sDim25,\
    \ v26 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 26 & DimIx( sDim25,\
    \ v27 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 27 & DimIx( sDim27,\
    \ v28 ) = 0 );\n      ItemSkip;\n  EndIf;\n\nEndIf;\n\n### Write data from source file to\
    \ target cube ###\n\nIf( nDimensionCount = 2 );\n    If( CellIsUpdateable( pCube, v2, v3\
    \ ) = 1 );\n        sElType = DType( sDim2, v3 );\n        If( SubSt( sDim2, 1, 19 ) @=\
    \ '}ElementAttributes_' % SubSt( pCube, 1, 17 ) @= '}ElementSecurity_' );\n            sDim\
    \ = sDim1;\n        ENDIF;\n        \n        If( SubSt( pCube, 1, 17 ) @= '}ElementSecurity_'\
    \ );\n            v4 = If( v4 @= '', 'NONE', v4 );\n            ElementSecurityPut( v4,\
    \ sDim, v2, v3 );\n        ELSEIf( sElType @= 'AS');\n            AttrPutS( v4, sDim, v2,\
    \ v3, 1 );\n        ELSEIf( sElType @= 'AA');\n            AttrPutS( v4, sDim, v2, v3 );\n\
    \        ELSEIf( sElType @= 'AN');\n            AttrPutN( StringToNumberEx(v4, sDecimalSeparator,\
    \ sThousandSeparator), sDim, v2, v3 );\n        ELSEIf( sElType @= 'S');\n            CellPutS(\
    \ v4, pCube, v2, v3 );\n        ElseIf( DimIx( sDim2, v3 ) <> 0 );\n            If(pCumulate\
    \ = 1);\n                nObal = CellGetN( pCube, v2, v3 );\n                nCbal = nObal\
    \ + StringToNumberEx(v4, sDecimalSeparator, sThousandSeparator);\n            ELSE;\n  \
    \              nCbal = StringToNumberEx(v4, sDecimalSeparator, sThousandSeparator);\n  \
    \          Endif;\n            CellPutN( nCbal, pCube, v2, v3 );\n        EndIf;\n    EndIf;\n\
    ElseIf( nDimensionCount = 3 );\n    If( CellIsUpdateable( pCube, v2, v3, v4 ) = 1 );\n \
    \       sElType = DType( sDim3, v4 );\n        If( sElType @<> 'S' );\n            If(pCumulate\
    \ = 1);\n                nObal = CellGetN( pCube, v2, v3, v4 );\n                nCbal =\
    \ nObal + StringToNumberEx(v5, sDecimalSeparator, sThousandSeparator);\n            ELSE;\n\
    \                nCbal = StringToNumberEx(v5, sDecimalSeparator, sThousandSeparator);\n\
    \            Endif;\n            CellPutN( nCbal, pCube, v2, v3, v4 );\n        Else;\n\
    \            CellPutS( v5, pCube, v2, v3, v4 );\n        EndIf;\n    EndIf;\nElseIf( nDimensionCount\
    \ = 4 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5 ) = 1 );\n        sElType = DType(\
    \ sDim4, v5 );\n        If( sElType @<> 'S' );\n            If(pCumulate = 1);\n       \
    \         nObal = CellGetN( pCube, v2, v3, v4, v5 );\n                nCbal = nObal + StringToNumberEx(v6,\
    \ sDecimalSeparator, sThousandSeparator);\n            ELSE;\n                nCbal = StringToNumberEx(v6,\
    \ sDecimalSeparator, sThousandSeparator);\n            Endif;\n            CellPutN( nCbal,\
    \ pCube, v2, v3, v4, v5 );\n        Else;\n            CellPutS( v6, pCube, v2, v3, v4,\
    \ v5 );\n        EndIf;\n    EndIf;\nElseIf( nDimensionCount = 5 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6 ) = 1 );\n      sElType = DType( sDim5, v6 );\n      If( sElType\
    \ @<> 'S' );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4,\
    \ v5, v6 );\n          nCbal = nObal + StringToNumberEx(v7, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v7, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6 );\n      Else;\n  \
    \      CellPutS( v7, pCube, v2, v3, v4, v5, v6 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 6 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7 ) = 1 );\n      sElType\
    \ = DType( sDim6, v7 );\n      If( sElType @<> 'S' );\n        If(pCumulate = 1);\n    \
    \      nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7 );\n          nCbal = nObal + StringToNumberEx(v8,\
    \ sDecimalSeparator, sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v8,\
    \ sDecimalSeparator, sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube,\
    \ v2, v3, v4, v5, v6, v7 );\n      Else;\n        CellPutS( v8, pCube, v2, v3, v4, v5, v6,\
    \ v7 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 7 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8 ) = 1 );\n      sElType = DType( sDim7, v8 );\n    \
    \  If( sElType @<> 'S' );\n        If( pCumulate = 1);\n          nObal = CellGetN( pCube,\
    \ v2, v3, v4, v5, v6, v7, v8 );\n          nCbal = nObal + StringToNumberEx(v9, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v9, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8 );\n      Else;\n        CellPutS( v9, pCube, v2, v3, v4, v5, v6, v7, v8 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 8 );\n    If( CellIsUpdateable( pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9 ) = 1 );\n      sElType = DType( sDim8, v9 );\n      If(\
    \ sElType @<> 'S' );\n        If( pCumulate = 1);\n          nObal = CellGetN( pCube, v2,\
    \ v3, v4, v5, v6, v7, v8, v9 );\n          nCbal = nObal + StringToNumberEx(v10, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v10, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9 );\n      Else;\n        CellPutS( v10, pCube, v2, v3, v4, v5, v6, v7,\
    \ v8, v9 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 9 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10 ) = 1 );\n      sElType = DType( sDim9, v10\
    \ );\n      If( sElType @<> 'S' );\n        If( pCumulate = 1);\n          nObal = CellGetN(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10 );\n          nCbal = nObal + StringToNumberEx(v11,\
    \ sDecimalSeparator, sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v11,\
    \ sDecimalSeparator, sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10 );\n      Else;\n        CellPutS( v11, pCube, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 10 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 ) =\
    \ 1 );\n      sElType = DType( sDim10, v11 );\n      If( sElType @<> 'S' );\n        If(pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 );\n\
    \          nCbal = nObal + StringToNumberEx(v12, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v12, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\
    \ );\n      Else;\n        CellPutS( v12, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 11 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 ) = 1 );\n      sElType = DType(\
    \ sDim11, v12 );\n      If( sElType @<> 'S' );\n        If(pCumulate = 1);\n          nObal\
    \ = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );\n          nCbal =\
    \ nObal + StringToNumberEx(v13, sDecimalSeparator, sThousandSeparator);\n        ELSE;\n\
    \          nCbal = StringToNumberEx(v13, sDecimalSeparator, sThousandSeparator);\n     \
    \   Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12\
    \ );\n      Else;\n        CellPutS( v13, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 12 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 ) = 1 );\n      sElType = DType(\
    \ sDim12, v13 );\n      If( sElType @<> 'S' );\n        If( pCumulate = 1);\n          nObal\
    \ = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 );\n          nCbal\
    \ = nObal + StringToNumberEx(v14, sDecimalSeparator, sThousandSeparator);\n        ELSE;\n\
    \          nCbal = StringToNumberEx(v14, sDecimalSeparator, sThousandSeparator);\n     \
    \   Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13 );\n      Else;\n        CellPutS( v14, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10,\
    \ v11, v12, v13 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 13 );\n    If(\
    \ CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 ) = 1\
    \ );\n      sElType = DType( sDim13, v14 );\n      If( sElType @<> 'S' );\n        If(pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14 );\n          nCbal = nObal + StringToNumberEx(v15, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v15, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14 );\n      Else;\n        CellPutS( v15, pCube, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount =\
    \ 14 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15 ) = 1 );\n      sElType = DType( sDim14, v15 );\n      If( sElType @<> 'S'\
    \ );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15 );\n          nCbal = nObal + StringToNumberEx(v16,\
    \ sDecimalSeparator, sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v16,\
    \ sDecimalSeparator, sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );\n      Else;\n       \
    \ CellPutS( v16, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 15 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 ) = 1 );\n  \
    \    sElType = DType( sDim15, v16 );\n      If( sElType @<> 'S' );\n        If(pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16 );\n          nCbal = nObal + StringToNumberEx(v17, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v17, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );\n      Else;\n        CellPutS( v17,\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );\n      EndIf;\n\
    \    EndIf;\n  ElseIf( nDimensionCount = 16 );\n    If( CellIsUpdateable( pCube, v2, v3,\
    \ v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 ) = 1 );\n      sElType\
    \ = DType( sDim16, v17 );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\n          nCbal\
    \ = nObal + StringToNumberEx(v18, sDecimalSeparator, sThousandSeparator);\n        ELSE;\n\
    \          nCbal = StringToNumberEx(v18, sDecimalSeparator, sThousandSeparator);\n     \
    \   Endif;\n      If( sElType @<> 'S' );\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\n      Else;\n        CellPutS(\
    \ v18, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 17 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 ) =\
    \ 1 );\n      sElType = DType( sDim17, v18 );\n      If( sElType @<> 'S' );\n        If(pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18 );\n          nCbal = nObal + StringToNumberEx(v19, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v19, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );\n      Else;\n        CellPutS(\
    \ v19, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 18 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19\
    \ ) = 1 );\n      sElType = DType( sDim18, v19 );\n      If( sElType @<> 'S' );\n      \
    \  If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9,\
    \ v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );\n          nCbal = nObal + StringToNumberEx(v20,\
    \ sDecimalSeparator, sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v20,\
    \ sDecimalSeparator, sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );\n\
    \      Else;\n        CellPutS( v20, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 19 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19, v20 ) = 1 );\n      sElType = DType( sDim19, v20 );\n\
    \      If( sElType @<> 'S' );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20\
    \ );\n          nCbal = nObal + StringToNumberEx(v21, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v21, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20 );\n      Else;\n        CellPutS( v21, pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 20 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\
    \ v20, v21 ) = 1 );\n      sElType = DType( sDim20, v21 );\n      If( sElType @<> 'S' );\n\
    \        If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7,\
    \ v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );\n          nCbal\
    \ = nObal + StringToNumberEx(v22, sDecimalSeparator, sThousandSeparator);\n        ELSE;\n\
    \          nCbal = StringToNumberEx(v22, sDecimalSeparator, sThousandSeparator);\n     \
    \   Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19, v20, v21 );\n      Else;\n        CellPutS( v22, pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20,\
    \ v21 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 21 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\
    \ v20, v21, v22 ) = 1 );\n      sElType = DType( sDim21, v22 );\n      If( sElType @<> 'S'\
    \ );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );\n     \
    \     nCbal = nObal + StringToNumberEx(v23, sDecimalSeparator, sThousandSeparator);\n  \
    \      ELSE;\n          nCbal = StringToNumberEx(v23, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );\n      Else;\n        CellPutS(\
    \ v23, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21, v22 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 22 );\n \
    \   If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22, v23 ) = 1 );\n      sElType = DType( sDim22, v23\
    \ );\n      If( sElType @<> 'S' );\n        If(pCumulate = 1);\n          nObal = CellGetN(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\
    \ v20, v21, v22, v23 );\n          nCbal = nObal + StringToNumberEx(v24, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v24, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23 );\n\
    \      Else;\n        CellPutS( v24, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23 );\n      EndIf;\n    EndIf;\n \
    \ ElseIf( nDimensionCount = 23 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n    v23,\
    \ v24 ) = 1 );\n      sElType = DType( sDim23, v24 );\n      If( sElType @<> 'S' );\n  \
    \      If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n            v23,\
    \ v24 );\n          nCbal = nObal + StringToNumberEx(v25, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v25, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n          v23, v24 );\n      Else;\n\
    \        CellPutS( v25, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22, v23, v24 );\n      EndIf;\n    EndIf;\n  ElseIf(\
    \ nDimensionCount = 24 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n      v23, v24,\
    \ v25 ) = 1 );\n      sElType = DType( sDim24, v25 );\n      If( sElType @<> 'S' );\n  \
    \      If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n            v23,\
    \ v24, v25 );\n          nCbal = nObal + StringToNumberEx(v26, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v26, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n          v23, v24, v25 );\n \
    \     Else;\n        CellPutS( v26, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n          v23, v24, v25 );\n      EndIf;\n\
    \    EndIf;\n  ElseIf( nDimensionCount = 25 );\n    If( CellIsUpdateable( pCube, v2, v3,\
    \ v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n\
    \      v23, v24, v25, v26 ) = 1 );\n      sElType = DType( sDim25, v26 );\n      If( sElType\
    \ @<> 'S' );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4,\
    \ v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n\
    \            v23, v24, v25, v26 );\n          nCbal = nObal + StringToNumberEx(v27, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v27, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n   \
    \       v23, v24, v25, v26 );\n      Else;\n        CellPutS( v27, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n   \
    \       v23, v24, v25, v26 );\n      EndIf;\n    EndIf;\nElseIf( nDimensionCount = 26 );\n\
    \    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22,\n    v23, v24, v25, v26, v27 ) = 1 );\n      sElType\
    \ = DType( sDim26, v27 );\n      If( sElType @<> 'S' );\n        If( pCumulate = 1);\n \
    \         nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22,\n            v23, v24, v25, v26, v27 );\n    \
    \      nCbal = nObal + StringToNumberEx(v28, sDecimalSeparator, sThousandSeparator);\n \
    \       ELSE;\n          nCbal = StringToNumberEx(v28, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n        v23, v24, v25, v26, v27\
    \ );\n      Else;\n        CellPutS( v28, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n          v22, v23, v24, v25, v26,\
    \ v27 );\n      EndIf;\n    EndIf;\nElseIf( nDimensionCount = 27 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\
    \ v20, v21, v22,\n    v23, v24, v25, v26, v27, v28 ) = 1 );\n      sElType = DType( sDim27,\
    \ v28 );\n      If( sElType @<> 'S' );\n        If(pCumulate = 1);\n          nObal = CellGetN(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\
    \ v20, v21, v22,\n            v23, v24, v25, v26, v27, v28 );\n          nCbal = nObal +\
    \ StringToNumberEx(v29, sDecimalSeparator, sThousandSeparator);\n        ELSE;\n       \
    \   nCbal = StringToNumberEx(v29, sDecimalSeparator, sThousandSeparator);\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22,\n          v23, v24, v25, v26, v27, v28 );\n \
    \     Else;\n        CellPutS( v29, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19, v20, v21,\n          v22, v23, v24, v25, v26, v27,\
    \ v28 );\n      EndIf;\n    EndIf;\n\n\n  EndIf;\n  \n## Increase Record count\nnRecordPostedCount\
    \ = nRecordPostedCount + 1;\n### End Data ###\n#Section Epilog\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Cube Logging\nIf ( pCubeLogging <= 1 );\n  CubeSetLogChanges(\
    \ pCube, If(sCubeLogging@='YES',1,0) );\nEndIf;\n    \n### Delete source file (only if no\
    \ errors) ###\nIf( nErrors = 0 & pFileDelete = 1 );\n    ASCIIDelete(sFile);\nEndIf;\n \
    \   \n### If errors occurred terminate process with a major error status ###\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 major error and consequently aborted.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for\
    \ details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    EndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\nElse;\n    sProcessAction = Expand(\
    \ 'Process:%cThisProcName% successfully imported data from file %sFile%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO"
- question: 'This Turbo Integrator process loads a CSV file into the target cube. It is intended
    for development, prototyping, or production environments. The process imports data from
    another TM1 model and to eliminate the possibility of locking, it is sometimes better to
    export and then import when copying data from one cube to another rather than copying directly.
    Note: A valid target cube name (pCube) is mandatory, otherwise the process will abort. Element
    mapping for new dimensions (pMappingToNewDims) is also required when the target cube has
    more dimensions than the source; otherwise, the process will abort. The default input path
    is the same as the error file path if not specified. If the file name is left blank, the
    process will look for a file called pCube_Export.csv. The expected file format follows the
    standard CMA export: v1 specifies the cube name, subsequent fields specify the cube address
    (individual element names). vN specifies the cell data value to load, with provision for
    files with header rows. Format of filter row for Zero out: v1 specifies source cube name,
    v2 must be ''Filter'', v3 specifies the filter to be used to zero out. Please note if the
    target cube has additional dimensions, this is the final filter used if pMappingToNewDims
    is not specified. All elements in additional dimensions will be cleaned. v4 specifies the
    dimension delimiter used in the filter. v5 specifies the element start delimiter used in
    the filter. v6 specifies the element delimiter used in the filter. Note about Zero out:
    if pMappingToNewDims parameter is specified, it will be concatenated to the filter in the
    file to restrict the cube slice to be zeroed out. Similarly, if pDim is specified, the source
    element is substituted with the target one should it be in the filter string. In both cases,
    the delimiters in the source file must match the delimiters passed in parameters of this
    process.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will load a csv text file to the target cube.\n\
    \n# Use case: Intended for development/prototyping or in Production environment.\n#1/ Import\
    \ data from another TM1 model.\n#2/ To eliminate possibility of locking it is sometimes\
    \ better to export and import when needing to copy data from one cube to another.\n\n# Note:\n\
    # Naturally, a valid target cube name (pCube) is mandatory otherwise the process will abort.\n\
    # Element mapping for new dimensions (pMappingToNewDims ) is also required when the target\
    \ cube has more dimensions than the source, otherwise the process will abort.\n# The default\
    \ input path is the same as the error file path if not specified.\n# If the file name is\
    \ left blank, the process will look for a file called pCube_Export.csv.\n\n# Format:\n#\
    \ The assumed file format is as per standard CMA export:\n# - v1 specIfies cube name, subsequent\
    \ fields specify cube address ( individual element names ).\n# - vN specIfies cell data\
    \ value to load. With provision for files with header rows.\n# Format of filter row for\
    \ Zero out:\n# - v1 specifies source cube name\n# - v2 must be equal to 'Filter'.\n# - v3\
    \ specifies the filter to be used to zero out. Please note if target cube has additional\
    \ dimensions this is the final filter used if pMappingToNewDims is not speficied. All the\
    \ elements in additional dimensions will be cleaned \n# - v4 specifies the dimension delimiter\
    \ used in filter\n# - v5 specifies the element start delimiter used in filter\n# - v6 specifies\
    \ the element delimiter used in filter\n# Note about the Zero out:\n# if pMappingToNewDims\
    \ parameter is specified, it will be concatenated to the filter in the file to restict the\
    \ cube slice to be zeroed out. Similarly, if pDim is specified the source element is substituted\
    \ with the targed one, sould it be in the filter string\n# in both cases the delimiters\
    \ in the source file must match the delimiters passed in parameters of this process.\n#EndRegion\
    \ @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pSrcDir:%pSrcDir%, pSrcFile:%pSrcFile%, pCube:%pCube%, pDim:%pDim%,\
    \ pSrcEle:%pSrcEle%, pTgtEle:%pTgtEle%, pTitleRows:%pTitleRows%, pDelim:%pDelim%, pQuote:%pQuote%,\
    \ pCumulate:%pCumulate%, pCubeLogging:%pCubeLogging%, pSandbox:%pSandbox%, pZeroFilter:%pZeroFilter%,\
    \ pMappingToNewDims:%pMappingToNewDims%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%.';   \ncMinLenASCIICode = 2;\ncMaxLenASCIICode = 3;\n\npDelimiter\
    \        = TRIM(pDelim);\nsDelimDim           = TRIM(pDimDelim);\nsElementStartDelim  =\
    \ TRIM(pElEStartDelim);\nsDelimElem          = TRIM(pEleDelim);\npDecimalSeparator   = TRIM(pDecimalSeparator);\n\
    pThousandSeparator  = TRIM(pThousandSeparator);\n\n## LogOutput parameters\nIf( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnRecordProcessedCount\
    \   = 0;\nnRecordPostedCount      = 0;\nnErrors                 = 0;\n\n\n### Validate Parameters\
    \ ###\npSourceDir    = TRIM(pSrcDir);\npSourceFile   = TRIM(pSrcFile);\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate source\
    \ directory\nIf(Trim( pSourceDir ) @= '' );\n    pSourceDir = GetProcessErrorFileDirectory;\n\
    EndIf;\n\nIf( SubSt( pSourceDir, Long( pSourceDir ), 1 ) @= sOSDelim );\n  pSourceDir =\
    \ SubSt( pSourceDir, 1, Long( pSourceDir ) - 1 );\nEndIf;\n\nIf( FileExists( pSourceDir\
    \ ) = 0 );\n  sMessage = 'Invalid source directory specified: folder does not exist.';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\nIf( pSourceFile @= '' );\n    pSourceFile = Expand('%pCube%_Export.csv');\nEndIf;\n\
    \nsFile = pSourceDir | sOSDelim | pSourceFile;\n# Validate source file\nIf( FileExists(\
    \ sFile ) = 0 );\n  sMessage = 'Invalid source file specified: file does not exist in directory:'\
    \ | sFile;\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Automatic file deletion\nIf( pFileDelete <> 1 );\n    pFileDelete =\
    \ 0;\nEndIf;\n\n# Skip invalid records\nIf( pSkipInvalidRecords <> 1 );\n    pSkipInvalidRecords\
    \ = 0;\nEndIf;\n\n## Validate cube\nIf( Trim( pCube ) @= '' );\n  sMessage = 'No target\
    \ cube specified.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n  sMessage = 'Invalid target cube specified:\
    \ ' | pCube;\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate file delimiter & quote character\nIf( pDelimiter @= '' );\n\
    \    pDelimiter = ',';\nElse;\n    # If length of pDelimiter is between 2 and 3 chars and\
    \ each of them is decimal digit, then the pDelimiter is entered as ASCII code\n    If (\
    \ LONG(pDelimiter) <= cMaxLenASCIICode & LONG(pDelimiter) >= cMinLenASCIICode  );\n    \
    \  nValid = 1;\n      nChar = 1;\n      While ( nChar <= LONG(pDelimiter) );\n        If(\
    \ CODE( pDelimiter, nChar ) < CODE( '0', 1 ) % CODE( pDelimiter, nChar ) > CODE( '9', 1\
    \ ) );\n          nValid = 0;\n          Break;\n        EndIf;\n        nChar = nChar +\
    \ 1;\n      End;\n      If ( nValid<>0 );\n        pDelimiter=CHAR(StringToNumber( pDelimiter\
    \ ));\n      EndIf;\n    EndIf;\nEndIf;\n\nIf( pQuote @= '' );\n    ## Use no quote character\
    \ \nElse;\n    # If length of pQuote is between 2 and 3 chars and each of them is decimal\
    \ digit, then the pQuote is entered as ASCII code\n    If ( LONG(pQuote) <= cMaxLenASCIICode\
    \ & LONG(pQuote) >= cMinLenASCIICode);\n      nValid = 1;\n      nChar = 1;\n      While\
    \ ( nChar <= LONG(pQuote) );\n        If( CODE( pQuote, nChar ) < CODE( '0', 1 ) % CODE(\
    \ pQuote, nChar ) > CODE( '9', 1 ) );\n          nValid = 0;\n          Break;\n       \
    \ EndIf;\n        nChar = nChar + 1;\n      End;\n      If ( nValid<>0 );\n        pQuote=CHAR(StringToNumber(\
    \ pQuote ));\n      EndIf;\n    EndIf;\nEndIf;\n\nIf ( LONG(pDecimalSeparator) <= cMaxLenASCIICode\
    \ & LONG(pDecimalSeparator) >= cMinLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While\
    \ ( nChar <= LONG(pDecimalSeparator) );\n    If( CODE( pDecimalSeparator, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pDecimalSeparator, nChar ) <= CODE( '9', 1 ) );\n      nValid = 1;\n\
    \    Else;\n      nValid = 0;\n      Break;\n    EndIf;\n    nChar = nChar + 1;\n  End;\n\
    \  If ( nValid<>0 );\n    pDecimalSeparator = CHAR(StringToNumber( pDecimalSeparator ));\n\
    \  Else;\n    pDecimalSeparator = SubSt( Trim( pDecimalSeparator ), 1, 1 );\n  EndIf;\n\
    EndIf;\nsDecimalSeparator = pDecimalSeparator;\n\nIf ( LONG(pThousandSeparator) <= cMaxLenASCIICode\
    \ & LONG(pThousandSeparator) >= cMinLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While\
    \ ( nChar <= LONG(pThousandSeparator) );\n    If( CODE( pThousandSeparator, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pThousandSeparator, nChar ) <= CODE( '9', 1 ) );\n      nValid = 1;\n\
    \    Else;\n      nValid = 0;\n      Break;\n    EndIf;\n    nChar = nChar + 1;\n  End;\n\
    \  If ( nValid<>0 );\n    pThousandSeparator = CHAR(StringToNumber( pThousandSeparator ));\n\
    \  Else;\n    pThousandSeparator = SubSt( Trim( pThousandSeparator ), 1, 1 );\n  EndIf;\n\
    EndIf;\nsThousandSeparator = pThousandSeparator;\n\n# Validate Sandbox\nIf( TRIM( pSandbox\
    \ ) @<> '' );\n    If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty(\
    \ 0 );\n        nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is\
    \ invalid for the current user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        ServerActiveSandboxSet( pSandbox );\n        SetUseActiveSandboxProperty(\
    \ 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty( 0 );\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate Dimension\n\
    pDimension      = TRIM( pDim);\npSourceElement  = TRIM(pSrcEle);\npTargetElement  = TRIM(pTgtEle);\n\
    \nIf( pDimension @<> '');\n    \n  If( DimensionExists( pDimension ) = 0 );\n    sMessage\
    \ = 'Invalid dimension specified: ' | pDimension;\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  EndIf;\n\n  # Validate Source Element\n\
    \  If( pSourceElement @= '' );\n    sMessage = 'Error: The Source Element parameter is blank.';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \  EndIf;\n\n  If( DimIx( pDimension, pSourceElement ) = 0 );\n    sMessage = 'Invalid source\
    \ element, ' | pSourceElement | ' specified for ' | pDimension | ' dimension.';\n    nErrors\
    \ = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  EndIf;\n\
    \  sSourceElement = DimensionElementPrincipalName( pDimension, pSourceElement);\n\n  # Validate\
    \ Target Element\n  If( pTargetElement @= '' );\n    sMessage = 'Error: The Target Element\
    \ parameter is blank.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n  ElseIf( DimIx( pDimension, pTargetElement ) = 0 );\n    sMessage\
    \ = 'Invalid target element, ' | pTargetElement | ' specified for ' | pDimension | ' dimension.';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \  EndIf;\n  sTargetElement = DimensionElementPrincipalName( pDimension, pTargetElement);\n\
    \nENDIF;\n\n## Validate delimiter\n\nIf( pDelimiter @= '' );\n  sMessage = 'Error: The file\
    \ delimiter parameter is blank.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( Long( pDelimiter ) > 1 );\n  sMessage = 'Invalid\
    \ delimiter specified: ' | pDelimiter | ' field delimiter must be single character or 2-3\
    \ symbols number representing ASCII code.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate quote character\nIf( Long( pQuote\
    \ ) > 1 );\n  sMessage = 'Invalid string qualIfier: ' | pQuote | ' quote character must\
    \ be single character or empty string or 2-3 symbols number representing ASCII code.';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Determine\
    \ number of dims in target cube ###\nnCount = 1;\nnSubstututeDimensionIndex = 0;\nWhile(\
    \ \nTabDim( pCube, nCount ) @<> '' );\n  sDimension = TabDim( pCube, nCount );\n  If( sDimension\
    \ @= pDimension );\n    nSubstututeDimensionIndex = nCount;\n  EndIf;\n  nCount = nCount\
    \ + 1;\nEnd;\nnDimensionCount = nCount - 1;\n\n## Validate the dimension is part of the\
    \ cube.\nIf( pDimension @= '');\n  ## CONTINUE;\nELSEIf( nSubstututeDimensionIndex = 0 );\n\
    \    sMessage = 'Specified dimension: ' | pDimension | ' is not a component of the cube:\
    \ ' | pCube;\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nENDIF;\n\n        ## Default filter delimiters\n        If( pDimDelim     @= ''\
    \ );\n            pDimDelim     = '&';\n        EndIf;\n        If( pEleStartDelim@= ''\
    \ );\n            pEleStartDelim= '¦';\n        EndIf;\n        If( pEleDelim     @= ''\
    \ );\n            pEleDelim     = '+';\n        EndIf;\n        \n\nIf( nDimensionCount\
    \ > 27 );\n  sMessage = 'Cube has too many dimensions: ' | pCube | ' max 27 dimensions.';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Determine\
    \ dimensions in target cube, we need to know this to test cell type before loading ###\n\
    sDim1  = TabDim( pCube, 1 );\nsDim2  = TabDim( pCube, 2 );\nsDim3  = TabDim( pCube, 3 );\n\
    sDim4  = TabDim( pCube, 4 );\nsDim5  = TabDim( pCube, 5 );\nsDim6  = TabDim( pCube, 6 );\n\
    sDim7  = TabDim( pCube, 7 );\nsDim8  = TabDim( pCube, 8 );\nsDim9  = TabDim( pCube, 9 );\n\
    sDim10 = TabDim( pCube, 10 );\nsDim11 = TabDim( pCube, 11 );\nsDim12 = TabDim( pCube, 12\
    \ );\nsDim13 = TabDim( pCube, 13 );\nsDim14 = TabDim( pCube, 14 );\nsDim15 = TabDim( pCube,\
    \ 15 );\nsDim16 = TabDim( pCube, 16 );\nsDim17 = TabDim( pCube, 17 );\nsDim18 = TabDim(\
    \ pCube, 18 );\nsDim19 = TabDim( pCube, 19 );\nsDim20 = TabDim( pCube, 20 );\nsDim21 = TabDim(\
    \ pCube, 21 );\nsDim22 = TabDim( pCube, 22 );\nsDim23 = TabDim( pCube, 23 );\nsDim24 = TabDim(\
    \ pCube, 24 );\nsDim25 = TabDim( pCube, 25 );\nsDim26 = TabDim( pCube, 26 );\nsDim27 = TabDim(\
    \ pCube, 27 );\n\n### Placeholders for mappped dimensions and for new dimensions\n\nnMappedDim1\
    \ = 0;\tsMappedV1 = '';\t\tnNewDim1 = 0;\t  sNewV1 = '';\nnMappedDim2 = 0;\tsMappedV2 =\
    \ '';\t\tnNewDim2 = 0;\t  sNewV2 = '';\nnMappedDim3 = 0;\tsMappedV3 = '';\t\tnNewDim3 =\
    \ 0;\t  sNewV3 = '';\nnMappedDim4 = 0;\tsMappedV4 = '';\t\tnNewDim4 = 0;\t  sNewV4 = '';\n\
    nMappedDim5 = 0;\tsMappedV5 = '';\t\tnNewDim5 = 0;\t  sNewV5 = '';\nnMappedDim6 = 0;\tsMappedV6\
    \ = '';\t\tnNewDim6 = 0;\t  sNewV6 = '';\nnMappedDim7 = 0;\tsMappedV7 = '';\t\tnNewDim7\
    \ = 0;\t  sNewV7 = '';\nnMappedDim8 = 0;\tsMappedV8 = '';\t\tnNewDim8 = 0;\t  sNewV8 = '';\n\
    nMappedDim9 = 0;\tsMappedV9 = '';\t\tnNewDim9 = 0;\t  sNewV9 = '';\nnMappedDim10 = 0;\t\
    sMappedV10 = '';\tnNewDim10 = 0;\tsNewV10 = '';\nnMappedDim11 = 0;\tsMappedV11 = '';\tnNewDim11\
    \ = 0;\tsNewV11 = '';\nnMappedDim12 = 0;\tsMappedV12 = '';\tnNewDim12 = 0;\tsNewV12 = '';\n\
    nMappedDim13 = 0;\tsMappedV13 = '';\tnNewDim13 = 0;\tsNewV13 = '';\nnMappedDim14 = 0;\t\
    sMappedV14 = '';\tnNewDim14 = 0;\tsNewV14 = '';\nnMappedDim15 = 0;\tsMappedV15 = '';\tnNewDim15\
    \ = 0;\tsNewV15 = '';\nnMappedDim16 = 0;\tsMappedV16 = '';\tnNewDim16 = 0;\tsNewV16 = '';\n\
    nMappedDim17 = 0;\tsMappedV17 = '';\tnNewDim17 = 0;\tsNewV17 = '';\nnMappedDim18 = 0;\t\
    sMappedV18 = '';\tnNewDim18 = 0;\tsNewV18 = '';\nnMappedDim19 = 0;\tsMappedV19 = '';\tnNewDim19\
    \ = 0;\tsNewV19 = '';\nnMappedDim20 = 0;\tsMappedV20 = '';\tnNewDim20 = 0;\tsNewV20 = '';\n\
    nMappedDim21 = 0;\tsMappedV21 = '';\tnNewDim21 = 0;\tsNewV21 = '';\nnMappedDim22 = 0;\t\
    sMappedV22 = '';\tnNewDim22 = 0;\tsNewV22 = '';\nnMappedDim23 = 0;\tsMappedV23 = '';\tnNewDim23\
    \ = 0;\tsNewV23 = '';\nnMappedDim24 = 0;\tsMappedV24 = '';\tnNewDim24 = 0;\tsNewV24 = '';\n\
    nMappedDim25 = 0;\tsMappedV25 = '';\tnNewDim25 = 0;\tsNewV25 = '';\nnMappedDim26 = 0;\t\
    sMappedV26 = '';\tnNewDim26 = 0;\tsNewV26 = '';\nnMappedDim27 = 0;\tsMappedV27 = '';\tnNewDim27\
    \ = 0;\tsNewV27 = '';\n                  sMappedV28 = '';\n\n###########################################\n\
    ### SPLIT MAPPING TO NEW DIMS PARAMETER ###\n###########################################\n\
    \nnTargetCubeDimensionCount   = nDimensionCount;\n\nsElementMapping = TRIM( pMappingToNewDims\
    \ );\nnChar = 1;\nnCharCount = LONG( sElementMapping );\n\nsTargetFilter = '';\nsWord =\
    \ '';\nsLastDelim = '';\nnIndex = 1;\n\n# Add a trailing element delimiter so that the last\
    \ element is picked up\nIf( nCharCount > 0 );\n  sElementMapping = sElementMapping | sDelimDim;\n\
    \  nCharCount = nCharCount + LONG(sDelimDim);\nEndIf;\n\nWHILE (nChar <= nCharCount);\n\
    \    sChar = SUBST( sElementMapping, nChar, 1);\n\n    # Used for delimiters, required for\
    \ multiple character delimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n    # Ignore spaces\n\
    \    IF (TRIM(sChar) @<> '' );\n\n      ### Dimension Name ###\n\n      # If the delimiter\
    \ is more than 1 character peek ahead the same amount\n      # Ignore the first character\n\
    \      sDelim = sChar;\n      nCount = LONG(sElementStartDelim) - 1;\n      If( nCount >\
    \ 0 & nChar + nCount <= nCharCount );\n        # Add the extra characters\n        sDelim\
    \ = sDelim | SUBST( sElementMapping, nChar + 1, nCount);\n        # Move to the end of the\
    \ delimter\n\n      EndIf;\n\n      If( sDelim @= sElementStartDelim );\n        nAddExtra\
    \ = nCount;\n        sChar = sDelim;\n\n        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim\
    \ );\n            sMessage = 'In pMappingToNewDims the name of a dimension must follow a\
    \ dimension delimiter (' | sDelimDim | ')';\n            nErrors = nErrors + 1;\n      \
    \      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            #ProcessError();\n\
    \        EndIf;\n\n        # Found a dimension\n        sDimension = sWord;\n\n        If(\
    \ DimensionExists( sDimension ) = 0 );\n            # The dimension does not exist in the\
    \ model. Cancel process\n            sMessage = 'In pMappingToNewDims - Dimension: ' | sDimension\
    \ | ' does not exist';\n            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n            #ProcessError();\n        EndIf;\n        \n\
    \        ### Determine the dimension is a member of the cube ###\n        nMapCount = 1;\n\
    \        nMapDimensionIndex = 0;\n        While( TabDim( pCube, nMapCount ) @<> '' );\n\
    \            sMapCubeDimName = TabDim( pCube, nMapCount );\n            If( sDimension @=\
    \ sMapCubeDimName );\n                nMapDimensionIndex = nMapCount;\n            EndIf;\n\
    \            nMapCount = nMapCount + 1;\n        End;\n\n        If( nMapDimensionIndex\
    \ = 0 );\n            # The dimension does not exist in the cube. Cancel process\n     \
    \       sMessage = 'Dimension: ' | sDimension | ' is not a member of: '| pCube | ' cube.';\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n  \
    \          Else;\n                ProcessBreak;\n            EndIf;\n        EndIf;\n\n\
    \        # Find the index of the dimension is in the Target cube\n        nTargetIndexCounter\
    \ = 1;\n\n        WHILE(nTargetIndexCounter <= nTargetCubeDimensionCount );\n          sNthDimension\
    \ = TabDim( pCube, nTargetIndexCounter );\n\n          If(sDimension @= sNthDimension);\n\
    \            nTargetIndex = nTargetIndexCounter;\n            nTargetIndexCounter = 1000;\n\
    \          EndIf;\n\n          nTargetIndexCounter = nTargetIndexCounter + 1;\n        END;\n\
    \        \n        #Add to the Target filter\n        If(sTargetFilter@='');\n         \
    \ sTargetFilter=sDimension;          \n        Else;\n          sTargetFilter=sTargetFilter|sDelimDim|sDimension;\n\
    \        Endif;  \n          \n        sLastDelim = sChar;\n        # Clear the word\n \
    \       sWord = '';\n\n      Else;\n\n        # Reset extra chars\n        nAddExtra = 0;\n\
    \n        ### Check both dim delimiter and element delimiter ###\n        nIsDelimiter =\
    \ 0;\n\n        ## Check dimension delimiter first\n        # If the delimiter is more than\
    \ 1 character peek ahead the same amount\n        # Ignore the first character\n       \
    \ sDelim = sChar;\n        nCount = LONG(sDelimDim) - 1;\n        If( nCount > 0 & nChar\
    \ + nCount <= nCharCount );\n          # Add the extra characters\n          sDelim = sDelim\
    \ | SUBST( sElementMapping, nChar + 1, nCount);\n          # Move to the end of the delimter\n\
    \          \n        EndIf;\n\n        If( sDelim @= sDelimDim );\n          nIsDelimiter\
    \ = 1;\n          sChar = sDelim;\n          nAddExtra = nCount;\n        EndIf;\n\n   \
    \     If ( nIsDelimiter = 1 );\n\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim\
    \ );\n            sMessage = 'In pMappingToNewDims - an element delimiter must follow a\
    \ dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';\n            nErrors\
    \ = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \            #ProcessError();\n          EndIf;\n\n          # an element has been found\n\
    \          sElement = sWord;\n\n          If( DimIx( sDimension, sElement ) = 0 );\n   \
    \           # The element does not exist in the dimension. Cancel process\n            \
    \  sMessage = 'In pMappingToNewDims - Element: ' | sElement | ' in dimension ' | sDimension\
    \ | ' does not exist';\n              nErrors = nErrors + 1;\n              LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n              #ProcessError();\n          EndIf;\n\n  \
    \        # Allow consolidations only if pSuppressConsol is set to 0\n\n          If ( DTYPE(\
    \ sDimension, sElement) @= 'C' );\n            sMessage = Expand( 'In pMappingToNewDims\
    \ - Target element: %sElement% for dimension %sDimension% is consolidated' );\n        \
    \    nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            #ProcessError();\n          Endif;  \n          \n\n          # Add\
    \ the element to the source or target depending on whether it's the first or the second\
    \ element\n          # Get principal name\n          # in case source element and this element\
    \ are using different aliases\n\n          sElement = DimensionElementPrincipalName(sDimension,sElement);\n\
    \n          ### Update the variable for InputElement Target Dim ######################################\n\
    \          If(nTargetIndex = 1);\n            nNewDim1 = 1;\n            sNewV1 = sElement;\n\
    \          ElseIf(nTargetIndex = 2);\n            nNewDim2 = 1;\n            sNewV2 = sElement;\n\
    \          ElseIf(nTargetIndex = 3);\n            nNewDim3 = 1;\n            sNewV3 = sElement;\n\
    \          ElseIf(nTargetIndex = 4);\n            nNewDim4 = 1;\n            sNewV4 = sElement;\n\
    \          ElseIf(nTargetIndex = 5);\n            nNewDim5 = 1;\n            sNewV5 = sElement;\n\
    \          ElseIf(nTargetIndex = 6);\n            nNewDim6 = 1;\n            sNewV6 = sElement;\n\
    \          ElseIf(nTargetIndex = 7);\n            nNewDim7 = 1;\n            sNewV7 = sElement;\n\
    \          ElseIf(nTargetIndex = 8);\n            nNewDim8 = 1;\n            sNewV8 = sElement;\n\
    \          ElseIf(nTargetIndex = 9);\n            nNewDim9 = 1;\n            sNewV9 = sElement;\n\
    \          ElseIf(nTargetIndex = 10);\n            nNewDim10 = 1;\n            sNewV10 =\
    \ sElement;\n          ElseIf(nTargetIndex = 11);\n            nNewDim11 = 1;\n        \
    \    sNewV11 = sElement;\n          ElseIf(nTargetIndex = 12);\n            nNewDim12 =\
    \ 1;\n            sNewV12 = sElement;\n          ElseIf(nTargetIndex = 13);\n          \
    \  nNewDim13 = 1;\n            sNewV13 = sElement;\n          ElseIf(nTargetIndex = 14);\n\
    \            nNewDim14 = 1;\n            sNewV14 = sElement;\n          ElseIf(nTargetIndex\
    \ = 15);\n            nNewDim15 = 1;\n            sNewV15 = sElement;\n          ElseIf(nTargetIndex\
    \ = 16);\n            nNewDim16 = 1;\n            sNewV16 = sElement;\n          ElseIf(nTargetIndex\
    \ = 17);\n            nNewDim17 = 1;\n            sNewV17 = sElement;\n          ElseIf(nTargetIndex\
    \ = 18);\n            nNewDim18 = 1;\n            sNewV18 = sElement;\n          ElseIf(nTargetIndex\
    \ = 19);\n            nNewDim19 = 1;\n            sNewV19 = sElement;\n          ElseIf(nTargetIndex\
    \ = 20);\n            nNewDim20 = 1;\n            sNewV20 = sElement;\n          ElseIf(nTargetIndex\
    \ = 21);\n            nNewDim21 = 1;\n            sNewV21 = sElement;\n          ElseIf(nTargetIndex\
    \ = 22);\n            nNewDim22 = 1;\n            sNewV22 = sElement;\n          ElseIf(nTargetIndex\
    \ = 23);\n            nNewDim23 = 1;\n            sNewV23 = sElement;\n          ElseIf(nTargetIndex\
    \ = 24);\n            nNewDim24 = 1;\n            sNewV24 = sElement;\n          ElseIf(nTargetIndex\
    \ = 25);\n            nNewDim25 = 1;\n            sNewV25 = sElement;\n          ElseIf(nTargetIndex\
    \ = 26);\n            nNewDim26 = 1;\n            sNewV26 = sElement;\n          ElseIf(nTargetIndex\
    \ = 27);\n            nNewDim27 = 1;\n            sNewV27 = sElement;\n          EndIf;\n\
    \n          #Add to the Target filter - no need to manage element separators, since just\
    \ one target element is possible in mapping\n          sTargetFilter=sTargetFilter|sElementStartDelim|sElement;\n\
    \          \n          # Clear the word\n          sWord = '';\n          sLastDelim = sChar;\n\
    \ \n        Else;\n          sWord = sWord | sChar;\n        EndIf;\n\n      EndIf;\n\n\
    \    EndIf;\n\n    nChar = nChar + nAddExtra + 1;\n\nEND;\n\n\n###########################################\n\
    #Region ### MAPPING Target DIMENSIONS #####\n\n## Source index starting from 2, since first\
    \ columns holds the export cube name\nnSourceIndex = 2;\nnTargetIndex = 1;\nWHILE(TabDim(\
    \ pCube, nTargetIndex ) @<> '');\n  sTargetDim = TabDim( pCube, nTargetIndex );\n  \n  If(nTargetIndex\
    \ = 1);\n    If( nNewDim1 = 0 );\n      nMappedDim1 = 1;\n      sMappedV1  = 'V' | NumberToString(nSourceIndex);\n\
    \      nSourceIndex = nSourceIndex + 1;\n    Else;\n      \n    EndIf;\n  ElseIf(nTargetIndex\
    \ = 2 & nNewDim2 = 0);\n    nMappedDim2 = 1;\n    sMappedV2  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 3 & nNewDim3 = 0);\n    nMappedDim3\
    \ = 1;\n    sMappedV3  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 4 & nNewDim4 = 0);\n    nMappedDim4 = 1;\n    sMappedV4\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 5 & nNewDim5 = 0);\n    nMappedDim5 = 1;\n    sMappedV5  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 6 & nNewDim6 = 0);\n    nMappedDim6\
    \ = 1;\n    sMappedV6  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 7 & nNewDim7 = 0);\n      nMappedDim7 = 1;\n      sMappedV7\
    \  = 'V' | NumberToString(nSourceIndex);\n      nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 8 & nNewDim8 = 0);\n    nMappedDim8 = 1;\n    sMappedV8  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 9 & nNewDim9 = 0);\n    nMappedDim9\
    \ = 1;\n    sMappedV9  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 10 & nNewDim10 = 0);\n    nMappedDim10 = 1;\n    sMappedV10\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 11 & nNewDim11 = 0);\n    nMappedDim11 = 1;\n    sMappedV11  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 12 & nNewDim12 = 0 );\n \
    \   nMappedDim12 = 1;\n    sMappedV12  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex\
    \ = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 13 & nNewDim13 = 0 );\n    nMappedDim13 =\
    \ 1;\n    sMappedV13  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 14 & nNewDim14 = 0 );\n    nMappedDim14 = 1;\n    sMappedV14\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 15 & nNewDim15 = 0 );\n    nMappedDim15 = 1;\n    sMappedV15  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 16 & nNewDim16 = 0 );\n \
    \   nMappedDim16 = 1;\n    sMappedV16  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex\
    \ = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 17 & nNewDim17 = 0 );\n    nMappedDim17 =\
    \ 1;\n    sMappedV17  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 18 & nNewDim18 = 0 );\n    nMappedDim18 = 1;\n    sMappedV18\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 19 & nNewDim19 = 0 );\n    nMappedDim19 = 1;\n    sMappedV19  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 20 & nNewDim20 = 0 );\n \
    \   nMappedDim20 = 1;\n    sMappedV20  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex\
    \ = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 21 & nNewDim21 = 0 );\n    nMappedDim21 =\
    \ 1;\n    sMappedV21  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 22 & nNewDim22 = 0 );\n    nMappedDim22 = 1;\n    sMappedV22\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 23 & nNewDim23 = 0 );\n    nMappedDim23 = 1;\n    sMappedV23  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 24 & nNewDim24 = 0 );\n \
    \   nMappedDim24 = 1;\n    sMappedV24  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex\
    \ = nSourceIndex + 1;\n  ElseIf(nTargetIndex = 25 & nNewDim25 = 0 );\n    nMappedDim25 =\
    \ 1;\n    sMappedV25  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex\
    \ + 1;\n  ElseIf(nTargetIndex = 26 & nNewDim26 = 0 );\n    nMappedDim26 = 1;\n    sMappedV26\
    \  = 'V' | NumberToString(nSourceIndex);\n    nSourceIndex = nSourceIndex + 1;\n  ElseIf(nTargetIndex\
    \ = 27 & nNewDim27 = 0 );\n    nMappedDim27 = 1;\n    sMappedV27  = 'V' | NumberToString(nSourceIndex);\n\
    \    nSourceIndex = nSourceIndex + 1;\n  EndIf;\n\n  nTargetIndex = nTargetIndex + 1;\n\n\
    END;\n\n# The last variable in the data source holds the values\n# which need to be mapped\
    \ to the last variable in the target\n\nIf(nTargetIndex = 1 & nNewDim1 = 0);\n  nMappedDim1\
    \ = 1;\n  sMappedV1  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex\
    \ + 1;\nElseIf(nTargetIndex = 2 & nNewDim2 = 0);\n  nMappedDim2 = 1;\n  sMappedV2  = 'V'\
    \ | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 3 & nNewDim3 = 0);\n  nMappedDim3 = 1;\n  sMappedV3  = 'V' | NumberToString(nSourceIndex);\n\
    \  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex = 4 & nNewDim4 = 0);\n  nMappedDim4\
    \ = 1;\n  sMappedV4  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex\
    \ + 1;\nElseIf(nTargetIndex = 5 & nNewDim5 = 0);\n  nMappedDim5 = 1;\n  sMappedV5  = 'V'\
    \ | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 6 & nNewDim6 = 0);\n  nMappedDim6 = 1;\n  sMappedV6  = 'V' | NumberToString(nSourceIndex);\n\
    \  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex = 7 & nNewDim7 = 0);\n  nMappedDim7\
    \ = 1;\n  sMappedV7  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex\
    \ + 1;\nElseIf(nTargetIndex = 8 & nNewDim8 = 0);\n  nMappedDim8 = 1;\n  sMappedV8  = 'V'\
    \ | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 9 & nNewDim9 = 0);\n  nMappedDim9 = 1;\n  sMappedV9  = 'V' | NumberToString(nSourceIndex);\n\
    \  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex = 10 & nNewDim10 = 0);\n  nMappedDim10\
    \ = 1;\n  sMappedV10  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex\
    \ + 1;\nElseIf(nTargetIndex = 11 & nNewDim11 = 0);\n  nMappedDim11 = 1;\n  sMappedV11  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 12);\n  nMappedDim12 = 1;\n  sMappedV12  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 13);\n  nMappedDim13 = 1;\n  sMappedV13  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 14);\n  nMappedDim14 = 1;\n  sMappedV14  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 15);\n  nMappedDim15 = 1;\n  sMappedV15  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 16);\n  nMappedDim16 = 1;\n  sMappedV16  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 17);\n  nMappedDim17 = 1;\n  sMappedV17  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 18);\n  nMappedDim18 = 1;\n  sMappedV18  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 19);\n  nMappedDim19 = 1;\n  sMappedV19  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 20);\n  nMappedDim20 = 1;\n  sMappedV20  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 21);\n  nMappedDim21 = 1;\n  sMappedV21  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 22);\n  nMappedDim22 = 1;\n  sMappedV22  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 23);\n  nMappedDim23 = 1;\n  sMappedV23  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 24);\n  nMappedDim24 = 1;\n  sMappedV24  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 25);\n  nMappedDim25 = 1;\n  sMappedV25  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\nElseIf(nTargetIndex\
    \ = 26);\n  nMappedDim26 = 1;\n  sMappedV26  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex\
    \ = nSourceIndex + 1;\nElseIf(nTargetIndex = 27);\n  nMappedDim27 = 1;\n  sMappedV27  =\
    \ 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex + 1;\n\n# a cube with\
    \ 27 dimensions uses V28 to hold the values\nElseIf(nTargetIndex = 28);\n  nMappedDim28\
    \ = 1;\n  sMapped28  = 'V' | NumberToString(nSourceIndex);\n  nSourceIndex = nSourceIndex\
    \ + 1;\nEndIf;\n\n# Check that an input element or variable has been specified for all dimensions\
    \ in the target cube\n\nnIndexInTarget = 1;\nWHILE(nIndexInTarget <= nTargetCubeDimensionCount);\n\
    \      \n      sMapped   = Expand('%nMappedDim'| NumberToString(nIndexInTarget) |'%'); \n\
    \      sMapped   = Subst( sMapped , Scan( '.' , sMapped )-1 , 99);\n      nMapped   = StringToNumber(\
    \ Trim( sMapped ) );\n      sNew      = Expand('%nNewDim'| NumberToString(nIndexInTarget)\
    \ |'%'); \n      sNew      = Subst( sNew , Scan( '.' , sNew )-1 , 99);\n      nNew     \
    \ = StringToNumber( Trim( sNew ) );\n      \n      If(nMapped = 0 & nNew = 0 );\n      \
    \      # there's no input element and this dimension is not in the source\n            nErrors\
    \         = nErrors + 1;\n            sTargetDimName  = TabDim( pCube,  nIndexInTarget );\n\
    \            sMessage        = 'Dimension ' | sTargetDimName | ' is missing an input element\
    \ in pMappingToNewDims';\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n  \
    \          Else;\n                ProcessBreak;\n            EndIf;\n       EndIf;\n   \
    \    \n       nIndexInTarget = nIndexInTarget + 1;\nEND;\n#EndRegion ### MAPPING Target\
    \ DIMENSIONS #####\n##############################################\n\n#CubeLogging\nIf (\
    \ pCubeLogging <= 1 );\n  sCubeLogging = CellGetS('}CubeProperties', pCube, 'LOGGING' );\n\
    \  CubeSetLogChanges( pCube, pCubeLogging);\nEndIf;\n\n### Assign Datasource ###\nDataSourceType\
    \                  = 'CHARACTERDELIMITED';\nDatasourceNameForServer         = sFile;\nDatasourceNameForClient\
    \         = sFile;\nDatasourceASCIIHeaderRecords    = pTitleRows;\nDatasourceASCIIDelimiter\
    \        = pDelimiter;\nDatasourceASCIIQuoteCharacter   = pQuote;\nSetInputCharacterSet\
    \ (pCharacterSet);\n\n### End Prolog ###\n#Section Metadaten\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# It would be too exhaustive to error trap elements\
    \ not existing in dimension for each possible number of dimensions\n# If an incorrect source\
    \ file is specfied for a target cube then the TI will error with standard TI error messages.\n\
    # Note: that the assumed file format is standard .cma cube export of Cube, d1, d2, dn, value\n\
    # This is equivalent to using the Bedrock.Cube.ExportToFile TI.\n\n## Increase Record count\n\
    nRecordProcessedCount = nRecordProcessedCount + 1;\n\n### Zero out Target view using filter\
    \ in the 1st record of the data source, if requested\nIf( nRecordProcessedCount = 1 );\n\
    \  If( pZeroFilter = 2 );\n    sRowIsFilter = v2;\n    sImportedFilter = v3;\n    sImportedDelimDim\
    \ = v4;\n    sImportedElementStartDelim = v5;\n    sImportedDelimElem = v6;\n    ### Check\
    \ Filter row\n    If(sRowIsFilter @<> 'Filter');\n        sMessage = 'Filter row in source\
    \ file not having the expected format.';\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 );\
    \ \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n        EndIf;\n\
    \    ENDIF;\n    ### Check delimiters are the same when using any mapping. This because\
    \ filter from the file and mappings form the params will be concatenated / substituted\n\
    \    If((sElementMapping @<> '' % pDimension @<>'') & (sDelimDim @<> sImportedDelimDim %\
    \ sElementStartDelim @<> sImportedElementStartDelim % sDelimElem @<> sImportedDelimElem));\n\
    \        sMessage = 'Error zeroing out target slice corresponding to the filter plus new\
    \ mapped dimensions: delimiters in source file do not match with the ones in parameters.';\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n\
    \            ProcessBreak;\n        EndIf;\n    ENDIF;\n    \n    ### Check filter in source\
    \ file and validate its dimensions\n    sFilter = TRIM( sImportedFilter );\n    nChar =\
    \ 1;\n    nCharCount = LONG( sFilter );\n    sWord = '';\n    sLastDelim = '';\n    nIndex\
    \ = 1;\n    # Add a trailing element delimiter so that the last element is picked up\n \
    \   If( nCharCount > 0 );\n      sFilter = sFilter | sDelimElem;\n      nCharCount = nCharCount\
    \ + LONG(sDelimElem);\n    EndIf;\n    \n    WHILE (nChar <= nCharCount);\n        sChar\
    \ = SUBST( sFilter, nChar, 1);\n    \n        # Used for delimiters, required for multiple\
    \ character delimiters\n        sDelim = '';\n        nAddExtra = 0;\n    \n        # Ignore\
    \ spaces\n        IF (TRIM(sChar) @<> '' );\n    \n          ### Dimension Name ###\n  \
    \  \n          # If the delimiter is more than 1 character peek ahead the same amount\n\
    \          # Ignore the first character\n          sDelim = sChar;\n          nCount = LONG(sElementStartDelim)\
    \ - 1;\n          If( nCount > 0 & nChar + nCount <= nCharCount );\n            # Add the\
    \ extra characters\n            sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n\
    \            # Move to the end of the delimter\n            nAddExtra = nCount;\n      \
    \    EndIf;\n    \n          If( sDelim @= sElementStartDelim );\n    \n            sChar\
    \ = sDelim;\n    \n            If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );\n   \
    \             sMessage = 'The name of a dimension must follow a dimension delimiter (' |\
    \ sDelimDim | ')';\n                nErrors = nErrors + 1;\n                LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n            EndIf;\n    \n            sDimension = sWord;\n\
    \            \n            If( DimensionExists( sDimension ) = 0 );\n                # The\
    \ dimension does not exist in the model. Cancel process\n                sMessage = 'Dimension:\
    \ ' | sDimension | ' does not exist';\n                nErrors = nErrors + 1;\n        \
    \        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            EndIf;\n\
    \    \n            ### Determine the dimension is a member of the cube ###\n           \
    \ nCount = 1;\n            nDimensionIndex = 0;\n            While( TabDim( pCube, nCount\
    \ ) @<> '' );\n                sCubeDimName = TabDim( pCube, nCount );\n               \
    \ If( sDimension @= sCubeDimName );\n                    nDimensionIndex = nCount;\n   \
    \             EndIf;\n                nCount = nCount + 1;\n            End;\n    \n   \
    \         If( nDimensionIndex = 0 );\n                # The dimension does not exist in\
    \ the cube. Cancel process\n                sMessage = 'Dimension: ' | sDimension | ' is\
    \ not a member of: '| pCube | ' cube.';\n                nErrors = nErrors + 1;\n      \
    \          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            EndIf;\n\
    \    \n\n    \n            nIndex = 1;\n            sLastDelim = sChar;\n            # Clear\
    \ the word\n            sWord = '';\n          Else;\n    \n            # Reset extra chars\n\
    \            nAddExtra = 0;\n    \n            ### Check both both dim delimiter and element\
    \ delimiter ###\n            nIsDelimiter = 0;\n    \n            ## Check dimension delimiter\
    \ first\n            # If the delimiter is more than 1 character peek ahead the same amount\n\
    \            # Ignore the first character\n            sDelim = sChar;\n            nCount\
    \ = LONG(sDelimDim) - 1;\n            If( nCount > 0 & nChar + nCount <= nCharCount );\n\
    \              # Add the extra characters\n              sDelim = sDelim | SUBST( sFilter,\
    \ nChar + 1, nCount);\n              # Move to the end of the delimter\n              nAddExtra\
    \ = nCount;\n            EndIf;\n    \n            If( sDelim @= sDelimDim );\n        \
    \      nIsDelimiter = 1;\n              sChar = sDelim;\n            Else;\n           \
    \   # Reset extra chars\n              nAddExtra = 0;\n    \n              ## Check element\
    \ delimiter\n    \n              # If the delimiter is more than 1 character peek ahead\
    \ the same amount\n              # Ignore the first character\n              sDelim = sChar;\n\
    \              nCount = LONG(sDelimElem) - 1;\n              If( nCount > 0 & nChar + nCount\
    \ <= nCharCount );\n                # Add the extra characters\n                sDelim =\
    \ sDelim | SUBST( sFilter, nChar + 1, nCount);\n                # Move to the end of the\
    \ delimter\n                nAddExtra = nCount;\n              EndIf;\n    \n          \
    \    If( sDelim @= sDelimElem );\n                nIsDelimiter = 1;\n                sChar\
    \ = sDelim;\n              Else;\n                # Reset extra chars\n                nAddExtra\
    \ = 0;\n              EndIf;\n    \n            EndIf;\n    \n            If ( nIsDelimiter\
    \ = 1 );\n    \n              If( sLastDelim @= '' % sLastDelim @= sDelimDim );\n      \
    \          sMessage = 'An element delimiter must follow a dimension name: ' |  sChar | '\
    \ (' | NumberToString(nChar) | ')';\n                nErrors = nErrors + 1;\n          \
    \      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                #ProcessError();\n\
    \              EndIf;\n    \n              sElement = sWord;\n    \n              If( DimIx(\
    \ sDimension, sElement ) = 0 );\n                  # The element does not exist in the dimension.\
    \ Cancel process\n                  sMessage = 'Element: ' | sElement | ' in dimension '\
    \ | sDimension | ' does not exist';\n                  nErrors = nErrors + 1;\n        \
    \          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                  #ProcessError();\n\
    \              EndIf;\n    \n              nIndex = nIndex + 1;\n              sLastDelim\
    \ = sChar;\n    \n              # Clear the word\n              sWord = '';\n          \
    \  Else;\n              sWord = sWord | sChar;\n            EndIf;\n    \n          EndIf;\n\
    \    \n        EndIf;\n    \n        nChar = nChar + nAddExtra + 1;\n    END;\n\n    ###\
    \ Check for errors before continuing\n    If( nErrors <> 0 );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;\n    EndIf;\n    \n    If( sTargetFilter @= '' );\n      sTargetFilter = sImportedFilter;\n\
    \    Else;\n      sTargetFilter = sTargetFilter | sDelimDim | sImportedFilter;\n    EndIf;\n\
    \    ### Determine target dimension substitution in data clear filter\n    If( pDimension\
    \ @<>'');\n      If( sTargetFilter @= '' );\n        sTargetFilter = pDimension | sElementStartDelim\
    \ | sTargetElement;\n      Else;\n        ### Remove spaces from the string, then remove\
    \ source element from the filter if present\n        sTargetFilter = UPPER( sTargetFilter\
    \ );\n        nSPIndex = SCAN( ' ', sTargetFilter );\n        While ( nSPIndex <> 0);\n\
    \          sTargetFilter = DELET( sTargetFilter, nSPIndex, 1 );\n          nSPIndex = SCAN(\
    \ ' ', sTargetFilter );\n        End;\n        sRemoveString = UPPER( sDelimDim | pDimension\
    \ | sElementStartDelim | pSrcEle );\n        nRemoveIndex = SCAN( sRemoveString, sTargetFilter\
    \ );\n        If( nRemoveIndex <> 0 );\n          sTargetFilter = DELET( sTargetFilter,\
    \ nRemoveIndex, Long(sRemoveString) );\n        EndIf;\n        sRemoveString2 = UPPER(\
    \ pDimension | sElementStartDelim | pSrcEle | sDelimDim );\n        nRemoveIndex = SCAN(\
    \ sRemoveString2, sTargetFilter );\n        If( nRemoveIndex <> 0 );\n          sTargetFilter\
    \ = DELET( sTargetFilter, nRemoveIndex, Long(sRemoveString2) );\n        EndIf;\n      \
    \  sRemoveString3 = UPPER( sDelimDim | pDimension | sElementStartDelim | sSourceElement\
    \ );\n        nRemoveIndex = SCAN( sRemoveString3, sTargetFilter );\n        If( nRemoveIndex\
    \ <> 0 );\n          sTargetFilter = DELET( sTargetFilter, nRemoveIndex, Long(sRemoveString3)\
    \ );\n        EndIf;\n        sRemoveString4 = UPPER( pDimension | sElementStartDelim |\
    \ sSourceElement | sDelimDim );\n        nRemoveIndex = SCAN( sRemoveString4, sTargetFilter\
    \ );\n        If( nRemoveIndex <> 0 );\n          sTargetFilter = DELET( sTargetFilter,\
    \ nRemoveIndex, Long(sRemoveString4) );\n        EndIf;\n        ## Add target element to\
    \ the filter\n        sTargetFilter = sTargetFilter | sDelimDim | pDimension | sElementStartDelim\
    \ | sTargetElement;\n      EndIf;\n    Endif;\n    \n    nRet = ExecuteProcess('}bedrock.cube.data.clear',\n\
    \       'pLogOutput', pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n\
    \       'pCube', pCube,\n       'pView', '',\n       'pFilter', sTargetFilter,\n       'pFilterParallel',\
    \ '',\n       'pParallelThreads', 0,\n       'pDimDelim', sImportedDelimDim,\n       'pEleStartDelim',\
    \ sImportedElementStartDelim,\n       'pEleDelim', sImportedDelimElem,\n       'pCubeLogging',\
    \ pCubeLogging,\n       'pTemp', 1,\n       'pSandbox', pSandbox\n      );\n  \n    If(nRet\
    \ <> 0);\n        sMessage = 'Error zeroing out target slice corresponding to the filter.';\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n\
    \            ProcessBreak;\n        EndIf;\n    ENDIF;\n  ENDIF;\n  If( pZeroFilter > 0\
    \ );\n    ItemSkip;\n  ENDIF;\nEndif;\n\n### Determine target dimension SubStitution ###\n\
    If( pDimension @<>'');\n  \n  If(sSourceElement@<>Expand('%v'|numbertostring(nSubstututeDimensionIndex+1)|'%'));\n\
    \   # leave variable as is\n  Else; \n  \n    v2 = If(nSubstututeDimensionIndex = 1, sTargetElement,\
    \ v2);\n    v3 = If(nSubstututeDimensionIndex = 2, sTargetElement, v3);\n    v4 = If(nSubstututeDimensionIndex\
    \ = 3, sTargetElement, v4);\n    v5 = If(nSubstututeDimensionIndex = 4, sTargetElement,\
    \ v5);\n    v6 = If(nSubstututeDimensionIndex = 5, sTargetElement, v6);\n    v7 = If(nSubstututeDimensionIndex\
    \ = 6, sTargetElement, v7);\n    v8 = If(nSubstututeDimensionIndex = 7, sTargetElement,\
    \ v8);\n    v9 = If(nSubstututeDimensionIndex = 8, sTargetElement, v9);\n    v10 = If(nSubstututeDimensionIndex\
    \ = 9, sTargetElement, v10);\n    v11 = If(nSubstututeDimensionIndex = 10, sTargetElement,\
    \ v11);\n    v12 = If(nSubstututeDimensionIndex = 11, sTargetElement, v12);\n    v13 = If(nSubstututeDimensionIndex\
    \ = 12, sTargetElement, v13);\n    v14 = If(nSubstututeDimensionIndex = 13, sTargetElement,\
    \ v14);\n    v15 = If(nSubstututeDimensionIndex = 14, sTargetElement, v15);\n    v16 = If(nSubstututeDimensionIndex\
    \ = 15, sTargetElement, v16);\n    v17 = If(nSubstututeDimensionIndex = 16, sTargetElement,\
    \ v17);\n    v18 = If(nSubstututeDimensionIndex = 17, sTargetElement, v18);\n    v19 = If(nSubstututeDimensionIndex\
    \ = 18, sTargetElement, v19);\n    v20 = If(nSubstututeDimensionIndex = 19, sTargetElement,\
    \ v20);\n    v21 = If(nSubstututeDimensionIndex = 20, sTargetElement, v21);\n    v22 = If(nSubstututeDimensionIndex\
    \ = 21, sTargetElement, v22);\n    v23 = If(nSubstututeDimensionIndex = 22, sTargetElement,\
    \ v23);\n    v24 = If(nSubstututeDimensionIndex = 23, sTargetElement, v24);\n    v25 = If(nSubstututeDimensionIndex\
    \ = 24, sTargetElement, v25);\n    v26 = If(nSubstututeDimensionIndex = 25, sTargetElement,\
    \ v26);\n    v27 = If(nSubstututeDimensionIndex = 26, sTargetElement, v27);\n  EndIf;\n\n\
    Endif;\n\n### Determine dimension Mapping SubStitution ###\nsV2 =If(nMappedDim1=1,  Expand('%'|sMappedV1|'%'),\
    \ If(nNewDim1=1, sNewV1,V1));\nsV3 =If(nMappedDim2=1,  Expand('%'|sMappedV2|'%'), If(nNewDim2=1,\
    \ sNewV2,V2));\nsV4 =If(nMappedDim3=1,  Expand('%'|sMappedV3|'%'), If(nNewDim3=1, sNewV3,V3));\n\
    sV5 =If(nMappedDim4=1,  Expand('%'|sMappedV4|'%'), If(nNewDim4=1, sNewV4,V4));\nsV6 =If(nMappedDim5=1,\
    \  Expand('%'|sMappedV5|'%'), If(nNewDim5=1, sNewV5,V5));\nsV7 =If(nMappedDim6=1,  Expand('%'|sMappedV6|'%'),\
    \ If(nNewDim6=1, sNewV6,V6));\nsV8 =If(nMappedDim7=1,  Expand('%'|sMappedV7|'%'), If(nNewDim7=1,\
    \ sNewV7,V7));\nsV9 =If(nMappedDim8=1,  Expand('%'|sMappedV8|'%'), If(nNewDim8=1, sNewV8,V8));\n\
    sV10 =If(nMappedDim9=1,  Expand('%'|sMappedV9|'%'), If(nNewDim9=1, sNewV9,V9));\nsV11=If(nMappedDim10=1,\
    \ Expand('%'|sMappedV10|'%'),If(nNewDim10=1,sNewV10,V10));\nsV12=If(nMappedDim11=1, Expand('%'|sMappedV11|'%'),If(nNewDim11=1,sNewV11,V11));\n\
    sV13=If(nMappedDim12=1, Expand('%'|sMappedV12|'%'),If(nNewDim12=1,sNewV12,V12));  \nsV14=If(nMappedDim13=1,\
    \ Expand('%'|sMappedV13|'%'),If(nNewDim13=1,sNewV13,V13));  \nsV15=If(nMappedDim14=1, Expand('%'|sMappedV14|'%'),If(nNewDim14=1,sNewV14,V14));\
    \   \nsV16=If(nMappedDim15=1, Expand('%'|sMappedV15|'%'),If(nNewDim15=1,sNewV15,V15)); \
    \ \nsV17=If(nMappedDim16=1, Expand('%'|sMappedV16|'%'),If(nNewDim16=1,sNewV16,V16));  \n\
    sV18=If(nMappedDim17=1, Expand('%'|sMappedV17|'%'),If(nNewDim17=1,sNewV17,V17));  \nsV19=If(nMappedDim18=1,\
    \ Expand('%'|sMappedV18|'%'),If(nNewDim18=1,sNewV18,V18));  \nsV20=If(nMappedDim19=1, Expand('%'|sMappedV19|'%'),If(nNewDim19=1,sNewV19,V19));\
    \  \nsV21=If(nMappedDim20=1, Expand('%'|sMappedV20|'%'),If(nNewDim20=1,sNewV20,V20));  \n\
    sV22=If(nMappedDim21=1, Expand('%'|sMappedV21|'%'),If(nNewDim21=1,sNewV21,V21));  \nsV23=If(nMappedDim22=1,\
    \ Expand('%'|sMappedV22|'%'),If(nNewDim22=1,sNewV22,V22));  \nsV24=If(nMappedDim23=1, Expand('%'|sMappedV23|'%'),If(nNewDim23=1,sNewV23,V23));\
    \  \nsV25=If(nMappedDim24=1, Expand('%'|sMappedV24|'%'),If(nNewDim24=1,sNewV24,V24));  \n\
    sV26=If(nMappedDim25=1, Expand('%'|sMappedV25|'%'),If(nNewDim25=1,sNewV25,V25));  \nsV27=If(nMappedDim26=1,\
    \ Expand('%'|sMappedV26|'%'),If(nNewDim26=1,sNewV26,V26));  \nsV28=If(nMappedDim27=1, Expand('%'|sMappedV27|'%'),If(nNewDim27=1,sNewV27,V27));\n\
    sV29=If(nMappedDim28=1, Expand('%'|sMappedV28|'%'),V28);  \n  \nV1 = V1;\nV2 = sV2; \nV3\
    \ = sV3; \nV4 = sV4; \nV5 = sV5; \nV6 = sV6; \nV7 = sV7; \nV8 = sV8; \nV9 = sV9; \nV10=\
    \ sV10;\nV11= sV11;\nV12= sV12;\nV13= sV13;\nV14= sV14;\nV15= sV15;\nV16= sV16;\nV17= sV17;\n\
    V18= sV18;\nV19= sV19;\nV20= sV20;\nV21= sV21;\nV22= sV22;\nV23= sV23;\nV24= sV24;\nV25=\
    \ sV25;\nV26= sV26;\nV27= sV27;\nV28= sV28;\nV29= sV29;\n \nIf( pSkipInvalidRecords < 1\
    \ );\n  ## Do not check for a valid datapoint (any element that doesn't exist will generate\
    \ error message on CellPut attempt)\nElse;\n  ## Allow records that do not have a valid\
    \ datapoint to be skipped.\n  If( nDimensionCount >= 2 & (DimIx( sDim1, v2 ) = 0 % DimIx(\
    \ sDim2, v3 ) = 0 ) );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 3 & DimIx(\
    \ sDim3, v4 ) = 0 );\n      ItemSkip;\n  EndIf;\n\n  If( nDimensionCount >= 4 & DimIx( sDim4,\
    \ v5 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 5 & DimIx( sDim5,\
    \ v6 ) = 0 );\n      ItemSkip;\n  EndIf;\n\n  If( nDimensionCount >= 6 & DimIx( sDim6, v7\
    \ ) = 0 );\n      ItemSkip;\n  EndIf;\n\n  If( nDimensionCount >= 7 & DimIx( sDim7, v8 )\
    \ = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 8 & DimIx( sDim8, v9 )\
    \ = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 9 & DimIx( sDim9, v10\
    \ ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 10 & DimIx( sDim10,\
    \ v11 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 11 & DimIx( sDim11,\
    \ v12 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 12 & DimIx( sDim12,\
    \ v13 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 13 & DimIx( sDim13,\
    \ v14 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 14 & DimIx( sDim14,\
    \ v15 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 15 & DimIx( sDim15,\
    \ v16 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 16 & DimIx( sDim16,\
    \ v17 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 17 & DimIx( sDim17,\
    \ v18 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 18 & DimIx( sDim18,\
    \ v19 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 19 & DimIx( sDim19,\
    \ v20 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 20 & DimIx( sDim20,\
    \ v21 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 21 & DimIx( sDim21,\
    \ v22 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 22 & DimIx( sDim22,\
    \ v23 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 23 & DimIx( sDim23,\
    \ v24 ) = 0 );\n      ItemSkip;\n  EndIf;\n\n  If( nDimensionCount >= 24 & DimIx( sDim24,\
    \ v25 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 25 & DimIx( sDim25,\
    \ v26 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 26 & DimIx( sDim25,\
    \ v27 ) = 0 );\n      ItemSkip;\n  EndIf;\n  \n  If( nDimensionCount >= 27 & DimIx( sDim27,\
    \ v28 ) = 0 );\n      ItemSkip;\n  EndIf;\n\nEndIf;\n\n### Write data from source file to\
    \ target cube ###\n\nIf( nDimensionCount = 2 );\n    If( CellIsUpdateable( pCube, v2, v3\
    \ ) = 1 );\n        sElType = DType( sDim2, v3 );\n        If( SubSt( sDim2, 1, 19 ) @=\
    \ '}ElementAttributes_' % SubSt( pCube, 1, 17 ) @= '}ElementSecurity_' );\n            sDim\
    \ = sDim1;\n        ENDIF;\n        \n        If( SubSt( pCube, 1, 17 ) @= '}ElementSecurity_'\
    \ );\n            v4 = If( v4 @= '', 'NONE', v4 );\n            ElementSecurityPut( v4,\
    \ sDim, v2, v3 );\n        ELSEIf( sElType @= 'AS');\n            AttrPutS( v4, sDim, v2,\
    \ v3, 1 );\n        ELSEIf( sElType @= 'AA');\n            AttrPutS( v4, sDim, v2, v3 );\n\
    \        ELSEIf( sElType @= 'AN');\n            AttrPutN( StringToNumberEx(v4, sDecimalSeparator,\
    \ sThousandSeparator), sDim, v2, v3 );\n        ELSEIf( sElType @= 'S');\n            CellPutS(\
    \ v4, pCube, v2, v3 );\n        ElseIf( DimIx( sDim2, v3 ) <> 0 );\n            If(pCumulate\
    \ = 1);\n                nObal = CellGetN( pCube, v2, v3 );\n                nCbal = nObal\
    \ + StringToNumberEx(v4, sDecimalSeparator, sThousandSeparator);\n            ELSE;\n  \
    \              nCbal = StringToNumberEx(v4, sDecimalSeparator, sThousandSeparator);\n  \
    \          Endif;\n            CellPutN( nCbal, pCube, v2, v3 );\n        EndIf;\n    EndIf;\n\
    ElseIf( nDimensionCount = 3 );\n    If( CellIsUpdateable( pCube, v2, v3, v4 ) = 1 );\n \
    \       sElType = DType( sDim3, v4 );\n        If( sElType @<> 'S' );\n            If(pCumulate\
    \ = 1);\n                nObal = CellGetN( pCube, v2, v3, v4 );\n                nCbal =\
    \ nObal + StringToNumberEx(v5, sDecimalSeparator, sThousandSeparator);\n            ELSE;\n\
    \                nCbal = StringToNumberEx(v5, sDecimalSeparator, sThousandSeparator);\n\
    \            Endif;\n            CellPutN( nCbal, pCube, v2, v3, v4 );\n        Else;\n\
    \            CellPutS( v5, pCube, v2, v3, v4 );\n        EndIf;\n    EndIf;\nElseIf( nDimensionCount\
    \ = 4 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5 ) = 1 );\n        sElType = DType(\
    \ sDim4, v5 );\n        If( sElType @<> 'S' );\n            If(pCumulate = 1);\n       \
    \         nObal = CellGetN( pCube, v2, v3, v4, v5 );\n                nCbal = nObal + StringToNumberEx(v6,\
    \ sDecimalSeparator, sThousandSeparator);\n            ELSE;\n                nCbal = StringToNumberEx(v6,\
    \ sDecimalSeparator, sThousandSeparator);\n            Endif;\n            CellPutN( nCbal,\
    \ pCube, v2, v3, v4, v5 );\n        Else;\n            CellPutS( v6, pCube, v2, v3, v4,\
    \ v5 );\n        EndIf;\n    EndIf;\nElseIf( nDimensionCount = 5 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6 ) = 1 );\n      sElType = DType( sDim5, v6 );\n      If( sElType\
    \ @<> 'S' );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4,\
    \ v5, v6 );\n          nCbal = nObal + StringToNumberEx(v7, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v7, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6 );\n      Else;\n  \
    \      CellPutS( v7, pCube, v2, v3, v4, v5, v6 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 6 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7 ) = 1 );\n      sElType\
    \ = DType( sDim6, v7 );\n      If( sElType @<> 'S' );\n        If(pCumulate = 1);\n    \
    \      nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7 );\n          nCbal = nObal + StringToNumberEx(v8,\
    \ sDecimalSeparator, sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v8,\
    \ sDecimalSeparator, sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube,\
    \ v2, v3, v4, v5, v6, v7 );\n      Else;\n        CellPutS( v8, pCube, v2, v3, v4, v5, v6,\
    \ v7 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 7 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8 ) = 1 );\n      sElType = DType( sDim7, v8 );\n    \
    \  If( sElType @<> 'S' );\n        If( pCumulate = 1);\n          nObal = CellGetN( pCube,\
    \ v2, v3, v4, v5, v6, v7, v8 );\n          nCbal = nObal + StringToNumberEx(v9, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v9, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8 );\n      Else;\n        CellPutS( v9, pCube, v2, v3, v4, v5, v6, v7, v8 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 8 );\n    If( CellIsUpdateable( pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9 ) = 1 );\n      sElType = DType( sDim8, v9 );\n      If(\
    \ sElType @<> 'S' );\n        If( pCumulate = 1);\n          nObal = CellGetN( pCube, v2,\
    \ v3, v4, v5, v6, v7, v8, v9 );\n          nCbal = nObal + StringToNumberEx(v10, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v10, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9 );\n      Else;\n        CellPutS( v10, pCube, v2, v3, v4, v5, v6, v7,\
    \ v8, v9 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 9 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10 ) = 1 );\n      sElType = DType( sDim9, v10\
    \ );\n      If( sElType @<> 'S' );\n        If( pCumulate = 1);\n          nObal = CellGetN(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10 );\n          nCbal = nObal + StringToNumberEx(v11,\
    \ sDecimalSeparator, sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v11,\
    \ sDecimalSeparator, sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10 );\n      Else;\n        CellPutS( v11, pCube, v2,\
    \ v3, v4, v5, v6, v7, v8, v9, v10 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 10 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 ) =\
    \ 1 );\n      sElType = DType( sDim10, v11 );\n      If( sElType @<> 'S' );\n        If(pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11 );\n\
    \          nCbal = nObal + StringToNumberEx(v12, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v12, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\
    \ );\n      Else;\n        CellPutS( v12, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 11 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 ) = 1 );\n      sElType = DType(\
    \ sDim11, v12 );\n      If( sElType @<> 'S' );\n        If(pCumulate = 1);\n          nObal\
    \ = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12 );\n          nCbal =\
    \ nObal + StringToNumberEx(v13, sDecimalSeparator, sThousandSeparator);\n        ELSE;\n\
    \          nCbal = StringToNumberEx(v13, sDecimalSeparator, sThousandSeparator);\n     \
    \   Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12\
    \ );\n      Else;\n        CellPutS( v13, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 12 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 ) = 1 );\n      sElType = DType(\
    \ sDim12, v13 );\n      If( sElType @<> 'S' );\n        If( pCumulate = 1);\n          nObal\
    \ = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13 );\n          nCbal\
    \ = nObal + StringToNumberEx(v14, sDecimalSeparator, sThousandSeparator);\n        ELSE;\n\
    \          nCbal = StringToNumberEx(v14, sDecimalSeparator, sThousandSeparator);\n     \
    \   Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13 );\n      Else;\n        CellPutS( v14, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10,\
    \ v11, v12, v13 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 13 );\n    If(\
    \ CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14 ) = 1\
    \ );\n      sElType = DType( sDim13, v14 );\n      If( sElType @<> 'S' );\n        If(pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14 );\n          nCbal = nObal + StringToNumberEx(v15, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v15, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14 );\n      Else;\n        CellPutS( v15, pCube, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount =\
    \ 14 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15 ) = 1 );\n      sElType = DType( sDim14, v15 );\n      If( sElType @<> 'S'\
    \ );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15 );\n          nCbal = nObal + StringToNumberEx(v16,\
    \ sDecimalSeparator, sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v16,\
    \ sDecimalSeparator, sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );\n      Else;\n       \
    \ CellPutS( v16, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 15 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 ) = 1 );\n  \
    \    sElType = DType( sDim15, v16 );\n      If( sElType @<> 'S' );\n        If(pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16 );\n          nCbal = nObal + StringToNumberEx(v17, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v17, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );\n      Else;\n        CellPutS( v17,\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16 );\n      EndIf;\n\
    \    EndIf;\n  ElseIf( nDimensionCount = 16 );\n    If( CellIsUpdateable( pCube, v2, v3,\
    \ v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 ) = 1 );\n      sElType\
    \ = DType( sDim16, v17 );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\n          nCbal\
    \ = nObal + StringToNumberEx(v18, sDecimalSeparator, sThousandSeparator);\n        ELSE;\n\
    \          nCbal = StringToNumberEx(v18, sDecimalSeparator, sThousandSeparator);\n     \
    \   Endif;\n      If( sElType @<> 'S' );\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\n      Else;\n        CellPutS(\
    \ v18, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17 );\n\
    \      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 17 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 ) =\
    \ 1 );\n      sElType = DType( sDim17, v18 );\n      If( sElType @<> 'S' );\n        If(pCumulate\
    \ = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18 );\n          nCbal = nObal + StringToNumberEx(v19, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v19, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18 );\n      Else;\n        CellPutS(\
    \ v19, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 18 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19\
    \ ) = 1 );\n      sElType = DType( sDim18, v19 );\n      If( sElType @<> 'S' );\n      \
    \  If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9,\
    \ v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );\n          nCbal = nObal + StringToNumberEx(v20,\
    \ sDecimalSeparator, sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v20,\
    \ sDecimalSeparator, sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19 );\n\
    \      Else;\n        CellPutS( v20, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount\
    \ = 19 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19, v20 ) = 1 );\n      sElType = DType( sDim19, v20 );\n\
    \      If( sElType @<> 'S' );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20\
    \ );\n          nCbal = nObal + StringToNumberEx(v21, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v21, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20 );\n      Else;\n        CellPutS( v21, pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20\
    \ );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 20 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\
    \ v20, v21 ) = 1 );\n      sElType = DType( sDim20, v21 );\n      If( sElType @<> 'S' );\n\
    \        If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7,\
    \ v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21 );\n          nCbal\
    \ = nObal + StringToNumberEx(v22, sDecimalSeparator, sThousandSeparator);\n        ELSE;\n\
    \          nCbal = StringToNumberEx(v22, sDecimalSeparator, sThousandSeparator);\n     \
    \   Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19, v20, v21 );\n      Else;\n        CellPutS( v22, pCube,\
    \ v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20,\
    \ v21 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 21 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\
    \ v20, v21, v22 ) = 1 );\n      sElType = DType( sDim21, v22 );\n      If( sElType @<> 'S'\
    \ );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );\n     \
    \     nCbal = nObal + StringToNumberEx(v23, sDecimalSeparator, sThousandSeparator);\n  \
    \      ELSE;\n          nCbal = StringToNumberEx(v23, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22 );\n      Else;\n        CellPutS(\
    \ v23, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18,\
    \ v19, v20, v21, v22 );\n      EndIf;\n    EndIf;\n  ElseIf( nDimensionCount = 22 );\n \
    \   If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22, v23 ) = 1 );\n      sElType = DType( sDim22, v23\
    \ );\n      If( sElType @<> 'S' );\n        If(pCumulate = 1);\n          nObal = CellGetN(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\
    \ v20, v21, v22, v23 );\n          nCbal = nObal + StringToNumberEx(v24, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v24, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23 );\n\
    \      Else;\n        CellPutS( v24, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23 );\n      EndIf;\n    EndIf;\n \
    \ ElseIf( nDimensionCount = 23 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6,\
    \ v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n    v23,\
    \ v24 ) = 1 );\n      sElType = DType( sDim23, v24 );\n      If( sElType @<> 'S' );\n  \
    \      If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n            v23,\
    \ v24 );\n          nCbal = nObal + StringToNumberEx(v25, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v25, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n          v23, v24 );\n      Else;\n\
    \        CellPutS( v25, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22, v23, v24 );\n      EndIf;\n    EndIf;\n  ElseIf(\
    \ nDimensionCount = 24 );\n    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n      v23, v24,\
    \ v25 ) = 1 );\n      sElType = DType( sDim24, v25 );\n      If( sElType @<> 'S' );\n  \
    \      If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8,\
    \ v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n            v23,\
    \ v24, v25 );\n          nCbal = nObal + StringToNumberEx(v26, sDecimalSeparator, sThousandSeparator);\n\
    \        ELSE;\n          nCbal = StringToNumberEx(v26, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n          v23, v24, v25 );\n \
    \     Else;\n        CellPutS( v26, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n          v23, v24, v25 );\n      EndIf;\n\
    \    EndIf;\n  ElseIf( nDimensionCount = 25 );\n    If( CellIsUpdateable( pCube, v2, v3,\
    \ v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n\
    \      v23, v24, v25, v26 ) = 1 );\n      sElType = DType( sDim25, v26 );\n      If( sElType\
    \ @<> 'S' );\n        If(pCumulate = 1);\n          nObal = CellGetN( pCube, v2, v3, v4,\
    \ v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n\
    \            v23, v24, v25, v26 );\n          nCbal = nObal + StringToNumberEx(v27, sDecimalSeparator,\
    \ sThousandSeparator);\n        ELSE;\n          nCbal = StringToNumberEx(v27, sDecimalSeparator,\
    \ sThousandSeparator);\n        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n   \
    \       v23, v24, v25, v26 );\n      Else;\n        CellPutS( v27, pCube, v2, v3, v4, v5,\
    \ v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n   \
    \       v23, v24, v25, v26 );\n      EndIf;\n    EndIf;\nElseIf( nDimensionCount = 26 );\n\
    \    If( CellIsUpdateable( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22,\n    v23, v24, v25, v26, v27 ) = 1 );\n      sElType\
    \ = DType( sDim26, v27 );\n      If( sElType @<> 'S' );\n        If( pCumulate = 1);\n \
    \         nObal = CellGetN( pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22,\n            v23, v24, v25, v26, v27 );\n    \
    \      nCbal = nObal + StringToNumberEx(v28, sDecimalSeparator, sThousandSeparator);\n \
    \       ELSE;\n          nCbal = StringToNumberEx(v28, sDecimalSeparator, sThousandSeparator);\n\
    \        Endif;\n        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22,\n        v23, v24, v25, v26, v27\
    \ );\n      Else;\n        CellPutS( v28, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11,\
    \ v12, v13, v14, v15, v16, v17, v18, v19, v20, v21,\n          v22, v23, v24, v25, v26,\
    \ v27 );\n      EndIf;\n    EndIf;\nElseIf( nDimensionCount = 27 );\n    If( CellIsUpdateable(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\
    \ v20, v21, v22,\n    v23, v24, v25, v26, v27, v28 ) = 1 );\n      sElType = DType( sDim27,\
    \ v28 );\n      If( sElType @<> 'S' );\n        If(pCumulate = 1);\n          nObal = CellGetN(\
    \ pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19,\
    \ v20, v21, v22,\n            v23, v24, v25, v26, v27, v28 );\n          nCbal = nObal +\
    \ StringToNumberEx(v29, sDecimalSeparator, sThousandSeparator);\n        ELSE;\n       \
    \   nCbal = StringToNumberEx(v29, sDecimalSeparator, sThousandSeparator);\n        Endif;\n\
    \        CellPutN( nCbal, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14,\
    \ v15, v16, v17, v18, v19, v20, v21, v22,\n          v23, v24, v25, v26, v27, v28 );\n \
    \     Else;\n        CellPutS( v29, pCube, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12,\
    \ v13, v14, v15, v16, v17, v18, v19, v20, v21,\n          v22, v23, v24, v25, v26, v27,\
    \ v28 );\n      EndIf;\n    EndIf;\n\n\n  EndIf;\n  \n## Increase Record count\nnRecordPostedCount\
    \ = nRecordPostedCount + 1;\n### End Data ###\n#Section Epilog\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Cube Logging\nIf ( pCubeLogging <= 1 );\n  CubeSetLogChanges(\
    \ pCube, If(sCubeLogging@='YES',1,0) );\nEndIf;\n    \n### Delete source file (only if no\
    \ errors) ###\nIf( nErrors = 0 & pFileDelete = 1 );\n    ASCIIDelete(sFile);\nEndIf;\n \
    \   \n### If errors occurred terminate process with a major error status ###\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 major error and consequently aborted.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for\
    \ details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    EndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\nElse;\n    sProcessAction = Expand(\
    \ 'Process:%cThisProcName% successfully imported data from file %sFile%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO"
- question: 'Dieser Turbo Integrator-Prozess von IBM dient dazu, Daten auf der Festplatte für
    die in den Parametern angegebenen Würfel zu speichern. Anwendungsfall: Der Prozess ist für
    Entwicklungs- oder Produktionsumgebungen gedacht. Er wird immer dann verwendet, wenn Daten
    für einen bestimmten Würfel gespeichert werden müssen, zum Beispiel nach dem Laden von Daten,
    um einen bestimmten Würfel zu sichern, oder bei manuellen Eingabewürfeln. Hinweis: Ein gültiger
    Würfelname (pCube) ist zwingend erforderlich, andernfalls wird der Prozess abgebrochen.
    Platzhalter und Listen sind akzeptabel. Dieser Prozess speichert die Daten für einen Würfel.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process save data to disk for the cubes provided\
    \ in parameter.\n\n# Use case: Intended for Development or production.\n#1/ This process\
    \ would be used any time data for a specific cube need to be saved (i.e.: After a data loading\
    \ to save a specific cube or or for manual entry cubes).\n\n# Note:\n# Naturally, a valid\
    \  cube name (pCube) is mandatory otherwise the process will abort. Wildcards and lists\
    \ are acceptable.\n# This process will save data for a cube.\n#EndRegion @DOC\n\n##Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName\
    \ = TM1User();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    sMessage = \t'';\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pCube:%pCube%, pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Validate\
    \ Parameters ###\n# If blank delimiter specified then convert to default\nIf( pDelim @=\
    \ '' );\n  pDelim = '&';\nEndIf;\n\n# If no cubes have been specified then terminate process\n\
    If( Trim( pCube ) @= '' );\n  sMessage = 'No cubes specified';\n  nErrors = nErrors + 1;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n### SET DATA SOURCE\
    \ ###\n\nDatasourceType = 'NULL';\n\n\n### Split parameter into individual cubes and delete\
    \ ###\n\nsCubes = pCube;\nnDelimiterIndex = 1;\nsMdx = '';\n\nWhile( nDelimiterIndex <>\
    \ 0 );\n  nDelimiterIndex = Scan( pDelim, sCubes );\n  If( nDelimiterIndex = 0 );\n    sCube\
    \ = sCubes;\n  Else;\n    sCube = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n   \
    \ sCubes = Trim( Subst( sCubes, nDelimiterIndex + Long(pDelim), Long( sCubes ) ) );\n  EndIf;\n\
    \  \n  # Check if a wildcard has been used to specify the Cube name.\n  # If it hasn't then\
    \ just delete the Cube if it exists\n      # If it has then search the relevant Cube folder\
    \ to find the matches\n      If( Scan( '*', sCube ) = 0 );\n        If( CubeExists( sCube\
    \ ) = 1 ); \n          CubeSaveData( sCube );\n        Endif;\n      Else;\n        # Create\
    \ subset of cubes using Wildcard\n        sCubeExp = '''|sCube|''';\n        sMdxPart =\
    \ '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'| sCubeExp | ')}';\n        IF( sMdx\
    \ @= ''); \n          sMdx = sMdxPart; \n        ELSE;\n          sMdx = sMdx | ' + ' |\
    \ sMdxPart;\n        ENDIF;\n        \n        If( SubsetExists( '}Cubes' , cTempSub ) =\
    \ 1 );\n            # If a delimited list of cube names includes wildcards then we may have\
    \ to re-use the subset multiple times\n            SubsetMDXSet( '}Cubes' , cTempSub, sMDX\
    \ );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n        EndIf;\n      \
    \  \n        # Loop through cubes in subset created based on wildcard\n        nCountCubes\
    \ = SubsetGetSize( '}Cubes' , cTempSub );\n        While( nCountCubes >= 1 );\n        \
    \  sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCubes );\n          # Validate\
    \ cube name\n          If( CubeExists( sCurrCube ) = 1 ); \n            # Save data\n  \
    \          CubeSaveData( sCurrCube );\n          Endif;\n            nCountCubes = nCountCubes\
    \ - 1;\n        End;\n      EndIf;\n\nEnd;\n\n\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully saved data for\
    \ cube %pCube% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n\n### End Epilog ###"
- question: 'This IBM Turbo Integrator process is designed to save data to disk for the cubes
    provided in the parameters. Use case: The process is intended for development or production
    environments. It is used whenever data for a specific cube needs to be saved, for instance,
    after loading data to save a specific cube or for manual entry cubes. Note: A valid cube
    name (pCube) is mandatory; otherwise, the process will abort. Wildcards and lists are acceptable.
    This process will save data for a cube'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process save data to disk for the cubes provided\
    \ in parameter.\n\n# Use case: Intended for Development or production.\n#1/ This process\
    \ would be used any time data for a specific cube need to be saved (i.e.: After a data loading\
    \ to save a specific cube or or for manual entry cubes).\n\n# Note:\n# Naturally, a valid\
    \  cube name (pCube) is mandatory otherwise the process will abort. Wildcards and lists\
    \ are acceptable.\n# This process will save data for a cube.\n#EndRegion @DOC\n\n##Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName\
    \ = TM1User();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    sMessage = \t'';\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pCube:%pCube%, pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Validate\
    \ Parameters ###\n# If blank delimiter specified then convert to default\nIf( pDelim @=\
    \ '' );\n  pDelim = '&';\nEndIf;\n\n# If no cubes have been specified then terminate process\n\
    If( Trim( pCube ) @= '' );\n  sMessage = 'No cubes specified';\n  nErrors = nErrors + 1;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n### SET DATA SOURCE\
    \ ###\n\nDatasourceType = 'NULL';\n\n\n### Split parameter into individual cubes and delete\
    \ ###\n\nsCubes = pCube;\nnDelimiterIndex = 1;\nsMdx = '';\n\nWhile( nDelimiterIndex <>\
    \ 0 );\n  nDelimiterIndex = Scan( pDelim, sCubes );\n  If( nDelimiterIndex = 0 );\n    sCube\
    \ = sCubes;\n  Else;\n    sCube = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n   \
    \ sCubes = Trim( Subst( sCubes, nDelimiterIndex + Long(pDelim), Long( sCubes ) ) );\n  EndIf;\n\
    \  \n  # Check if a wildcard has been used to specify the Cube name.\n  # If it hasn't then\
    \ just delete the Cube if it exists\n      # If it has then search the relevant Cube folder\
    \ to find the matches\n      If( Scan( '*', sCube ) = 0 );\n        If( CubeExists( sCube\
    \ ) = 1 ); \n          CubeSaveData( sCube );\n        Endif;\n      Else;\n        # Create\
    \ subset of cubes using Wildcard\n        sCubeExp = '''|sCube|''';\n        sMdxPart =\
    \ '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'| sCubeExp | ')}';\n        IF( sMdx\
    \ @= ''); \n          sMdx = sMdxPart; \n        ELSE;\n          sMdx = sMdx | ' + ' |\
    \ sMdxPart;\n        ENDIF;\n        \n        If( SubsetExists( '}Cubes' , cTempSub ) =\
    \ 1 );\n            # If a delimited list of cube names includes wildcards then we may have\
    \ to re-use the subset multiple times\n            SubsetMDXSet( '}Cubes' , cTempSub, sMDX\
    \ );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n        EndIf;\n      \
    \  \n        # Loop through cubes in subset created based on wildcard\n        nCountCubes\
    \ = SubsetGetSize( '}Cubes' , cTempSub );\n        While( nCountCubes >= 1 );\n        \
    \  sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCubes );\n          # Validate\
    \ cube name\n          If( CubeExists( sCurrCube ) = 1 ); \n            # Save data\n  \
    \          CubeSaveData( sCurrCube );\n          Endif;\n            nCountCubes = nCountCubes\
    \ - 1;\n        End;\n      EndIf;\n\nEnd;\n\n\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully saved data for\
    \ cube %pCube% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n\n### End Epilog ###"
- question: Erstelle einen IBM Turbo Integrator Prozess, der verwendet wird, um Cube(s) zu löschen.
    Diese Funktion eignet sich besonders für Aufräumarbeiten nach der Entwicklungs- oder Prototypphase.
    Der Prozess sollte in der Lage sein, alle Cubes zu löschen, die nach der Produktivschaltung
    nicht mehr benötigt werden. Beachte, dass eine Liste von Cube-Namen angegeben oder Platzhalter
    verwendet werden können. Es müssen selbstverständlich gültige Cube-Namen angegeben werden,
    da der Prozess andernfalls abgebrochen wird. Standardmäßig (pCtrlObj) sollen keine Kontroll-Cubes
    wie Attribute oder Sicherheits-Cubes gelöscht werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes cube(s).\n\n# Use case: Intended\
    \ for cleaning up after development/prototyping.\n# 1\\ Delete all cubes not needed after\
    \ Go Live.\n\n# Note:\n# A list of cubes can be specified and/or wild cards can be used.\n\
    # Naturally valid cube name(s) must be specified otherwise the process will abort.\n# By\
    \ default (pCtrlObj) the process will not delete control cubes (i.e. attributes, security\
    \ etc).\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    \ncThisProcName = GetProcessName();\ncUserName = TM1User();\ncTimeStamp = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub   \
    \       = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDelim:%pDelim%,\
    \ pCtrlObj:%pCtrlObj%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\n# If\
    \ blank delimiter specified then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\n\
    EndIf;\n\n# If no cubes have been specified, then log error message\nIf( Trim( pCube ) @=\
    \ '' );\n  nErrors = 1;\n  sMessage = 'No cubes specified';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# If no wildcard and no delimiter,\
    \ log error message if cubename is invalid \nIf( Scan( pDelim, pCube ) = 0 & Scan( '*',\
    \ pCube ) = 0  & Trim( pCube ) @<> '' & CubeExists( pCube ) = 0 ); \n  nErrors = 1;\n  sMessage\
    \ = 'Cubename ' | pCube | ' is invalid';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Split parameter into individual cubes and delete ###\nsCubes =\
    \ pCube;\nnDelimiterIndex = 1;\nsMdx = '';\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex\
    \ = Scan( pDelim, sCubes );\n  If( nDelimiterIndex = 0 );\n    sCube = sCubes;\n  Else;\n\
    \    sCube = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n    sCubes = Trim( Subst(\
    \ sCubes, nDelimiterIndex + Long(pDelim), Long( sCubes ) ) );\n  EndIf;\n  \n  # Check if\
    \ a wildcard has been used to specify the Cube name.\n  # If it hasn't then just delete\
    \ the Cube if it exists\n  # If it has then create cubes subset using Wildcard expression\
    \ in Mdx\n  If( Scan( '*', sCube ) = 0 );\n    If( CubeExists( sCube ) = 1 ); \n      If(Subst(sCube,1,1)\
    \ @= '}');\n        If(pCtrlObj = 1);\n          CubeDestroy( sCube );\n        Endif;\n\
    \      Else;\n        CubeDestroy( sCube );\n      Endif;\n    Endif;\n  Else;\n      #\
    \ Create subset of cubes using Wildcard\n    sCubeExp = '''|sCube|''';\n    IF( pCtrlObj\
    \ = 1 );\n      sMdxPart = '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'| sCubeExp |\
    \ ')}';\n    ELSE;\n      sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Cubes]\
    \ ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) , '}*' ) ) ,'| sCubeExp | ')}';  \n \
    \   ENDIF;\n    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx\
    \ | ' + ' | sMdxPart;\n    ENDIF;\n    \n    If( SubsetExists( '}Cubes' , cTempSub ) = 1\
    \ );\n        # If a delimited list of cube names includes wildcards then we may have to\
    \ re-use the subset multiple times\n        SubsetMDXSet( '}Cubes' , cTempSub, sMDX );\n\
    \    Else;\n        # temp subset, therefore no need to destroy in epilog\n        SubsetCreatebyMDX(\
    \ cTempSub, sMDX, '}Cubes' , 1 );\n    EndIf;\n    \n    # Loop through cubes in subset\
    \ created based on wildcard\n    nCountCubes = SubsetGetSize( '}Cubes' , cTempSub );\n \
    \   While( nCountCubes >= 1 );\n      sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub,\
    \ nCountCubes );\n      # Validate cube name\n      If( CubeExists( sCurrCube ) = 1 ); \n\
    \        # Destroy Cube\n        If(Subst(sCube,1,1) @= '}');\n          If(pCtrlObj = 1);\n\
    \            CubeDestroy( sCurrCube );\n          Endif;\n        Else;\n          CubeDestroy(\
    \ sCurrCube );\n        Endif;\n      Endif;\n        nCountCubes = nCountCubes - 1;\n \
    \   End;\n  EndIf;\n\nEnd;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted cube %pCube%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Create an IBM Turbo Integrator process that is used to delete cube(s). This functionality
    is particularly suitable for cleaning up after development or prototyping. The process should
    be capable of deleting all cubes not needed after Go Live. Note that a list of cube names
    can be specified or wildcards can be used. Naturally, valid cube names must be specified,
    otherwise the process will abort. By default (pCtrlObj), control cubes such as attributes
    or security cubes should not be deleted.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes cube(s).\n\n# Use case: Intended\
    \ for cleaning up after development/prototyping.\n# 1\\ Delete all cubes not needed after\
    \ Go Live.\n\n# Note:\n# A list of cubes can be specified and/or wild cards can be used.\n\
    # Naturally valid cube name(s) must be specified otherwise the process will abort.\n# By\
    \ default (pCtrlObj) the process will not delete control cubes (i.e. attributes, security\
    \ etc).\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    \ncThisProcName = GetProcessName();\ncUserName = TM1User();\ncTimeStamp = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub   \
    \       = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDelim:%pDelim%,\
    \ pCtrlObj:%pCtrlObj%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\n# If\
    \ blank delimiter specified then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\n\
    EndIf;\n\n# If no cubes have been specified, then log error message\nIf( Trim( pCube ) @=\
    \ '' );\n  nErrors = 1;\n  sMessage = 'No cubes specified';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# If no wildcard and no delimiter,\
    \ log error message if cubename is invalid \nIf( Scan( pDelim, pCube ) = 0 & Scan( '*',\
    \ pCube ) = 0  & Trim( pCube ) @<> '' & CubeExists( pCube ) = 0 ); \n  nErrors = 1;\n  sMessage\
    \ = 'Cubename ' | pCube | ' is invalid';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Split parameter into individual cubes and delete ###\nsCubes =\
    \ pCube;\nnDelimiterIndex = 1;\nsMdx = '';\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex\
    \ = Scan( pDelim, sCubes );\n  If( nDelimiterIndex = 0 );\n    sCube = sCubes;\n  Else;\n\
    \    sCube = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n    sCubes = Trim( Subst(\
    \ sCubes, nDelimiterIndex + Long(pDelim), Long( sCubes ) ) );\n  EndIf;\n  \n  # Check if\
    \ a wildcard has been used to specify the Cube name.\n  # If it hasn't then just delete\
    \ the Cube if it exists\n  # If it has then create cubes subset using Wildcard expression\
    \ in Mdx\n  If( Scan( '*', sCube ) = 0 );\n    If( CubeExists( sCube ) = 1 ); \n      If(Subst(sCube,1,1)\
    \ @= '}');\n        If(pCtrlObj = 1);\n          CubeDestroy( sCube );\n        Endif;\n\
    \      Else;\n        CubeDestroy( sCube );\n      Endif;\n    Endif;\n  Else;\n      #\
    \ Create subset of cubes using Wildcard\n    sCubeExp = '''|sCube|''';\n    IF( pCtrlObj\
    \ = 1 );\n      sMdxPart = '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'| sCubeExp |\
    \ ')}';\n    ELSE;\n      sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Cubes]\
    \ ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) , '}*' ) ) ,'| sCubeExp | ')}';  \n \
    \   ENDIF;\n    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx\
    \ | ' + ' | sMdxPart;\n    ENDIF;\n    \n    If( SubsetExists( '}Cubes' , cTempSub ) = 1\
    \ );\n        # If a delimited list of cube names includes wildcards then we may have to\
    \ re-use the subset multiple times\n        SubsetMDXSet( '}Cubes' , cTempSub, sMDX );\n\
    \    Else;\n        # temp subset, therefore no need to destroy in epilog\n        SubsetCreatebyMDX(\
    \ cTempSub, sMDX, '}Cubes' , 1 );\n    EndIf;\n    \n    # Loop through cubes in subset\
    \ created based on wildcard\n    nCountCubes = SubsetGetSize( '}Cubes' , cTempSub );\n \
    \   While( nCountCubes >= 1 );\n      sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub,\
    \ nCountCubes );\n      # Validate cube name\n      If( CubeExists( sCurrCube ) = 1 ); \n\
    \        # Destroy Cube\n        If(Subst(sCube,1,1) @= '}');\n          If(pCtrlObj = 1);\n\
    \            CubeDestroy( sCurrCube );\n          Endif;\n        Else;\n          CubeDestroy(\
    \ sCurrCube );\n        Endif;\n      Endif;\n        nCountCubes = nCountCubes - 1;\n \
    \   End;\n  EndIf;\n\nEnd;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted cube %pCube%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, um eine Dimension zu einem bereits
    erstellten Würfel hinzuzufügen, wobei die Möglichkeit besteht, Daten zu bewahren. Dieser
    Prozess soll im Entwicklungs- oder Prototyping-Kontext eingesetzt werden, bei dem ein vorhandener
    Würfel mit einer zusätzlichen Dimension ohne Datenverlust neu aufgebaut wird. Beachte, dass
    ein gültiger Zielwürfelname (pCube) zwingend erforderlich ist, da der Prozess sonst abbricht.
    Ebenso ist ein gültiger neuer Dimensionsname (pDim) erforderlich, da der Prozess sonst abbricht.
    Wenn die Daten beibehalten werden müssen (unter Verwendung von pIncludeData), muss ein gültiges
    Element (pEle) angegeben werden, um die Daten in der neuen Dimension zu speichern. Regeln
    können entweder nur als Sicherungsdatei aufbewahrt oder wieder geladen werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI adds a dimension to a cube that has already been\
    \ built with the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n\
    # 1/ Rebuild existing cube with extra dimension without losing data.\n\n# Note:\n# Naturally,\
    \ a valid target cube name (pCube) is mandatory otherwise the process will abort.\n# Also,\
    \ a valid new dimension name (pDim) is mandatory otherwise the process will abort.\n# When\
    \ data needs to be kept (using pIncludeData) a valid element (pEle) must be specified where\
    \ to store the data in new dimension.\n# Rule can be kept as backup file only or reloaded\
    \ back.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pDim:%pDim%, pDimIndex:%pDimIndex%, pIncludeData:%pIncludeData%,\
    \ pEle:%pEle%, pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.';\n\n\
    ## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n \
    \ sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory )\
    \ > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\n\
    EndIf;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n# Validate cube\n\
    If( Trim( pCube ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No cube specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube\
    \ ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid cube specified:\
    \ %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Don't allow system cubes to be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <=\
    \ 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Do not modify system cubes:\
    \ %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'New dimension: %pDim% does not exist');\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# check element chosen in new dimension\nIf( pIncludeData\
    \ = 1 & Trim(pEle)@='' );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'No element\
    \ specified in new dimension %pDim% to store cube data.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pIncludeData = 1 & DIMIX(pDim, pEle)=0 );\n\
    \    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid element %pEle% specified for\
    \ the new dimension %pDim% to store cube data.');\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n    cCubeRuleFileName\
    \ = '.' | sOSDelim | pCube | '.RUX';\n    If(FileExists(cCubeRuleFileName) = 0);\n     \
    \   pIncludeRules = 0;\n        LogOutput( 'INFO', Expand( 'No rule found for %pCube%.'\
    \ ) );\n    Endif;\nEndif;  \n\n### Determine number of dims in source cube & create strings\
    \ to check and recreate ###\nnCount = 1;\nsDimString = '';\nsDimCheck = '';\nsDelim = '+';\n\
    nNewFound = 0;\nnIncrement = 1;\nWhile( TabDim( pCube, nCount ) @<> '' );\n  sDim = TabDim(\
    \ pCube, nCount );\n  IF(nCount=pDimIndex & nNewFound = 0);\n    sNewDim=pDim;\n    nNewFound\
    \ = 1;\n    nIncrement = 0;\n  else;\n    sNewDim=sDim;\n    nIncrement = 1;\n  Endif; \
    \ \n  IF(nCount = 1);\n    sDimCheck = '+'|sDim|'+';\n    #sDimString = sNewDim;\n  elseif(nCount\
    \ > 1);\n    sDimCheck = sDimCheck|'+'|sDim|'+';\n  Endif;\n  sDimString = sDimString|'+'|sNewDim;\n\
    \  nCount = nCount + nIncrement;\nEnd;\nnDimensionCount = nCount;\n\n#Remove any leading\
    \ +\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\n    sDimString      = Subst ( sDimString\
    \ , 2 , 999 );\nEndIf;\n\nIF(scan('+'|pDim|'+',sDimCheck)>0);\n    nErrors = nErrors + 1;\n\
    \    sMessage = Expand( 'The chosen new dimension %pDim% already exists in cube %pCube%.');\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n# Check if cube\
    \ exceeds current max dimenions\nIf( nDimensionCount > 27 );\n    sMessage = 'Process needs\
    \ to be modified to handle cubes with more than 27 dimensions';\n    nErrors = nErrors +\
    \ 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check\
    \ for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n######  CALLING\
    \ THE STEP PROCESSES #####\n\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n\
    \  \n  sProc = '}bedrock.cube.rule.manage';\n  nRet = EXECUTEPROCESS( sProc,\n    'pLogOutput',\
    \ pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube', pCube,\n\
    \    'pMode', 'UNLOAD'\n    );\n    \n  IF(nRet <> 0);\n    sMessage = 'Error unloading\
    \ the rule for %pCube%.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n \
    \   Else;\n        ProcessBreak;\n    EndIf;\n  ENDIF;\n  \nEndif; \n\n# create clone cube\
    \ with data\nIF(pIncludeData = 1);\n  \n    pCloneCube = pCube | '_Clone';\n    nIncludeRules\
    \ = IF(pIncludeRules = 1 % pIncludeRules = 2, 1, 0);\n    nSuppressRules = IF(nIncludeRules\
    \ = 1,  1, 0);\n  \n    sProc = '}bedrock.cube.clone';\n    nRet = EXECUTEPROCESS( sProc,\n\
    \        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pSrcCube', pCube,\n        'pTgtCube', pCloneCube,\n        'pIncludeRules', nIncludeRules,\n\
    \        'pIncludeData', pIncludeData,\n        'pSuppressRules', nSuppressRules,\n    \
    \    'pTemp', pTemp,\n        'pCubeLogging', 0\n        );\n\n    IF(nRet <> 0);\n    \
    \    sMessage = 'Error creating cloned cube for keeping data.';\n        nErrors = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;\n    ENDIF;\nEndif;\n\n# recreate the cube\nsProc = '}bedrock.cube.create';\nnRet\
    \ = ExecuteProcess( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n\
    \    'pCube', pCube,\n    'pDims', sDimString,\n    'pRecreate', 1,\n    'pDelim', sDelim\n\
    \    );\n\nIF(nRet <> 0);\n    sMessage = Expand('Error recreating the cube: %pCube%.');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\nENDIF;\n\n# copy back the data\nIF(pIncludeData = 1);\n    sEleStartDelim =\
    \ '¦';\n    sMappingToNewDims = pDim|sEleStartDelim|pEle;\n  \n    nRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \  \t'pLogOutput',pLogOutput,\n  \t'pStrictErrorHandling', pStrictErrorHandling,\n  \t'pSrcCube',pCloneCube,\n\
    \  \t'pFilter','',\n  \t'pTgtCube',pCube,\n  \t'pMappingToNewDims',sMappingToNewDims,\n\
    \    'pSuppressConsol', 1,\n    'pSuppressRules', nSuppressRules,\n  \t'pZeroTarget',0,\n\
    \  \t'pZeroSource',0,\n  \t'pFactor',1,\n  \t'pDimDelim','&',\n  \t'pEleStartDelim',sEleStartDelim,\n\
    \  \t'pEleDelim','+',\n  \t'pTemp',pTemp,\n  \t'pCubeLogging',0);\n    \n    IF(nRet <>\
    \ 0);\n        sMessage = Expand('Error copying back the data from clone cube: %pCloneCube%.');\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n\
    \            ProcessBreak;\n        EndIf;\n    ENDIF;\n  \n    # destroy clone cube\n \
    \   IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n        nRet = EXECUTEPROCESS(\
    \ sProc,\n            'pLogOutput', pLogOutput,\n            'pStrictErrorHandling', pStrictErrorHandling,\n\
    \            'pCube', pCloneCube,\n            'pCtrlObj', 0\n            );\n\n       \
    \ IF(nRet <> 0);\n            sMessage = Expand('Error deleting the clone cube: %pCloneCube%.');\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n  \
    \          Else;\n                ProcessBreak;\n            EndIf;\n        ENDIF;\n  \
    \  Endif;\n\nEndif; \n\n# reload the rule\nIF(pIncludeRules = 2);\n  \n    sProc = '}bedrock.cube.rule.manage';\n\
    \n    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pCube', pCube,\n        'pMode', 'LOAD'\n        );\n\
    \    \n    IF(nRet <> 0);\n      sMessage = Expand('Error reloading the rule for %pCube%.');\n\
    \      nErrors = nErrors + 1;\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n      # Create error rule file \n      cErrorRuleName = 'ErrorRuleFile.rux';\n \
    \     \n      IF(FileExists( cErrorRuleName ) = 0 );\n        sFile = '.' | sOSDelim | cErrorRuleName;\n\
    \        LogOutput(cMsgErrorLevel, 'Rule could not be attached due to invalid !Dimension\
    \ references. Please recover from the backup and fix manually.');\n      ENDIF;\n      \n\
    \      EXECUTEPROCESS( sProc,\n      'pLogOutput', pLogOutput,\n      'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n      'pCube', pCube,\n      'pFileName', cErrorRuleName,\n   \
    \   'pMode', 'LOAD'\n      );\n      If( pStrictErrorHandling = 1 ); \n          ProcessQuit;\
    \ \n      Else;\n          ProcessBreak;\n      EndIf;\n    ENDIF;\n  \nEndif; \n\n### End\
    \ Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully added dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Develop an IBM Turbo Integrator process to add a dimension to an already built cube
    with the ability to preserve data. This process is intended for development or prototyping
    use, where an existing cube is rebuilt with an extra dimension without losing data. Note
    that a valid target cube name (pCube) is mandatory; otherwise, the process will abort. Likewise,
    a valid new dimension name (pDim) is mandatory; otherwise, the process will abort. When
    data needs to be kept (using pIncludeData), a valid element (pEle) must be specified to
    store the data in the new dimension. Rules can be kept as a backup file only or reloaded
    back.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI adds a dimension to a cube that has already been\
    \ built with the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n\
    # 1/ Rebuild existing cube with extra dimension without losing data.\n\n# Note:\n# Naturally,\
    \ a valid target cube name (pCube) is mandatory otherwise the process will abort.\n# Also,\
    \ a valid new dimension name (pDim) is mandatory otherwise the process will abort.\n# When\
    \ data needs to be kept (using pIncludeData) a valid element (pEle) must be specified where\
    \ to store the data in new dimension.\n# Rule can be kept as backup file only or reloaded\
    \ back.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pDim:%pDim%, pDimIndex:%pDimIndex%, pIncludeData:%pIncludeData%,\
    \ pEle:%pEle%, pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.';\n\n\
    ## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n \
    \ sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory )\
    \ > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\n\
    EndIf;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n# Validate cube\n\
    If( Trim( pCube ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No cube specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube\
    \ ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid cube specified:\
    \ %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Don't allow system cubes to be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <=\
    \ 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Do not modify system cubes:\
    \ %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'New dimension: %pDim% does not exist');\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# check element chosen in new dimension\nIf( pIncludeData\
    \ = 1 & Trim(pEle)@='' );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'No element\
    \ specified in new dimension %pDim% to store cube data.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pIncludeData = 1 & DIMIX(pDim, pEle)=0 );\n\
    \    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid element %pEle% specified for\
    \ the new dimension %pDim% to store cube data.');\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n    cCubeRuleFileName\
    \ = '.' | sOSDelim | pCube | '.RUX';\n    If(FileExists(cCubeRuleFileName) = 0);\n     \
    \   pIncludeRules = 0;\n        LogOutput( 'INFO', Expand( 'No rule found for %pCube%.'\
    \ ) );\n    Endif;\nEndif;  \n\n### Determine number of dims in source cube & create strings\
    \ to check and recreate ###\nnCount = 1;\nsDimString = '';\nsDimCheck = '';\nsDelim = '+';\n\
    nNewFound = 0;\nnIncrement = 1;\nWhile( TabDim( pCube, nCount ) @<> '' );\n  sDim = TabDim(\
    \ pCube, nCount );\n  IF(nCount=pDimIndex & nNewFound = 0);\n    sNewDim=pDim;\n    nNewFound\
    \ = 1;\n    nIncrement = 0;\n  else;\n    sNewDim=sDim;\n    nIncrement = 1;\n  Endif; \
    \ \n  IF(nCount = 1);\n    sDimCheck = '+'|sDim|'+';\n    #sDimString = sNewDim;\n  elseif(nCount\
    \ > 1);\n    sDimCheck = sDimCheck|'+'|sDim|'+';\n  Endif;\n  sDimString = sDimString|'+'|sNewDim;\n\
    \  nCount = nCount + nIncrement;\nEnd;\nnDimensionCount = nCount;\n\n#Remove any leading\
    \ +\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\n    sDimString      = Subst ( sDimString\
    \ , 2 , 999 );\nEndIf;\n\nIF(scan('+'|pDim|'+',sDimCheck)>0);\n    nErrors = nErrors + 1;\n\
    \    sMessage = Expand( 'The chosen new dimension %pDim% already exists in cube %pCube%.');\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n# Check if cube\
    \ exceeds current max dimenions\nIf( nDimensionCount > 27 );\n    sMessage = 'Process needs\
    \ to be modified to handle cubes with more than 27 dimensions';\n    nErrors = nErrors +\
    \ 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check\
    \ for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n######  CALLING\
    \ THE STEP PROCESSES #####\n\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n\
    \  \n  sProc = '}bedrock.cube.rule.manage';\n  nRet = EXECUTEPROCESS( sProc,\n    'pLogOutput',\
    \ pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube', pCube,\n\
    \    'pMode', 'UNLOAD'\n    );\n    \n  IF(nRet <> 0);\n    sMessage = 'Error unloading\
    \ the rule for %pCube%.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n \
    \   Else;\n        ProcessBreak;\n    EndIf;\n  ENDIF;\n  \nEndif; \n\n# create clone cube\
    \ with data\nIF(pIncludeData = 1);\n  \n    pCloneCube = pCube | '_Clone';\n    nIncludeRules\
    \ = IF(pIncludeRules = 1 % pIncludeRules = 2, 1, 0);\n    nSuppressRules = IF(nIncludeRules\
    \ = 1,  1, 0);\n  \n    sProc = '}bedrock.cube.clone';\n    nRet = EXECUTEPROCESS( sProc,\n\
    \        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pSrcCube', pCube,\n        'pTgtCube', pCloneCube,\n        'pIncludeRules', nIncludeRules,\n\
    \        'pIncludeData', pIncludeData,\n        'pSuppressRules', nSuppressRules,\n    \
    \    'pTemp', pTemp,\n        'pCubeLogging', 0\n        );\n\n    IF(nRet <> 0);\n    \
    \    sMessage = 'Error creating cloned cube for keeping data.';\n        nErrors = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;\n    ENDIF;\nEndif;\n\n# recreate the cube\nsProc = '}bedrock.cube.create';\nnRet\
    \ = ExecuteProcess( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n\
    \    'pCube', pCube,\n    'pDims', sDimString,\n    'pRecreate', 1,\n    'pDelim', sDelim\n\
    \    );\n\nIF(nRet <> 0);\n    sMessage = Expand('Error recreating the cube: %pCube%.');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\nENDIF;\n\n# copy back the data\nIF(pIncludeData = 1);\n    sEleStartDelim =\
    \ '¦';\n    sMappingToNewDims = pDim|sEleStartDelim|pEle;\n  \n    nRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \  \t'pLogOutput',pLogOutput,\n  \t'pStrictErrorHandling', pStrictErrorHandling,\n  \t'pSrcCube',pCloneCube,\n\
    \  \t'pFilter','',\n  \t'pTgtCube',pCube,\n  \t'pMappingToNewDims',sMappingToNewDims,\n\
    \    'pSuppressConsol', 1,\n    'pSuppressRules', nSuppressRules,\n  \t'pZeroTarget',0,\n\
    \  \t'pZeroSource',0,\n  \t'pFactor',1,\n  \t'pDimDelim','&',\n  \t'pEleStartDelim',sEleStartDelim,\n\
    \  \t'pEleDelim','+',\n  \t'pTemp',pTemp,\n  \t'pCubeLogging',0);\n    \n    IF(nRet <>\
    \ 0);\n        sMessage = Expand('Error copying back the data from clone cube: %pCloneCube%.');\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n\
    \            ProcessBreak;\n        EndIf;\n    ENDIF;\n  \n    # destroy clone cube\n \
    \   IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n        nRet = EXECUTEPROCESS(\
    \ sProc,\n            'pLogOutput', pLogOutput,\n            'pStrictErrorHandling', pStrictErrorHandling,\n\
    \            'pCube', pCloneCube,\n            'pCtrlObj', 0\n            );\n\n       \
    \ IF(nRet <> 0);\n            sMessage = Expand('Error deleting the clone cube: %pCloneCube%.');\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n  \
    \          Else;\n                ProcessBreak;\n            EndIf;\n        ENDIF;\n  \
    \  Endif;\n\nEndif; \n\n# reload the rule\nIF(pIncludeRules = 2);\n  \n    sProc = '}bedrock.cube.rule.manage';\n\
    \n    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pCube', pCube,\n        'pMode', 'LOAD'\n        );\n\
    \    \n    IF(nRet <> 0);\n      sMessage = Expand('Error reloading the rule for %pCube%.');\n\
    \      nErrors = nErrors + 1;\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n      # Create error rule file \n      cErrorRuleName = 'ErrorRuleFile.rux';\n \
    \     \n      IF(FileExists( cErrorRuleName ) = 0 );\n        sFile = '.' | sOSDelim | cErrorRuleName;\n\
    \        LogOutput(cMsgErrorLevel, 'Rule could not be attached due to invalid !Dimension\
    \ references. Please recover from the backup and fix manually.');\n      ENDIF;\n      \n\
    \      EXECUTEPROCESS( sProc,\n      'pLogOutput', pLogOutput,\n      'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n      'pCube', pCube,\n      'pFileName', cErrorRuleName,\n   \
    \   'pMode', 'LOAD'\n      );\n      If( pStrictErrorHandling = 1 ); \n          ProcessQuit;\
    \ \n      Else;\n          ProcessBreak;\n      EndIf;\n    ENDIF;\n  \nEndif; \n\n### End\
    \ Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully added dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der dazu dient, eine Dimension aus
    einem bereits erstellten Würfel zu löschen, wobei die Möglichkeit besteht, Daten zu erhalten.
    Der Prozess richtet sich an die Entwicklung und das Prototyping und ermöglicht es, einen
    bestehenden Würfel mit der Entfernung einer Dimension neu zu erstellen, ohne alle Daten
    zu verlieren. Beachte, dass ein gültiger Würfelname (pCube) und ein gültiger Dimensionsname
    (pDim) erforderlich sind, andernfalls wird der Prozess abgebrochen. Wenn Daten erhalten
    werden müssen (mithilfe von pIncludeData), werden die Daten aus pDim summiert. Regeln können
    nur als Sicherungsdatei beibehalten oder erneut geladen werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI deletes a dimension from a cube that has already\
    \ been built with the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n\
    # 1/ Rebuild existing cube with the removal of one dimension without losing all the data.\n\
    \n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process will\
    \ abort.\n# Also, a valid dimension name (pDim) is mandatory otherwise the process will\
    \ abort.\n# If data needs to be kept (using pIncludeData), data from pDim will be summed.\n\
    # Rule can be kept as backup file only or reloaded back.\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters\
    \ pCube:%pCube%, pDim:%pDim%, pIncludeData:%pIncludeData%, pIncludeRules:%pIncludeRules%,\
    \ pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.';\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n# Validate cube\n\
    If( Trim( pCube ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No cube specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube\
    \ ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid cube specified:\
    \ %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Don't allow system cubes to be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <=\
    \ 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Do not modify system cubes:\
    \ %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'New dimension: %pDim% does not exist');\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n    cCubeRuleFileName\
    \ = '.' | sOSDelim | pCube | '.RUX';\n    If(FileExists(cCubeRuleFileName) = 0);\n     \
    \   pIncludeRules = 0;\n        LogOutput( 'INFO', Expand( 'No rule found for %pCube%.'\
    \ ) );\n    Endif;\nEndif;  \n\n### Determine number of dims in source cube & create strings\
    \ to check and recreate ###\nnCount = 1;\nsDimString = '';\nsDimCheck = '';\nsDelim = '+';\n\
    nSkip=0;\nnIncrement = 1;\nWhile( TabDim( pCube, nCount ) @<> '' );\n    sDim = TabDim(\
    \ pCube, nCount );\n    IF(sDim@=pDim);\n        nSkip = 1;\n    else;\n        nSkip =\
    \ 0;\n    Endif; \n    IF(nCount = 1);\n        sDimCheck = '+'|sDim|'+';\n    elseif(nCount\
    \ > 1);\n        sDimCheck = sDimCheck|'+'|sDim|'+';\n    Endif;\n    IF(nCount = 1 & nSkip\
    \ = 0);\n        sDimString = sDim;\n    elseif(nCount > 1 & nSkip = 0);\n        sDimString\
    \ = sDimString|'+'|sDim;\n    Endif;\n    nCount = nCount + 1;\nEnd;\nnDimensionCount =\
    \ nCount-1;\n\n#Remove any leading +\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\n    sDimString\
    \      = Subst ( sDimString , 2 , 999 );\nEndIf;\n\n\nIF(scan('+'|pDim|'+',sDimCheck)=0);\n\
    \    nErrors = nErrors + 1;\n    sMessage = Expand( 'The chosen dimension %pDim% does not\
    \ exists in cube %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndif;\n\n# Check if cube exceeds current max dimenions\nIf( nDimensionCount > 27\
    \ );\n    sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n######\
    \  CALLING THE STEP PROCESSES #####\n\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules\
    \ = 2);\n  \n  sProc = '}bedrock.cube.rule.manage';\n\n  nRet = EXECUTEPROCESS( sProc,\n\
    \    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube',\
    \ pCube,\n    'pMode', 'UNLOAD'\n    );\n    \n  IF(nRet <> 0);\n    sMessage = 'Error unloading\
    \ the rule for %pCube%.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n \
    \   Else;\n        ProcessBreak;\n    EndIf;\n  ENDIF;\n  \nEndif; \n\n# create clone cube\
    \ with data\nIF(pIncludeData = 1);\n    pCloneCube = pCube | '_Clone';\n    nIncludeRules\
    \ = IF(pIncludeRules = 1 % pIncludeRules = 2, 1, 0);\n    nSuppressRules = IF(nIncludeRules\
    \ = 1,  1, 0);\n  \n    sProc = '}bedrock.cube.clone';\n    nRet = EXECUTEPROCESS( sProc,\n\
    \        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pSrcCube', pCube,\n        'pTgtCube', pCloneCube,\n        'pIncludeRules', nIncludeRules,\n\
    \        'pIncludeData', pIncludeData,\n        'pSuppressRules', nSuppressRules,\n    \
    \    'pTemp', pTemp,\n        'pCubeLogging', 0\n        );\n\n    IF(nRet <> 0);\n    \
    \    sMessage = 'Error creating cloned cube for keeping data.';\n        nErrors = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;\n    ENDIF;\n  \nEndif;\n\n#Processbreak;\n\n# recreate the cube\nsProc = '}bedrock.cube.create';\n\
    nRet = ExecuteProcess( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    'pCube', pCube,\n    'pDims', sDimString,\n    'pRecreate',\
    \ 1,\n    'pDelim', sDelim\n    );\n\nIF(nRet <> 0);\n    sMessage = Expand('Error recreating\
    \ the cube: %pCube%.');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n \
    \   Else;\n        ProcessBreak;\n    EndIf;\nENDIF;\n\n#Processbreak;\n\n# copy back the\
    \ data\nIF(pIncludeData = 1);\n    sProc = '}bedrock.cube.data.copy.intercube';\n    nRet\
    \ = ExecuteProcess( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pSrcCube', pCloneCube,\n        'pFilter', '',\n     \
    \   'pTgtCube', pCube,\n        'pMappingToNewDims', '',\n        'pSuppressConsol', 1,\n\
    \        'pSuppressRules', nSuppressRules,\n        'pZeroSource', 0,\n        'pZeroTarget',\
    \ 0,\n        'pFactor', 1,\n        'pTemp', pTemp,\n        'pCubeLogging', 0\n      \
    \  );  \n    \n    IF(nRet <> 0);\n        sMessage = Expand('Error copying back the data\
    \ from clone cube: %pCloneCube%.');\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 );\
    \ \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n        EndIf;\n\
    \    ENDIF;\n  \n    # destroy clone cube\n    IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n\
    \        nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pCube', pCloneCube,\n        'pCtrlObj', 0\n        );\n\
    \n        IF(nRet <> 0);\n            sMessage = Expand('Error deleting cloned cube: %pCloneCube%.');\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n  \
    \          Else;\n                ProcessBreak;\n            EndIf;\n        ENDIF;\n  \
    \  Endif;\n  \nEndif; \n\n# reload the rule\nIF(pIncludeRules = 2);\n  \n  sProc = '}bedrock.cube.rule.manage';\n\
    \n  nRet = EXECUTEPROCESS( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    'pCube', pCube,\n    'pMode', 'LOAD'\n    );\n    \n  IF(nRet\
    \ <> 0);\n    sMessage = Expand('Error reloading the rule for %pCube%.');\n    nErrors =\
    \ nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    # Create\
    \ error rule file \n    cErrorRuleName = 'ErrorRuleFile.rux';\n\n    IF(FileExists( cErrorRuleName\
    \ ) = 0 );\n      sFile = '.' | sOSDelim | cErrorRuleName;\n      LogOutput(cMsgErrorLevel,\
    \ 'Rule could not be attached due to invalid !Dimension references. Please recover from\
    \ the backup and fix manually.');\n    ENDIF;\n\n    EXECUTEPROCESS( sProc,\n    'pLogOutput',\
    \ pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube', pCube,\n\
    \    'pFileName', cErrorRuleName,\n    'pMode', 'LOAD'\n    );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\n  ENDIF;\n\
    \  \nEndif; \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted dimension %pDim% from the %pCube%\
    \ cube.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand(\
    \ sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that is designed to delete a dimension from
    an already built cube with the ability to preserve data. The process is intended for development
    and prototyping and allows for rebuilding an existing cube with the removal of one dimension
    without losing all the data. Note that a valid cube name (pCube) and a valid dimension name
    (pDim) are mandatory; otherwise, the process will abort. If data needs to be kept (using
    pIncludeData), data from pDim will be summed. Rules can be kept as a backup file only or
    reloaded back.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI deletes a dimension from a cube that has already\
    \ been built with the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n\
    # 1/ Rebuild existing cube with the removal of one dimension without losing all the data.\n\
    \n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process will\
    \ abort.\n# Also, a valid dimension name (pDim) is mandatory otherwise the process will\
    \ abort.\n# If data needs to be kept (using pIncludeData), data from pDim will be summed.\n\
    # Rule can be kept as backup file only or reloaded back.\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters\
    \ pCube:%pCube%, pDim:%pDim%, pIncludeData:%pIncludeData%, pIncludeRules:%pIncludeRules%,\
    \ pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.';\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n# Validate cube\n\
    If( Trim( pCube ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No cube specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube\
    \ ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid cube specified:\
    \ %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Don't allow system cubes to be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <=\
    \ 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Do not modify system cubes:\
    \ %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'New dimension: %pDim% does not exist');\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n    cCubeRuleFileName\
    \ = '.' | sOSDelim | pCube | '.RUX';\n    If(FileExists(cCubeRuleFileName) = 0);\n     \
    \   pIncludeRules = 0;\n        LogOutput( 'INFO', Expand( 'No rule found for %pCube%.'\
    \ ) );\n    Endif;\nEndif;  \n\n### Determine number of dims in source cube & create strings\
    \ to check and recreate ###\nnCount = 1;\nsDimString = '';\nsDimCheck = '';\nsDelim = '+';\n\
    nSkip=0;\nnIncrement = 1;\nWhile( TabDim( pCube, nCount ) @<> '' );\n    sDim = TabDim(\
    \ pCube, nCount );\n    IF(sDim@=pDim);\n        nSkip = 1;\n    else;\n        nSkip =\
    \ 0;\n    Endif; \n    IF(nCount = 1);\n        sDimCheck = '+'|sDim|'+';\n    elseif(nCount\
    \ > 1);\n        sDimCheck = sDimCheck|'+'|sDim|'+';\n    Endif;\n    IF(nCount = 1 & nSkip\
    \ = 0);\n        sDimString = sDim;\n    elseif(nCount > 1 & nSkip = 0);\n        sDimString\
    \ = sDimString|'+'|sDim;\n    Endif;\n    nCount = nCount + 1;\nEnd;\nnDimensionCount =\
    \ nCount-1;\n\n#Remove any leading +\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\n    sDimString\
    \      = Subst ( sDimString , 2 , 999 );\nEndIf;\n\n\nIF(scan('+'|pDim|'+',sDimCheck)=0);\n\
    \    nErrors = nErrors + 1;\n    sMessage = Expand( 'The chosen dimension %pDim% does not\
    \ exists in cube %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndif;\n\n# Check if cube exceeds current max dimenions\nIf( nDimensionCount > 27\
    \ );\n    sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n######\
    \  CALLING THE STEP PROCESSES #####\n\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules\
    \ = 2);\n  \n  sProc = '}bedrock.cube.rule.manage';\n\n  nRet = EXECUTEPROCESS( sProc,\n\
    \    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube',\
    \ pCube,\n    'pMode', 'UNLOAD'\n    );\n    \n  IF(nRet <> 0);\n    sMessage = 'Error unloading\
    \ the rule for %pCube%.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n \
    \   Else;\n        ProcessBreak;\n    EndIf;\n  ENDIF;\n  \nEndif; \n\n# create clone cube\
    \ with data\nIF(pIncludeData = 1);\n    pCloneCube = pCube | '_Clone';\n    nIncludeRules\
    \ = IF(pIncludeRules = 1 % pIncludeRules = 2, 1, 0);\n    nSuppressRules = IF(nIncludeRules\
    \ = 1,  1, 0);\n  \n    sProc = '}bedrock.cube.clone';\n    nRet = EXECUTEPROCESS( sProc,\n\
    \        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pSrcCube', pCube,\n        'pTgtCube', pCloneCube,\n        'pIncludeRules', nIncludeRules,\n\
    \        'pIncludeData', pIncludeData,\n        'pSuppressRules', nSuppressRules,\n    \
    \    'pTemp', pTemp,\n        'pCubeLogging', 0\n        );\n\n    IF(nRet <> 0);\n    \
    \    sMessage = 'Error creating cloned cube for keeping data.';\n        nErrors = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;\n    ENDIF;\n  \nEndif;\n\n#Processbreak;\n\n# recreate the cube\nsProc = '}bedrock.cube.create';\n\
    nRet = ExecuteProcess( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    'pCube', pCube,\n    'pDims', sDimString,\n    'pRecreate',\
    \ 1,\n    'pDelim', sDelim\n    );\n\nIF(nRet <> 0);\n    sMessage = Expand('Error recreating\
    \ the cube: %pCube%.');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n \
    \   Else;\n        ProcessBreak;\n    EndIf;\nENDIF;\n\n#Processbreak;\n\n# copy back the\
    \ data\nIF(pIncludeData = 1);\n    sProc = '}bedrock.cube.data.copy.intercube';\n    nRet\
    \ = ExecuteProcess( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pSrcCube', pCloneCube,\n        'pFilter', '',\n     \
    \   'pTgtCube', pCube,\n        'pMappingToNewDims', '',\n        'pSuppressConsol', 1,\n\
    \        'pSuppressRules', nSuppressRules,\n        'pZeroSource', 0,\n        'pZeroTarget',\
    \ 0,\n        'pFactor', 1,\n        'pTemp', pTemp,\n        'pCubeLogging', 0\n      \
    \  );  \n    \n    IF(nRet <> 0);\n        sMessage = Expand('Error copying back the data\
    \ from clone cube: %pCloneCube%.');\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 );\
    \ \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n        EndIf;\n\
    \    ENDIF;\n  \n    # destroy clone cube\n    IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n\
    \        nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pCube', pCloneCube,\n        'pCtrlObj', 0\n        );\n\
    \n        IF(nRet <> 0);\n            sMessage = Expand('Error deleting cloned cube: %pCloneCube%.');\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n  \
    \          Else;\n                ProcessBreak;\n            EndIf;\n        ENDIF;\n  \
    \  Endif;\n  \nEndif; \n\n# reload the rule\nIF(pIncludeRules = 2);\n  \n  sProc = '}bedrock.cube.rule.manage';\n\
    \n  nRet = EXECUTEPROCESS( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    'pCube', pCube,\n    'pMode', 'LOAD'\n    );\n    \n  IF(nRet\
    \ <> 0);\n    sMessage = Expand('Error reloading the rule for %pCube%.');\n    nErrors =\
    \ nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    # Create\
    \ error rule file \n    cErrorRuleName = 'ErrorRuleFile.rux';\n\n    IF(FileExists( cErrorRuleName\
    \ ) = 0 );\n      sFile = '.' | sOSDelim | cErrorRuleName;\n      LogOutput(cMsgErrorLevel,\
    \ 'Rule could not be attached due to invalid !Dimension references. Please recover from\
    \ the backup and fix manually.');\n    ENDIF;\n\n    EXECUTEPROCESS( sProc,\n    'pLogOutput',\
    \ pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube', pCube,\n\
    \    'pFileName', cErrorRuleName,\n    'pMode', 'LOAD'\n    );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\n  ENDIF;\n\
    \  \nEndif; \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted dimension %pDim% from the %pCube%\
    \ cube.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand(\
    \ sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'er angezeigte IBM Turbo Integrator Prozess beschreibt einen Anwendungsfall, bei
    dem eine Dimension aus einem bestehenden Würfel entfernt und eine andere hinzugefügt wird,
    ohne dass dabei Daten verloren gehen. Dieser Prozess ist hauptsächlich für Entwicklungs-
    und Prototyping-Zwecke gedacht und funktioniert folgendermaßen: 1/ Nach der Entfernung einer
    Dimension und dem Hinzufügen einer anderen wird der bestehende Würfel wieder aufgebaut,
    ohne dass alle Daten verloren gehen. Wichtig zu beachten ist, dass ein gültiger Würfelname
    (pCube) erforderlich ist, da der Prozess ansonsten abgebrochen wird. Auch die Namen der
    relevanten Dimensionen (pSrcDim & pTgtDim) sind obligatorisch, da der Prozess ebenfalls
    bei Ungültigkeit abgebrochen wird. Wenn die Daten beibehalten werden sollen, muss ein gültiges
    Element (pEle) in der neuen Dimension angegeben werden, wo die Daten gespeichert werden
    sollen. Daten werden aus der originalen Dimension summiert. Regeln können sowohl als Backup-Datei
    gespeichert als auch wieder geladen werden.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI deletes a dimension and adds another one to an\
    \ existing cube with the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n\
    # 1/ Rebuild existing cube after removal of one dimension and adding anothr one without\
    \ losing all the data.\n\n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise\
    \ the process will abort.\n# Also, valid dimension names (pSrcDim & pTgtDim) are mandatory\
    \ otherwise the process will abort.\n# When data needs to be kept (using pIncludeData) a\
    \ valid element (pEle) in new dimension must be specified\n# where to store the data. Data\
    \ is summed from original dimension.\n# Rule can be kept as backup file only or reloaded\
    \ back.\n#EndRegion @DOC\n\n\n# This process selects the cube and replaces\n# the source\
    \ dimensions from a specified target dimensions.\n# This process should only be run on an\
    \ EMPTY cube or a cube that\n# has already had all data exported to a text file\n\n# Note:\n\
    # - This process does not preserve any cube rules as they would likely no longer be\n# \
    \  valid if a dimension is replaced\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\n\n### Constants ###\ncThisProcName     = GetProcessName();\n\
    cUserName         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n\
    cRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pSrcDim:%pSrcDim%,\
    \ pTgtDim:%pTgtDim%, pIncludeData:%pIncludeData%, pEle:%pEle%, pIncludeRules:%pIncludeRules%,\
    \ pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.' ;   \ncDefaultView      = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%'\
    \ );\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':'\
    \ );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n### Validate Parameters ###\nnErrors = 0;\n# Validate cube\nIf( Trim( pCube\
    \ ) @= '' );\n    sMessage = 'No cube specified.';\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) = 0 );\n  \
    \  sMessage = Expand( 'Cube %pCube% does not exist.' );\n    nErrors = nErrors + 1;\n  \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Don't allow system\
    \ cubes to be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\n  nErrors =\
    \ nErrors + 1;\n  sMessage = Expand( 'Do not modify system cubes: %pCube%.');\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate source dimension\n\
    If( Trim( pSrcDim ) @= '' );\n  nErrors = nErrors + 1;\n  sMessage = 'No source dimension\
    \ specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists(\
    \ pSrcDim ) = 0 );\n  nErrors = nErrors + 1;\n  sMessage = Expand( 'Source dimension %pSrcDim%\
    \ does not exist.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate target dimension\nIf( Trim( pTgtDim ) @= '' );\n  nErrors = nErrors + 1;\n\
    \  sMessage = 'No target dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pTgtDim ) = 0 );\n  nErrors = nErrors + 1;\n  sMessage\
    \ = Expand( 'Target dimension %pTgtDim% does not exist.');\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check that the source and target dimensions\
    \ are different\nIf( pSrcDim @= pTgtDim );\n  sMessage = Expand('Source and target dimensions\
    \ are the same: %pSrcDim%');\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# check element chosen in new dimension\nIf( pIncludeData\
    \ = 1 & Trim(pEle)@='' );\n  nErrors = nErrors + 1;\n  sMessage = Expand( 'No element specified\
    \ in new dimension %pTgtDim% to store cube data.');\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\nIf( pIncludeData = 1 & DIMIX(pTgtDim, pEle)=0 );\n  nErrors\
    \ = nErrors + 1;\n  sMessage = Expand( 'Invalid element %pEle% specified for the new dimension\
    \ %pTgtDim% to store cube data.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n  cCubeRuleFileName = '.'\
    \ | sOSDelim | pCube | '.RUX';\n  If(FileExists(cCubeRuleFileName) = 0);\n    pIncludeRules\
    \ = 0;\n    LogOutput( 'INFO', Expand( 'No rule found for %pCube%.' ) );\n  Endif;\nEndif;\
    \  \n\n### Determine number of dims in source cube & create strings to check and recreate\
    \ ###\nnCount = 1;\nsDimString = '';\nsDimCheck = '';\nsDelim = '+';\nWhile( TabDim( pCube,\
    \ nCount ) @<> '' );\n  sDim = TabDim( pCube, nCount );\n  IF(sDim@=pSrcDim);\n    sNewDim=pTgtDim;\n\
    \  else;\n    sNewDim=sDim;\n  Endif;  \n  IF(nCount = 1);\n    sDimCheck = '+'|sDim|'+';\n\
    \    sDimString = sNewDim;\n  elseif(nCount > 1);\n    sDimCheck = sDimCheck|'+'|sDim|'+';\n\
    \    sDimString = sDimString|'+'|sNewDim;\n  Endif;\n  nCount = nCount + 1;\nEnd;\nnDimensionCount\
    \ = nCount - 1;\n\n#Remove any leading +\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\n  \
    \  sDimString      = Subst ( sDimString , 2 , 999 );\nEndIf;\n\n#check source dimension\n\
    IF(scan('+'|pSrcDim|'+', sDimCheck)=0);\n  nErrors = nErrors + 1;\n  sMessage = Expand(\
    \ 'Source Dimension %pSrcDim% does not exist in %pCube%.');\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n#check target dimension\nIF(scan('+'|pTgtDim|'+',\
    \ sDimCheck)>0);\n  nErrors = nErrors + 1;\n  sMessage = Expand( 'Target Dimension %pTgtDim%\
    \ already exists in %pCube%.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndif;\n\n# Check if cube exceeds current max dimenions\nIf( nDimensionCount > 27\
    \ );\n  sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n######\
    \  CALLING THE STEP PROCESSES #####\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules\
    \ = 2);\n    sProc = '}bedrock.cube.rule.manage';\n\n    nRet = EXECUTEPROCESS( sProc,\n\
    \        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pCube', pCube,\n        'pMode', 'UNLOAD'\n        );\n    \n    IF(nRet <> 0);\n\
    \        sMessage = 'Error unloading the rule for %pCube%.';\n        nErrors = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;        \n    ENDIF;\n  \nEndif; \n\n# create clone cube with data\nIF(pIncludeData\
    \ = 1);\n  \n    pCloneCube = pCube | '_Clone';\n    nIncludeRules = IF(pIncludeRules =\
    \ 1 % pIncludeRules = 2, 1, 0);\n     nSuppressRules = IF(nIncludeRules = 1,  1, 0);\n \
    \ \n    sProc = '}bedrock.cube.clone';\n    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput',\
    \ pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n        'pSrcCube',\
    \ pCube,\n        'pTgtCube', pCloneCube,\n        'pIncludeRules', nIncludeRules,\n   \
    \     'pIncludeData', pIncludeData,\n        'pSuppressRules', nSuppressRules,\n       \
    \ 'pTemp', pTemp,\n        'pCubeLogging', 0\n        );\n\n    IF(nRet <> 0);\n       \
    \ sMessage = 'Error creating cloned cube for keeping data.';\n        nErrors = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;\n    ENDIF;\n  \nEndif;\n\n# recreate the cube\nsProc = '}bedrock.cube.create';\n\
    nRet = ExecuteProcess( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pCube', pCube,\n        'pDims', sDimString,\n       \
    \ 'pRecreate', 1,\n        'pDelim', sDelim\n        );\n\nIF(nRet <> 0);\n    sMessage\
    \ = Expand('Error recreating the cube: %pCube%.');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n\
    \        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\nENDIF;\n\n\n# copy\
    \ back the data\nIF(pIncludeData = 1);\n    sEleStartDelim = '¦';\n    sMappingToNewDims\
    \ = pTgtDim|sEleStartDelim|pEle;\n  \n    nRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \t    'pLogOutput',pLogOutput,\n\t    'pStrictErrorHandling', pStrictErrorHandling,\n\t\
    \    'pSrcCube',pCloneCube,\n\t    'pFilter','',\n\t    'pTgtCube',pCube,\n\t    'pMappingToNewDims',sMappingToNewDims,\n\
    \        'pSuppressConsol', 1,\n        'pSuppressRules', nSuppressRules,\n\t    'pZeroTarget',0,\n\
    \t    'pZeroSource',0,\n\t    'pFactor',1,\n\t    'pDimDelim','&',\n\t    'pEleStartDelim',sEleStartDelim,\n\
    \t    'pEleDelim','+',\n\t    'pTemp',pTemp,\n\t    'pCubeLogging',0);\n    \n    IF(nRet\
    \ <> 0);\n        sMessage = Expand('Error copying back the data from clone cube: %pCloneCube%.');\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n\
    \            ProcessBreak;\n        EndIf;\n    ENDIF;\n  \n    # destroy clone cube\n \
    \   IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n        nRet = EXECUTEPROCESS(\
    \ sProc,\n            'pLogOutput', pLogOutput,\n            'pStrictErrorHandling', pStrictErrorHandling,\n\
    \            'pCube', pCloneCube,\n            'pCtrlObj', 0\n            );\n\n       \
    \ IF(nRet <> 0);\n            sMessage = Expand('Error deleting the clone cube: %pCloneCube%.');\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n  \
    \          Else;\n                ProcessBreak;\n            EndIf;\n        ENDIF;\n  \
    \  Endif;\n  \nEndif; \n\n# reload the rule\nIF(pIncludeRules = 2);\n  \n    sProc = '}bedrock.cube.rule.manage';\n\
    \n    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pCube', pCube,\n        'pMode', 'LOAD'\n        );\n\
    \    \n    IF(nRet <> 0);\n      sMessage = Expand('Error reloading the rule for %pCube%.');\n\
    \      nErrors = nErrors + 1;\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n      # Create error rule file \n      cErrorRuleName = 'ErrorRuleFile.rux';\n\n\
    \      IF(FileExists( cErrorRuleName ) = 0 );\n        sFile = '.' | sOSDelim | cErrorRuleName;\n\
    \        LogOutput(cMsgErrorLevel, 'Rule could not be attached due to invalid !Dimension\
    \ references. Please recover from the backup and fix manually.');\n      ENDIF;\n\n    \
    \  EXECUTEPROCESS( sProc,\n      'pLogOutput', pLogOutput,\n      'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n      'pCube', pCube,\n      'pFileName', cErrorRuleName,\n   \
    \   'pMode', 'LOAD'\n      );\n      If( pStrictErrorHandling = 1 ); \n          ProcessQuit;\
    \ \n      Else;\n          ProcessBreak;\n      EndIf;\n    ENDIF;\n  \nEndif; \n\n### End\
    \ Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully replaced the %pSrcDim% dimension with the %pTgtDim% in the %pCube% cube.\
    \ Data was loaded to the %pEle% item.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n  \n### End Epilog\
    \ ###"
- question: 'The IBM Turbo Integrator process described involves removing one dimension from
    an existing cube and adding another one without losing data. This process is intended primarily
    for development and prototyping purposes and operates as follows: 1/ After removing one
    dimension and adding another, the existing cube is rebuilt without losing all the data.
    It is important to note that a valid cube name (pCube) is mandatory, otherwise, the process
    will abort. Additionally, the names of the relevant dimensions (pSrcDim & pTgtDim) are mandatory,
    and the process will also abort if they are invalid. If data needs to be preserved, a valid
    element (pEle) in the new dimension must be specified for data storage. The data is summed
    from the original dimension. Rules can be saved as backup files or reloaded.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI deletes a dimension and adds another one to an\
    \ existing cube with the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n\
    # 1/ Rebuild existing cube after removal of one dimension and adding anothr one without\
    \ losing all the data.\n\n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise\
    \ the process will abort.\n# Also, valid dimension names (pSrcDim & pTgtDim) are mandatory\
    \ otherwise the process will abort.\n# When data needs to be kept (using pIncludeData) a\
    \ valid element (pEle) in new dimension must be specified\n# where to store the data. Data\
    \ is summed from original dimension.\n# Rule can be kept as backup file only or reloaded\
    \ back.\n#EndRegion @DOC\n\n\n# This process selects the cube and replaces\n# the source\
    \ dimensions from a specified target dimensions.\n# This process should only be run on an\
    \ EMPTY cube or a cube that\n# has already had all data exported to a text file\n\n# Note:\n\
    # - This process does not preserve any cube rules as they would likely no longer be\n# \
    \  valid if a dimension is replaced\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\n\n### Constants ###\ncThisProcName     = GetProcessName();\n\
    cUserName         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n\
    cRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pSrcDim:%pSrcDim%,\
    \ pTgtDim:%pTgtDim%, pIncludeData:%pIncludeData%, pEle:%pEle%, pIncludeRules:%pIncludeRules%,\
    \ pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.' ;   \ncDefaultView      = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%'\
    \ );\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':'\
    \ );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n### Validate Parameters ###\nnErrors = 0;\n# Validate cube\nIf( Trim( pCube\
    \ ) @= '' );\n    sMessage = 'No cube specified.';\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) = 0 );\n  \
    \  sMessage = Expand( 'Cube %pCube% does not exist.' );\n    nErrors = nErrors + 1;\n  \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Don't allow system\
    \ cubes to be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\n  nErrors =\
    \ nErrors + 1;\n  sMessage = Expand( 'Do not modify system cubes: %pCube%.');\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate source dimension\n\
    If( Trim( pSrcDim ) @= '' );\n  nErrors = nErrors + 1;\n  sMessage = 'No source dimension\
    \ specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists(\
    \ pSrcDim ) = 0 );\n  nErrors = nErrors + 1;\n  sMessage = Expand( 'Source dimension %pSrcDim%\
    \ does not exist.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate target dimension\nIf( Trim( pTgtDim ) @= '' );\n  nErrors = nErrors + 1;\n\
    \  sMessage = 'No target dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pTgtDim ) = 0 );\n  nErrors = nErrors + 1;\n  sMessage\
    \ = Expand( 'Target dimension %pTgtDim% does not exist.');\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check that the source and target dimensions\
    \ are different\nIf( pSrcDim @= pTgtDim );\n  sMessage = Expand('Source and target dimensions\
    \ are the same: %pSrcDim%');\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# check element chosen in new dimension\nIf( pIncludeData\
    \ = 1 & Trim(pEle)@='' );\n  nErrors = nErrors + 1;\n  sMessage = Expand( 'No element specified\
    \ in new dimension %pTgtDim% to store cube data.');\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\nIf( pIncludeData = 1 & DIMIX(pTgtDim, pEle)=0 );\n  nErrors\
    \ = nErrors + 1;\n  sMessage = Expand( 'Invalid element %pEle% specified for the new dimension\
    \ %pTgtDim% to store cube data.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n  cCubeRuleFileName = '.'\
    \ | sOSDelim | pCube | '.RUX';\n  If(FileExists(cCubeRuleFileName) = 0);\n    pIncludeRules\
    \ = 0;\n    LogOutput( 'INFO', Expand( 'No rule found for %pCube%.' ) );\n  Endif;\nEndif;\
    \  \n\n### Determine number of dims in source cube & create strings to check and recreate\
    \ ###\nnCount = 1;\nsDimString = '';\nsDimCheck = '';\nsDelim = '+';\nWhile( TabDim( pCube,\
    \ nCount ) @<> '' );\n  sDim = TabDim( pCube, nCount );\n  IF(sDim@=pSrcDim);\n    sNewDim=pTgtDim;\n\
    \  else;\n    sNewDim=sDim;\n  Endif;  \n  IF(nCount = 1);\n    sDimCheck = '+'|sDim|'+';\n\
    \    sDimString = sNewDim;\n  elseif(nCount > 1);\n    sDimCheck = sDimCheck|'+'|sDim|'+';\n\
    \    sDimString = sDimString|'+'|sNewDim;\n  Endif;\n  nCount = nCount + 1;\nEnd;\nnDimensionCount\
    \ = nCount - 1;\n\n#Remove any leading +\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\n  \
    \  sDimString      = Subst ( sDimString , 2 , 999 );\nEndIf;\n\n#check source dimension\n\
    IF(scan('+'|pSrcDim|'+', sDimCheck)=0);\n  nErrors = nErrors + 1;\n  sMessage = Expand(\
    \ 'Source Dimension %pSrcDim% does not exist in %pCube%.');\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n#check target dimension\nIF(scan('+'|pTgtDim|'+',\
    \ sDimCheck)>0);\n  nErrors = nErrors + 1;\n  sMessage = Expand( 'Target Dimension %pTgtDim%\
    \ already exists in %pCube%.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndif;\n\n# Check if cube exceeds current max dimenions\nIf( nDimensionCount > 27\
    \ );\n  sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n######\
    \  CALLING THE STEP PROCESSES #####\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules\
    \ = 2);\n    sProc = '}bedrock.cube.rule.manage';\n\n    nRet = EXECUTEPROCESS( sProc,\n\
    \        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pCube', pCube,\n        'pMode', 'UNLOAD'\n        );\n    \n    IF(nRet <> 0);\n\
    \        sMessage = 'Error unloading the rule for %pCube%.';\n        nErrors = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;        \n    ENDIF;\n  \nEndif; \n\n# create clone cube with data\nIF(pIncludeData\
    \ = 1);\n  \n    pCloneCube = pCube | '_Clone';\n    nIncludeRules = IF(pIncludeRules =\
    \ 1 % pIncludeRules = 2, 1, 0);\n     nSuppressRules = IF(nIncludeRules = 1,  1, 0);\n \
    \ \n    sProc = '}bedrock.cube.clone';\n    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput',\
    \ pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n        'pSrcCube',\
    \ pCube,\n        'pTgtCube', pCloneCube,\n        'pIncludeRules', nIncludeRules,\n   \
    \     'pIncludeData', pIncludeData,\n        'pSuppressRules', nSuppressRules,\n       \
    \ 'pTemp', pTemp,\n        'pCubeLogging', 0\n        );\n\n    IF(nRet <> 0);\n       \
    \ sMessage = 'Error creating cloned cube for keeping data.';\n        nErrors = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;\n    ENDIF;\n  \nEndif;\n\n# recreate the cube\nsProc = '}bedrock.cube.create';\n\
    nRet = ExecuteProcess( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pCube', pCube,\n        'pDims', sDimString,\n       \
    \ 'pRecreate', 1,\n        'pDelim', sDelim\n        );\n\nIF(nRet <> 0);\n    sMessage\
    \ = Expand('Error recreating the cube: %pCube%.');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n\
    \        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\nENDIF;\n\n\n# copy\
    \ back the data\nIF(pIncludeData = 1);\n    sEleStartDelim = '¦';\n    sMappingToNewDims\
    \ = pTgtDim|sEleStartDelim|pEle;\n  \n    nRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \t    'pLogOutput',pLogOutput,\n\t    'pStrictErrorHandling', pStrictErrorHandling,\n\t\
    \    'pSrcCube',pCloneCube,\n\t    'pFilter','',\n\t    'pTgtCube',pCube,\n\t    'pMappingToNewDims',sMappingToNewDims,\n\
    \        'pSuppressConsol', 1,\n        'pSuppressRules', nSuppressRules,\n\t    'pZeroTarget',0,\n\
    \t    'pZeroSource',0,\n\t    'pFactor',1,\n\t    'pDimDelim','&',\n\t    'pEleStartDelim',sEleStartDelim,\n\
    \t    'pEleDelim','+',\n\t    'pTemp',pTemp,\n\t    'pCubeLogging',0);\n    \n    IF(nRet\
    \ <> 0);\n        sMessage = Expand('Error copying back the data from clone cube: %pCloneCube%.');\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n\
    \            ProcessBreak;\n        EndIf;\n    ENDIF;\n  \n    # destroy clone cube\n \
    \   IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n        nRet = EXECUTEPROCESS(\
    \ sProc,\n            'pLogOutput', pLogOutput,\n            'pStrictErrorHandling', pStrictErrorHandling,\n\
    \            'pCube', pCloneCube,\n            'pCtrlObj', 0\n            );\n\n       \
    \ IF(nRet <> 0);\n            sMessage = Expand('Error deleting the clone cube: %pCloneCube%.');\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n  \
    \          Else;\n                ProcessBreak;\n            EndIf;\n        ENDIF;\n  \
    \  Endif;\n  \nEndif; \n\n# reload the rule\nIF(pIncludeRules = 2);\n  \n    sProc = '}bedrock.cube.rule.manage';\n\
    \n    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pCube', pCube,\n        'pMode', 'LOAD'\n        );\n\
    \    \n    IF(nRet <> 0);\n      sMessage = Expand('Error reloading the rule for %pCube%.');\n\
    \      nErrors = nErrors + 1;\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n      # Create error rule file \n      cErrorRuleName = 'ErrorRuleFile.rux';\n\n\
    \      IF(FileExists( cErrorRuleName ) = 0 );\n        sFile = '.' | sOSDelim | cErrorRuleName;\n\
    \        LogOutput(cMsgErrorLevel, 'Rule could not be attached due to invalid !Dimension\
    \ references. Please recover from the backup and fix manually.');\n      ENDIF;\n\n    \
    \  EXECUTEPROCESS( sProc,\n      'pLogOutput', pLogOutput,\n      'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n      'pCube', pCube,\n      'pFileName', cErrorRuleName,\n   \
    \   'pMode', 'LOAD'\n      );\n      If( pStrictErrorHandling = 1 ); \n          ProcessQuit;\
    \ \n      Else;\n          ProcessBreak;\n      EndIf;\n    ENDIF;\n  \nEndif; \n\n### End\
    \ Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully replaced the %pSrcDim% dimension with the %pTgtDim% in the %pCube% cube.\
    \ Data was loaded to the %pEle% item.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n  \n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der das Backup und Entfernen oder
    das erneute Anhängen einer Regeldatei an einen Würfel durchführt. Der Prozess soll im produktiven
    Umfeld verwendet werden und zwei Hauptfunktionen erfüllen: Erstens soll die Regeldatei vor
    dem Laden von Daten entfernt werden, um den Ladeprozess zu beschleunigen. Zweitens soll
    die Regeldatei nach dem Laden der Daten wieder angehängt werden. Beachte, dass ein gültiger
    Würfelname (pCube) notwendig ist, da der Prozess andernfalls abbrechen wird. Der Pflichtparameter
    pMode muss auf ''Unload'' gesetzt werden, um die Regeldatei zu entfernen oder zu entladen.
    Um die Regeldatei wieder anzuhängen und die Regeln anzuwenden, muss der pMode-Parameter
    auf ''Load'' gesetzt werden.'
  answer: "Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will backup & remove **OR** re-attach the\
    \ rule file to cube.\n\n# Use case: Intended to be used in production.\n# 1/ Remove rule\
    \ file before data load to speed up data load.\n# 2/ Re-attach rule file after data load.\n\
    \n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process will\
    \ abort.\n# The mandatory pMode parameter must be set to 'Unload' to remove/unload the rule\
    \ file.\n# The pMode parameter must be set to 'Load' to re-attach the rule file and apply\
    \ the rules.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    \ncThisProcName       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\\
    h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub   \
    \         = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncCubeDim            =\
    \ '}Cubes';\ncCubeHier           = cCubeDim;\nsPath               = '';\ncUserName     \
    \      = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pMode:%pMode%, pFileName:%pFileName%, pDelim:%pDelim%,\
    \ pPath:%pPath%.' ;  \ncDimCubes           = '}Cubes';\n\n## check operating system\nIf(\
    \ SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim\
    \ = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors\
    \ = 0;\n\n### PROCESS PROPERTIES\nDatasourceASCIIDelimiter = '';\nDatasourceASCIIQuoteCharacter\
    \ = '';\n\n##Validate Mode\nIf(upper(pMode) @<> 'LOAD' & upper(pMode) @<> 'UNLOAD');\n \
    \   sMessage = Expand('Invalid Mode: %pMode%. Valid Modes are Load or Unload');\n    nErrors\
    \ = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\
    \n##Validate Cube\nIf( Trim(pCube) @= '' );\n    sMessage = Expand('No cube specified');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;\n\n## Default filter delimiters\nIf( pDelim     @= '' );\n    pDelim     = '&';\n\
    EndIf;\n\n# define backupdir\nIf(pPath @<> '');\n    If(Subst(pPath,long(pPath),1) @= sOSDelim\
    \ );\n        sPath = pPath;\n    Else;\n        sPath = pPath | sOSDelim;\n    Endif;\n\
    Else;\n  sPath = '.' | sOSDelim;\nEndif;\n\n## Default files names for storing rule and\
    \ backups\nIF(pFileName@='');\n  sRuleFileName         = '%sCube%.txt';\n  sBackupFileName\
    \       = '%sCube%.rux.bkp_%cTimeStamp%.txt';\nElse;\n  sRuleFileName         = pFileName;\n\
    \  sBackupFileName       = '%pFileName%.bkp_%cTimeStamp%.txt';\nEndif;  \n  \n# Loop through\
    \ list of Cubes\nsCubes = pCube;\nnCubeDelimIndex = 1;\n\nWhile( nCubeDelimIndex <> 0 );\n\
    \  nCubeDelimIndex = Scan( pDelim, sCubes );\n  If( nCubeDelimIndex = 0 );\n    sCube =\
    \ sCubes;\n  Else;\n    If (sOS @= 'Windows');\n      sCube = Trim( SubSt( sCubes, 1, nCubeDelimIndex\
    \ - 1 ) );\n    Else;\n      sCube = LOWER(Trim( SubSt( sCubes, 1, nCubeDelimIndex - 1 )\
    \ ));\n    EndIf;\n    sCubes = Trim( Subst( sCubes, nCubeDelimIndex + Long(pDelim), Long(\
    \ sCubes ) ) );\n  EndIf;\n\n  sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL([}Cubes]),\
    \ '%sCube%')}' );\n\n  sProc = '}bedrock.hier.sub.create.bymdx';\n  ExecuteProcess( sProc,\n\
    \    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim',\
    \ cDimCubes,\n    'pHier', '',\n    'pSub', cTempSub,\n    'pMDXExpr', sMDX,\n    'pConvertToStatic',\
    \ 1,\n    'pTemp', 1\n  );\n\n  nCube = 1;\n  nCubes = SubsetGetSize( cDimCubes, cTempSub\
    \ );\n  While( nCube <= nCubes );\n    sCube = SubsetGetElementName( cDimCubes, cTempSub,\
    \ nCube );\n    nCube = nCube + 1;\n    \n    If( sOS @= 'Windows');\n      cCubeRuleFileName\
    \ = '.' | sOSDelim | sCube | '.rux';\n    Else;\n      cCubeRuleFileName = '.' | sOSDelim\
    \ | LOWER(sCube) | '.rux';\n    EndIf;\n    If( sOS @= 'Windows');\n      cStoreDirFile\
    \ = sPath | Expand(sRuleFileName);\n      cBackupDirFile = sPath | Expand(sBackupFileName);\
    \ \n    Else;\n      cStoreDirFile = sPath | LOWER(Expand(sRuleFileName));\n      cBackupDirFile\
    \ = sPath | LOWER(Expand(sBackupFileName)); \n    EndIf;\n    # if there already is a rule\
    \ file\n    If(FileExists(cCubeRuleFileName) <> 0);\n      ##Loading the Rule###\n     \
    \ If(Upper(pMode) @= 'LOAD');\n        ##Backup the existing rule (saved as .bkp.txt in\
    \ given path or data directory) \n        ##and load the new rule file. New Rule file should\
    \ available in the given path or in data directory\n        If( sOS @= 'Windows');\n   \
    \       sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cBackupDirFile | '';          \n\
    \        Else;\n          sCmd = 'cp '' | cCubeRuleFileName | '' '' | cBackupDirFile | ''';\
    \        \n        EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the backup\
    \ file exists\n        If( FileExists( cBackupDirFile ) <> 0 );\n          RuleLoadFromFile(\
    \ sCube, cStoreDirFile);\n        Else;\n          sMessage = Expand('Backup of rule file\
    \ (%cCubeRuleFileName%) has failed, rule was not loaded.');\n          nErrors = nErrors\
    \ + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n          If(\
    \ pStrictErrorHandling = 1 ); \n              ProcessQuit; \n          Else;\n         \
    \     ProcessBreak;\n          EndIf;\n        EndIf;\n      Else;\n        ##Unloading\
    \ the Rule###\n        ##Before unloading, backup the existing rule (saved as .bkp.txt in\
    \ data directory or with the suffix parameter)\n        ##and drop current rule\n      \
    \  If( sOS @= 'Windows');\n          sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cBackupDirFile\
    \ | '';\n        Else;\n          sCmd = 'cp '' | cCubeRuleFileName | '' '' | cBackupDirFile\
    \ |''';\n        EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the backup\
    \ file exists\n        If( FileExists( cBackupDirFile ) = 0 );\n          sMessage = Expand('Backup\
    \ of rule file (%cCubeRuleFileName%) has failed, rule was not unloaded.');\n          nErrors\
    \ = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \         If( pStrictErrorHandling = 1 ); \n              ProcessQuit; \n          Else;\n\
    \              ProcessBreak;\n          EndIf;\n        EndIf;\n        If( sOS @= 'Windows');\n\
    \          sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cStoreDirFile | '';\n      \
    \  Else;\n          sCmd = 'cp '' | cCubeRuleFileName | ''  '' | cStoreDirFile |''';\n \
    \       EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the saved rule file\
    \ exists\n        If( FileExists( cStoreDirFile ) <> 0 );\n          CubeRuleDestroy( sCube\
    \ );\n        Else;\n          sMessage = Expand('Copy of rule file (%cCubeRuleFileName%)\
    \ has failed, rule was not unloaded.');\n          nErrors = nErrors + 1;\n          LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n          If( pStrictErrorHandling = 1\
    \ ); \n              ProcessQuit; \n          Else;\n              ProcessBreak;\n     \
    \     EndIf;\n        EndIf;\n      Endif;\n      \n    Else;\n      ###To create a new\
    \ rule file for the cube (no existing rule)\n      If(Upper(pMode) @= 'LOAD');\n       \
    \ RuleLoadFromFile( sCube, cStoreDirFile );\n      Else;\n        nErrors = nErrors + 1;\n\
    \        sMessage = 'No Rule file found for cube: ' | sCube;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n      Endif;\n    Endif;\n  End;\nEnd;\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    ### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully %pMode% cube rule from cube %pCube% .' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that performs the backup and removal or
    re-attachment of a rule file to a cube. This process is intended to be used in a production
    environment with two main functions: Firstly, to remove the rule file before data loading
    to speed up the data loading process. Secondly, to re-attach the rule file after data load.
    Note that a valid cube name (pCube) is mandatory, otherwise the process will abort. The
    mandatory pMode parameter must be set to ''Unload'' to remove/unload the rule file. To re-attach
    the rule file and apply the rules, the pMode parameter must be set to ''Load''.'
  answer: "Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will backup & remove **OR** re-attach the\
    \ rule file to cube.\n\n# Use case: Intended to be used in production.\n# 1/ Remove rule\
    \ file before data load to speed up data load.\n# 2/ Re-attach rule file after data load.\n\
    \n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process will\
    \ abort.\n# The mandatory pMode parameter must be set to 'Unload' to remove/unload the rule\
    \ file.\n# The pMode parameter must be set to 'Load' to re-attach the rule file and apply\
    \ the rules.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    \ncThisProcName       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\\
    h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub   \
    \         = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncCubeDim            =\
    \ '}Cubes';\ncCubeHier           = cCubeDim;\nsPath               = '';\ncUserName     \
    \      = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pMode:%pMode%, pFileName:%pFileName%, pDelim:%pDelim%,\
    \ pPath:%pPath%.' ;  \ncDimCubes           = '}Cubes';\n\n## check operating system\nIf(\
    \ SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim\
    \ = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors\
    \ = 0;\n\n### PROCESS PROPERTIES\nDatasourceASCIIDelimiter = '';\nDatasourceASCIIQuoteCharacter\
    \ = '';\n\n##Validate Mode\nIf(upper(pMode) @<> 'LOAD' & upper(pMode) @<> 'UNLOAD');\n \
    \   sMessage = Expand('Invalid Mode: %pMode%. Valid Modes are Load or Unload');\n    nErrors\
    \ = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\
    \n##Validate Cube\nIf( Trim(pCube) @= '' );\n    sMessage = Expand('No cube specified');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;\n\n## Default filter delimiters\nIf( pDelim     @= '' );\n    pDelim     = '&';\n\
    EndIf;\n\n# define backupdir\nIf(pPath @<> '');\n    If(Subst(pPath,long(pPath),1) @= sOSDelim\
    \ );\n        sPath = pPath;\n    Else;\n        sPath = pPath | sOSDelim;\n    Endif;\n\
    Else;\n  sPath = '.' | sOSDelim;\nEndif;\n\n## Default files names for storing rule and\
    \ backups\nIF(pFileName@='');\n  sRuleFileName         = '%sCube%.txt';\n  sBackupFileName\
    \       = '%sCube%.rux.bkp_%cTimeStamp%.txt';\nElse;\n  sRuleFileName         = pFileName;\n\
    \  sBackupFileName       = '%pFileName%.bkp_%cTimeStamp%.txt';\nEndif;  \n  \n# Loop through\
    \ list of Cubes\nsCubes = pCube;\nnCubeDelimIndex = 1;\n\nWhile( nCubeDelimIndex <> 0 );\n\
    \  nCubeDelimIndex = Scan( pDelim, sCubes );\n  If( nCubeDelimIndex = 0 );\n    sCube =\
    \ sCubes;\n  Else;\n    If (sOS @= 'Windows');\n      sCube = Trim( SubSt( sCubes, 1, nCubeDelimIndex\
    \ - 1 ) );\n    Else;\n      sCube = LOWER(Trim( SubSt( sCubes, 1, nCubeDelimIndex - 1 )\
    \ ));\n    EndIf;\n    sCubes = Trim( Subst( sCubes, nCubeDelimIndex + Long(pDelim), Long(\
    \ sCubes ) ) );\n  EndIf;\n\n  sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL([}Cubes]),\
    \ '%sCube%')}' );\n\n  sProc = '}bedrock.hier.sub.create.bymdx';\n  ExecuteProcess( sProc,\n\
    \    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim',\
    \ cDimCubes,\n    'pHier', '',\n    'pSub', cTempSub,\n    'pMDXExpr', sMDX,\n    'pConvertToStatic',\
    \ 1,\n    'pTemp', 1\n  );\n\n  nCube = 1;\n  nCubes = SubsetGetSize( cDimCubes, cTempSub\
    \ );\n  While( nCube <= nCubes );\n    sCube = SubsetGetElementName( cDimCubes, cTempSub,\
    \ nCube );\n    nCube = nCube + 1;\n    \n    If( sOS @= 'Windows');\n      cCubeRuleFileName\
    \ = '.' | sOSDelim | sCube | '.rux';\n    Else;\n      cCubeRuleFileName = '.' | sOSDelim\
    \ | LOWER(sCube) | '.rux';\n    EndIf;\n    If( sOS @= 'Windows');\n      cStoreDirFile\
    \ = sPath | Expand(sRuleFileName);\n      cBackupDirFile = sPath | Expand(sBackupFileName);\
    \ \n    Else;\n      cStoreDirFile = sPath | LOWER(Expand(sRuleFileName));\n      cBackupDirFile\
    \ = sPath | LOWER(Expand(sBackupFileName)); \n    EndIf;\n    # if there already is a rule\
    \ file\n    If(FileExists(cCubeRuleFileName) <> 0);\n      ##Loading the Rule###\n     \
    \ If(Upper(pMode) @= 'LOAD');\n        ##Backup the existing rule (saved as .bkp.txt in\
    \ given path or data directory) \n        ##and load the new rule file. New Rule file should\
    \ available in the given path or in data directory\n        If( sOS @= 'Windows');\n   \
    \       sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cBackupDirFile | '';          \n\
    \        Else;\n          sCmd = 'cp '' | cCubeRuleFileName | '' '' | cBackupDirFile | ''';\
    \        \n        EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the backup\
    \ file exists\n        If( FileExists( cBackupDirFile ) <> 0 );\n          RuleLoadFromFile(\
    \ sCube, cStoreDirFile);\n        Else;\n          sMessage = Expand('Backup of rule file\
    \ (%cCubeRuleFileName%) has failed, rule was not loaded.');\n          nErrors = nErrors\
    \ + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n          If(\
    \ pStrictErrorHandling = 1 ); \n              ProcessQuit; \n          Else;\n         \
    \     ProcessBreak;\n          EndIf;\n        EndIf;\n      Else;\n        ##Unloading\
    \ the Rule###\n        ##Before unloading, backup the existing rule (saved as .bkp.txt in\
    \ data directory or with the suffix parameter)\n        ##and drop current rule\n      \
    \  If( sOS @= 'Windows');\n          sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cBackupDirFile\
    \ | '';\n        Else;\n          sCmd = 'cp '' | cCubeRuleFileName | '' '' | cBackupDirFile\
    \ |''';\n        EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the backup\
    \ file exists\n        If( FileExists( cBackupDirFile ) = 0 );\n          sMessage = Expand('Backup\
    \ of rule file (%cCubeRuleFileName%) has failed, rule was not unloaded.');\n          nErrors\
    \ = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \         If( pStrictErrorHandling = 1 ); \n              ProcessQuit; \n          Else;\n\
    \              ProcessBreak;\n          EndIf;\n        EndIf;\n        If( sOS @= 'Windows');\n\
    \          sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cStoreDirFile | '';\n      \
    \  Else;\n          sCmd = 'cp '' | cCubeRuleFileName | ''  '' | cStoreDirFile |''';\n \
    \       EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the saved rule file\
    \ exists\n        If( FileExists( cStoreDirFile ) <> 0 );\n          CubeRuleDestroy( sCube\
    \ );\n        Else;\n          sMessage = Expand('Copy of rule file (%cCubeRuleFileName%)\
    \ has failed, rule was not unloaded.');\n          nErrors = nErrors + 1;\n          LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n          If( pStrictErrorHandling = 1\
    \ ); \n              ProcessQuit; \n          Else;\n              ProcessBreak;\n     \
    \     EndIf;\n        EndIf;\n      Endif;\n      \n    Else;\n      ###To create a new\
    \ rule file for the cube (no existing rule)\n      If(Upper(pMode) @= 'LOAD');\n       \
    \ RuleLoadFromFile( sCube, cStoreDirFile );\n      Else;\n        nErrors = nErrors + 1;\n\
    \        sMessage = 'No Rule file found for cube: ' | sCube;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n      Endif;\n    Endif;\n  End;\nEnd;\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    ### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully %pMode% cube rule from cube %pCube% .' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###"
- question: Dieser IBM Turbo Integrator Prozess ist darauf ausgelegt, Feeders neu zu verarbeiten,
    wenn konsolidierte Summen nicht korrekt addiert werden. Der Anwendungsfall erstreckt sich
    sowohl auf Entwicklungs- als auch auf Produktionsumgebungen. Er wird eingesetzt, wenn Feeders
    neu verarbeitet werden müssen, beispielsweise wenn neue Elemente zu irgendeiner Dimension
    hinzugefügt werden. Beachten Sie, dass ein gültiger Würfelname (pCube) zwingend erforderlich
    ist; andernfalls wird der Prozess abgebrochen. Sowohl Platzhalter als auch Listen sind zulässig.
    Dieser Prozess verarbeitet Feeders für einen Würfel.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process reprocesses feeders when consolidated totals\
    \ are not adding up.\n\n# Use case: Intended for Deveopment or production.\n#1/ This process\
    \ would be used any time feeders need to be reprocessed (e.g. when new elements are added\
    \ to any of the dimensions).\n\n# Note:\n# Naturally, a valid  cube name (pCube) is mandatory\
    \ otherwise the process will abort. Wildcards and lists are acceptable.\n# This process\
    \ will process feeders for a cube.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    \ncThisProcName = GetProcessName();\ncUserName = TM1User();\ncTimeStamp = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub   \
    \       = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\nsMessage = \t'';\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\nnErrors = 0;\n\n### Validate Parameters ###\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# If no cubes\
    \ have been specified then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'No\
    \ cubes specified';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n\n### SET DATA SOURCE ###\n\nDatasourceType = 'NULL';\n\n\n### Split\
    \ parameter into individual cubes and delete ###\n\nsCubes = pCube;\nnDelimiterIndex = 1;\n\
    sMdx = '';\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex = Scan( pDelim, sCubes );\n\
    \  If( nDelimiterIndex = 0 );\n    sCube = sCubes;\n  Else;\n    sCube = Trim( SubSt( sCubes,\
    \ 1, nDelimiterIndex - 1 ) );\n    sCubes = Trim( Subst( sCubes, nDelimiterIndex + Long(pDelim),\
    \ Long( sCubes ) ) );\n  EndIf;\n  \n  # Check if a wildcard has been used to specify the\
    \ Cube name.\n  # If it hasn't then just delete the Cube if it exists\n      # If it has\
    \ then search the relevant Cube folder to find the matches\n      If( Scan( '*', sCube )\
    \ = 0 );\n        If( CubeExists( sCube ) = 1 ); \n          CubeProcessFeeders( sCube );\n\
    \        Endif;\n      Else;\n        # Create subset of cubes using Wildcard\n        sCubeExp\
    \ = '''|sCube|''';\n        sMdxPart = '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'|\
    \ sCubeExp | ')}';\n        IF( sMdx @= ''); \n          sMdx = sMdxPart; \n        ELSE;\n\
    \          sMdx = sMdx | ' + ' | sMdxPart;\n        ENDIF;\n        \n        If( SubsetExists(\
    \ '}Cubes' , cTempSub ) = 1 );\n            # If a delimited list of cube names includes\
    \ wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ '}Cubes' , cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need\
    \ to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n\
    \        EndIf;\n        \n        # Loop through cubes in subset created based on wildcard\n\
    \        nCountCubes = SubsetGetSize( '}Cubes' , cTempSub );\n        While( nCountCubes\
    \ >= 1 );\n          sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCubes\
    \ );\n          # Validate cube name\n          If( CubeExists( sCurrCube ) = 1 ); \n  \
    \          # Process Feeders\n            CubeProcessFeeders( sCurrCube );\n          Endif;\n\
    \            nCountCubes = nCountCubes - 1;\n        End;\n      EndIf;\n\nEnd;\n\n\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully processed feeders for cube %pCube% .' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n\n### End Epilog ###"
- question: This IBM Turbo Integrator process is designed to reprocess feeders when consolidated
    totals are not adding up accurately. The use case applies to both development and production
    environments. It is used when feeders need to be reprocessed, such as when new elements
    are added to any dimensions. Note that a valid cube name (pCube) is mandatory; otherwise,
    the process will abort. Wildcards and lists are acceptable. This process processes feeders
    for a cube.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process reprocesses feeders when consolidated totals\
    \ are not adding up.\n\n# Use case: Intended for Deveopment or production.\n#1/ This process\
    \ would be used any time feeders need to be reprocessed (e.g. when new elements are added\
    \ to any of the dimensions).\n\n# Note:\n# Naturally, a valid  cube name (pCube) is mandatory\
    \ otherwise the process will abort. Wildcards and lists are acceptable.\n# This process\
    \ will process feeders for a cube.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    \ncThisProcName = GetProcessName();\ncUserName = TM1User();\ncTimeStamp = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub   \
    \       = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\nsMessage = \t'';\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\nnErrors = 0;\n\n### Validate Parameters ###\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# If no cubes\
    \ have been specified then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'No\
    \ cubes specified';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n\n### SET DATA SOURCE ###\n\nDatasourceType = 'NULL';\n\n\n### Split\
    \ parameter into individual cubes and delete ###\n\nsCubes = pCube;\nnDelimiterIndex = 1;\n\
    sMdx = '';\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex = Scan( pDelim, sCubes );\n\
    \  If( nDelimiterIndex = 0 );\n    sCube = sCubes;\n  Else;\n    sCube = Trim( SubSt( sCubes,\
    \ 1, nDelimiterIndex - 1 ) );\n    sCubes = Trim( Subst( sCubes, nDelimiterIndex + Long(pDelim),\
    \ Long( sCubes ) ) );\n  EndIf;\n  \n  # Check if a wildcard has been used to specify the\
    \ Cube name.\n  # If it hasn't then just delete the Cube if it exists\n      # If it has\
    \ then search the relevant Cube folder to find the matches\n      If( Scan( '*', sCube )\
    \ = 0 );\n        If( CubeExists( sCube ) = 1 ); \n          CubeProcessFeeders( sCube );\n\
    \        Endif;\n      Else;\n        # Create subset of cubes using Wildcard\n        sCubeExp\
    \ = '''|sCube|''';\n        sMdxPart = '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'|\
    \ sCubeExp | ')}';\n        IF( sMdx @= ''); \n          sMdx = sMdxPart; \n        ELSE;\n\
    \          sMdx = sMdx | ' + ' | sMdxPart;\n        ENDIF;\n        \n        If( SubsetExists(\
    \ '}Cubes' , cTempSub ) = 1 );\n            # If a delimited list of cube names includes\
    \ wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ '}Cubes' , cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need\
    \ to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n\
    \        EndIf;\n        \n        # Loop through cubes in subset created based on wildcard\n\
    \        nCountCubes = SubsetGetSize( '}Cubes' , cTempSub );\n        While( nCountCubes\
    \ >= 1 );\n          sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCubes\
    \ );\n          # Validate cube name\n          If( CubeExists( sCurrCube ) = 1 ); \n  \
    \          # Process Feeders\n            CubeProcessFeeders( sCurrCube );\n          Endif;\n\
    \            nCountCubes = nCountCubes - 1;\n        End;\n      EndIf;\n\nEnd;\n\n\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully processed feeders for cube %pCube% .' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine Ansicht erstellt, die zum
    Exportieren, Kopieren oder Nullstellen von Zahlen verwendet werden kann. Der Prozess sollte
    sowohl für die Entwicklung/Prototyping als auch für den produktiven Einsatz geeignet sein.
    Stelle sicher, dass der Prozess in der Lage ist, eine Ansicht zum Nullstellen von Daten
    zu erstellen und eine weitere Ansicht, die als Quelle für den Export oder das Kopieren verwendet
    werden kann. Beachte, dass ein gültiger Würfelname (pCube) erforderlich ist, andernfalls
    wird der Prozess abgebrochen. Das pFilter-Parameter enthält die Dimensionen und Elemente
    zur Filterung, im Format ''Dim1: Elem1 + Elem2 & Dim2: Elem3 + Elem4''. Die Dimensionsparameter
    müssen nicht in der Reihenfolge der Indizes der Dimensionen im Würfel angegeben werden.
    Verwende Leerzeichen, um den Filter lesbarer zu machen. Das pTemp-Parameter steuert, ob
    die Ansicht temporär (Wert 1) oder dauerhaft (Wert 0) gespeichert wird.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***s\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates a view that can be used for exporting,\
    \ copying or zeroing out numbers.\n\n# Use case: Intended for development/prototyping or\
    \ production.\n# 1/ Create a view to zero out data.\n# 2/ Create a view to use as a source\
    \ for exporting or copying.\n\n# Note:\n# Naturally, a valid cube name (pCube) is mandatory\
    \ otherwise the process will abort.\n# The pFilter parameter contains the dimenson and elements\
    \ to be used for filtering:\n# - The format of the pFilter parameter is as follows delimiters\
    \ of :, & and +: Dim1: Elem1 + Elem2 & Dim2: Elem3 + Elem4.\n# - The dimension parameters\
    \ do not need to be given in the index order of dimensions in the cube.\n# - The dimension\
    \ name is specified as the first member of the delimited string of elements.\n# - If consols\
    \ are skipped the N level children of any consolidated filter elements will be used.\n#\
    \ - Spaces are ignored so use them to make your filter more readable.\n# - pTemp: This parameter\
    \ will control whether to make the view temporary (value 1) or if the\n#   view will be\
    \ permanently retained (value 0).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable\
    \ ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nStringGlobalVariable('sBedrockViewCreateParsedFilter');\n\
    sProcessReturnCode = '';\nnProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName  \
    \   = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp        = TimSt( Now,\
    \ '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSubset       = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile    \
    \     = GetProcessErrorFileDirectory | cTempSubset | '.csv';\nsMessage          = '';\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncMsgInfoLevel     =  'INFO';\ncMsgInfoContent   = '%cThisProcName%\
    \ : %sMessage% : %cUserName%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pCube:%pCube%, pView:%pView%, pFilter:%pFilter%, pSuppressZero:%pSuppressZero%, pSuppressConsol:%pSuppressConsol%,\
    \ pSuppressRules:%pSuppressRules%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%, pTemp:%pTemp%, pSuppressConsolStrings:%pSuppressConsolStrings%.'\
    \ ;  \n\n\nsSubset           = pView;\nsDelimDim         = TRIM(pDimDelim);\nsElementStartDelim=\
    \ TRIM(pEleStartDelim);\nsDelimElem        = TRIM(pEleDelim);\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors\
    \ = 0;\n\n### Validate Parameters ###\n\n## Default filter delimiters\nIf( pDimDelim   \
    \  @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n    pEleStartDelim=\
    \ '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\nEndIf;\n\n# If specified\
    \ cube does not exist then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'A\
    \ cube name must be provided.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) = 0 );\n  sMessage = 'Cube:\
    \ ' | pCube | ' does not exist.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate the View parameter\nIf( Trim( pView\
    \ ) @= '' );\n  sMessage = 'A view name must be provided.';\n  nErrors = nErrors + 1;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check the delimiters\n\
    If( sDelimDim @= sElementStartDelim % sDelimDim @= sDelimElem % sElementStartDelim @= sDelimElem\
    \ );\n  sMessage = 'The delimiters cannot be the same';\n  nErrors = nErrors + 1;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp<>\
    \ 0 & pTemp<> 1 );\n    nErrors = 1;\n    sMessage = 'Invalid value for pTemp' | NumberToString(\
    \ pTemp ) | '. Valid values are 0 and 1';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### If errors occurred terminate process with a major error status ###\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n  \n# Reset all of the subsets that may be attached\
    \ to the view in the case that dimensions not in the filter\nIf( ViewExists( pCube, pView\
    \ ) = 1 );\n    ### Reset View ###\n    sMessage = 'Resetting view ' | pView | ' on cube\
    \ ' | pCube;\n    IF ( pLogoutput = 1 );\n       LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent\
    \ ) );\n    EndIf;\n    nCount = 1;\n    While( TabDim( pCube, nCount ) @<> '' );\n    \
    \    sCubeDimName = TabDim( pCube, nCount );\n        # Subset is the same name as the view\
    \ (no way to test if subset assigned, assume it is if same name)\n        If( SubsetExists(\
    \ sCubeDimName, sSubset ) = 1 );\n            # Add all elements\n            If( SubsetIsAllSet(sCubeDimName,\
    \ sSubset, 1) <> 1 );\n                sMessage = Expand('Unable to add all elements on\
    \ subset %sSubset% in dimension %sCubeDimName%');\n                nErrors = nErrors + 1;\n\
    \                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            EndIf;\n\
    \        EndIf;\n        nCount = nCount + 1;\n    End;\nElse;\n    ### Create View ###\n\
    \    sMessage = Expand('Creating view %pView% in cube %pCube%');\n    IF ( pLogoutput =\
    \ 1 );\n       LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n    EndIf;\n    ViewCreate(\
    \ pCube, pView, pTemp );\nEndIf;\n\nViewExtractSkipCalcsSet( pCube, pView, pSuppressConsol\
    \ );\nViewExtractSkipZeroesSet( pCube, pView, pSuppressZero );\nViewExtractSkipRuleValuesSet(\
    \ pCube, pView, pSuppressRules );\n# Fix of issue #141, https://github.com/cubewise-code/bedrock/issues/141\n\
    If( pSuppressConsolStrings <> -1 );\n    ViewExtractSkipConsolidatedStringsSet( pCube, pView,\
    \ pSuppressConsolStrings );\nEndIf;\n\n### Split filter and create subsets ###\nsFilter\
    \ = TRIM( pFilter );\nsParsedFilter = '';\nnChar = 1;\nnCharCount = LONG( sFilter );\nsWord\
    \ = '';\nsLastDelim = '';\nnIndex = 1;\n# Add a trailing element delimiter so that the last\
    \ element is picked up\nIf( nCharCount > 0 );\n  sFilter = sFilter | sDelimElem;\n  nCharCount\
    \ = nCharCount + LONG(sDelimElem);\nEndIf;\n\nWHILE (nChar <= nCharCount);\n    sChar =\
    \ SUBST( sFilter, nChar, 1);\n\n    # Used for delimiters, required for multiple character\
    \ delimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n    # Ignore spaces\n    IF (TRIM(sChar)\
    \ @<> '' );\n\n      ### Dimension Name ###\n\n      # If the delimiter is more than 1 character\
    \ peek ahead the same amount\n      # Ignore the first character\n      sDelim = sChar;\n\
    \      nCount = LONG(sElementStartDelim) - 1;\n      If( nCount > 0 & nChar + nCount <=\
    \ nCharCount );\n        # Add the extra characters\n        sDelim = sDelim | SUBST( sFilter,\
    \ nChar + 1, nCount);\n        # Move to the end of the delimter\n        nAddExtra = nCount;\n\
    \      EndIf;\n\n      If( sDelim @= sElementStartDelim );\n\n        sChar = sDelim;\n\n\
    \        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );\n            sMessage = 'The\
    \ name of a dimension must follow a dimension delimiter (' | sDelimDim | ')';\n        \
    \    nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        EndIf;\n\n        sDimension = sWord;\n        nOneDimEleAdded = 0;\n  \
    \      \n        If( DimensionExists( sDimension ) = 0 );\n            # The dimension does\
    \ not exist in the model. Cancel process\n            sMessage = 'Dimension: ' | sDimension\
    \ | ' does not exist';\n            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        EndIf;\n\n        ### Determine the dimension is\
    \ a member of the cube ###\n        nCount = 1;\n        nDimensionIndex = 0;\n        While(\
    \ TabDim( pCube, nCount ) @<> '' );\n            sCubeDimName = TabDim( pCube, nCount );\n\
    \            If( sDimension @= sCubeDimName );\n                nDimensionIndex = nCount;\n\
    \            EndIf;\n            nCount = nCount + 1;\n        End;\n\n        If( nDimensionIndex\
    \ = 0 );\n            # The dimension does not exist in the cube. Cancel process\n     \
    \       sMessage = 'Dimension: ' | sDimension | ' is not a member of: '| pCube | 'cube.';\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        EndIf;\n\n        # Create the subset\n        If( SubsetExists( sDimension,\
    \ sSubset ) = 1 );\n            SubsetDeleteAllElements( sDimension, sSubset );\n      \
    \  Else;\n            SubsetCreate( sDimension, sSubset, pTemp );            \n        EndIf;\n\
    \n        # Attach to the view\n        ViewSubsetAssign( pCube, pView, sDimension, sSubset\
    \ );\n        \n        #Add to the Parsed filter\n        IF(sParsedFilter@='');\n    \
    \      sParsedFilter=sDimension;          \n        Else;\n          sParsedFilter=sParsedFilter|sDelimDim|sDimension;\n\
    \        Endif;  \n\n        nIndex = 1;\n        sLastDelim = sChar;\n        # Clear the\
    \ word\n        sWord = '';\n      Else;\n\n        # Reset extra chars\n        nAddExtra\
    \ = 0;\n\n        ### Check both both dim delimiter and element delimiter ###\n        nIsDelimiter\
    \ = 0;\n\n        ## Check dimension delimiter first\n        # If the delimiter is more\
    \ than 1 character peek ahead the same amount\n        # Ignore the first character\n  \
    \      sDelim = sChar;\n        nCount = LONG(sDelimDim) - 1;\n        If( nCount > 0 &\
    \ nChar + nCount <= nCharCount );\n          # Add the extra characters\n          sDelim\
    \ = sDelim | SUBST( sFilter, nChar + 1, nCount);\n          # Move to the end of the delimter\n\
    \          nAddExtra = nCount;\n        EndIf;\n\n        If( sDelim @= sDelimDim );\n \
    \         nIsDelimiter = 1;\n          sChar = sDelim;\n        Else;\n          # Reset\
    \ extra chars\n          nAddExtra = 0;\n\n          ## Check element delimiter\n\n    \
    \      # If the delimiter is more than 1 character peek ahead the same amount\n        \
    \  # Ignore the first character\n          sDelim = sChar;\n          nCount = LONG(sDelimElem)\
    \ - 1;\n          If( nCount > 0 & nChar + nCount <= nCharCount );\n            # Add the\
    \ extra characters\n            sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n\
    \            # Move to the end of the delimter\n            nAddExtra = nCount;\n      \
    \    EndIf;\n\n          If( sDelim @= sDelimElem );\n            nIsDelimiter = 1;\n  \
    \          sChar = sDelim;\n          Else;\n            # Reset extra chars\n         \
    \   nAddExtra = 0;\n          EndIf;\n\n        EndIf;\n\n        If ( nIsDelimiter = 1\
    \ );\n\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim );\n            sMessage\
    \ = 'An element delimiter must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar)\
    \ | ')';\n            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n            #ProcessError();\n          EndIf;\n\n          sElement\
    \ = sWord;\n\n          If( DIMIX( sDimension, sElement ) = 0 );\n              # The element\
    \ does not exist in the dimension. Cancel process\n              sMessage = 'Element: '\
    \ | sElement | ' in dimension ' | sDimension | ' does not exist';\n              nErrors\
    \ = nErrors + 1;\n              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \              #ProcessError();\n          EndIf;\n          \n          sElement = DimensionElementPrincipalName(sDimension,sElement);\n\
    \n          If ( pSuppressConsol = 1 & DTYPE( sDimension, sElement) @= 'C'  );\n       \
    \       # Add all N level elements to the subset\n              # Loop through all elements\
    \ and check if it is an ancestor\n              sMessage = 'Element ' | sElement | ' is\
    \ consolidated' ;\n              IF ( pLogoutput = 1 );\n                LogOutput( cMsgInfoLevel,\
    \ Expand( cMsgInfoContent ) );\n              EndIf;\n              nElCount = DIMSIZ (\
    \ sDimension );\n              n = 1;\n              WHILE ( n <= nElCount );\n        \
    \          sEl = DIMNM( sDimension, n );\n                  IF( DTYPE( sDimension, sEl)\
    \ @<> 'C' & ELISANC( sDimension, sElement, sEl ) = 1 );\n                      SubsetElementInsert(\
    \ sDimension, sSubset, sEl, 0 );\n                  EndIf;\n                  n = n + 1;\n\
    \              END;\n              \n              # Add the consolidated element to the\
    \ subset as well to export strings, if necessary\n              If ( pSuppressConsolStrings\
    \ = 0 );\n                SubsetElementInsert( sDimension, sSubset, sElement, 0 );\n   \
    \           EndIf;\n\n          Else;\n              # Add the element to the subset\n \
    \             SubsetElementInsert( sDimension, sSubset, sElement, 0 );\n          EndIf;\n\
    \          \n          #Add to the Parsed filter\n          If( nOneDimEleAdded = 0 );\n\
    \            sParsedFilter=sParsedFilter|pEleStartDelim|sElement;\n            nOneDimEleAdded\
    \ = nOneDimEleAdded + 1;\n          Else;\n            sParsedFilter=sParsedFilter|sDelimElem|sElement;\n\
    \          EndIf;\n\n          nIndex = nIndex + 1;\n          sLastDelim = sChar;\n\n \
    \         # Clear the word\n          sWord = '';\n        Else;\n          sWord = sWord\
    \ | sChar;\n        EndIf;\n\n      EndIf;\n\n    EndIf;\n\n    nChar = nChar + nAddExtra\
    \ + 1;\n\nEND;\nsBedrockViewCreateParsedFilter = sParsedFilter;\n\n# creating N level subset\
    \ for all dim not included in pFilter \n# useful when suppress consolidation is not on\n\
    If(pSubN = 1);\n    \n    nCountDimC = 1;\n    While( TabDim( pCube, nCountDimC ) @<> ''\
    \ );\n        sDimC = TabDim( pCube, nCountDimC );\n        sDimString = lower(sDimC);\n\
    \        \n        # filters created by other bedrock processes skip spaces from dim names\
    \ and between separators\n        While(Scan(' ',sDimString)>0);\n            sDimString\
    \ = subst(sDimString, 1, Scan(' ',sDimString)-1)|subst(sDimString,Scan(' ',sDimString)+1,long(sDimString));\n\
    \        End; \n        sTFilter = lower(sFilter);\n        While(Scan(' ',sTFilter)>0);\n\
    \            sTFilter = subst(sTFilter, 1, Scan(' ',sTFilter)-1)|subst(sTFilter,Scan(' ',sTFilter)+1,long(sTFilter));\n\
    \        End;\n        \n        # to make sure that the name of the dim is not part of\
    \ the name of another dim\n        If(Scan(pDimDelim|sDimString|pEleStartDelim, sTFilter)=0\
    \ & Scan(sDimString|pEleStartDelim, sTFilter)<>1);\n            sProc   = '}bedrock.hier.sub.create';\n\
    \            nRet    = ExecuteProcess( sProc,\n                'pLogOutput', pLogOutput,\n\
    \                'pStrictErrorHandling', pStrictErrorHandling,\n                'pDim',\
    \ sDimC,\n                'pHier', '',\n                'pSub', sSubset,\n             \
    \   'pConsol', '',\n                'pAttr', '',\n                'pAttrValue', '',\n  \
    \              'pLevelFrom', 0,\n                'pLevelTo', 0,\n                'pExclusions',\
    \ '',\n                'pDelim', pEleDelim,\n                'pAddToSubset', 0,\n      \
    \          'pAlias', '',\n                'pTemp', pTemp\n            );\n            \n\
    \            IF(nRet <> 0);\n                sMessage = 'Error creating the view from the\
    \ filter.';\n                nErrors = nErrors + 1;\n                LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n                If( pStrictErrorHandling = 1 ); \n    \
    \                ProcessQuit; \n                Else;\n                    ProcessBreak;\n\
    \                EndIf;\n            ENDIF;\n            \n            ViewSubsetAssign(\
    \ pCube, pView, sDimC, sSubset );\n        \n        EndIf;\n        \n        nCountDimC\
    \ = nCountDimC + 1;\n    End;\n\n  EndIf;  \n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling ###\nIf( nErrors <> 0 );\n    sMessage = 'the process incurred at least 1 error.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( 'ERROR' , Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n\
    \        ProcessBreak;\n    EndIf;\nElse; \n\n    sProcessAction      = Expand( 'Process:%cThisProcName%\
    \ successfully created View %pView% in Cube %pCube%.' );\n    sProcessReturnCode  = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode  = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \  \n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a view which can be used for
    exporting, copying, or zeroing out numbers. The process should be suitable for both development/prototyping
    and production. Ensure that the process is capable of creating a view to zero out data and
    another view to be used as a source for exporting or copying. Note that a valid cube name
    (pCube) is mandatory; otherwise, the process will abort. The pFilter parameter contains
    the dimensions and elements for filtering, in the format ''Dim1: Elem1 + Elem2 & Dim2: Elem3
    + Elem4''. The dimension parameters do not need to be given in the index order of dimensions
    in the cube. Use spaces to make the filter more readable. The pTemp parameter controls whether
    to make the view temporary (value 1) or permanently retained (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***s\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates a view that can be used for exporting,\
    \ copying or zeroing out numbers.\n\n# Use case: Intended for development/prototyping or\
    \ production.\n# 1/ Create a view to zero out data.\n# 2/ Create a view to use as a source\
    \ for exporting or copying.\n\n# Note:\n# Naturally, a valid cube name (pCube) is mandatory\
    \ otherwise the process will abort.\n# The pFilter parameter contains the dimenson and elements\
    \ to be used for filtering:\n# - The format of the pFilter parameter is as follows delimiters\
    \ of :, & and +: Dim1: Elem1 + Elem2 & Dim2: Elem3 + Elem4.\n# - The dimension parameters\
    \ do not need to be given in the index order of dimensions in the cube.\n# - The dimension\
    \ name is specified as the first member of the delimited string of elements.\n# - If consols\
    \ are skipped the N level children of any consolidated filter elements will be used.\n#\
    \ - Spaces are ignored so use them to make your filter more readable.\n# - pTemp: This parameter\
    \ will control whether to make the view temporary (value 1) or if the\n#   view will be\
    \ permanently retained (value 0).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable\
    \ ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nStringGlobalVariable('sBedrockViewCreateParsedFilter');\n\
    sProcessReturnCode = '';\nnProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName  \
    \   = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp        = TimSt( Now,\
    \ '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSubset       = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile    \
    \     = GetProcessErrorFileDirectory | cTempSubset | '.csv';\nsMessage          = '';\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncMsgInfoLevel     =  'INFO';\ncMsgInfoContent   = '%cThisProcName%\
    \ : %sMessage% : %cUserName%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pCube:%pCube%, pView:%pView%, pFilter:%pFilter%, pSuppressZero:%pSuppressZero%, pSuppressConsol:%pSuppressConsol%,\
    \ pSuppressRules:%pSuppressRules%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%,\
    \ pEleDelim:%pEleDelim%, pTemp:%pTemp%, pSuppressConsolStrings:%pSuppressConsolStrings%.'\
    \ ;  \n\n\nsSubset           = pView;\nsDelimDim         = TRIM(pDimDelim);\nsElementStartDelim=\
    \ TRIM(pEleStartDelim);\nsDelimElem        = TRIM(pEleDelim);\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors\
    \ = 0;\n\n### Validate Parameters ###\n\n## Default filter delimiters\nIf( pDimDelim   \
    \  @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n    pEleStartDelim=\
    \ '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\nEndIf;\n\n# If specified\
    \ cube does not exist then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'A\
    \ cube name must be provided.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) = 0 );\n  sMessage = 'Cube:\
    \ ' | pCube | ' does not exist.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate the View parameter\nIf( Trim( pView\
    \ ) @= '' );\n  sMessage = 'A view name must be provided.';\n  nErrors = nErrors + 1;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check the delimiters\n\
    If( sDelimDim @= sElementStartDelim % sDelimDim @= sDelimElem % sElementStartDelim @= sDelimElem\
    \ );\n  sMessage = 'The delimiters cannot be the same';\n  nErrors = nErrors + 1;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp<>\
    \ 0 & pTemp<> 1 );\n    nErrors = 1;\n    sMessage = 'Invalid value for pTemp' | NumberToString(\
    \ pTemp ) | '. Valid values are 0 and 1';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### If errors occurred terminate process with a major error status ###\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n  \n# Reset all of the subsets that may be attached\
    \ to the view in the case that dimensions not in the filter\nIf( ViewExists( pCube, pView\
    \ ) = 1 );\n    ### Reset View ###\n    sMessage = 'Resetting view ' | pView | ' on cube\
    \ ' | pCube;\n    IF ( pLogoutput = 1 );\n       LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent\
    \ ) );\n    EndIf;\n    nCount = 1;\n    While( TabDim( pCube, nCount ) @<> '' );\n    \
    \    sCubeDimName = TabDim( pCube, nCount );\n        # Subset is the same name as the view\
    \ (no way to test if subset assigned, assume it is if same name)\n        If( SubsetExists(\
    \ sCubeDimName, sSubset ) = 1 );\n            # Add all elements\n            If( SubsetIsAllSet(sCubeDimName,\
    \ sSubset, 1) <> 1 );\n                sMessage = Expand('Unable to add all elements on\
    \ subset %sSubset% in dimension %sCubeDimName%');\n                nErrors = nErrors + 1;\n\
    \                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            EndIf;\n\
    \        EndIf;\n        nCount = nCount + 1;\n    End;\nElse;\n    ### Create View ###\n\
    \    sMessage = Expand('Creating view %pView% in cube %pCube%');\n    IF ( pLogoutput =\
    \ 1 );\n       LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n    EndIf;\n    ViewCreate(\
    \ pCube, pView, pTemp );\nEndIf;\n\nViewExtractSkipCalcsSet( pCube, pView, pSuppressConsol\
    \ );\nViewExtractSkipZeroesSet( pCube, pView, pSuppressZero );\nViewExtractSkipRuleValuesSet(\
    \ pCube, pView, pSuppressRules );\n# Fix of issue #141, https://github.com/cubewise-code/bedrock/issues/141\n\
    If( pSuppressConsolStrings <> -1 );\n    ViewExtractSkipConsolidatedStringsSet( pCube, pView,\
    \ pSuppressConsolStrings );\nEndIf;\n\n### Split filter and create subsets ###\nsFilter\
    \ = TRIM( pFilter );\nsParsedFilter = '';\nnChar = 1;\nnCharCount = LONG( sFilter );\nsWord\
    \ = '';\nsLastDelim = '';\nnIndex = 1;\n# Add a trailing element delimiter so that the last\
    \ element is picked up\nIf( nCharCount > 0 );\n  sFilter = sFilter | sDelimElem;\n  nCharCount\
    \ = nCharCount + LONG(sDelimElem);\nEndIf;\n\nWHILE (nChar <= nCharCount);\n    sChar =\
    \ SUBST( sFilter, nChar, 1);\n\n    # Used for delimiters, required for multiple character\
    \ delimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n    # Ignore spaces\n    IF (TRIM(sChar)\
    \ @<> '' );\n\n      ### Dimension Name ###\n\n      # If the delimiter is more than 1 character\
    \ peek ahead the same amount\n      # Ignore the first character\n      sDelim = sChar;\n\
    \      nCount = LONG(sElementStartDelim) - 1;\n      If( nCount > 0 & nChar + nCount <=\
    \ nCharCount );\n        # Add the extra characters\n        sDelim = sDelim | SUBST( sFilter,\
    \ nChar + 1, nCount);\n        # Move to the end of the delimter\n        nAddExtra = nCount;\n\
    \      EndIf;\n\n      If( sDelim @= sElementStartDelim );\n\n        sChar = sDelim;\n\n\
    \        If( sLastDelim @<> '' & sLastDelim @<> sDelimDim );\n            sMessage = 'The\
    \ name of a dimension must follow a dimension delimiter (' | sDelimDim | ')';\n        \
    \    nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        EndIf;\n\n        sDimension = sWord;\n        nOneDimEleAdded = 0;\n  \
    \      \n        If( DimensionExists( sDimension ) = 0 );\n            # The dimension does\
    \ not exist in the model. Cancel process\n            sMessage = 'Dimension: ' | sDimension\
    \ | ' does not exist';\n            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        EndIf;\n\n        ### Determine the dimension is\
    \ a member of the cube ###\n        nCount = 1;\n        nDimensionIndex = 0;\n        While(\
    \ TabDim( pCube, nCount ) @<> '' );\n            sCubeDimName = TabDim( pCube, nCount );\n\
    \            If( sDimension @= sCubeDimName );\n                nDimensionIndex = nCount;\n\
    \            EndIf;\n            nCount = nCount + 1;\n        End;\n\n        If( nDimensionIndex\
    \ = 0 );\n            # The dimension does not exist in the cube. Cancel process\n     \
    \       sMessage = 'Dimension: ' | sDimension | ' is not a member of: '| pCube | 'cube.';\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        EndIf;\n\n        # Create the subset\n        If( SubsetExists( sDimension,\
    \ sSubset ) = 1 );\n            SubsetDeleteAllElements( sDimension, sSubset );\n      \
    \  Else;\n            SubsetCreate( sDimension, sSubset, pTemp );            \n        EndIf;\n\
    \n        # Attach to the view\n        ViewSubsetAssign( pCube, pView, sDimension, sSubset\
    \ );\n        \n        #Add to the Parsed filter\n        IF(sParsedFilter@='');\n    \
    \      sParsedFilter=sDimension;          \n        Else;\n          sParsedFilter=sParsedFilter|sDelimDim|sDimension;\n\
    \        Endif;  \n\n        nIndex = 1;\n        sLastDelim = sChar;\n        # Clear the\
    \ word\n        sWord = '';\n      Else;\n\n        # Reset extra chars\n        nAddExtra\
    \ = 0;\n\n        ### Check both both dim delimiter and element delimiter ###\n        nIsDelimiter\
    \ = 0;\n\n        ## Check dimension delimiter first\n        # If the delimiter is more\
    \ than 1 character peek ahead the same amount\n        # Ignore the first character\n  \
    \      sDelim = sChar;\n        nCount = LONG(sDelimDim) - 1;\n        If( nCount > 0 &\
    \ nChar + nCount <= nCharCount );\n          # Add the extra characters\n          sDelim\
    \ = sDelim | SUBST( sFilter, nChar + 1, nCount);\n          # Move to the end of the delimter\n\
    \          nAddExtra = nCount;\n        EndIf;\n\n        If( sDelim @= sDelimDim );\n \
    \         nIsDelimiter = 1;\n          sChar = sDelim;\n        Else;\n          # Reset\
    \ extra chars\n          nAddExtra = 0;\n\n          ## Check element delimiter\n\n    \
    \      # If the delimiter is more than 1 character peek ahead the same amount\n        \
    \  # Ignore the first character\n          sDelim = sChar;\n          nCount = LONG(sDelimElem)\
    \ - 1;\n          If( nCount > 0 & nChar + nCount <= nCharCount );\n            # Add the\
    \ extra characters\n            sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n\
    \            # Move to the end of the delimter\n            nAddExtra = nCount;\n      \
    \    EndIf;\n\n          If( sDelim @= sDelimElem );\n            nIsDelimiter = 1;\n  \
    \          sChar = sDelim;\n          Else;\n            # Reset extra chars\n         \
    \   nAddExtra = 0;\n          EndIf;\n\n        EndIf;\n\n        If ( nIsDelimiter = 1\
    \ );\n\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim );\n            sMessage\
    \ = 'An element delimiter must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar)\
    \ | ')';\n            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n            #ProcessError();\n          EndIf;\n\n          sElement\
    \ = sWord;\n\n          If( DIMIX( sDimension, sElement ) = 0 );\n              # The element\
    \ does not exist in the dimension. Cancel process\n              sMessage = 'Element: '\
    \ | sElement | ' in dimension ' | sDimension | ' does not exist';\n              nErrors\
    \ = nErrors + 1;\n              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \              #ProcessError();\n          EndIf;\n          \n          sElement = DimensionElementPrincipalName(sDimension,sElement);\n\
    \n          If ( pSuppressConsol = 1 & DTYPE( sDimension, sElement) @= 'C'  );\n       \
    \       # Add all N level elements to the subset\n              # Loop through all elements\
    \ and check if it is an ancestor\n              sMessage = 'Element ' | sElement | ' is\
    \ consolidated' ;\n              IF ( pLogoutput = 1 );\n                LogOutput( cMsgInfoLevel,\
    \ Expand( cMsgInfoContent ) );\n              EndIf;\n              nElCount = DIMSIZ (\
    \ sDimension );\n              n = 1;\n              WHILE ( n <= nElCount );\n        \
    \          sEl = DIMNM( sDimension, n );\n                  IF( DTYPE( sDimension, sEl)\
    \ @<> 'C' & ELISANC( sDimension, sElement, sEl ) = 1 );\n                      SubsetElementInsert(\
    \ sDimension, sSubset, sEl, 0 );\n                  EndIf;\n                  n = n + 1;\n\
    \              END;\n              \n              # Add the consolidated element to the\
    \ subset as well to export strings, if necessary\n              If ( pSuppressConsolStrings\
    \ = 0 );\n                SubsetElementInsert( sDimension, sSubset, sElement, 0 );\n   \
    \           EndIf;\n\n          Else;\n              # Add the element to the subset\n \
    \             SubsetElementInsert( sDimension, sSubset, sElement, 0 );\n          EndIf;\n\
    \          \n          #Add to the Parsed filter\n          If( nOneDimEleAdded = 0 );\n\
    \            sParsedFilter=sParsedFilter|pEleStartDelim|sElement;\n            nOneDimEleAdded\
    \ = nOneDimEleAdded + 1;\n          Else;\n            sParsedFilter=sParsedFilter|sDelimElem|sElement;\n\
    \          EndIf;\n\n          nIndex = nIndex + 1;\n          sLastDelim = sChar;\n\n \
    \         # Clear the word\n          sWord = '';\n        Else;\n          sWord = sWord\
    \ | sChar;\n        EndIf;\n\n      EndIf;\n\n    EndIf;\n\n    nChar = nChar + nAddExtra\
    \ + 1;\n\nEND;\nsBedrockViewCreateParsedFilter = sParsedFilter;\n\n# creating N level subset\
    \ for all dim not included in pFilter \n# useful when suppress consolidation is not on\n\
    If(pSubN = 1);\n    \n    nCountDimC = 1;\n    While( TabDim( pCube, nCountDimC ) @<> ''\
    \ );\n        sDimC = TabDim( pCube, nCountDimC );\n        sDimString = lower(sDimC);\n\
    \        \n        # filters created by other bedrock processes skip spaces from dim names\
    \ and between separators\n        While(Scan(' ',sDimString)>0);\n            sDimString\
    \ = subst(sDimString, 1, Scan(' ',sDimString)-1)|subst(sDimString,Scan(' ',sDimString)+1,long(sDimString));\n\
    \        End; \n        sTFilter = lower(sFilter);\n        While(Scan(' ',sTFilter)>0);\n\
    \            sTFilter = subst(sTFilter, 1, Scan(' ',sTFilter)-1)|subst(sTFilter,Scan(' ',sTFilter)+1,long(sTFilter));\n\
    \        End;\n        \n        # to make sure that the name of the dim is not part of\
    \ the name of another dim\n        If(Scan(pDimDelim|sDimString|pEleStartDelim, sTFilter)=0\
    \ & Scan(sDimString|pEleStartDelim, sTFilter)<>1);\n            sProc   = '}bedrock.hier.sub.create';\n\
    \            nRet    = ExecuteProcess( sProc,\n                'pLogOutput', pLogOutput,\n\
    \                'pStrictErrorHandling', pStrictErrorHandling,\n                'pDim',\
    \ sDimC,\n                'pHier', '',\n                'pSub', sSubset,\n             \
    \   'pConsol', '',\n                'pAttr', '',\n                'pAttrValue', '',\n  \
    \              'pLevelFrom', 0,\n                'pLevelTo', 0,\n                'pExclusions',\
    \ '',\n                'pDelim', pEleDelim,\n                'pAddToSubset', 0,\n      \
    \          'pAlias', '',\n                'pTemp', pTemp\n            );\n            \n\
    \            IF(nRet <> 0);\n                sMessage = 'Error creating the view from the\
    \ filter.';\n                nErrors = nErrors + 1;\n                LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n                If( pStrictErrorHandling = 1 ); \n    \
    \                ProcessQuit; \n                Else;\n                    ProcessBreak;\n\
    \                EndIf;\n            ENDIF;\n            \n            ViewSubsetAssign(\
    \ pCube, pView, sDimC, sSubset );\n        \n        EndIf;\n        \n        nCountDimC\
    \ = nCountDimC + 1;\n    End;\n\n  EndIf;  \n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling ###\nIf( nErrors <> 0 );\n    sMessage = 'the process incurred at least 1 error.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( 'ERROR' , Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n\
    \        ProcessBreak;\n    EndIf;\nElse; \n\n    sProcessAction      = Expand( 'Process:%cThisProcName%\
    \ successfully created View %pView% in Cube %pCube%.' );\n    sProcessReturnCode  = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode  = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \  \n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine dynamische Ansicht aus einem
    MDX-Ausdruck erstellt, der sich zu einer nicht-leeren Menge in der angegebenen Dimension
    auswertet. Der Prozess sollte für Entwicklungs-/Prototyping-Zwecke oder in der Produktion
    geeignet sein. Die Hauptanwendungsfälle umfassen die Erstellung einer Ansicht zum Nullsetzen
    von Daten und die Erstellung einer Ansicht, die als Quelle für den Export oder das Kopieren
    dient. Beachte, dass ein gültiger Würfelname (pCube) obligatorisch ist, da der Prozess ansonsten
    abgebrochen wird. Sollte der MDX-Ausdruck nicht kompilieren oder eine leere Menge erzeugen,
    wird der Prozess fehlerhaft enden. Ein Parameter (pTemp) steuert, ob die Ansicht temporär
    (Wert 1) oder dauerhaft (Wert 0) gespeichert wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description: \n# This process will Create a dynamic view from an MDX expression\
    \ that evaluates to a non-empty set in the specified dimension.\n\n# Use case: Intended\
    \ for development/prototyping or production.\n# 1/ Create a view to zero out data.\n# 2/\
    \ Create a view to use as a source for exporting or copying.\n\n# Note:\n# Naturally, a\
    \ valid cube name (pCube) is mandatory otherwise the process will abort.\n# If the MDX does\
    \ not compile or produces an empty set the process will error.\n# pTemp: This parameter\
    \ will control whether to make the view temporary (value 1) or if the\n#   view will be\
    \ permanently retained (value 0).\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    \ncThisProcName     = GetProcessName();\ncUserName = TM1User();\ncTimeStamp = TimSt( Now,\
    \ '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset\
    \ = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile = GetProcessErrorFileDirectory\
    \ | cTempSubset | '.csv';\nsMessage = \t'';\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo         \
    \ = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%, pMDXExpr:%pMDXExpr%,\
    \ pTemp:%pTemp%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nsMDXExpr = TRIM( pMDXExpr );\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\n# Validate Cube\nIf( Trim( pCube ) @= '' );\n    sMessage = 'No cube\
    \ specified.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage = Expand('Cube %pCube% does not\
    \ exist') ;\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate View\nIf( Trim( pView ) @= '' );\n    sMessage = 'No view specified';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate MDX\nIf( Trim( sMDXExpr ) @= '' );\n    sMessage = 'No MDX expression\
    \ specified';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate MDX. Checking Cube name mentioned in MDX\nIf( SCAN ( pCube\
    \ , sMDXExpr ) = 0 );\n    sMessage = 'No Cube Name mentioned in MDX. Not a valid MDX expression';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n## Validate pTemp\nIF( pTemp<> 0 & pTemp<> 1 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid value for pTemp' | NumberToString( pTemp ) | '. Valid values are 0 and 1';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create View ###\nIf( ViewExists(\
    \ pCube , pView ) = 1 );\n    ViewDestroy( pCube , pView );\nEndIf;\n\nViewCreatebyMDX (\
    \ pCube , pView , sMDXExpr, pTemp ) ; \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully created view %pView%\
    \ in cube %pCube%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates a dynamic view from an MDX
    expression evaluating to a non-empty set in the specified dimension. The process should
    be intended for development/prototyping or production. The main use cases include creating
    a view to zero out data and creating a view to use as a source for exporting or copying.
    Note that a valid cube name (pCube) is mandatory; otherwise, the process will abort. If
    the MDX does not compile or produces an empty set, the process will error. A parameter (pTemp)
    will control whether the view is made temporary (value 1) or permanently retained (value
    0).
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description: \n# This process will Create a dynamic view from an MDX expression\
    \ that evaluates to a non-empty set in the specified dimension.\n\n# Use case: Intended\
    \ for development/prototyping or production.\n# 1/ Create a view to zero out data.\n# 2/\
    \ Create a view to use as a source for exporting or copying.\n\n# Note:\n# Naturally, a\
    \ valid cube name (pCube) is mandatory otherwise the process will abort.\n# If the MDX does\
    \ not compile or produces an empty set the process will error.\n# pTemp: This parameter\
    \ will control whether to make the view temporary (value 1) or if the\n#   view will be\
    \ permanently retained (value 0).\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    \ncThisProcName     = GetProcessName();\ncUserName = TM1User();\ncTimeStamp = TimSt( Now,\
    \ '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset\
    \ = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile = GetProcessErrorFileDirectory\
    \ | cTempSubset | '.csv';\nsMessage = \t'';\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo         \
    \ = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%, pMDXExpr:%pMDXExpr%,\
    \ pTemp:%pTemp%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nsMDXExpr = TRIM( pMDXExpr );\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\n# Validate Cube\nIf( Trim( pCube ) @= '' );\n    sMessage = 'No cube\
    \ specified.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage = Expand('Cube %pCube% does not\
    \ exist') ;\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate View\nIf( Trim( pView ) @= '' );\n    sMessage = 'No view specified';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate MDX\nIf( Trim( sMDXExpr ) @= '' );\n    sMessage = 'No MDX expression\
    \ specified';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate MDX. Checking Cube name mentioned in MDX\nIf( SCAN ( pCube\
    \ , sMDXExpr ) = 0 );\n    sMessage = 'No Cube Name mentioned in MDX. Not a valid MDX expression';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n## Validate pTemp\nIF( pTemp<> 0 & pTemp<> 1 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid value for pTemp' | NumberToString( pTemp ) | '. Valid values are 0 and 1';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create View ###\nIf( ViewExists(\
    \ pCube , pView ) = 1 );\n    ViewDestroy( pCube , pView );\nEndIf;\n\nViewCreatebyMDX (\
    \ pCube , pView , sMDXExpr, pTemp ) ; \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully created view %pView%\
    \ in cube %pCube%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen Turbo Integrator Prozess, der öffentliche Ansichten löscht. Der
    Anwendungsfall umfasst die Entwicklung/Prototypisierung oder Produktion, bei denen nach
    der Erstellung einer Ansicht als Null oder Datenquelle diese gelöscht werden muss, sowie
    das Bereinigen öffentlicher Ansichten nach dem Go-Live. Dieser Prozess kann auf einem oder
    mehreren Cubes sowie auf einer oder mehreren Ansichten angewendet werden. Erläutere die
    Verwendung von Wildcards bei der Spezifizierung von Ansichts- und Cube-Namen durch den *-Zeichensatz.
    Erkläre die Funktion der verschiedenen Parameter: pCube - zur Festlegung, aus welchen Cubes
    Ansichten gelöscht werden sollen, wobei der Benutzer einzelne oder mehrere Cube-Namen angeben
    kann. Ermögliche das Löschen von Ansichten aus allen Cubes durch die Einstellung des pCube-Parameters
    auf *. Bei ungültigen Cubes wird der Vorgang übersprungen, jedoch fortgesetzt. pView - zur
    Bestimmung, welche Ansichten gelöscht werden sollen, wobei Leerwerte zum Prozessabbruch
    führen. Der Parameter gestattet das Löschen einzelner oder mehrerer Ansichten durch die
    Verwendung von Delimitern. Die Wildcard-Zeichenfolge folgt dem Format von Windows-gestützten
    Dateiwildcards und unterstützt das Löschen von Ansichten, die mit, auf oder innerhalb eines
    bestimmten Strings beginnen. Erkläre pDelim, den Delimiter-Parameter zur Angabe mehrerer
    Cubes oder Ansichten. Der Standard-Delimiter ist &, jedoch kann jeder geeignete Delimiter
    verwendet werden, der nicht in den Wildcards oder Cubenamen enthalten ist.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes public views.\n\n# Use case: Intended\
    \ for development/prototyping or production.\n# 1/ After a view has been created to zero\
    \ or as a data source it needs to be deleted.\n# 2/ Clean up public views after Go Live.\n\
    \n# Note:\n# This process can work on a single cubes or multiple cubes.\n# This process\
    \ can work on a single view or multiple views.\n# When specifying view names wildcards can\
    \ be included by using the * character. \n#       **Parameter pCube**.\n#   - To specify\
    \ which cubes to delete views from use the pCubes parameter.\n#   - To delete views from\
    \ a single cube only just specify that cube name e.g. Sales.\n#   - To delete views from\
    \ multiple cubes specify each cube name separated by a delimiter e.g. Sales&Inventory&Cashflow.\n\
    #   - To delete views from all cubes then set pCubes as *.\n#   - If any invalid cubes are\
    \ specified they will be skipped but the process will continue to process the other cubes.\n\
    #       **Parameter pView**.\n#   - To specify which views to delete use the pViews parameter.\n\
    #   - This parameter must be specified, a blank value will cause the process to terminate.\n\
    #   - To delete a single view only just specify that view name e.g. SalesByProduct.\n# \
    \  - To delete multiple views specify each view name separated by a delimiter e.g. SalesByProduct&SalesByManager&SalesByStore.\n\
    #   - When specifying view names wildcards are permitted and all views that match the wildcard\
    \ search string will be deleted.\n#   - The wildcard search string follows the same format\
    \ as windows based file wildcards.\n#   - To delete all views that 'start' with a specific\
    \ string use a trailing * e.g. Bedrock*.\n#   - To delete all views that 'end' in a specific\
    \ string use a leading * e.g. *Bedrock.\n#   - To delete all views that 'contain' a specific\
    \ string use leading and trailing *'s e.g. *Bedrock*.\n#   - To delete a single specific\
    \ view only don't use *'s at all e.g. Bedrock.\n#   - To specify multiple search stings\
    \ list them all separated by a delimiter e.g. Bedrock*;*Temp;*Test*.\n#   - Specific view\
    \ names and wildcard based names can both be used together e.g. SalesByProduct;Bedrock*.\n\
    #       **Parameter pDelim**.\n#   - The delimiter can be used when specifying multiple\
    \ cubes and/or multiple views.\n#   - The default delimiter is &.\n#   - Any delimiter can\
    \ be used by specifying a value for pDelimiter.\n#   - Choose a delimiter that won't be\
    \ used in either the wildcard search strings or cube names.\n#EndRegion @DOC\n\n\n##Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName       = GetProcessName();\n\
    cUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s'\
    \ );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset       \
    \  = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory\
    \ | cTempSubset | '.csv';\nsMessage            = \t'';\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%,\
    \ pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nnErrors             = 0;\ncDimension          = '}Cubes';\n\
    \n### Validate Parameters ###\nnErrors = 0;\n\n# Validate views\nIf( Trim( pView ) @= ''\
    \ );\n    sMessage        = 'No views specified.';\n    nErrors         = nErrors + 1;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate delimiter\n\
    If( Trim( pDelim ) @= '' );\n    pDelim     = '&';\nEndIf;\n\n### Iterate through cubes\
    \ ###\n\n# If no cube has been specified then process all cubes\nIf( Trim( pCube ) @= ''\
    \ );\n    sMessage = 'No cube specified.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ > 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n# Work through all cubes specified in pCube\nsCubes               \
    \           = pCube;\nnCubeDelimIndex                 = 1;\nsDelimiter                 \
    \     = pDelim;\nsMdx = '';\nWhile( nCubeDelimIndex <> 0 );\n    nCubeDelimIndex       \
    \      = Scan( sDelimiter, sCubes  );\n    If( nCubeDelimIndex = 0 );\n        sCube   \
    \                = Trim( sCubes );\n    Else;\n        sCube                   = Trim( SubSt(\
    \ sCubes, 1, nCubeDelimIndex - 1 ) );\n        sCubes                  = Trim( SubSt( sCubes,\
    \ nCubeDelimIndex + Long( sDelimiter ), Long( sCubes ) ) );\n    EndIf;\n\n    # Create\
    \ subset of cubes using Wildcard to loop through cubes in pCube with wildcard\n    sCubeExp\
    \ = '''|sCube|''';\n    sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ),\
    \ %sCubeExp% )}');\n    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx\
    \ = sMdx | ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n    \nIf( SubsetExists( '}Cubes' , cTempSubset\
    \ ) = 1 );\n    # If a delimited list of cube names includes wildcards then we may have\
    \ to re-use the subset multiple times\n    SubsetMDXSet( '}Cubes' , cTempSubset, sMDX );\n\
    Else;\n    # temp subset, therefore no need to destroy in epilog\n    SubsetCreatebyMDX(\
    \ cTempSubset, sMDX, '}Cubes' , 1 );\nEndIf;\n    \n    \n    # Loop through cubess in subset\
    \ created based on wildcard\n    nCountCubes = SubsetGetSize( '}Cubes' , cTempSubset );\n\
    \    While( nCountCubes >= 1 );\n      sCurrentCube = SubsetGetElementName( '}Cubes' , cTempSubset,\
    \ nCountCubes );\n      # If a valid cube has been specified then delete specified views\
    \ from it\n      If( CubeExists( sCurrentCube ) = 1 );\n          If( pLogOutput = 1 );\n\
    \            LogOutput( 'INFO', Expand( 'Processing cube %sCurrentCube%.' ) );\n       \
    \   EndIf;\n          # Work through all views specified in pViews\n          sViews   \
    \               = pView;\n          nViewDelimIndex         = 1;\n          sMdxView = '';\n\
    \  \n          While( nViewDelimIndex <> 0 );\n              nViewDelimIndex       = Scan(\
    \ sDelimiter, sViews );\n              If( nViewDelimIndex = 0 );\n                  sView\
    \           = Trim( sViews );\n              Else;\n                  sView           =\
    \ Trim( SubSt( sViews, 1, nViewDelimIndex - 1 ) );\n                  sViews          =\
    \ Trim( SubSt( sViews, nViewDelimIndex + Long( sDelimiter ), Long( sViews ) ) );\n     \
    \         EndIf;\n  \n              # Check if a wildcard has been used to specify the view\
    \ name.\n              # If it hasn't then just delete the view if it exists\n         \
    \     If( Scan( '*', sView ) = 0 );\n                  If( ViewExists( sCurrentCube, sView\
    \ ) = 1 );\n                      If( pLogOutput = 1 );\n                        LogOutput(\
    \ 'INFO', Expand( '  Destroying view %sView% in cube %sCurrentCube%.' ) );\n           \
    \           EndIf;\n                      ViewDestroy( sCurrentCube, sView );\n        \
    \          EndIf;\n              # If it has then iterate through '}Views_CubeName' dimension\n\
    \              Else;\n                  sDimViews       = '}Views_' | sCurrentCube ;\n \
    \                 If( DimensionExists( sDimViews ) = 1 );\n                    # Create\
    \ subset of views using Wildcard to loop through views in current cube\n               \
    \     sViewExp = '''|sView|''';\n                    sMdxViewPart = Expand('{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([%sDimViews%])}, %sViewExp% )}');\n                    IF( sMdxView @= '');\
    \ \n                      sMdxview = sMdxViewPart; \n                    ELSE;\n       \
    \               sMdxView = sMdxView | ' + ' | sMdxViewPart;\n                    ENDIF;\n\
    \                    If( SubsetExists( sDimViews, cTempSubset ) = 1 );\n               \
    \         # If a delimited list of attr names includes wildcards then we may have to re-use\
    \ the subset multiple times\n                        SubsetMDXSet( sDimViews, cTempSubset,\
    \ sMdxView );\n                    Else;\n                        # temp subset, therefore\
    \ no need to destroy in epilog\n                        SubsetCreatebyMDX( cTempSubset,\
    \ sMdxView, sDimViews, 1 );\n                    EndIf;\n                \n            \
    \        # Loop through subset of views created based on wildcard\n                    nCountView\
    \ = SubsetGetSize( sDimViews, cTempSubset );\n                    While( nCountView >= 1\
    \ );\n                        sViewEle = SubsetGetElementName( sDimViews, cTempSubset, nCountView\
    \ );\n                        # Validate attribute name in sDim\n                      \
    \  If( ViewExists( sCurrentCube, sViewEle ) = 1 );\n                          If( pLogOutput\
    \ = 1 );\n                            LogOutput( 'INFO', Expand( 'Destroying view %sViewEle%\
    \ in cube %sCurrentCube%.' ) );\n                          EndIf;\n                    \
    \        ViewDestroy( sCurrentCube, sViewEle );\n                        Endif;\n      \
    \                  nCountView = nCountView - 1;\n                    End;\n            \
    \      EndIf;\n              EndIf;\n          \n          End;\n  \n      # Cube does not\
    \ exist\n      Else;\n          sMessage                = Expand('Cube %sCurrentCube% does\
    \ not exist.');\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  \
    \    EndIf;\n            \n      nCountCubes = nCountCubes - 1;\n    End;\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted view %pView% from cube %pCube%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n\n### End Epilog ###"
- question: 'Develop a IBM Turbo Integrator process that deletes public views. The use case
    includes development/prototyping or production scenarios where a view needs to be deleted
    after being created as zero or a data source, and cleaning up public views post-Go Live.
    This process can operate on single or multiple cubes, and on single or multiple views. Explain
    the use of wildcards in specifying view and cube names using the * character. Discuss the
    function of various parameters: pCube - to specify which cubes to delete views from, allowing
    the user to specify single or multiple cube names. Enable view deletion from all cubes by
    setting pCube to *. Any invalid cubes specified will be skipped, but processing of other
    cubes will continue. pView - to specify which views to delete, requiring a non-blank value
    for process continuation. Permits deletion of single or multiple views using delimiters.
    The wildcard search string follows the format of Windows-based file wildcards, supporting
    deletion of views that start with, end with, or contain a specific string. Explain pDelim,
    the delimiter parameter, for specifying multiple cubes or views. The default delimiter is
    &, but any suitable delimiter can be used that is not part of the wildcard search strings
    or cube names.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes public views.\n\n# Use case: Intended\
    \ for development/prototyping or production.\n# 1/ After a view has been created to zero\
    \ or as a data source it needs to be deleted.\n# 2/ Clean up public views after Go Live.\n\
    \n# Note:\n# This process can work on a single cubes or multiple cubes.\n# This process\
    \ can work on a single view or multiple views.\n# When specifying view names wildcards can\
    \ be included by using the * character. \n#       **Parameter pCube**.\n#   - To specify\
    \ which cubes to delete views from use the pCubes parameter.\n#   - To delete views from\
    \ a single cube only just specify that cube name e.g. Sales.\n#   - To delete views from\
    \ multiple cubes specify each cube name separated by a delimiter e.g. Sales&Inventory&Cashflow.\n\
    #   - To delete views from all cubes then set pCubes as *.\n#   - If any invalid cubes are\
    \ specified they will be skipped but the process will continue to process the other cubes.\n\
    #       **Parameter pView**.\n#   - To specify which views to delete use the pViews parameter.\n\
    #   - This parameter must be specified, a blank value will cause the process to terminate.\n\
    #   - To delete a single view only just specify that view name e.g. SalesByProduct.\n# \
    \  - To delete multiple views specify each view name separated by a delimiter e.g. SalesByProduct&SalesByManager&SalesByStore.\n\
    #   - When specifying view names wildcards are permitted and all views that match the wildcard\
    \ search string will be deleted.\n#   - The wildcard search string follows the same format\
    \ as windows based file wildcards.\n#   - To delete all views that 'start' with a specific\
    \ string use a trailing * e.g. Bedrock*.\n#   - To delete all views that 'end' in a specific\
    \ string use a leading * e.g. *Bedrock.\n#   - To delete all views that 'contain' a specific\
    \ string use leading and trailing *'s e.g. *Bedrock*.\n#   - To delete a single specific\
    \ view only don't use *'s at all e.g. Bedrock.\n#   - To specify multiple search stings\
    \ list them all separated by a delimiter e.g. Bedrock*;*Temp;*Test*.\n#   - Specific view\
    \ names and wildcard based names can both be used together e.g. SalesByProduct;Bedrock*.\n\
    #       **Parameter pDelim**.\n#   - The delimiter can be used when specifying multiple\
    \ cubes and/or multiple views.\n#   - The default delimiter is &.\n#   - Any delimiter can\
    \ be used by specifying a value for pDelimiter.\n#   - Choose a delimiter that won't be\
    \ used in either the wildcard search strings or cube names.\n#EndRegion @DOC\n\n\n##Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName       = GetProcessName();\n\
    cUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s'\
    \ );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset       \
    \  = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory\
    \ | cTempSubset | '.csv';\nsMessage            = \t'';\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%,\
    \ pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nnErrors             = 0;\ncDimension          = '}Cubes';\n\
    \n### Validate Parameters ###\nnErrors = 0;\n\n# Validate views\nIf( Trim( pView ) @= ''\
    \ );\n    sMessage        = 'No views specified.';\n    nErrors         = nErrors + 1;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate delimiter\n\
    If( Trim( pDelim ) @= '' );\n    pDelim     = '&';\nEndIf;\n\n### Iterate through cubes\
    \ ###\n\n# If no cube has been specified then process all cubes\nIf( Trim( pCube ) @= ''\
    \ );\n    sMessage = 'No cube specified.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ > 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n# Work through all cubes specified in pCube\nsCubes               \
    \           = pCube;\nnCubeDelimIndex                 = 1;\nsDelimiter                 \
    \     = pDelim;\nsMdx = '';\nWhile( nCubeDelimIndex <> 0 );\n    nCubeDelimIndex       \
    \      = Scan( sDelimiter, sCubes  );\n    If( nCubeDelimIndex = 0 );\n        sCube   \
    \                = Trim( sCubes );\n    Else;\n        sCube                   = Trim( SubSt(\
    \ sCubes, 1, nCubeDelimIndex - 1 ) );\n        sCubes                  = Trim( SubSt( sCubes,\
    \ nCubeDelimIndex + Long( sDelimiter ), Long( sCubes ) ) );\n    EndIf;\n\n    # Create\
    \ subset of cubes using Wildcard to loop through cubes in pCube with wildcard\n    sCubeExp\
    \ = '''|sCube|''';\n    sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ),\
    \ %sCubeExp% )}');\n    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx\
    \ = sMdx | ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n    \nIf( SubsetExists( '}Cubes' , cTempSubset\
    \ ) = 1 );\n    # If a delimited list of cube names includes wildcards then we may have\
    \ to re-use the subset multiple times\n    SubsetMDXSet( '}Cubes' , cTempSubset, sMDX );\n\
    Else;\n    # temp subset, therefore no need to destroy in epilog\n    SubsetCreatebyMDX(\
    \ cTempSubset, sMDX, '}Cubes' , 1 );\nEndIf;\n    \n    \n    # Loop through cubess in subset\
    \ created based on wildcard\n    nCountCubes = SubsetGetSize( '}Cubes' , cTempSubset );\n\
    \    While( nCountCubes >= 1 );\n      sCurrentCube = SubsetGetElementName( '}Cubes' , cTempSubset,\
    \ nCountCubes );\n      # If a valid cube has been specified then delete specified views\
    \ from it\n      If( CubeExists( sCurrentCube ) = 1 );\n          If( pLogOutput = 1 );\n\
    \            LogOutput( 'INFO', Expand( 'Processing cube %sCurrentCube%.' ) );\n       \
    \   EndIf;\n          # Work through all views specified in pViews\n          sViews   \
    \               = pView;\n          nViewDelimIndex         = 1;\n          sMdxView = '';\n\
    \  \n          While( nViewDelimIndex <> 0 );\n              nViewDelimIndex       = Scan(\
    \ sDelimiter, sViews );\n              If( nViewDelimIndex = 0 );\n                  sView\
    \           = Trim( sViews );\n              Else;\n                  sView           =\
    \ Trim( SubSt( sViews, 1, nViewDelimIndex - 1 ) );\n                  sViews          =\
    \ Trim( SubSt( sViews, nViewDelimIndex + Long( sDelimiter ), Long( sViews ) ) );\n     \
    \         EndIf;\n  \n              # Check if a wildcard has been used to specify the view\
    \ name.\n              # If it hasn't then just delete the view if it exists\n         \
    \     If( Scan( '*', sView ) = 0 );\n                  If( ViewExists( sCurrentCube, sView\
    \ ) = 1 );\n                      If( pLogOutput = 1 );\n                        LogOutput(\
    \ 'INFO', Expand( '  Destroying view %sView% in cube %sCurrentCube%.' ) );\n           \
    \           EndIf;\n                      ViewDestroy( sCurrentCube, sView );\n        \
    \          EndIf;\n              # If it has then iterate through '}Views_CubeName' dimension\n\
    \              Else;\n                  sDimViews       = '}Views_' | sCurrentCube ;\n \
    \                 If( DimensionExists( sDimViews ) = 1 );\n                    # Create\
    \ subset of views using Wildcard to loop through views in current cube\n               \
    \     sViewExp = '''|sView|''';\n                    sMdxViewPart = Expand('{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([%sDimViews%])}, %sViewExp% )}');\n                    IF( sMdxView @= '');\
    \ \n                      sMdxview = sMdxViewPart; \n                    ELSE;\n       \
    \               sMdxView = sMdxView | ' + ' | sMdxViewPart;\n                    ENDIF;\n\
    \                    If( SubsetExists( sDimViews, cTempSubset ) = 1 );\n               \
    \         # If a delimited list of attr names includes wildcards then we may have to re-use\
    \ the subset multiple times\n                        SubsetMDXSet( sDimViews, cTempSubset,\
    \ sMdxView );\n                    Else;\n                        # temp subset, therefore\
    \ no need to destroy in epilog\n                        SubsetCreatebyMDX( cTempSubset,\
    \ sMdxView, sDimViews, 1 );\n                    EndIf;\n                \n            \
    \        # Loop through subset of views created based on wildcard\n                    nCountView\
    \ = SubsetGetSize( sDimViews, cTempSubset );\n                    While( nCountView >= 1\
    \ );\n                        sViewEle = SubsetGetElementName( sDimViews, cTempSubset, nCountView\
    \ );\n                        # Validate attribute name in sDim\n                      \
    \  If( ViewExists( sCurrentCube, sViewEle ) = 1 );\n                          If( pLogOutput\
    \ = 1 );\n                            LogOutput( 'INFO', Expand( 'Destroying view %sViewEle%\
    \ in cube %sCurrentCube%.' ) );\n                          EndIf;\n                    \
    \        ViewDestroy( sCurrentCube, sViewEle );\n                        Endif;\n      \
    \                  nCountView = nCountView - 1;\n                    End;\n            \
    \      EndIf;\n              EndIf;\n          \n          End;\n  \n      # Cube does not\
    \ exist\n      Else;\n          sMessage                = Expand('Cube %sCurrentCube% does\
    \ not exist.');\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  \
    \    EndIf;\n            \n      nCountCubes = nCountCubes - 1;\n    End;\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted view %pView% from cube %pCube%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine private Ansicht in eine öffentliche
    Ansicht für einen angegebenen Client umwandelt. Der Prozess sollte in Entwicklungs-, Prototyping-
    oder Produktionsszenarien eingesetzt werden können. Das Ziel ist, private Ansichten öffentlich
    zugänglich zu machen. Stelle sicher, dass ein gültiger Würfelname (pCube) angegeben ist,
    da der Prozess sonst abbricht. Ebenso muss ein gültiger Ansichtsname (pView) vorhanden sein,
    da der Prozess ansonsten ebenfalls abbricht. Der Prozess muss von dem Benutzer ausgeführt
    werden, der die private Ansicht besitzt, da er nicht von einem anderen Benutzer ausgeführt
    werden kann. Wenn die Ansicht private Untergruppen enthält, müssen auch diese öffentlich
    gemacht werden, andernfalls schlägt das Veröffentlichen der Ansicht fehl.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process converts a private view to a public view\
    \ for the named client.\n#\n# Use case: Intended for development/prototyping or production.\n\
    # 1. Make private view public to enable public consumption.\n#\n# Note:\n# * A valid cube\
    \ name pCube is mandatory otherwise the process will abort.\n# * Also, a valid view name\
    \ pView is mandatory otherwise the process will abort.\n# * This process must be run by\
    \ the user owning the private view; it canot be run by another user.\n# * If the view contains\
    \ private subsets they must also be made public or the view publish will fail.\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName       = GetProcessName();\n\
    cUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s'\
    \ );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset       \
    \  = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory\
    \ | cTempSubset | '.csv';\nsMessage            = \t'';\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%,\
    \ pSubPublish:%pSubPublish%, pOverwrite:%pOverwrite%.' ;\n\n## LogOutput parameters\nIF(\
    \ pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\n# create friendly name for user handle\nIf( DimIx( '}ElementAttributes_}Clients',\
    \ '}TM1_DefaultDisplayValue' ) > 0 );\n    pClient = AttrS( '}Clients', cUserName, '}TM1_DefaultDisplayValue'\
    \ );\n    If( pClient @= '' );\n        pClient = cUserName;\n    EndIf;\nElse;\n    pClient\
    \ = cUserName;\nEndIf;\n\n# Validate Cube\nIf( Trim( pCube ) @= '' );\n    sMessage = 'No\
    \ cube specified';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage = Expand('Cube %pCube% does not\
    \ exist on server');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate view\nIf( Trim( pView ) @= '' );\n    sMessage\
    \ = 'No view specified';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# No way to check if private view exists except via file\
    \ system.\n# Could include data directory param and concatenate with user, cube and view\
    \ to check\n# if private view exists to handle error in the case that private view does\
    \ not exist\n\n# Check for valid view name, subset publish and overwrite parameters\nIf(\
    \ pSubPublish <> 0 & pSubPublish <> 1 );\n    sMessage = 'Invalid publish private subsets\
    \ selection: ' | NumberToString( pSubPublish );\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pOverwrite <> 0 & pOverwrite\
    \ <> 1 );\n    sMessage = 'Invalid overwrite existing public view selection: ' | NumberToString(\
    \ pOverwrite );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( pOverwrite = 0 & ViewExists( pCube, pView ) = 1 );\n    # If NOT overwriting\
    \ current public view AND view of the same name exists then cause minor error ( major error\
    \ if not handled )\n    sMessage = 'Public view of same name already exists and Overwrite=0\
    \ specified';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Publish\
    \ the view ( and any private subsets ) ###\nPublishView( pCube, pView, pSubPublish, pOverwrite\
    \ );\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully published view %pView% in cube %pCube%\
    \ created by cient %pClient%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Develop an IBM Turbo Integrator process that converts a private view to a public
    view for the named client. The process should be applicable for development, prototyping,
    or production scenarios. The goal is to make private views publicly consumable. Ensure that
    a valid cube name (pCube) is provided, otherwise the process will abort. Similarly, a valid
    view name (pView) is mandatory, otherwise the process will also abort. The process must
    be executed by the user owning the private view and cannot be run by another user. If the
    view contains private subsets, these must also be made public, or the view publish will
    fail.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process converts a private view to a public view\
    \ for the named client.\n#\n# Use case: Intended for development/prototyping or production.\n\
    # 1. Make private view public to enable public consumption.\n#\n# Note:\n# * A valid cube\
    \ name pCube is mandatory otherwise the process will abort.\n# * Also, a valid view name\
    \ pView is mandatory otherwise the process will abort.\n# * This process must be run by\
    \ the user owning the private view; it canot be run by another user.\n# * If the view contains\
    \ private subsets they must also be made public or the view publish will fail.\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName       = GetProcessName();\n\
    cUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s'\
    \ );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset       \
    \  = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory\
    \ | cTempSubset | '.csv';\nsMessage            = \t'';\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%,\
    \ pSubPublish:%pSubPublish%, pOverwrite:%pOverwrite%.' ;\n\n## LogOutput parameters\nIF(\
    \ pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\n# create friendly name for user handle\nIf( DimIx( '}ElementAttributes_}Clients',\
    \ '}TM1_DefaultDisplayValue' ) > 0 );\n    pClient = AttrS( '}Clients', cUserName, '}TM1_DefaultDisplayValue'\
    \ );\n    If( pClient @= '' );\n        pClient = cUserName;\n    EndIf;\nElse;\n    pClient\
    \ = cUserName;\nEndIf;\n\n# Validate Cube\nIf( Trim( pCube ) @= '' );\n    sMessage = 'No\
    \ cube specified';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage = Expand('Cube %pCube% does not\
    \ exist on server');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate view\nIf( Trim( pView ) @= '' );\n    sMessage\
    \ = 'No view specified';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# No way to check if private view exists except via file\
    \ system.\n# Could include data directory param and concatenate with user, cube and view\
    \ to check\n# if private view exists to handle error in the case that private view does\
    \ not exist\n\n# Check for valid view name, subset publish and overwrite parameters\nIf(\
    \ pSubPublish <> 0 & pSubPublish <> 1 );\n    sMessage = 'Invalid publish private subsets\
    \ selection: ' | NumberToString( pSubPublish );\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pOverwrite <> 0 & pOverwrite\
    \ <> 1 );\n    sMessage = 'Invalid overwrite existing public view selection: ' | NumberToString(\
    \ pOverwrite );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( pOverwrite = 0 & ViewExists( pCube, pView ) = 1 );\n    # If NOT overwriting\
    \ current public view AND view of the same name exists then cause minor error ( major error\
    \ if not handled )\n    sMessage = 'Public view of same name already exists and Overwrite=0\
    \ specified';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Publish\
    \ the view ( and any private subsets ) ###\nPublishView( pCube, pView, pSubPublish, pOverwrite\
    \ );\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully published view %pView% in cube %pCube%\
    \ created by cient %pClient%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine Verarbeitungsansicht für
    einen Würfel sowie für ausgewählte Dimensionen dieses Würfels erstellt. Dieser Prozess ist
    sowohl für Entwicklungs-/Prototyping- als auch Produktionsumgebungen gedacht. Zuerst sollte
    eine Ansicht mit gleichnamigen Teilmengen erstellt werden, die leer sind. Beachte, dass
    leere Teilmengen erstellt und diesen Teilmengen der Ansicht zugewiesen werden. Ein nachfolgender
    Prozess ist erforderlich, um Elemente in die Teilmengen einzufügen, da die Ansichten sonst
    keine Daten enthalten. Ein gültiger Würfelname (pCube) ist zwingend erforderlich, da der
    Prozess andernfalls abgebrochen wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates a processing view for the cube and\
    \ for specified dimensions of the cube. \n\n# Use case: Intended for development/prototyping\
    \ or in Production environment.\n# 1. Create a view with subsets of the same name that are\
    \ empty.\n\n# Note:\n# Creates empty subsets and assigns the empty subsets to the view.\
    \ \n# A subsequent process is required to insert elements into subsets otherwise the views\
    \ will not contain any data.\n# Naturally, a valid cube name (pCube) is mandatory otherwise\
    \ the process will abort.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n\n### Constants\
    \ ###\ncThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\ncMsgInfoLevel\
    \     =  'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%,\
    \ pSubset:%pSub%, pDim:%pDim%, pDelim:%pDelim%, pSuppressZero:%pSuppressZero%, pSuppressConsol:%pSuppressConsol%,\
    \ pSuppressRules:%pSuppressRules%.'; \ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\\
    s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset       =\
    \ cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\nsMessage          = '';\ncDimCubes \
    \        = '}Cubes';\ncDimDimensions    = '}Dimensions';\ncAll              = 'ALL';\ncTemp\
    \             = If( pTemp >= 1, 1, 0 );\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    \nnErrors = 0;\n\n# Validate cube\nIf( Trim( pCube ) @= '' );\n    sMessage    = 'No cube\
    \ specified.';\n    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate dimensions\nIf( Trim( pDim ) @= '' );\n    sMessage    = 'No\
    \ dimensions specified.';\n    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate suppression parameters\nIf( pSuppressZero\
    \ <> 0 & pSuppressZero <> 1 );\n    sMessage    = 'Invalid value for suppress zero parameter.';\n\
    \    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( pSuppressConsol <> 0 & pSuppressConsol <> 1 );\n    sMessage    =\
    \ 'Invalid value for suppress consol parameter.';\n    nErrors     = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pSuppressRules <> 0 & pSuppressRules\
    \ <> 1 );\n    sMessage    = 'Invalid value for suppress rules parameter.';\n    nErrors\
    \     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate view and subsets\nIf( pView @= '' & pSub @= '' );\n    ## Use standard view\
    \ name.\n    cView       = cTempSubset;\n    cSubset     = cView;\nElseIf( pView @<> ''\
    \ & pSub @= '' );\n    ## Use the nominated view name for the subset name.\n    cView  \
    \     = pView;\n    cSubset     = pView;\nElseIf( pView @= '' & pSub @<> '' );\n    ## Use\
    \ the nominated subset name for the view name.\n    cView       = pSub;\n    cSubset   \
    \  = pSub;\nElse;\n    cView   = pView;\n    cSubset = pSub;\nEndIf;\n\n\n# Validate delimiter\n\
    If( pDelim @= '' );\n    pDelim     = '&';\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Handle All cubes or a cubes list\nIf ( TRIM(\
    \ pCube ) @= cAll );\n  sMDX = Expand( '{TM1SUBSETALL([%cDimCubes%])}' );\nElse;\n  sCubeTokenizer\
    \ = TRIM( pCube );\n  sMDX = '';\n  ### Loop and tokenize Cube list\n  While ( sCubeTokenizer\
    \ @<> '' );\n    nPos = SCAN( pDelim, sCubeTokenizer );\n    If ( nPos = 0 );\n      nPos\
    \ = LONG( sCubeTokenizer ) + 1;\n    EndIf;\n    sSearchCube = TRIM( SUBST( sCubeTokenizer,\
    \ 1, nPos - 1 ) );\n    If ( SCAN( '*', sSearchCube ) <> 0 % SCAN( '?', sSearchCube ) <>\
    \ 0 );\n      If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimCubes%])},\
    \ '%sSearchCube%')}' );\n      Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimCubes%])},\
    \ '%sSearchCube%')}' );\n      EndIf;\n    Else;\n      If ( CubeExists( sSearchCube ) =\
    \ 0 );\n        sMessage = Expand( 'Cube: %sSearchCube% does not exist.' );\n        nErrors\
    \ = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n   \
    \     If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n     \
    \       ProcessBreak;\n        EndIf;\n      Else;\n        If( sMDX @= '' );\n        \
    \  sMDX = Expand( '{[%cDimCubes%].[%sSearchCube%]}' );\n        Else;\n          sMDX =\
    \ Expand( '%sMDX% + {[%cDimCubes%].[%sSearchCube%]}' );\n        EndIf;\n      EndIf;\n\
    \    EndIf;\n    ### Consume dimension and delimiter\n    sCubeTokenizer = TRIM( DELET(\
    \ sCubeTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX = Expand( '{%sMDX%}'\
    \ );\nEndIf;\n\nIf (SubsetExists( cDimCubes, cTempSubset ) = 1 );\n  SubsetDestroy( cDimCubes,\
    \ cTempSubset );\nEndIf;\nSubsetCreateByMDX( cTempSubset, sMDX, cDimCubes, 1 );\n\n### Handle\
    \ All dimensions or a dimension list\n### We must exclude hierarchies\nIf ( TRIM( pDim )\
    \ @= cAll );\n  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}' );\nElse;\n  sDimTokenizer = TRIM( pDim );\n  sMDX = '';\n  ### Loop and\
    \ tokenize dimension list\n  While ( sDimTokenizer @<> '' );\n    nPos = SCAN( pDelim, sDimTokenizer\
    \ );\n    If ( nPos = 0 );\n      nPos = LONG( sDimTokenizer ) + 1;\n    EndIf;\n    sSearchDim\
    \ = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n    If ( SCAN( ':', sSearchDim ) <> 0\
    \ );\n      sMessage    = Expand( 'Dimension: The process is not accepting hierarchies:\
    \ %sSearchDim%' );\n      nErrors     = nErrors + 1;\n      LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    ElseIf ( SCAN( '*', sSearchDim ) <> 0 % SCAN( '?', sSearchDim\
    \ ) <> 0 );\n      If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n  \
    \    Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n  \
    \    EndIf;\n    Else;\n      If ( DimensionExists( sSearchDim ) = 0 );\n        sMessage\
    \    = Expand( 'Dimension: %sSearchDim% does not exist.' );\n        nErrors     = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;\n      Else;\n        If( sMDX @= '' );\n          sMDX = Expand( '{[%cDimDimensions%].[%sSearchDim%]}'\
    \ );\n        Else;\n          sMDX = Expand( '%sMDX% + {[%cDimDimensions%].[%sSearchDim%]}'\
    \ );\n        EndIf;\n      EndIf;\n    EndIf;\n    ### Consume dimension and delimiter\n\
    \    sDimTokenizer = TRIM( DELET( sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n\
    \  sMDX = Expand( '{%sMDX%}' );\nEndIf;\n\nIf (SubsetExists( cDimDimensions, cTempSubset\
    \ ) = 1 );\n  SubsetDestroy( cDimDimensions, cTempSubset );\nEndIf;\nSubsetCreateByMDX(\
    \ cTempSubset, sMDX, cDimDimensions, 1 );\n\n### Build Subsets and assign to View ###\n\
    nCube = 1;\nWhile ( nCube <= SubsetGetSize( cDimCubes, cTempSubset ) );\n  sCube = SubsetGetElementName(\
    \ cDimCubes, cTempSubset, nCube );\n  ### Build View ###\n  If( ViewExists( sCube, cView\
    \ ) = 1 );\n    ViewDestroy( sCube, cView );\n  EndIf;\n  nDim = 1;\n  sDim = TABDIM( sCube,\
    \ nDim );\n  While ( sDim @<> '' );\n   # filter selection has non-empty intersect with\
    \ current cube dimensions\n   #If ( SubsetElementExists( cDimDimensions, cTempSubset, sDim\
    \ ) = 1 ); - bug does not work\n   IF( SubsetElementGetIndex( cDimDimensions, cTempSubset,\
    \ sDim, 1 ) > 0 );\n      # create view if and only if there is at least one match with\
    \ dimensions\n      If( ViewExists( sCube, cView ) = 0 );\n        ViewCreate( sCube, cView,\
    \ cTemp );\n        ViewExtractSkipZeroesSet( sCube, cView, pSuppressZero );\n        ViewExtractSkipCalcsSet(\
    \ sCube, cView, pSuppressConsol );\n        ViewExtractSkipRuleValuesSet( sCube, cView,\
    \ pSuppressRules );\n      EndIf;\n      If ( SubsetExists ( sDim, cSubset ) = 1 );\n  \
    \      If ( SubsetGetSize( sDim, cSubset ) > 0 );\n          SubsetDeleteAllElements( sDim,\
    \ cSubset );\n        EndIf;\n      Else;\n        SubsetCreate( sDim, cSubset, cTemp );\n\
    \      EndIf;\n      ViewSubsetAssign( sCube, cView, sDim, cSubset );\n    EndIf;\n    nDim\
    \ = nDim + 1;\n    sDim = TABDIM( sCube, nDim );\n  End;\n  \n  # creating N level subset\
    \ for all dim not included in pDim for the cube\n  If(pSubN = 1);\n    nCountDimC = 1;\n\
    \    While( TabDim( sCube, nCountDimC ) @<> '' );\n    sDimC = TabDim( sCube, nCountDimC\
    \ );\n    If ( ViewExists( sCube, cView ) = 1 & SubsetElementGetIndex( cDimDimensions, cTempSubset,\
    \ sDimC, 1 ) = 0 );\n      If ( SubsetExists ( sDimC, cSubset ) = 1 );\n        If ( SubsetGetSize(\
    \ sDimC, cSubset ) > 0 );\n          SubsetDeleteAllElements( sDimC, cSubset );\n      \
    \  EndIf;\n      Else;\n        SubsetCreate( sDimC, cSubset, cTemp );\n      Endif;  \n\
    \      nElCount = DIMSIZ ( sDimC );\n      nElC = 1;\n      WHILE ( nElC <= nElCount );\n\
    \        sEl = DIMNM( sDimC, nElC );\n        IF(ElementLevel( sDimC, sDimC, sEl )= 0 );\n\
    \          SubsetElementInsert( sDimC, cSubset, sEl, 0 );\n        EndIf;\n        nElC\
    \ = nElC + 1;\n      END;\n      ViewSubsetAssign( sCube, cView, sDimC, cSubset );\n   \
    \ Endif;\n    nCountDimC = nCountDimC + 1;\n    End;\n  Endif;\n\n\n  nCube = nCube + 1;\n\
    End;\n\n\n### End Prolog ###\n\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created views and subsets for cube  %pCube%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates a processing view for a cube
    and specified dimensions of the cube. This process is intended for both development/prototyping
    and production environments. First, create a view with subsets of the same name that are
    empty. Note that empty subsets are created and assigned to the view. A subsequent process
    is required to insert elements into these subsets; otherwise, the views will not contain
    any data. A valid cube name (pCube) is mandatory, as the process will abort otherwise.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates a processing view for the cube and\
    \ for specified dimensions of the cube. \n\n# Use case: Intended for development/prototyping\
    \ or in Production environment.\n# 1. Create a view with subsets of the same name that are\
    \ empty.\n\n# Note:\n# Creates empty subsets and assigns the empty subsets to the view.\
    \ \n# A subsequent process is required to insert elements into subsets otherwise the views\
    \ will not contain any data.\n# Naturally, a valid cube name (pCube) is mandatory otherwise\
    \ the process will abort.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n\n### Constants\
    \ ###\ncThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\ncMsgInfoLevel\
    \     =  'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%,\
    \ pSubset:%pSub%, pDim:%pDim%, pDelim:%pDelim%, pSuppressZero:%pSuppressZero%, pSuppressConsol:%pSuppressConsol%,\
    \ pSuppressRules:%pSuppressRules%.'; \ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\\
    s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset       =\
    \ cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\nsMessage          = '';\ncDimCubes \
    \        = '}Cubes';\ncDimDimensions    = '}Dimensions';\ncAll              = 'ALL';\ncTemp\
    \             = If( pTemp >= 1, 1, 0 );\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    \nnErrors = 0;\n\n# Validate cube\nIf( Trim( pCube ) @= '' );\n    sMessage    = 'No cube\
    \ specified.';\n    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate dimensions\nIf( Trim( pDim ) @= '' );\n    sMessage    = 'No\
    \ dimensions specified.';\n    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate suppression parameters\nIf( pSuppressZero\
    \ <> 0 & pSuppressZero <> 1 );\n    sMessage    = 'Invalid value for suppress zero parameter.';\n\
    \    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( pSuppressConsol <> 0 & pSuppressConsol <> 1 );\n    sMessage    =\
    \ 'Invalid value for suppress consol parameter.';\n    nErrors     = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pSuppressRules <> 0 & pSuppressRules\
    \ <> 1 );\n    sMessage    = 'Invalid value for suppress rules parameter.';\n    nErrors\
    \     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate view and subsets\nIf( pView @= '' & pSub @= '' );\n    ## Use standard view\
    \ name.\n    cView       = cTempSubset;\n    cSubset     = cView;\nElseIf( pView @<> ''\
    \ & pSub @= '' );\n    ## Use the nominated view name for the subset name.\n    cView  \
    \     = pView;\n    cSubset     = pView;\nElseIf( pView @= '' & pSub @<> '' );\n    ## Use\
    \ the nominated subset name for the view name.\n    cView       = pSub;\n    cSubset   \
    \  = pSub;\nElse;\n    cView   = pView;\n    cSubset = pSub;\nEndIf;\n\n\n# Validate delimiter\n\
    If( pDelim @= '' );\n    pDelim     = '&';\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Handle All cubes or a cubes list\nIf ( TRIM(\
    \ pCube ) @= cAll );\n  sMDX = Expand( '{TM1SUBSETALL([%cDimCubes%])}' );\nElse;\n  sCubeTokenizer\
    \ = TRIM( pCube );\n  sMDX = '';\n  ### Loop and tokenize Cube list\n  While ( sCubeTokenizer\
    \ @<> '' );\n    nPos = SCAN( pDelim, sCubeTokenizer );\n    If ( nPos = 0 );\n      nPos\
    \ = LONG( sCubeTokenizer ) + 1;\n    EndIf;\n    sSearchCube = TRIM( SUBST( sCubeTokenizer,\
    \ 1, nPos - 1 ) );\n    If ( SCAN( '*', sSearchCube ) <> 0 % SCAN( '?', sSearchCube ) <>\
    \ 0 );\n      If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimCubes%])},\
    \ '%sSearchCube%')}' );\n      Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimCubes%])},\
    \ '%sSearchCube%')}' );\n      EndIf;\n    Else;\n      If ( CubeExists( sSearchCube ) =\
    \ 0 );\n        sMessage = Expand( 'Cube: %sSearchCube% does not exist.' );\n        nErrors\
    \ = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n   \
    \     If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n     \
    \       ProcessBreak;\n        EndIf;\n      Else;\n        If( sMDX @= '' );\n        \
    \  sMDX = Expand( '{[%cDimCubes%].[%sSearchCube%]}' );\n        Else;\n          sMDX =\
    \ Expand( '%sMDX% + {[%cDimCubes%].[%sSearchCube%]}' );\n        EndIf;\n      EndIf;\n\
    \    EndIf;\n    ### Consume dimension and delimiter\n    sCubeTokenizer = TRIM( DELET(\
    \ sCubeTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX = Expand( '{%sMDX%}'\
    \ );\nEndIf;\n\nIf (SubsetExists( cDimCubes, cTempSubset ) = 1 );\n  SubsetDestroy( cDimCubes,\
    \ cTempSubset );\nEndIf;\nSubsetCreateByMDX( cTempSubset, sMDX, cDimCubes, 1 );\n\n### Handle\
    \ All dimensions or a dimension list\n### We must exclude hierarchies\nIf ( TRIM( pDim )\
    \ @= cAll );\n  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}' );\nElse;\n  sDimTokenizer = TRIM( pDim );\n  sMDX = '';\n  ### Loop and\
    \ tokenize dimension list\n  While ( sDimTokenizer @<> '' );\n    nPos = SCAN( pDelim, sDimTokenizer\
    \ );\n    If ( nPos = 0 );\n      nPos = LONG( sDimTokenizer ) + 1;\n    EndIf;\n    sSearchDim\
    \ = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n    If ( SCAN( ':', sSearchDim ) <> 0\
    \ );\n      sMessage    = Expand( 'Dimension: The process is not accepting hierarchies:\
    \ %sSearchDim%' );\n      nErrors     = nErrors + 1;\n      LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    ElseIf ( SCAN( '*', sSearchDim ) <> 0 % SCAN( '?', sSearchDim\
    \ ) <> 0 );\n      If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n  \
    \    Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n  \
    \    EndIf;\n    Else;\n      If ( DimensionExists( sSearchDim ) = 0 );\n        sMessage\
    \    = Expand( 'Dimension: %sSearchDim% does not exist.' );\n        nErrors     = nErrors\
    \ + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n       \
    \ EndIf;\n      Else;\n        If( sMDX @= '' );\n          sMDX = Expand( '{[%cDimDimensions%].[%sSearchDim%]}'\
    \ );\n        Else;\n          sMDX = Expand( '%sMDX% + {[%cDimDimensions%].[%sSearchDim%]}'\
    \ );\n        EndIf;\n      EndIf;\n    EndIf;\n    ### Consume dimension and delimiter\n\
    \    sDimTokenizer = TRIM( DELET( sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n\
    \  sMDX = Expand( '{%sMDX%}' );\nEndIf;\n\nIf (SubsetExists( cDimDimensions, cTempSubset\
    \ ) = 1 );\n  SubsetDestroy( cDimDimensions, cTempSubset );\nEndIf;\nSubsetCreateByMDX(\
    \ cTempSubset, sMDX, cDimDimensions, 1 );\n\n### Build Subsets and assign to View ###\n\
    nCube = 1;\nWhile ( nCube <= SubsetGetSize( cDimCubes, cTempSubset ) );\n  sCube = SubsetGetElementName(\
    \ cDimCubes, cTempSubset, nCube );\n  ### Build View ###\n  If( ViewExists( sCube, cView\
    \ ) = 1 );\n    ViewDestroy( sCube, cView );\n  EndIf;\n  nDim = 1;\n  sDim = TABDIM( sCube,\
    \ nDim );\n  While ( sDim @<> '' );\n   # filter selection has non-empty intersect with\
    \ current cube dimensions\n   #If ( SubsetElementExists( cDimDimensions, cTempSubset, sDim\
    \ ) = 1 ); - bug does not work\n   IF( SubsetElementGetIndex( cDimDimensions, cTempSubset,\
    \ sDim, 1 ) > 0 );\n      # create view if and only if there is at least one match with\
    \ dimensions\n      If( ViewExists( sCube, cView ) = 0 );\n        ViewCreate( sCube, cView,\
    \ cTemp );\n        ViewExtractSkipZeroesSet( sCube, cView, pSuppressZero );\n        ViewExtractSkipCalcsSet(\
    \ sCube, cView, pSuppressConsol );\n        ViewExtractSkipRuleValuesSet( sCube, cView,\
    \ pSuppressRules );\n      EndIf;\n      If ( SubsetExists ( sDim, cSubset ) = 1 );\n  \
    \      If ( SubsetGetSize( sDim, cSubset ) > 0 );\n          SubsetDeleteAllElements( sDim,\
    \ cSubset );\n        EndIf;\n      Else;\n        SubsetCreate( sDim, cSubset, cTemp );\n\
    \      EndIf;\n      ViewSubsetAssign( sCube, cView, sDim, cSubset );\n    EndIf;\n    nDim\
    \ = nDim + 1;\n    sDim = TABDIM( sCube, nDim );\n  End;\n  \n  # creating N level subset\
    \ for all dim not included in pDim for the cube\n  If(pSubN = 1);\n    nCountDimC = 1;\n\
    \    While( TabDim( sCube, nCountDimC ) @<> '' );\n    sDimC = TabDim( sCube, nCountDimC\
    \ );\n    If ( ViewExists( sCube, cView ) = 1 & SubsetElementGetIndex( cDimDimensions, cTempSubset,\
    \ sDimC, 1 ) = 0 );\n      If ( SubsetExists ( sDimC, cSubset ) = 1 );\n        If ( SubsetGetSize(\
    \ sDimC, cSubset ) > 0 );\n          SubsetDeleteAllElements( sDimC, cSubset );\n      \
    \  EndIf;\n      Else;\n        SubsetCreate( sDimC, cSubset, cTemp );\n      Endif;  \n\
    \      nElCount = DIMSIZ ( sDimC );\n      nElC = 1;\n      WHILE ( nElC <= nElCount );\n\
    \        sEl = DIMNM( sDimC, nElC );\n        IF(ElementLevel( sDimC, sDimC, sEl )= 0 );\n\
    \          SubsetElementInsert( sDimC, cSubset, sEl, 0 );\n        EndIf;\n        nElC\
    \ = nElC + 1;\n      END;\n      ViewSubsetAssign( sCube, cView, sDimC, cSubset );\n   \
    \ Endif;\n    nCountDimC = nCountDimC + 1;\n    End;\n  Endif;\n\n\n  nCube = nCube + 1;\n\
    End;\n\n\n### End Prolog ###\n\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created views and subsets for cube  %pCube%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Dieser IBM Turbo Integrator-Prozess löscht eine Ansicht und alle Teilmengen desselben
    Namens. Der Anwendungsfall umfasst zwei Hauptszenarien: Erstens wird er in Produktionsumgebungen
    im Epilog verwendet, um Ansichten und Teilmengen zu entfernen, die für die Verarbeitung
    genutzt werden. Zweitens dient er der manuellen Bereinigung von Ansichten und Teilmengen
    in Entwicklungs- oder Prototypenphasen. Bitte beachten Sie, dass Listen und Wildcards in
    diesem Prozess nicht unterstützt werden. Ein gültiger Würfelname (pCube) ist zwingend erforderlich,
    andernfalls wird der Prozess abgebrochen. Ebenso ist ein gültiger Ansichtsname (pView) erforderlich,
    um den Prozess fortzusetzen. Die Annahme zur Übereinstimmung basiert auf dem **Namen**.
    Teilmengen mit demselben Namen wie die Ansicht werden gelöscht, unabhängig davon, ob sie
    der Ansicht zugeordnet waren oder nicht. Für die Parameter gibt es drei Modi: Modus 0 löscht
    Ansichten und löscht Teilmengen **indirekt** über den Bedrock-Prozessaufruf. Sollte eine
    Teilmenge nicht gelöscht werden können, wird der Prozess mit einem geringfügigen Fehlerstatus
    fortgesetzt. Modus 1 löscht Ansichten und löscht Teilmengen **direkt** über die SubsetDestroy-Funktion.
    Scheitert das Löschen einer Teilmenge, wird der Prozess mit großem Fehlerstatus abgebrochen.
    Modus 2 löscht nur Ansichten und belässt Teilmengen unverändert.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a view and all subsets of the same\
    \ name.\n\n# Use case: \n# 1. In production environment used in Epilog to remove view &\
    \ subsets used for processing.\n# 2. In development/prototyping to manually clean up views\
    \ & subsets. \n\n# Note:\n# * Lists and wildcards are not supported in this process\n# *\
    \ A valid cube name pCube is mandatory otherwise the process will abort. \n# * A valid view\
    \ name pView is mandatory otherwise the process will abort.\n# * The matching assumption\
    \ is based on **name**. Subsets of the same name as the view will be deleted (whether they\
    \ were assigned to the view or not).\n# * pMode 0 = Delete views and **indirectly** delete\
    \ subsets via bedrock process call. If a subset cannot be deleted the process will continue\
    \ and exit with minor error status.\n# * pMode 1 = Delete views and **directly** delete\
    \ subsets via SubsetDestroy function. If a subset cannot be deleted the process will abort\
    \ with major error status.\n# * pMode 2 = Delete views only and leave subsets as is.\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncMsgInfoLevel     = 'INFO';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo         \
    \ = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%, pSub:%pSub%,\
    \ pMode:%pMode%.' ;  \ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset       = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\nsMessage          = '';\n\n## LogOutput parameters\nIF(\
    \ pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\n### Validate Paramters ##\nIF( pMode <> 0 & pMode <> 1\
    \ & pMode <> 2 );\n    sMessage = 'Invailid mode value provided %pMode%. Do not destroy\
    \ views or subsets.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nENDIF;\n\nIf( Trim( pCube ) @= '' );\n    sMessage    = 'No cube\
    \ specified.';\n    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );    \n    sMessage    = Expand( 'Invalid  cube\
    \ specified: %pCube%.' );\n    nErrors     = 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate pView \nIf( Trim( pView ) @= '' );\n    sMessage\
    \    = 'No view specified.';\n    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( ViewExists(pCube, pView ) = 0 ); \n    sMessage\
    \    = Expand('There is no view :%pView% in %pCube% cube.') ;\n    nErrors     = nErrors\
    \ + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElse;\n    cView \
    \      = Trim( pView );\nEndIf;\n\n# Validate psubset\nIf( pSub @= '' );\n    cSubset  \
    \   = Trim( pView );\nElse;\n    cSubset     = Trim( pSub );\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors     > 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Clean up view\nViewDestroy( pCube,\
    \ cView );\n\n## Clean up subsets\nIf( pMode       <= 1 );\n\n    nDimCount = 0;\n    i\
    \ = 1;\n    sDimName = TabDim( pCube, i );\n    While( sDimName @<> '' );\n        If( SubsetExists\
    \ ( sDimName, cSubset ) = 1 );\n            If( pMode = 0 );\n                # 'indirect'\
    \ deletion\n                 nRet = ExecuteProcess( '}bedrock.hier.sub.delete',\n      \
    \            'pStrictErrorHandling', pStrictErrorHandling,\n                \t'pLogOutput',\
    \ pLogOutput,\n                \t'pDim', sDimName,\n                \t'pHier','',\n    \
    \            \t'pSub', cSubset,\n                \t'pDelim', If( Scan( '&', cSubset ) =\
    \ 0, '&', ':' ),\n                \t'pMode', 0\n                );\n                If(\
    \ pLogOutput >= 1 & nRet <> ProcessExitNormal() );\n                    nErrors = nErrors\
    \ + 1;\n                    sMessage = 'Subset %cSubset% in dimension %sDimName% could not\
    \ be deleted. It may be used in another view.';\n                    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n                EndIf;\n            ElseIf( pMode = 1 );\n\
    \                # pMode=1, 'direct' deletion\n                SubsetDestroy( sDimName,\
    \ cSubset );\n            EndIf;\n        EndIf;\n        i = i + 1;\n        sDimName =\
    \ TabDim( pCube, i );\n    End;\n\nEndIf;\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted views and subsets for cube  %pCube%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'This IBM Turbo Integrator process deletes a view and all subsets of the same name.
    The use case includes two main scenarios: First, it is used in production environments in
    the epilog to remove views and subsets used for processing. Second, it is for manually cleaning
    up views and subsets during development or prototyping phases. Please note that lists and
    wildcards are not supported in this process. A valid cube name (pCube) is mandatory; otherwise,
    the process will abort. Similarly, a valid view name (pView) is required to proceed. The
    matching assumption is based on **name**. Subsets with the same name as the view will be
    deleted, regardless of whether they were assigned to the view or not. There are three modes
    for the parameters: Mode 0 deletes views and **indirectly** deletes subsets via bedrock
    process call. If a subset cannot be deleted, the process will continue and exit with a minor
    error status. Mode 1 deletes views and **directly** deletes subsets via the SubsetDestroy
    function. If a subset cannot be deleted, the process will abort with a major error status.
    Mode 2 deletes views only and leaves subsets unchanged.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a view and all subsets of the same\
    \ name.\n\n# Use case: \n# 1. In production environment used in Epilog to remove view &\
    \ subsets used for processing.\n# 2. In development/prototyping to manually clean up views\
    \ & subsets. \n\n# Note:\n# * Lists and wildcards are not supported in this process\n# *\
    \ A valid cube name pCube is mandatory otherwise the process will abort. \n# * A valid view\
    \ name pView is mandatory otherwise the process will abort.\n# * The matching assumption\
    \ is based on **name**. Subsets of the same name as the view will be deleted (whether they\
    \ were assigned to the view or not).\n# * pMode 0 = Delete views and **indirectly** delete\
    \ subsets via bedrock process call. If a subset cannot be deleted the process will continue\
    \ and exit with minor error status.\n# * pMode 1 = Delete views and **directly** delete\
    \ subsets via SubsetDestroy function. If a subset cannot be deleted the process will abort\
    \ with major error status.\n# * pMode 2 = Delete views only and leave subsets as is.\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncMsgInfoLevel     = 'INFO';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo         \
    \ = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%, pSub:%pSub%,\
    \ pMode:%pMode%.' ;  \ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset       = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\nsMessage          = '';\n\n## LogOutput parameters\nIF(\
    \ pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\n### Validate Paramters ##\nIF( pMode <> 0 & pMode <> 1\
    \ & pMode <> 2 );\n    sMessage = 'Invailid mode value provided %pMode%. Do not destroy\
    \ views or subsets.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nENDIF;\n\nIf( Trim( pCube ) @= '' );\n    sMessage    = 'No cube\
    \ specified.';\n    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );    \n    sMessage    = Expand( 'Invalid  cube\
    \ specified: %pCube%.' );\n    nErrors     = 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate pView \nIf( Trim( pView ) @= '' );\n    sMessage\
    \    = 'No view specified.';\n    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( ViewExists(pCube, pView ) = 0 ); \n    sMessage\
    \    = Expand('There is no view :%pView% in %pCube% cube.') ;\n    nErrors     = nErrors\
    \ + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElse;\n    cView \
    \      = Trim( pView );\nEndIf;\n\n# Validate psubset\nIf( pSub @= '' );\n    cSubset  \
    \   = Trim( pView );\nElse;\n    cSubset     = Trim( pSub );\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors     > 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Clean up view\nViewDestroy( pCube,\
    \ cView );\n\n## Clean up subsets\nIf( pMode       <= 1 );\n\n    nDimCount = 0;\n    i\
    \ = 1;\n    sDimName = TabDim( pCube, i );\n    While( sDimName @<> '' );\n        If( SubsetExists\
    \ ( sDimName, cSubset ) = 1 );\n            If( pMode = 0 );\n                # 'indirect'\
    \ deletion\n                 nRet = ExecuteProcess( '}bedrock.hier.sub.delete',\n      \
    \            'pStrictErrorHandling', pStrictErrorHandling,\n                \t'pLogOutput',\
    \ pLogOutput,\n                \t'pDim', sDimName,\n                \t'pHier','',\n    \
    \            \t'pSub', cSubset,\n                \t'pDelim', If( Scan( '&', cSubset ) =\
    \ 0, '&', ':' ),\n                \t'pMode', 0\n                );\n                If(\
    \ pLogOutput >= 1 & nRet <> ProcessExitNormal() );\n                    nErrors = nErrors\
    \ + 1;\n                    sMessage = 'Subset %cSubset% in dimension %sDimName% could not\
    \ be deleted. It may be used in another view.';\n                    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n                EndIf;\n            ElseIf( pMode = 1 );\n\
    \                # pMode=1, 'direct' deletion\n                SubsetDestroy( sDimName,\
    \ cSubset );\n            EndIf;\n        EndIf;\n        i = i + 1;\n        sDimName =\
    \ TabDim( pCube, i );\n    End;\n\nEndIf;\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted views and subsets for cube  %pCube%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Erstellen Sie einen IBM Turbo Integrator Prozess, der in der Lage ist, ein oder
    mehrere Attribute in eine oder mehrere spezifizierte Dimensionen einzufügen. Dieser Prozess
    ist hauptsächlich für die Entwicklung oder Prototyping vorgesehen. Ihre Aufgabe ist es,
    einen Prozess zu generieren, der mehrere Dimensionen-Attribute hinzufügt. Beachten Sie,
    dass durch Trennzeichen getrennte Listen und/oder Platzhalter (*) für die Parameter pDim
    und pAttr akzeptabel sind. Es ist jedoch zwingend erforderlich, dass gültige Dimensionsnamen
    (pDim) vorhanden sind, da der Prozess sonst abgebrochen wird. Zu den bekannten Einschränkungen
    gehört, dass dieser Prozess mehrere Attribute zu mehreren Dimensionen hinzufügen kann, jedoch
    nur für einen einzigen Attributtyp.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can insert one or more attributes in one\
    \ or more specified dimensions. \n\n# Use case: Intended for development/prototyping.\n\
    # 1/ Add multiple dimension attributes.\n\n# Note:\n# Delimited lists and/or wild card(*)\
    \ are acceptable for pDim & pAttr.\n# Naturally, valid dimension name(s) (pDim) are mandatory\
    \ otherwise the process will abort.\n# Known limitation: This process can insert multiple\
    \ attributes to multiple dimensions but only for a single attribute type.\n#EndRegion @DOC\n\
    \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'User:%cUserName% Process:%cThisProcName% run\
    \ with parameters pDim:%pDim%, pPrevAttr:%pPrevAttr%, pAttr:%pAttr%, pAttrType:%pAttrType%,\
    \ pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# Validate\
    \ dimension\nIf( Trim( pDim ) @= '' );\n    nErrors         = 1;\n    sMessage        =\
    \ 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndIf;\n\n# Validate attribute\nIF( Trim( pAttr ) @= '' );\n    nErrors         =\
    \ 1;\n    sMessage        = 'No attribute specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate attribute type\npAttrType           = Upper(\
    \ SubSt( pAttrType, 1, 1 ) );\nIf( pAttrType @<> 'A' & pAttrType @<> 'S' & pAttrType @<>\
    \ 'N' );\n    nErrors         = 1;\n    sMessage        = 'Invalid attribute type specified:\
    \ ' | pAttrType | '. Defaulted to String type';\n    LogOutput( 'INFO', Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate previous attribute\nIf( DimIx( '}ElementAttributes_' | pDim,\
    \ pPrevAttr ) = 0 % pPrevAttr @= pAttr );\n    pPrevAttr       = '';\nEndIf;\n\n# If blank\
    \ delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim         \
    \ = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop\
    \ through dimensions in pDim and attributes in pAttr\nsDims               = pDim;\nnDimDelimiterIndex\
    \  = 1;\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension\
    \ > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex =\
    \ 0 );\n        sDim        = sDims;\n    Else;\n        sDim        = Trim( SubSt( sDims,\
    \ 1, nDimDelimiterIndex - 1 ) );\n        sDims       = Trim( Subst( sDims, nDimDelimiterIndex\
    \ + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n    # Check if sDim has wildcard\n\
    \    If( Scan( '*', sDim ) = 0);\n        # Validate dimension\n        If( DimensionExists(sDim)\
    \ = 0 );\n            nErrors = 1;\n            sMessage = Expand( 'Dimension '%sDim%' does\
    \ not exist.' );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n      \
    \      If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n            Else;\n\
    \                ProcessBreak;\n            EndIf;\n        Else;\n            # Loop through\
    \ attributes in pAttr  \n            sAttrs = pAttr;\n            nDelimiterIndex = 1;\n\
    \            sAttrDim = '}ElementAttributes_'|sDim ;\n            While( nDelimiterIndex\
    \ <> 0 );\n    \n                nDelimiterIndex = Scan( pDelim, sAttrs );\n           \
    \     If( nDelimiterIndex = 0 );\n                    sAttr   = sAttrs;\n              \
    \  Else;\n                    sAttr   = Trim( SubSt( sAttrs, 1, nDelimiterIndex - 1 ) );\n\
    \                    sAttrs  = Trim( Subst( sAttrs, nDelimiterIndex + Long(pDelim), Long(\
    \ sAttrs ) ) );\n                EndIf;\n    \n                # Check to see if attribute\
    \ already exists.\n                If( Dimix( sAttrDim , sAttr ) = 1 );\n              \
    \      nErrors = 1;\n                    sMessage = 'Attribute ' | sAttr | ' already exist\
    \ in dimension ' | sDim;\n                    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n                Else;\n                    AttrInsert( sDim , pPrevAttr , sAttr\
    \ , pAttrType ) ;\n                    If( pLogOutput = 1 );\n                        LogOutput(\
    \ 'INFO', Expand( 'Attribute '%sAttr%' added to dimension %sDim%.' ) );\n              \
    \      EndIf;\n                Endif;\n            End;\n        EndIf;    \n    Else;\n\
    \        # Create subset using Wildcard to loop through dimensions in pDim with wildcard\n\
    \        sDimExp = '''|sDim|''';\n        sMdx = '{TM1FILTERBYPATTERN( EXCEPT ( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp\
    \ | ')}';\n        If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n            # If\
    \ a delimited list of attr names includes wildcards then we may have to re-use the subset\
    \ multiple times\n            SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n        Else;\n\
    \            # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, '}Dimensions' , 1 );\n        EndIf;\n        \n        # Loop through\
    \ dimensions in subset created based on wildcard\n        nCountDim = SubsetGetSize( '}Dimensions'\
    \ , cTempSub );\n        While( nCountDim >= 1 );\n            \n            sDim = SubsetGetElementName(\
    \ '}Dimensions' , cTempSub, nCountDim );\n            # Validate dimension name\n      \
    \      If( DimensionExists(sDim) = 0 );\n                nErrors = 1;\n                sMessage\
    \ = Expand( 'Dimension '%sDim%' does not exist.' );\n                LogOutput( 'ERROR',\
    \ Expand( cMsgErrorContent ) );\n                If( pStrictErrorHandling = 1 ); \n    \
    \                ProcessQuit; \n                Else;\n                    ProcessBreak;\n\
    \                EndIf;\n            Else;\n            # Loop through attributes in pAttr\
    \ \n                sAttrs = pAttr;\n                nDelimiterIndex = 1;\n            \
    \    sAttrDim = '}ElementAttributes_'|sDim ;\n                While( nDelimiterIndex <>\
    \ 0 );\n    \n                    nDelimiterIndex = Scan( pDelim, sAttrs );\n          \
    \          If( nDelimiterIndex = 0 );\n                        sAttr   = sAttrs;\n     \
    \               Else;\n                        sAttr   = Trim( SubSt( sAttrs, 1, nDelimiterIndex\
    \ - 1 ) );\n                        sAttrs  = Trim( Subst( sAttrs, nDelimiterIndex + Long(pDelim),\
    \ Long( sAttrs ) ) );\n                    EndIf;\n    \n                    # Check to\
    \ see if attribute already exists.\n                    If( Dimix( sAttrDim , sAttr ) =\
    \ 1 );\n                        nErrors = 1;\n                        sMessage = 'Attribute\
    \ ' | sAttr | ' already exist in dimension ' | sDim;\n                        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                    Else;\n           \
    \             AttrInsert( sDim , pPrevAttr , sAttr , pAttrType ) ;\n                   \
    \     If( pLogOutput = 1 );\n                            LogOutput( 'INFO', Expand( 'Attribute\
    \ '%sAttr%' added to dimension %sDim%.' ) );\n                        EndIf;\n         \
    \           Endif;\n                End; \n            EndIf;\n            \n          \
    \  nCountDim = nCountDim - 1;\n        End;\n    EndIf;\n    \n   \nEnd;\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created attribute %pAttr% in dimension %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Create an IBM Turbo Integrator process that is capable of inserting one or more
    attributes into one or more specified dimensions. This process is primarily intended for
    development or prototyping. Your task is to generate a process that adds multiple dimension
    attributes. Note that delimited lists and/or wild cards (*) are acceptable for the parameters
    pDim and pAttr. However, it is mandatory to have valid dimension names (pDim), otherwise,
    the process will abort. A known limitation is that this process can add multiple attributes
    to multiple dimensions, but only for a single attribute type.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can insert one or more attributes in one\
    \ or more specified dimensions. \n\n# Use case: Intended for development/prototyping.\n\
    # 1/ Add multiple dimension attributes.\n\n# Note:\n# Delimited lists and/or wild card(*)\
    \ are acceptable for pDim & pAttr.\n# Naturally, valid dimension name(s) (pDim) are mandatory\
    \ otherwise the process will abort.\n# Known limitation: This process can insert multiple\
    \ attributes to multiple dimensions but only for a single attribute type.\n#EndRegion @DOC\n\
    \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'User:%cUserName% Process:%cThisProcName% run\
    \ with parameters pDim:%pDim%, pPrevAttr:%pPrevAttr%, pAttr:%pAttr%, pAttrType:%pAttrType%,\
    \ pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# Validate\
    \ dimension\nIf( Trim( pDim ) @= '' );\n    nErrors         = 1;\n    sMessage        =\
    \ 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndIf;\n\n# Validate attribute\nIF( Trim( pAttr ) @= '' );\n    nErrors         =\
    \ 1;\n    sMessage        = 'No attribute specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate attribute type\npAttrType           = Upper(\
    \ SubSt( pAttrType, 1, 1 ) );\nIf( pAttrType @<> 'A' & pAttrType @<> 'S' & pAttrType @<>\
    \ 'N' );\n    nErrors         = 1;\n    sMessage        = 'Invalid attribute type specified:\
    \ ' | pAttrType | '. Defaulted to String type';\n    LogOutput( 'INFO', Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate previous attribute\nIf( DimIx( '}ElementAttributes_' | pDim,\
    \ pPrevAttr ) = 0 % pPrevAttr @= pAttr );\n    pPrevAttr       = '';\nEndIf;\n\n# If blank\
    \ delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim         \
    \ = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop\
    \ through dimensions in pDim and attributes in pAttr\nsDims               = pDim;\nnDimDelimiterIndex\
    \  = 1;\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension\
    \ > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex =\
    \ 0 );\n        sDim        = sDims;\n    Else;\n        sDim        = Trim( SubSt( sDims,\
    \ 1, nDimDelimiterIndex - 1 ) );\n        sDims       = Trim( Subst( sDims, nDimDelimiterIndex\
    \ + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n    # Check if sDim has wildcard\n\
    \    If( Scan( '*', sDim ) = 0);\n        # Validate dimension\n        If( DimensionExists(sDim)\
    \ = 0 );\n            nErrors = 1;\n            sMessage = Expand( 'Dimension '%sDim%' does\
    \ not exist.' );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n      \
    \      If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n            Else;\n\
    \                ProcessBreak;\n            EndIf;\n        Else;\n            # Loop through\
    \ attributes in pAttr  \n            sAttrs = pAttr;\n            nDelimiterIndex = 1;\n\
    \            sAttrDim = '}ElementAttributes_'|sDim ;\n            While( nDelimiterIndex\
    \ <> 0 );\n    \n                nDelimiterIndex = Scan( pDelim, sAttrs );\n           \
    \     If( nDelimiterIndex = 0 );\n                    sAttr   = sAttrs;\n              \
    \  Else;\n                    sAttr   = Trim( SubSt( sAttrs, 1, nDelimiterIndex - 1 ) );\n\
    \                    sAttrs  = Trim( Subst( sAttrs, nDelimiterIndex + Long(pDelim), Long(\
    \ sAttrs ) ) );\n                EndIf;\n    \n                # Check to see if attribute\
    \ already exists.\n                If( Dimix( sAttrDim , sAttr ) = 1 );\n              \
    \      nErrors = 1;\n                    sMessage = 'Attribute ' | sAttr | ' already exist\
    \ in dimension ' | sDim;\n                    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n                Else;\n                    AttrInsert( sDim , pPrevAttr , sAttr\
    \ , pAttrType ) ;\n                    If( pLogOutput = 1 );\n                        LogOutput(\
    \ 'INFO', Expand( 'Attribute '%sAttr%' added to dimension %sDim%.' ) );\n              \
    \      EndIf;\n                Endif;\n            End;\n        EndIf;    \n    Else;\n\
    \        # Create subset using Wildcard to loop through dimensions in pDim with wildcard\n\
    \        sDimExp = '''|sDim|''';\n        sMdx = '{TM1FILTERBYPATTERN( EXCEPT ( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp\
    \ | ')}';\n        If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n            # If\
    \ a delimited list of attr names includes wildcards then we may have to re-use the subset\
    \ multiple times\n            SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n        Else;\n\
    \            # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, '}Dimensions' , 1 );\n        EndIf;\n        \n        # Loop through\
    \ dimensions in subset created based on wildcard\n        nCountDim = SubsetGetSize( '}Dimensions'\
    \ , cTempSub );\n        While( nCountDim >= 1 );\n            \n            sDim = SubsetGetElementName(\
    \ '}Dimensions' , cTempSub, nCountDim );\n            # Validate dimension name\n      \
    \      If( DimensionExists(sDim) = 0 );\n                nErrors = 1;\n                sMessage\
    \ = Expand( 'Dimension '%sDim%' does not exist.' );\n                LogOutput( 'ERROR',\
    \ Expand( cMsgErrorContent ) );\n                If( pStrictErrorHandling = 1 ); \n    \
    \                ProcessQuit; \n                Else;\n                    ProcessBreak;\n\
    \                EndIf;\n            Else;\n            # Loop through attributes in pAttr\
    \ \n                sAttrs = pAttr;\n                nDelimiterIndex = 1;\n            \
    \    sAttrDim = '}ElementAttributes_'|sDim ;\n                While( nDelimiterIndex <>\
    \ 0 );\n    \n                    nDelimiterIndex = Scan( pDelim, sAttrs );\n          \
    \          If( nDelimiterIndex = 0 );\n                        sAttr   = sAttrs;\n     \
    \               Else;\n                        sAttr   = Trim( SubSt( sAttrs, 1, nDelimiterIndex\
    \ - 1 ) );\n                        sAttrs  = Trim( Subst( sAttrs, nDelimiterIndex + Long(pDelim),\
    \ Long( sAttrs ) ) );\n                    EndIf;\n    \n                    # Check to\
    \ see if attribute already exists.\n                    If( Dimix( sAttrDim , sAttr ) =\
    \ 1 );\n                        nErrors = 1;\n                        sMessage = 'Attribute\
    \ ' | sAttr | ' already exist in dimension ' | sDim;\n                        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                    Else;\n           \
    \             AttrInsert( sDim , pPrevAttr , sAttr , pAttrType ) ;\n                   \
    \     If( pLogOutput = 1 );\n                            LogOutput( 'INFO', Expand( 'Attribute\
    \ '%sAttr%' added to dimension %sDim%.' ) );\n                        EndIf;\n         \
    \           Endif;\n                End; \n            EndIf;\n            \n          \
    \  nCountDim = nCountDim - 1;\n        End;\n    EndIf;\n    \n   \nEnd;\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created attribute %pAttr% in dimension %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle eine Prompt für einen IBM Turbo Integrator Prozess, der Attribute einer
    Dimension aus einer Datei erstellt. Der Prozess soll insbesondere für die Entwicklung oder
    das Prototyping genutzt werden und soll verschiedene Attributtypen hinzufügen können. Beachte,
    dass das Dateiformat dem einer Dimensionsexportdatei entsprechen muss, die auf eine }ElementsAttributes
    Dimension angewendet wird. Es ist zwingend erforderlich, einen gültigen Dimensionsnamen
    (pDim) sowie einen gültigen Pfad (pSrcDir) und Dateinamen (pSrcFile) anzugeben, da der Prozess
    sonst abgebrochen wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create Attributes of the dimension from\
    \ a file.\n\n# Use case: Intended for development/prototyping. \n#1/ Add multiple dimension\
    \ attributes of different types.\n\n# Note:\n# The file format is as per the dimension export\
    \ file applied to an }ElementsAttributes dimension.\n# Naturally, a valid diension name\
    \ (pDim) is mandatory otherwise the process will abort.\n# Also, valid path (pSrcDir) &\
    \ file name (pSrcFile) are mandatory otherwise the process will abort.\n#EndRegion @DOC\n\
    \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pSrcDir:%pSrcDir%, pSrcFile:%pSrcFile%, pTitleRows:%pTitleRows%,\
    \ pDelim:%pDelim%, pQuote:%pQuote%.'; \ncLenASCIICode = 3;\n\npDelimiter        = TRIM(pDelim);\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\nnMetaDataCount = 0;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\
    \n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n\
    \  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory )\
    \ > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\n\
    EndIf;\n\n# Validate source dir\nIf(Trim( pSrcDir ) @= '' );\n    pSrcDir = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @= sOSDelim );\n    pSrcDir = SubSt( pSrcDir,\
    \ 1, Long( pSrcDir ) -1 );\nEndIf;\nIf( FileExists( pSrcDir ) = 0 );\n    nErrors = 1;\n\
    \    sMessage = 'Invalid source directory specified: folder does not exist.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npSrcDir\
    \ = pSrcDir | sOSDelim;\n\n# Validate source file\nsFile = pSrcDir | pSrcFile;\nIF ( Trim\
    \ ( pSrcFile ) @= '' );\n    nErrors = 1;\n    sMessage = 'No source file specified.';\n\
    \    DataSourceType = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nElseIf( FileExists( sFile ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid path\
    \ or source file specified: It does not exist.';\n    DataSourceType = 'NULL';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n\
    \    nErrors = 1;\n    sMessage = 'Dimension: ' | pDim | ' does not exist on server.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate file\
    \ delimiter & quote character\nIf( pDelimiter @= '' );\n    pDelimiter = ',';\nElse;\n \
    \   # If length of pDelimiter is exactly 3 chars and each of them is decimal digit, then\
    \ the pDelimiter is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pDelimiter) =\
    \ cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If(\
    \ CODE( pDelimiter, nChar )>=CODE( '0', 1 ) & CODE( pDelimiter, nChar )<=CODE( '9', 1 )\
    \ );\n          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n    \
    \    nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelimiter=CHAR(StringToNumber(\
    \ pDelimiter ));\n    Else;\n      pDelimiter = SubSt( Trim( pDelimiter ), 1, 1 );\n   \
    \ EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length\
    \ of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote is entered\
    \ as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar\
    \ = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n       \
    \ Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n\
    \    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n\
    \      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Datasource ###\n\nDataSourceType\
    \              = 'CHARACTERDELIMITED';\nDatasourceNameForServer     = sFile;\nDatasourceNameForClient\
    \     = sFile;\nDatasourceASCIIHeaderRecords= pTitleRows;\nDatasourceASCIIDelimiter    =\
    \ pDelimiter;\nDatasourceASCIIQuoteCharacter= pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n## Metatdata\
    \ Count\nnMetaDataCount = nMetaDataCount + 1;\n\n### Write data from source file to target\
    \ dimension ###\nsAttrType = Upper(SubSt( vAttrType, 1, 1 ));\n\n### Validate Record ###\n\
    IF(\n  sAttrType @= 'A' %\n  sAttrType @= 'N' %\n  sAttrType @= 'S' );\n  ## Continute\n\
    ELSE;\n  sMessage = 'Invalid attribute type.';\n     ITEMSKIP;\nENDIF;\n\nAttrInsert( pDim,\
    \ '', vAttr, sAttrType );\n\n### End Metadata ###\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created attributes in %pDim% from file\
    \ %pSrcFile%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop a prompt for an IBM Turbo Integrator process that creates attributes of
    a dimension from a file. The process should be intended for development or prototyping and
    be capable of adding multiple attribute types. Note that the file format must match that
    of a dimension export file applied to an }ElementsAttributes dimension. It is mandatory
    to provide a valid dimension name (pDim) and a valid path (pSrcDir) and file name (pSrcFile);
    otherwise, the process will terminate.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create Attributes of the dimension from\
    \ a file.\n\n# Use case: Intended for development/prototyping. \n#1/ Add multiple dimension\
    \ attributes of different types.\n\n# Note:\n# The file format is as per the dimension export\
    \ file applied to an }ElementsAttributes dimension.\n# Naturally, a valid diension name\
    \ (pDim) is mandatory otherwise the process will abort.\n# Also, valid path (pSrcDir) &\
    \ file name (pSrcFile) are mandatory otherwise the process will abort.\n#EndRegion @DOC\n\
    \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pSrcDir:%pSrcDir%, pSrcFile:%pSrcFile%, pTitleRows:%pTitleRows%,\
    \ pDelim:%pDelim%, pQuote:%pQuote%.'; \ncLenASCIICode = 3;\n\npDelimiter        = TRIM(pDelim);\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\nnMetaDataCount = 0;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\
    \n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n\
    \  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory )\
    \ > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\n\
    EndIf;\n\n# Validate source dir\nIf(Trim( pSrcDir ) @= '' );\n    pSrcDir = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @= sOSDelim );\n    pSrcDir = SubSt( pSrcDir,\
    \ 1, Long( pSrcDir ) -1 );\nEndIf;\nIf( FileExists( pSrcDir ) = 0 );\n    nErrors = 1;\n\
    \    sMessage = 'Invalid source directory specified: folder does not exist.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npSrcDir\
    \ = pSrcDir | sOSDelim;\n\n# Validate source file\nsFile = pSrcDir | pSrcFile;\nIF ( Trim\
    \ ( pSrcFile ) @= '' );\n    nErrors = 1;\n    sMessage = 'No source file specified.';\n\
    \    DataSourceType = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nElseIf( FileExists( sFile ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid path\
    \ or source file specified: It does not exist.';\n    DataSourceType = 'NULL';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n\
    \    nErrors = 1;\n    sMessage = 'Dimension: ' | pDim | ' does not exist on server.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate file\
    \ delimiter & quote character\nIf( pDelimiter @= '' );\n    pDelimiter = ',';\nElse;\n \
    \   # If length of pDelimiter is exactly 3 chars and each of them is decimal digit, then\
    \ the pDelimiter is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pDelimiter) =\
    \ cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If(\
    \ CODE( pDelimiter, nChar )>=CODE( '0', 1 ) & CODE( pDelimiter, nChar )<=CODE( '9', 1 )\
    \ );\n          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n    \
    \    nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelimiter=CHAR(StringToNumber(\
    \ pDelimiter ));\n    Else;\n      pDelimiter = SubSt( Trim( pDelimiter ), 1, 1 );\n   \
    \ EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length\
    \ of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote is entered\
    \ as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar\
    \ = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n       \
    \ Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n\
    \    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n\
    \      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Datasource ###\n\nDataSourceType\
    \              = 'CHARACTERDELIMITED';\nDatasourceNameForServer     = sFile;\nDatasourceNameForClient\
    \     = sFile;\nDatasourceASCIIHeaderRecords= pTitleRows;\nDatasourceASCIIDelimiter    =\
    \ pDelimiter;\nDatasourceASCIIQuoteCharacter= pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n## Metatdata\
    \ Count\nnMetaDataCount = nMetaDataCount + 1;\n\n### Write data from source file to target\
    \ dimension ###\nsAttrType = Upper(SubSt( vAttrType, 1, 1 ));\n\n### Validate Record ###\n\
    IF(\n  sAttrType @= 'A' %\n  sAttrType @= 'N' %\n  sAttrType @= 'S' );\n  ## Continute\n\
    ELSE;\n  sMessage = 'Invalid attribute type.';\n     ITEMSKIP;\nENDIF;\n\nAttrInsert( pDim,\
    \ '', vAttr, sAttrType );\n\n### End Metadata ###\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created attributes in %pDim% from file\
    \ %pSrcFile%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der die Werte des angegebenen Alias
    mit dem Hauptnamen für alle Elemente der Zieldimension vertauscht. Dieser Prozess ist ausschließlich
    für Entwicklungs- und Prototypisierungsszenarien gedacht und sollte **nicht in einer Produktionsumgebung
    verwendet werden**. Beachte, dass die Funktion SwapAliasWithPrincipalName **nicht unterstützt**
    für alternative Hierarchien ist. Wenn alternative Hierarchien für die Zieldimension existieren,
    wird der Prozess abgebrochen. Achtung: Verwende diesen Prozess mit Vorsicht, da die zugrundeliegende
    Funktion SwapAliasWithPrincipalName von IBM nie offiziell dokumentiert oder unterstützt
    wurde.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will swap the values of the nominated alias\
    \ with the principal name for all elements of the target dimension.\n#\n# Use case: Strictly\
    \ for development/prototyping scenarios. This process should **not be used** in a production\
    \ environment. \n# 1. Swap an alias with principal name \n#\n# Note:\n# The SwapAliasWithPrincipalName\
    \ function is **not supported** for alternate hierarchies. Therefore this process checks\
    \ for the \n# existance of alternate hierarches and if any exist for the target dimension\
    \ then the process will abort.\n#\n# Warning: \n# Use with care. This process works, however,\
    \ the underlying SwapAliasWithPrincipalName function  has never been officially \n# documented\
    \ or suported by IBM. \n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode = 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\\
    s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncDebugFile        =\
    \ GetProcessErrorFileDirectory | cThisProcName | '.' | cTimeStamp | '.' | cRandomInt ;\n\
    cCubeAttr         = '}ElementAttributes_' | pDim;\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\ncLogInfo\
    \          = '***Parameters for Process:%cThisProcName% for pDim:%pDim%, pAlias:%pAlias%.'\
    \ ;  \ncDim              = '}Dimensions';\ncSubset           = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt; \n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\n##\
    \ Validate dimension\nIF( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension\
    \ specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( DimensionExists(\
    \ pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate alias\nIf( Trim( pAlias\
    \ ) @= '' );\n  nErrors = 1;\n  sMessage = 'No alias specified';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( DimIx( cCubeAttr, pAlias ) = 0 );\n  nErrors =\
    \ 1;\n  sMessage = 'Alias: ' | pAlias | ' does not exist in dimension: ' | pDim;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nsElementType = DType( cCubeAttr,\
    \ pAlias );\nIf( sElementType @<> 'AA' );\n  nErrors = 1;\n  sMessage = 'Attribute: ' |\
    \ pAlias | ' is not a valid alias.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Swap\
    \ Dimension ###\nSwapAliasWithPrincipalName( pDim, pAlias, 0 );\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully swapped the principal element names of the %pDim% with the %pAlias% alias.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that swaps the values of the nominated
    alias with the principal name for all elements of the target dimension. This process is
    strictly for development and prototyping scenarios and should **not be used in a production
    environment**. Note that the SwapAliasWithPrincipalName function is **not supported** for
    alternate hierarchies. Therefore, if alternate hierarchies exist for the target dimension,
    the process will abort. Warning: Use this process with care, as the underlying SwapAliasWithPrincipalName
    function has never been officially documented or supported by IBM.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will swap the values of the nominated alias\
    \ with the principal name for all elements of the target dimension.\n#\n# Use case: Strictly\
    \ for development/prototyping scenarios. This process should **not be used** in a production\
    \ environment. \n# 1. Swap an alias with principal name \n#\n# Note:\n# The SwapAliasWithPrincipalName\
    \ function is **not supported** for alternate hierarchies. Therefore this process checks\
    \ for the \n# existance of alternate hierarches and if any exist for the target dimension\
    \ then the process will abort.\n#\n# Warning: \n# Use with care. This process works, however,\
    \ the underlying SwapAliasWithPrincipalName function  has never been officially \n# documented\
    \ or suported by IBM. \n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode = 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\\
    s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncDebugFile        =\
    \ GetProcessErrorFileDirectory | cThisProcName | '.' | cTimeStamp | '.' | cRandomInt ;\n\
    cCubeAttr         = '}ElementAttributes_' | pDim;\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\ncLogInfo\
    \          = '***Parameters for Process:%cThisProcName% for pDim:%pDim%, pAlias:%pAlias%.'\
    \ ;  \ncDim              = '}Dimensions';\ncSubset           = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt; \n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\n##\
    \ Validate dimension\nIF( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension\
    \ specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( DimensionExists(\
    \ pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate alias\nIf( Trim( pAlias\
    \ ) @= '' );\n  nErrors = 1;\n  sMessage = 'No alias specified';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( DimIx( cCubeAttr, pAlias ) = 0 );\n  nErrors =\
    \ 1;\n  sMessage = 'Alias: ' | pAlias | ' does not exist in dimension: ' | pDim;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nsElementType = DType( cCubeAttr,\
    \ pAlias );\nIf( sElementType @<> 'AA' );\n  nErrors = 1;\n  sMessage = 'Attribute: ' |\
    \ pAlias | ' is not a valid alias.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Swap\
    \ Dimension ###\nSwapAliasWithPrincipalName( pDim, pAlias, 0 );\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully swapped the principal element names of the %pDim% with the %pAlias% alias.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Beschreibe einen IBM Turbo Integrator Prozess, der eine Quell-Dimension und alle
    ihre Hierarchien klonen kann. Dieser Prozess ist für die Entwicklung und das Prototyping
    gedacht, insbesondere um eine Dimension mit ihren Hierarchien für Testzwecke zu replizieren.
    Beachte, dass wenn die Ziel-Dimension oder Hierarchie bereits existiert, diese überschrieben
    wird. Es ist zwingend erforderlich, einen gültigen Namen für die Quell-Dimension (pSrcDim)
    anzugeben, da der Prozess andernfalls abgebrochen wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can clone a source dimension and all the\
    \ Hierarchies.\n\n# Use case: Intended for development/prototyping.\n# 1/ Replicate a dimension\
    \ with it's hierarchies for testing.\n\n# Note:\n# If the target dimension:hierarchy already\
    \ exists then it will be overwritten.\n# Naturally, a valid source dimension name (pSrcDim)\
    \ is mandatory otherwise the process will abort.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncSubset           = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName%\
    \ : %sMessage% : %cUserName%';\ncMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName%\
    \ Message:%sMessage%';\ncLogInfo          = '***Parameters for Process:%cThisProcName% for\
    \ pSrcDim:%pSrcDim%, pTgtDim:%pTgtDim%, pHier:%pHier%, pAttr:%pAttr%, pUnwind:%pUnwind%,\
    \ pDelim:%pDelim%.';\ncLangDim          = '}Cultures';\nnNumLang          = DimSiz( cLangDim\
    \ );\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*', pSrcDim\
    \ )=0 &  Scan( '?', pSrcDim )=0 & Scan( pDelim, pSrcDim )=0 & Scan( ':', pSrcDim ) > 0 &\
    \ pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error\
    \ by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pSrcDim, Scan(\
    \ ':', pSrcDim ) + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan(\
    \ ':', pSrcDim ) - 1 );\nEndIf;\n\n## Validate dimension\nIF( Trim( pSrcDim ) @= '' );\n\
    \  nErrors = 1;\n  sMessage = 'No source dimension specified.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIF( DimensionExists( pSrcDim ) = 0 );\n  nErrors =\
    \ 1;\n  sMessage = 'Invalid source dimension: ' | pSrcDim;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pTgtDim @= '' % pTgtDim @= pSrcDim );\n \
    \ pTgtDim = pSrcDim | '_Clone';\nEndIf;\n\n# Validate hierarchy\nIF( Scan( '*', pSrcDim\
    \ )=0 &  Scan( '?', pSrcDim )=0 & Scan( pDelim, pSrcDim )=0 & pHier @= '');\n    pHier =\
    \ pSrcDim;\nElseIf( Scan( '*', pHier )=0 &  Scan( '?', pHier )=0 & Scan( pDelim, pHier )=0\
    \ & pHier @<> '' & HierarchyExists(pSrcDim, pHier) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid dimension hierarchy: ' | pHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n\nIf( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards\
    \ are allowed, this is managed inside the code below\nEndIf;\n\n## Default delimiter\nIf(\
    \ pDelim     @= '' );\n    pDelim     = '&';\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create target dimension ###\n\nIf(DimensionExists(\
    \ pTgtDim ) = 0 );\n    DimensionCreate( pTgtDim );\nElse;\n    IF(pUnwind = 1 );\n    \
    \   nRet = ExecuteProcess('}bedrock.hier.unwind',\n        'pLogOutput', pLogOutput,\n \
    \       'pStrictErrorHandling', pStrictErrorHandling,\n        'pDim', pTgtDim,\n      \
    \  'pHier', pTgtDim,\n        'pConsol', '*',\n        'pRecursive', 1\n        );\n   \
    \ ELSEIF(pUnwind = 2 );\n      # Do nothing;\n    ELSE;\n      DimensionDeleteAllElements(\
    \ pTgtDim );\n    EndIf;\nEndIf;\n\n### Set the target Sort Order ###\nsSortElementsType\
    \     = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTELEMENTSTYPE');\nsSortElementsSense\
    \    = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTELEMENTSSENSE');\nsSortComponentsType\
    \   = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTCOMPONENTSTYPE');\nsSortComponentsSense\
    \  = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTCOMPONENTSSENSE');\n\nDimensionSortOrder(\
    \ pTgtDim, sSortComponentsType, sSortComponentsSense, sSortElementsType , sSortElementsSense);\n\
    \n\nnSourceDimSize = DIMSIZ( pSrcDim );\nnIndex = 1;\nWHILE( nIndex <= nSourceDimSize );\n\
    \  sElName = DIMNM( pSrcDim, nIndex);\n  sElType = DTYPE( pSrcDim, sElName);\n  \n    DimensionElementInsert(\
    \ pTgtDim, '', sElName, sElType );\n\n  nIndex = nIndex + 1;\nEND;\n\n### Assign Data Source\
    \ ###\nDatasourceNameForServer   = pSrcDim;\nDatasourceNameForClient   = pSrcDim;\nDataSourceType\
    \            = 'SUBSET';\nDatasourceDimensionSubset = 'ALL';\n\n\n### Replicate Attributes\
    \ ###\n# Note: DType on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\
    sAttrDim        = '}ElementAttributes_' | pSrcDim;\nsAttrLoc        = '}LocalizedElementAttributes_'\
    \ | pSrcDim;\nsAttrTargetDim  = '}ElementAttributes_' | pTgtDim;\nsAttrLocTarget  = '}LocalizedElementAttributes_'\
    \ | pTgtDim;\n\nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n  nNumAttrs = DimSiz(\
    \ sAttrDim );\n  nCount = 1;\n  While( nCount <= nNumAttrs );\n    sAttrName = DimNm( sAttrDim,\
    \ nCount );\n    sAttCheck = SubSt( DTYPE( sAttrDim, sAttrName ), 1, 1 );\n    IF (sAttCheck\
    \ @= 'A');\n    sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ), 2, 1 );\n    Else;\n  \
    \  sAttrType = sAttcheck;\n    EndIf; \n      \n      If ( DimensionExists( sAttrTargetDim\
    \ ) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n       ElseIF(DimIx(sAttrTargetDim,\
    \ sAttrName) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n      Endif;\n\
    \        \n    nCount = nCount + 1;\n  End;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Check for\
    \ errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n    \
    \  ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Add Elements to\
    \ target dimension ###\n\nsElType = DType( pSrcDim, vEle );\nIF( sElType @= 'C' & ElCompN(\
    \ pSrcDim, vEle ) > 0 );\n    nChildren = ElCompN( pSrcDim, vEle );\n    nCount = 1;\n \
    \   While( nCount <= nChildren );\n      sChildElement = ElComp( pSrcDim, vEle, nCount );\n\
    \      sChildWeight = ElWeight( pSrcDim, vEle, sChildElement );\n      DimensionElementComponentAdd(\
    \ pTgtDim, vEle, sChildElement, sChildWeight );\n      nCount = nCount + 1;\n    End;\n\
    EndIf;\n\n### End MetaData ###\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Check for errors in prolog ###\n\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Replicate Attributes ###\n# Note: DTYPE on Attr dim returns 'AS',\
    \ 'AN' or 'AA' need to strip off leading 'A'\n\nIf( pAttr = 1 & DimensionExists( sAttrDim\
    \ ) = 1 );\n\n    nAttr = 1;\n    While( nAttr <= nNumAttrs );\n        sAttrName = DimNm(\
    \ sAttrDim, nAttr );\n        sAttCheck = SubSt( DTYPE( sAttrDim, sAttrName ), 1, 1 );\n\
    \        IF (sAttCheck @= 'A');\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ),\
    \ 2, 1 );\n        Else;\n        sAttrType = sAttcheck;\n        sMessage = pSrcDim | '\
    \ dimension contains invalid attribute - ' | sAttrName ;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 );\n          ItemReject(Expand(\
    \ cMsgErrorContent ));\n        EndIf;  \n        EndIf;\n        If( CellIsUpdateable(\
    \ sAttrTargetDim, vEle, sAttrName ) = 1 );\n            If( sAttrType @= 'S' % sAttrType\
    \ @= 'A' );\n                #sAttrVal = AttrS( pSrcDim, vEle, sAttrName );\n          \
    \      sAttrVal = CellgetS('}ElementAttributes_'| pSrcDim, vEle, sAttrName);\n         \
    \       If( sAttrVal @<> '' );\n                    If( sAttrType @= 'A' );\n          \
    \              AttrPutS( sAttrVal, pTgtDim, vEle, sAttrName, 1 );\n                    Else;\n\
    \                        AttrPutS( sAttrVal, pTgtDim, vEle, sAttrName );\n             \
    \       EndIf;\n                EndIf;\n            Else;\n                #nAttrVal = AttrN(\
    \ pSrcDim, vEle, sAttrName );\n                nAttrVal = CellgetN('}ElementAttributes_'|\
    \ pSrcDim, vEle, sAttrName);\n                If( nAttrVal <> 0 );\n                   \
    \ AttrPutN( nAttrVal, pTgtDim, vEle, sAttrName );\n                EndIf;\n            EndIf;\n\
    \        EndIf;\n        # check for localized attributes\n        If( CubeExists( sAttrLoc\
    \ ) = 1 );\n            nLang = 1;\n            While( nLang <= nNumLang );\n          \
    \      sLang       = DimNm( cLangDim, nLang );\n                If( sAttrType @= 'A' % sAttrType\
    \ @= 'S' );\n                    sAttrVal    = AttrS( pSrcDim, vEle, sAttrName );\n    \
    \                sAttrValLoc = AttrSL( pSrcDim, vEle, sAttrName, sLang );\n            \
    \        If( sAttrValLoc @= sAttrVal ); sAttrValLoc = ''; EndIf;\n                Else;\n\
    \                    nAttrVal    = AttrN( pSrcDim, vEle, sAttrName );\n                \
    \    nAttrValLoc = AttrNL( pSrcDim, vEle, sAttrName, sLang );\n                EndIf;\n\
    \                If( CubeExists( sAttrLocTarget ) = 0 );\n                    If( sAttrType\
    \ @= 'A' );\n                        AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName, sLang,\
    \ 1 );\n                    ElseIf( sAttrType @= 'N' );\n                        If( nAttrValLoc\
    \ <> nAttrVal );\n                            AttrPutN( nAttrValLoc, pTgtDim, vEle, sAttrName,\
    \ sLang );\n                        EndIf;\n                    Else;\n                \
    \        AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\n                   \
    \ EndIf;\n                ElseIf( CubeExists( sAttrLocTarget ) = 1 );\n                \
    \    If( CellIsUpdateable( sAttrLocTarget, vEle, sLang, sAttrName ) = 1 );\n           \
    \             If( sAttrType @= 'A' );\n                            AttrPutS( sAttrValLoc,\
    \ pTgtDim, vEle, sAttrName, sLang, 1 );\n                        ElseIf( sAttrType @= 'N'\
    \ );\n                            If( nAttrValLoc <> nAttrVal );\n                     \
    \           AttrPutN( nAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\n                \
    \            EndIf;\n                        Else;\n                            AttrPutS(\
    \ sAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\n                        EndIf;\n    \
    \                EndIf;\n                EndIf;\n                nLang   = nLang + 1;\n\
    \            End;\n        EndIf;\n        nAttr = nAttr + 1;\n    End;\n\nEndIf;\n\n###\
    \ End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#################################################################################################\
    \ \n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock\
    \ Ver 4.0.0~~##\n#################################################################################################\
    \ \n\n\n### Set the target Sort Order ###\n  CELLPUTS( sSortElementsType, '}DimensionProperties',\
    \ pTgtDim, 'SORTELEMENTSTYPE');\n  CELLPUTS( sSortElementsSense, '}DimensionProperties',\
    \ pTgtDim, 'SORTELEMENTSSENSE');\n  CELLPUTS( sSortComponentsType, '}DimensionProperties',\
    \ pTgtDim, 'SORTCOMPONENTSTYPE');\n  CELLPUTS( sSortComponentsSense, '}DimensionProperties',\
    \ pTgtDim, 'SORTCOMPONENTSSENSE');\n\n### Destroy Source Subset ###\n\n  If( SubsetExists(\
    \ pSrcDim, cSubset ) = 1 );\n    SubsetDestroy( pSrcDim, cSubset );\n  EndIf;\n\n##Clone\
    \ all the Hierarchies except default hierarchy & Leaves\nIf( pHier @= '*' );\n    sDim =\
    \ pSrcDim;\n    sHierDim = '}Hierarchies_' | sDim;\n    sTargetHierarchy = '';\n    nMax\
    \ = DimSiz( sHierDim );\n    nCtr = 1;\n    While( nCtr <= nMax );\n        sEle = DimNm(\
    \ sHierDim, nCtr );\n        nElength = Long(sEle);\n        nElestart  = 0;\n        nElestart\
    \ = SCAN(':', sEle) + 1;\n        If(nElestart > 1);\n          vSourceHierarchy = SUBST(sEle,nElestart,nElength);\n\
    \         If ( vSourceHierarchy @<> 'Leaves');\n             nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n\
    \               'pLogOutput', pLogOutput,\n               'pStrictErrorHandling', pStrictErrorHandling,\n\
    \               'pSrcDim', sDim,\n               'pSrcHier', vSourceHierarchy,\n       \
    \        'pTgtDim', pTgtDim,\n               'pTgtHier', vSourceHierarchy,\n           \
    \    'pAttr', pAttr,\n               'pUnwind',pUnwind\n               );\n         Endif;\n\
    \         sTargetHierarchy = sTargetHierarchy |':'|vSourceHierarchy;\n        Endif;\n \
    \       nCtr = nCtr + 1;\n    End;\n### Just one hierarchy specified in parameter\nElseIf(\
    \ Scan( '*', pHier )=0 &  Scan( '?', pHier )=0 & Scan( pDelim, pHier )=0 & Trim( pHier )\
    \ @<> '' );\n    sDim = pSrcDim;\n    sHierDim = '}Hierarchies_' | sDim;\n    sCurrHier\
    \ = pHier;\n    sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier)\
    \ );\n    # Validate hierarchy name in sHierDim\n    If( Dimix( sHierDim , sDim |':'| sCurrHier\
    \ ) = 0 );\n        sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the\
    \ '%sDim%' dimension.');\n        LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n   \
    \ ElseIf( sCurrHierName @= 'Leaves' );\n        sMessage = 'Invalid  Hierarchy: ' | sCurrHier\
    \ | ' will be skipped....';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    ElseIf( sCurrHierName @<> sDim );\n      If( pLogOutput = 1 );\n        sMessage\
    \ = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%' being processed....' );\n\
    \        LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n      EndIf;\n      nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n\
    \       'pLogOutput', pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n\
    \       'pSrcDim', sDim,\n       'pSrcHier', sCurrHierName,\n       'pTgtDim', pTgtDim,\n\
    \       'pTgtHier', sCurrHierName,\n       'pAttr', pAttr,\n       'pUnwind',pUnwind\n \
    \     );\n    Endif;\n### Hierachy is a delimited list with no wildcards\nElseIf( Scan(\
    \ '*', pHier )=0 &  Scan( '?', pHier )=0 & Trim( pHier ) @<> '' );\n  \n      # Loop through\
    \ hierarchies in pHier\n    sDim = pSrcDim;\n    sHierarchies              = pHier;\n  \
    \  nDelimiterIndexA    = 1;\n    sHierDim            = '}Hierarchies_'| sDim ;\n    sMdxHier\
    \ = '';\n    While( nDelimiterIndexA <> 0 );\n  \n        nDelimiterIndexA = Scan( pDelim,\
    \ sHierarchies );\n        If( nDelimiterIndexA = 0 );\n            sHierarchy   = sHierarchies;\n\
    \        Else;\n            sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA\
    \ - 1 ) );\n            sHierarchies  = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim),\
    \ Long( sHierarchies ) ) );\n        EndIf;\n        sCurrHier = sHierarchy;\n        sCurrHierName\
    \ = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n        # Validate hierarchy\
    \ name in sHierDim\n        If( Dimix( sHierDim , sDim |':'| sCurrHier ) = 0 );\n      \
    \      sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n\
    \            LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n        ElseIf( sCurrHierName\
    \ @= 'Leaves' );\n            sMessage = 'Invalid  Hierarchy: ' | sCurrHier | ' will be\
    \ skipped....';\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \        ElseIf( sCurrHierName @<> sDim );\n          If( pLogOutput = 1 );\n          \
    \  sMessage = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%' being processed....'\
    \ );\n            LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n          EndIf;\n  \
    \        nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n           'pLogOutput', pLogOutput,\n\
    \           'pStrictErrorHandling', pStrictErrorHandling,\n           'pSrcDim', sDim,\n\
    \           'pSrcHier', sCurrHierName,\n           'pTgtDim', pTgtDim,\n           'pTgtHier',\
    \ sCurrHierName,\n           'pAttr', pAttr,\n           'pUnwind',pUnwind\n          );\n\
    \        Endif;\n    End;\n\n### Hierachy has wildcards inside\nElseIf( Trim( pHier ) @<>\
    \ '' );\n  \n      # Loop through hierarchies in pHier\n    sDim = pSrcDim;\n    sHierarchies\
    \              = pHier;\n    nDelimiterIndexA    = 1;\n    sHierDim            = '}Hierarchies_'|\
    \ sDim ;\n    sMdxHier = '';\n    While( nDelimiterIndexA <> 0 );\n  \n        nDelimiterIndexA\
    \ = Scan( pDelim, sHierarchies );\n        If( nDelimiterIndexA = 0 );\n            sHierarchy\
    \   = sHierarchies;\n        Else;\n            sHierarchy   = Trim( SubSt( sHierarchies,\
    \ 1, nDelimiterIndexA - 1 ) );\n            sHierarchies  = Trim( Subst( sHierarchies, nDelimiterIndexA\
    \ + Long(pDelim), Long( sHierarchies ) ) );\n        EndIf;\n  \n        # Create subset\
    \ of Hierarchies using Wildcard\n        sHierExp = '''| sDim | ':' | sHierarchy|''';\n\
    \        sMdxHierPart = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp\
    \ | ')}';\n        IF( sMdxHier @= ''); \n          sMdxHier = sMdxHierPart; \n        ELSE;\n\
    \          sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n        ENDIF;\n    End;\n  \n \
    \   If( SubsetExists( sHierDim, cSubset ) = 1 );\n        # If a delimited list of attr\
    \ names includes wildcards then we may have to re-use the subset multiple times\n      \
    \  SubsetMDXSet( sHierDim, cSubset, sMdxHier );\n    Else;\n        # temp subset, therefore\
    \ no need to destroy in epilog\n        SubsetCreatebyMDX( cSubset, sMdxHier, sHierDim,\
    \ 1 );\n    EndIf;\n  \n    # Loop through subset of hierarchies created based on wildcard\n\
    \    nCountHier = SubsetGetSize( sHierDim, cSubset  );\n    While( nCountHier >= 1 );\n\
    \        sCurrHier = SubsetGetElementName( sHierDim, cSubset , nCountHier );\n        sCurrHierName\
    \ = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n        # Validate hierarchy\
    \ name in sHierDim\n        If( Dimix( sHierDim , sCurrHier ) = 0 );\n            sMessage\
    \ = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n \
    \           LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n        ElseIf( sCurrHierName\
    \ @= 'Leaves' );\n            sMessage = 'Invalid  Hierarchy: ' | sCurrHier | ' will be\
    \ skipped....';\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \        ElseIf( sCurrHierName @<> sDim );\n          If( pLogOutput = 1 );\n          \
    \  sMessage = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%' being processed....'\
    \ );\n            LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n          EndIf;\n  \
    \        nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n           'pLogOutput', pLogOutput,\n\
    \           'pStrictErrorHandling', pStrictErrorHandling,\n           'pSrcDim', sDim,\n\
    \           'pSrcHier', sCurrHierName,\n           'pTgtDim', pTgtDim,\n           'pTgtHier',\
    \ sCurrHierName,\n           'pAttr', pAttr,\n           'pUnwind',pUnwind\n          );\n\
    \        Endif;\n      \n        nCountHier = nCountHier - 1;\n    End;\nEndif;\n\n### Clone\
    \ dimension subsets\nIf( pSub = 1);\n  nCountSubs = DimSiz ('}Subsets_' | sDim);\n  While\
    \ ( nCountSubs >= 1 );\n    sCurrSub = If( Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))\
    \ = 0, DimNm ('}Subsets_' | sDim, nCountSubs), Subst( DimNm ('}Subsets_' | sDim, nCountSubs),\
    \ Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))+1, Long(DimNm ('}Subsets_' | sDim,\
    \ nCountSubs))-Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))));\n    sCurrHier = If(\
    \ Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs)) = 0, '', Subst(DimNm ('}Subsets_' |\
    \ sDim, nCountSubs), 1, Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))-1));\n\n    ExecuteProcess('}bedrock.hier.sub.clone',\n\
    \      'pLogOutput',0,\n      'pStrictErrorHandling',0,\n      'pSrcDim',sDim,\n      'pSrcHier',sCurrHier,\n\
    \      'pSrcSub',sCurrSub,\n      'pTgtDim', pTgtDim,\n      'pTgtHier', sCurrHier,\n  \
    \    'pTgtSub',sCurrSub,\n      'pTemp',0,\n      'pAlias','');\n    nCountSubs = nCountSubs\
    \ - 1;\n  End;\nEndif;\n          \n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% has cloned the %pSrcDim% dimension into %pTgtDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Describe an IBM Turbo Integrator process that can clone a source dimension and all
    its hierarchies. This process is intended for development and prototyping purposes, specifically
    to replicate a dimension with its hierarchies for testing. Note that if the target dimension
    or hierarchy already exists, it will be overwritten. A valid source dimension name (pSrcDim)
    is mandatory, otherwise the process will abort.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can clone a source dimension and all the\
    \ Hierarchies.\n\n# Use case: Intended for development/prototyping.\n# 1/ Replicate a dimension\
    \ with it's hierarchies for testing.\n\n# Note:\n# If the target dimension:hierarchy already\
    \ exists then it will be overwritten.\n# Naturally, a valid source dimension name (pSrcDim)\
    \ is mandatory otherwise the process will abort.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncSubset           = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName%\
    \ : %sMessage% : %cUserName%';\ncMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName%\
    \ Message:%sMessage%';\ncLogInfo          = '***Parameters for Process:%cThisProcName% for\
    \ pSrcDim:%pSrcDim%, pTgtDim:%pTgtDim%, pHier:%pHier%, pAttr:%pAttr%, pUnwind:%pUnwind%,\
    \ pDelim:%pDelim%.';\ncLangDim          = '}Cultures';\nnNumLang          = DimSiz( cLangDim\
    \ );\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*', pSrcDim\
    \ )=0 &  Scan( '?', pSrcDim )=0 & Scan( pDelim, pSrcDim )=0 & Scan( ':', pSrcDim ) > 0 &\
    \ pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error\
    \ by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pSrcDim, Scan(\
    \ ':', pSrcDim ) + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan(\
    \ ':', pSrcDim ) - 1 );\nEndIf;\n\n## Validate dimension\nIF( Trim( pSrcDim ) @= '' );\n\
    \  nErrors = 1;\n  sMessage = 'No source dimension specified.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIF( DimensionExists( pSrcDim ) = 0 );\n  nErrors =\
    \ 1;\n  sMessage = 'Invalid source dimension: ' | pSrcDim;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pTgtDim @= '' % pTgtDim @= pSrcDim );\n \
    \ pTgtDim = pSrcDim | '_Clone';\nEndIf;\n\n# Validate hierarchy\nIF( Scan( '*', pSrcDim\
    \ )=0 &  Scan( '?', pSrcDim )=0 & Scan( pDelim, pSrcDim )=0 & pHier @= '');\n    pHier =\
    \ pSrcDim;\nElseIf( Scan( '*', pHier )=0 &  Scan( '?', pHier )=0 & Scan( pDelim, pHier )=0\
    \ & pHier @<> '' & HierarchyExists(pSrcDim, pHier) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid dimension hierarchy: ' | pHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n\nIf( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards\
    \ are allowed, this is managed inside the code below\nEndIf;\n\n## Default delimiter\nIf(\
    \ pDelim     @= '' );\n    pDelim     = '&';\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create target dimension ###\n\nIf(DimensionExists(\
    \ pTgtDim ) = 0 );\n    DimensionCreate( pTgtDim );\nElse;\n    IF(pUnwind = 1 );\n    \
    \   nRet = ExecuteProcess('}bedrock.hier.unwind',\n        'pLogOutput', pLogOutput,\n \
    \       'pStrictErrorHandling', pStrictErrorHandling,\n        'pDim', pTgtDim,\n      \
    \  'pHier', pTgtDim,\n        'pConsol', '*',\n        'pRecursive', 1\n        );\n   \
    \ ELSEIF(pUnwind = 2 );\n      # Do nothing;\n    ELSE;\n      DimensionDeleteAllElements(\
    \ pTgtDim );\n    EndIf;\nEndIf;\n\n### Set the target Sort Order ###\nsSortElementsType\
    \     = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTELEMENTSTYPE');\nsSortElementsSense\
    \    = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTELEMENTSSENSE');\nsSortComponentsType\
    \   = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTCOMPONENTSTYPE');\nsSortComponentsSense\
    \  = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTCOMPONENTSSENSE');\n\nDimensionSortOrder(\
    \ pTgtDim, sSortComponentsType, sSortComponentsSense, sSortElementsType , sSortElementsSense);\n\
    \n\nnSourceDimSize = DIMSIZ( pSrcDim );\nnIndex = 1;\nWHILE( nIndex <= nSourceDimSize );\n\
    \  sElName = DIMNM( pSrcDim, nIndex);\n  sElType = DTYPE( pSrcDim, sElName);\n  \n    DimensionElementInsert(\
    \ pTgtDim, '', sElName, sElType );\n\n  nIndex = nIndex + 1;\nEND;\n\n### Assign Data Source\
    \ ###\nDatasourceNameForServer   = pSrcDim;\nDatasourceNameForClient   = pSrcDim;\nDataSourceType\
    \            = 'SUBSET';\nDatasourceDimensionSubset = 'ALL';\n\n\n### Replicate Attributes\
    \ ###\n# Note: DType on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\
    sAttrDim        = '}ElementAttributes_' | pSrcDim;\nsAttrLoc        = '}LocalizedElementAttributes_'\
    \ | pSrcDim;\nsAttrTargetDim  = '}ElementAttributes_' | pTgtDim;\nsAttrLocTarget  = '}LocalizedElementAttributes_'\
    \ | pTgtDim;\n\nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n  nNumAttrs = DimSiz(\
    \ sAttrDim );\n  nCount = 1;\n  While( nCount <= nNumAttrs );\n    sAttrName = DimNm( sAttrDim,\
    \ nCount );\n    sAttCheck = SubSt( DTYPE( sAttrDim, sAttrName ), 1, 1 );\n    IF (sAttCheck\
    \ @= 'A');\n    sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ), 2, 1 );\n    Else;\n  \
    \  sAttrType = sAttcheck;\n    EndIf; \n      \n      If ( DimensionExists( sAttrTargetDim\
    \ ) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n       ElseIF(DimIx(sAttrTargetDim,\
    \ sAttrName) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n      Endif;\n\
    \        \n    nCount = nCount + 1;\n  End;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Check for\
    \ errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n    \
    \  ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Add Elements to\
    \ target dimension ###\n\nsElType = DType( pSrcDim, vEle );\nIF( sElType @= 'C' & ElCompN(\
    \ pSrcDim, vEle ) > 0 );\n    nChildren = ElCompN( pSrcDim, vEle );\n    nCount = 1;\n \
    \   While( nCount <= nChildren );\n      sChildElement = ElComp( pSrcDim, vEle, nCount );\n\
    \      sChildWeight = ElWeight( pSrcDim, vEle, sChildElement );\n      DimensionElementComponentAdd(\
    \ pTgtDim, vEle, sChildElement, sChildWeight );\n      nCount = nCount + 1;\n    End;\n\
    EndIf;\n\n### End MetaData ###\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Check for errors in prolog ###\n\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Replicate Attributes ###\n# Note: DTYPE on Attr dim returns 'AS',\
    \ 'AN' or 'AA' need to strip off leading 'A'\n\nIf( pAttr = 1 & DimensionExists( sAttrDim\
    \ ) = 1 );\n\n    nAttr = 1;\n    While( nAttr <= nNumAttrs );\n        sAttrName = DimNm(\
    \ sAttrDim, nAttr );\n        sAttCheck = SubSt( DTYPE( sAttrDim, sAttrName ), 1, 1 );\n\
    \        IF (sAttCheck @= 'A');\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ),\
    \ 2, 1 );\n        Else;\n        sAttrType = sAttcheck;\n        sMessage = pSrcDim | '\
    \ dimension contains invalid attribute - ' | sAttrName ;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 );\n          ItemReject(Expand(\
    \ cMsgErrorContent ));\n        EndIf;  \n        EndIf;\n        If( CellIsUpdateable(\
    \ sAttrTargetDim, vEle, sAttrName ) = 1 );\n            If( sAttrType @= 'S' % sAttrType\
    \ @= 'A' );\n                #sAttrVal = AttrS( pSrcDim, vEle, sAttrName );\n          \
    \      sAttrVal = CellgetS('}ElementAttributes_'| pSrcDim, vEle, sAttrName);\n         \
    \       If( sAttrVal @<> '' );\n                    If( sAttrType @= 'A' );\n          \
    \              AttrPutS( sAttrVal, pTgtDim, vEle, sAttrName, 1 );\n                    Else;\n\
    \                        AttrPutS( sAttrVal, pTgtDim, vEle, sAttrName );\n             \
    \       EndIf;\n                EndIf;\n            Else;\n                #nAttrVal = AttrN(\
    \ pSrcDim, vEle, sAttrName );\n                nAttrVal = CellgetN('}ElementAttributes_'|\
    \ pSrcDim, vEle, sAttrName);\n                If( nAttrVal <> 0 );\n                   \
    \ AttrPutN( nAttrVal, pTgtDim, vEle, sAttrName );\n                EndIf;\n            EndIf;\n\
    \        EndIf;\n        # check for localized attributes\n        If( CubeExists( sAttrLoc\
    \ ) = 1 );\n            nLang = 1;\n            While( nLang <= nNumLang );\n          \
    \      sLang       = DimNm( cLangDim, nLang );\n                If( sAttrType @= 'A' % sAttrType\
    \ @= 'S' );\n                    sAttrVal    = AttrS( pSrcDim, vEle, sAttrName );\n    \
    \                sAttrValLoc = AttrSL( pSrcDim, vEle, sAttrName, sLang );\n            \
    \        If( sAttrValLoc @= sAttrVal ); sAttrValLoc = ''; EndIf;\n                Else;\n\
    \                    nAttrVal    = AttrN( pSrcDim, vEle, sAttrName );\n                \
    \    nAttrValLoc = AttrNL( pSrcDim, vEle, sAttrName, sLang );\n                EndIf;\n\
    \                If( CubeExists( sAttrLocTarget ) = 0 );\n                    If( sAttrType\
    \ @= 'A' );\n                        AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName, sLang,\
    \ 1 );\n                    ElseIf( sAttrType @= 'N' );\n                        If( nAttrValLoc\
    \ <> nAttrVal );\n                            AttrPutN( nAttrValLoc, pTgtDim, vEle, sAttrName,\
    \ sLang );\n                        EndIf;\n                    Else;\n                \
    \        AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\n                   \
    \ EndIf;\n                ElseIf( CubeExists( sAttrLocTarget ) = 1 );\n                \
    \    If( CellIsUpdateable( sAttrLocTarget, vEle, sLang, sAttrName ) = 1 );\n           \
    \             If( sAttrType @= 'A' );\n                            AttrPutS( sAttrValLoc,\
    \ pTgtDim, vEle, sAttrName, sLang, 1 );\n                        ElseIf( sAttrType @= 'N'\
    \ );\n                            If( nAttrValLoc <> nAttrVal );\n                     \
    \           AttrPutN( nAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\n                \
    \            EndIf;\n                        Else;\n                            AttrPutS(\
    \ sAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\n                        EndIf;\n    \
    \                EndIf;\n                EndIf;\n                nLang   = nLang + 1;\n\
    \            End;\n        EndIf;\n        nAttr = nAttr + 1;\n    End;\n\nEndIf;\n\n###\
    \ End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#################################################################################################\
    \ \n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock\
    \ Ver 4.0.0~~##\n#################################################################################################\
    \ \n\n\n### Set the target Sort Order ###\n  CELLPUTS( sSortElementsType, '}DimensionProperties',\
    \ pTgtDim, 'SORTELEMENTSTYPE');\n  CELLPUTS( sSortElementsSense, '}DimensionProperties',\
    \ pTgtDim, 'SORTELEMENTSSENSE');\n  CELLPUTS( sSortComponentsType, '}DimensionProperties',\
    \ pTgtDim, 'SORTCOMPONENTSTYPE');\n  CELLPUTS( sSortComponentsSense, '}DimensionProperties',\
    \ pTgtDim, 'SORTCOMPONENTSSENSE');\n\n### Destroy Source Subset ###\n\n  If( SubsetExists(\
    \ pSrcDim, cSubset ) = 1 );\n    SubsetDestroy( pSrcDim, cSubset );\n  EndIf;\n\n##Clone\
    \ all the Hierarchies except default hierarchy & Leaves\nIf( pHier @= '*' );\n    sDim =\
    \ pSrcDim;\n    sHierDim = '}Hierarchies_' | sDim;\n    sTargetHierarchy = '';\n    nMax\
    \ = DimSiz( sHierDim );\n    nCtr = 1;\n    While( nCtr <= nMax );\n        sEle = DimNm(\
    \ sHierDim, nCtr );\n        nElength = Long(sEle);\n        nElestart  = 0;\n        nElestart\
    \ = SCAN(':', sEle) + 1;\n        If(nElestart > 1);\n          vSourceHierarchy = SUBST(sEle,nElestart,nElength);\n\
    \         If ( vSourceHierarchy @<> 'Leaves');\n             nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n\
    \               'pLogOutput', pLogOutput,\n               'pStrictErrorHandling', pStrictErrorHandling,\n\
    \               'pSrcDim', sDim,\n               'pSrcHier', vSourceHierarchy,\n       \
    \        'pTgtDim', pTgtDim,\n               'pTgtHier', vSourceHierarchy,\n           \
    \    'pAttr', pAttr,\n               'pUnwind',pUnwind\n               );\n         Endif;\n\
    \         sTargetHierarchy = sTargetHierarchy |':'|vSourceHierarchy;\n        Endif;\n \
    \       nCtr = nCtr + 1;\n    End;\n### Just one hierarchy specified in parameter\nElseIf(\
    \ Scan( '*', pHier )=0 &  Scan( '?', pHier )=0 & Scan( pDelim, pHier )=0 & Trim( pHier )\
    \ @<> '' );\n    sDim = pSrcDim;\n    sHierDim = '}Hierarchies_' | sDim;\n    sCurrHier\
    \ = pHier;\n    sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier)\
    \ );\n    # Validate hierarchy name in sHierDim\n    If( Dimix( sHierDim , sDim |':'| sCurrHier\
    \ ) = 0 );\n        sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the\
    \ '%sDim%' dimension.');\n        LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n   \
    \ ElseIf( sCurrHierName @= 'Leaves' );\n        sMessage = 'Invalid  Hierarchy: ' | sCurrHier\
    \ | ' will be skipped....';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    ElseIf( sCurrHierName @<> sDim );\n      If( pLogOutput = 1 );\n        sMessage\
    \ = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%' being processed....' );\n\
    \        LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n      EndIf;\n      nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n\
    \       'pLogOutput', pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n\
    \       'pSrcDim', sDim,\n       'pSrcHier', sCurrHierName,\n       'pTgtDim', pTgtDim,\n\
    \       'pTgtHier', sCurrHierName,\n       'pAttr', pAttr,\n       'pUnwind',pUnwind\n \
    \     );\n    Endif;\n### Hierachy is a delimited list with no wildcards\nElseIf( Scan(\
    \ '*', pHier )=0 &  Scan( '?', pHier )=0 & Trim( pHier ) @<> '' );\n  \n      # Loop through\
    \ hierarchies in pHier\n    sDim = pSrcDim;\n    sHierarchies              = pHier;\n  \
    \  nDelimiterIndexA    = 1;\n    sHierDim            = '}Hierarchies_'| sDim ;\n    sMdxHier\
    \ = '';\n    While( nDelimiterIndexA <> 0 );\n  \n        nDelimiterIndexA = Scan( pDelim,\
    \ sHierarchies );\n        If( nDelimiterIndexA = 0 );\n            sHierarchy   = sHierarchies;\n\
    \        Else;\n            sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA\
    \ - 1 ) );\n            sHierarchies  = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim),\
    \ Long( sHierarchies ) ) );\n        EndIf;\n        sCurrHier = sHierarchy;\n        sCurrHierName\
    \ = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n        # Validate hierarchy\
    \ name in sHierDim\n        If( Dimix( sHierDim , sDim |':'| sCurrHier ) = 0 );\n      \
    \      sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n\
    \            LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n        ElseIf( sCurrHierName\
    \ @= 'Leaves' );\n            sMessage = 'Invalid  Hierarchy: ' | sCurrHier | ' will be\
    \ skipped....';\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \        ElseIf( sCurrHierName @<> sDim );\n          If( pLogOutput = 1 );\n          \
    \  sMessage = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%' being processed....'\
    \ );\n            LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n          EndIf;\n  \
    \        nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n           'pLogOutput', pLogOutput,\n\
    \           'pStrictErrorHandling', pStrictErrorHandling,\n           'pSrcDim', sDim,\n\
    \           'pSrcHier', sCurrHierName,\n           'pTgtDim', pTgtDim,\n           'pTgtHier',\
    \ sCurrHierName,\n           'pAttr', pAttr,\n           'pUnwind',pUnwind\n          );\n\
    \        Endif;\n    End;\n\n### Hierachy has wildcards inside\nElseIf( Trim( pHier ) @<>\
    \ '' );\n  \n      # Loop through hierarchies in pHier\n    sDim = pSrcDim;\n    sHierarchies\
    \              = pHier;\n    nDelimiterIndexA    = 1;\n    sHierDim            = '}Hierarchies_'|\
    \ sDim ;\n    sMdxHier = '';\n    While( nDelimiterIndexA <> 0 );\n  \n        nDelimiterIndexA\
    \ = Scan( pDelim, sHierarchies );\n        If( nDelimiterIndexA = 0 );\n            sHierarchy\
    \   = sHierarchies;\n        Else;\n            sHierarchy   = Trim( SubSt( sHierarchies,\
    \ 1, nDelimiterIndexA - 1 ) );\n            sHierarchies  = Trim( Subst( sHierarchies, nDelimiterIndexA\
    \ + Long(pDelim), Long( sHierarchies ) ) );\n        EndIf;\n  \n        # Create subset\
    \ of Hierarchies using Wildcard\n        sHierExp = '''| sDim | ':' | sHierarchy|''';\n\
    \        sMdxHierPart = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp\
    \ | ')}';\n        IF( sMdxHier @= ''); \n          sMdxHier = sMdxHierPart; \n        ELSE;\n\
    \          sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n        ENDIF;\n    End;\n  \n \
    \   If( SubsetExists( sHierDim, cSubset ) = 1 );\n        # If a delimited list of attr\
    \ names includes wildcards then we may have to re-use the subset multiple times\n      \
    \  SubsetMDXSet( sHierDim, cSubset, sMdxHier );\n    Else;\n        # temp subset, therefore\
    \ no need to destroy in epilog\n        SubsetCreatebyMDX( cSubset, sMdxHier, sHierDim,\
    \ 1 );\n    EndIf;\n  \n    # Loop through subset of hierarchies created based on wildcard\n\
    \    nCountHier = SubsetGetSize( sHierDim, cSubset  );\n    While( nCountHier >= 1 );\n\
    \        sCurrHier = SubsetGetElementName( sHierDim, cSubset , nCountHier );\n        sCurrHierName\
    \ = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n        # Validate hierarchy\
    \ name in sHierDim\n        If( Dimix( sHierDim , sCurrHier ) = 0 );\n            sMessage\
    \ = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n \
    \           LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n        ElseIf( sCurrHierName\
    \ @= 'Leaves' );\n            sMessage = 'Invalid  Hierarchy: ' | sCurrHier | ' will be\
    \ skipped....';\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \        ElseIf( sCurrHierName @<> sDim );\n          If( pLogOutput = 1 );\n          \
    \  sMessage = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%' being processed....'\
    \ );\n            LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n          EndIf;\n  \
    \        nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n           'pLogOutput', pLogOutput,\n\
    \           'pStrictErrorHandling', pStrictErrorHandling,\n           'pSrcDim', sDim,\n\
    \           'pSrcHier', sCurrHierName,\n           'pTgtDim', pTgtDim,\n           'pTgtHier',\
    \ sCurrHierName,\n           'pAttr', pAttr,\n           'pUnwind',pUnwind\n          );\n\
    \        Endif;\n      \n        nCountHier = nCountHier - 1;\n    End;\nEndif;\n\n### Clone\
    \ dimension subsets\nIf( pSub = 1);\n  nCountSubs = DimSiz ('}Subsets_' | sDim);\n  While\
    \ ( nCountSubs >= 1 );\n    sCurrSub = If( Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))\
    \ = 0, DimNm ('}Subsets_' | sDim, nCountSubs), Subst( DimNm ('}Subsets_' | sDim, nCountSubs),\
    \ Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))+1, Long(DimNm ('}Subsets_' | sDim,\
    \ nCountSubs))-Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))));\n    sCurrHier = If(\
    \ Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs)) = 0, '', Subst(DimNm ('}Subsets_' |\
    \ sDim, nCountSubs), 1, Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))-1));\n\n    ExecuteProcess('}bedrock.hier.sub.clone',\n\
    \      'pLogOutput',0,\n      'pStrictErrorHandling',0,\n      'pSrcDim',sDim,\n      'pSrcHier',sCurrHier,\n\
    \      'pSrcSub',sCurrSub,\n      'pTgtDim', pTgtDim,\n      'pTgtHier', sCurrHier,\n  \
    \    'pTgtSub',sCurrSub,\n      'pTemp',0,\n      'pAlias','');\n    nCountSubs = nCountSubs\
    \ - 1;\n  End;\nEndif;\n          \n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% has cloned the %pSrcDim% dimension into %pTgtDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine Dimension oder eine Liste
    von Dimensionen basierend auf einem übereinstimmenden Wildcard-Namen löscht. Dieser Prozess
    ist für die Entwicklung oder Prototypenerstellung gedacht, insbesondere während der agilen
    Entwicklung, um Dimensionen aufgrund von Umbenennungen oder geänderten Anforderungen zu
    entfernen. Er kann auch verwendet werden, um ungenutzte Dimensionen vor dem Systemstart
    zu bereinigen. Beachte, dass ein gültiger Dimensionsname pDim oder eine Liste davon zwingend
    erforderlich ist, andernfalls wird der Prozess abgebrochen. Attributedimensionen sind ausgeschlossen,
    da diese automatisch durch das Entfernen der Basisdimension bereinigt werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a dimension, list of dimensions,\
    \ or set of dimensions specified by wildcard name match.\n\n# Use case: Intended for development/prototyping.\n\
    # 1. During active agile development to remove dimensions due to renaming, change of requirements,\
    \ etc.\n# 2. Clean up unused dimensions prior to system Go Live.\n\n# Note:\n# * A valid\
    \ dimension name pDim or list thereof is mandatory otherwise the process will abort.\n#\
    \ * Attribute dimensions are deliberately excluded because these are automatically cleaned\
    \ up by removing the base dimension.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp      \
    \  = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pDelim:%pDelim%.';\
    \ \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Trim( pDim ) @= ''\
    \ );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Default delimiter\nIf( pDelim     @= '' );\n\
    \    pDelim     = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Dimension delete\n# Loop through dimensions in pDim \nsDims    \
    \           = Trim( pDim );\nnDimDelimiterIndex  = 1;\n# Get 1st dimension\nWhile( nDimDelimiterIndex\
    \ <> 0 );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims\
    \ );\n    If( nDimDelimiterIndex = 0 );\n        sDim        = sDims;\n    Else;\n     \
    \   sDim        = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims    \
    \   = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n\
    \    \n    # Check if sDim has wildcard\n    If( Scan( '*', sDim ) = 0);\n        # check\
    \ if dim is used in a cube\n        sDimIsUsed ='';\n        nDimIsUsed = 0;\n        nCubes\
    \ = DimSiz( '}Cubes' );\n        nCube = 1;\n        While(nCube <= nCubes);\n         \
    \   sCube = DimNm( '}Cubes' , nCube );\n            nDim = 1;\n            While(TabDim(sCube,nDim)@<>''\
    \ & Subst( sCube , 1 , 1) @<>'}' );\n                sDimInCube = TABDIM(sCube,nDim);\n\
    \                If(sDimInCube@=sDim);\n                    sDimIsUsed = sDimIsUsed | sCube\
    \ | ' ';\n                    nDimIsUsed = nDimIsUsed+1;\n                EndIf;\n     \
    \           nDim = nDim + 1;\n            End;\n            nCube = nCube + 1;\n       \
    \ End;     \n        \n        # Delete if it exists and is not being used in a cube\n \
    \       If( DimensionExists(sDim) = 0 );\n            nErrors = 1;\n            sMessage\
    \ = Expand( 'Dimension '%sDim%' does not exist.' );\n            LogOutput( 'ERROR', Expand(\
    \ cMsgErrorContent ) );\n        ElseIF( sDimIsUsed@='');\n            DimensionDestroy(\
    \ sDim );\n        Else;\n            nErrors = 1;\n            sMessage = 'The dimension\
    \ ' | sDim | ' could not be destroyed as it is being used for ' | NumberToString(nDimIsUsed)\
    \  | ' cube(s) :' | sDimIsUsed;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        Endif;\n    Else;\n        # Create subset of dimensions using Wildcard\
    \ to loop through dimensions in pDim with wildcard\n        sDimExp = '''|sDim|''';\n  \
    \      sMdx = '{TM1FILTERBYPATTERN( EXCEPT ( EXCEPT ( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ), TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) , '}ElementAttributes_*') ) ,'| sDimExp | ')}';\n        If( SubsetExists( '}Dimensions'\
    \ , cTempSub ) = 1 );\n            # If a delimited list of dim names includes wildcards\
    \ then we may have to re-use the subset multiple times\n            SubsetMDXSet( '}Dimensions'\
    \ , cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\n     \
    \   EndIf;\n        \n        # Loop through dimensions in subset created based on wildcard\n\
    \        nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n        While( nCountDim\
    \ >= 1 );\n            sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim\
    \ );\n            # check if dim is used in a cube\n            sDimIsUsed ='';\n      \
    \      nDimIsUsed = 0;\n            nCubes = DimSiz( '}Cubes' );\n            nCube = 1;\n\
    \            While(nCube <= nCubes);\n                sCube = DimNm( '}Cubes' , nCube );\n\
    \                nDim = 1;\n                While(TabDim(sCube,nDim)@<>'' & Subst( sCube\
    \ , 1 , 1) @<>'}' );\n                    sDimInCube = TABDIM(sCube,nDim);\n           \
    \         If(sDimInCube@=sDim);\n                        sDimIsUsed = sDimIsUsed | sCube\
    \ | ' ';\n                        nDimIsUsed = nDimIsUsed+1;\n                    EndIf;\n\
    \                    nDim = nDim + 1;\n                End;\n                nCube = nCube\
    \ + 1;\n            End;  \n            # Delete if it exists and is not being used in a\
    \ cube\n            If( DimensionExists(sDim) = 0 );\n                nErrors = 1;\n   \
    \             sMessage = Expand( 'Dimension %sDim% does not exist.' );\n               \
    \ LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n            ElseIF( sDimIsUsed@='');\n\
    \                DimensionDestroy( sDim );\n            Else;\n                nErrors =\
    \ 1;\n                sMessage = 'The dimension ' | sDim | ' could not be destroyed as it\
    \ is being used for ' | NumberToString(nDimIsUsed)  | ' cube(s) :' | sDimIsUsed;\n     \
    \           LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            Endif;\n\
    \            IF( SubsetGetSize( '}Dimensions' , cTempSub ) < nCountDim - 1 );\n        \
    \      nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n            ELSE;\n     \
    \       nCountDim = nCountDim - 1;\n            ENDIF;\n        End;\n    EndIf;\n   \n\
    End;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted dimensions %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that deletes a dimension or a list of dimensions
    based on a matching wildcard name. This process is intended for development or prototyping,
    especially during active agile development to remove dimensions due to renaming or changing
    requirements. It can also be used to clean up unused dimensions prior to system go-live.
    Note that a valid dimension name pDim or a list thereof is mandatory, otherwise, the process
    will abort. Attribute dimensions are deliberately excluded as they are automatically cleaned
    up by removing the base dimension.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a dimension, list of dimensions,\
    \ or set of dimensions specified by wildcard name match.\n\n# Use case: Intended for development/prototyping.\n\
    # 1. During active agile development to remove dimensions due to renaming, change of requirements,\
    \ etc.\n# 2. Clean up unused dimensions prior to system Go Live.\n\n# Note:\n# * A valid\
    \ dimension name pDim or list thereof is mandatory otherwise the process will abort.\n#\
    \ * Attribute dimensions are deliberately excluded because these are automatically cleaned\
    \ up by removing the base dimension.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp      \
    \  = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pDelim:%pDelim%.';\
    \ \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Trim( pDim ) @= ''\
    \ );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Default delimiter\nIf( pDelim     @= '' );\n\
    \    pDelim     = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Dimension delete\n# Loop through dimensions in pDim \nsDims    \
    \           = Trim( pDim );\nnDimDelimiterIndex  = 1;\n# Get 1st dimension\nWhile( nDimDelimiterIndex\
    \ <> 0 );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims\
    \ );\n    If( nDimDelimiterIndex = 0 );\n        sDim        = sDims;\n    Else;\n     \
    \   sDim        = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims    \
    \   = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n\
    \    \n    # Check if sDim has wildcard\n    If( Scan( '*', sDim ) = 0);\n        # check\
    \ if dim is used in a cube\n        sDimIsUsed ='';\n        nDimIsUsed = 0;\n        nCubes\
    \ = DimSiz( '}Cubes' );\n        nCube = 1;\n        While(nCube <= nCubes);\n         \
    \   sCube = DimNm( '}Cubes' , nCube );\n            nDim = 1;\n            While(TabDim(sCube,nDim)@<>''\
    \ & Subst( sCube , 1 , 1) @<>'}' );\n                sDimInCube = TABDIM(sCube,nDim);\n\
    \                If(sDimInCube@=sDim);\n                    sDimIsUsed = sDimIsUsed | sCube\
    \ | ' ';\n                    nDimIsUsed = nDimIsUsed+1;\n                EndIf;\n     \
    \           nDim = nDim + 1;\n            End;\n            nCube = nCube + 1;\n       \
    \ End;     \n        \n        # Delete if it exists and is not being used in a cube\n \
    \       If( DimensionExists(sDim) = 0 );\n            nErrors = 1;\n            sMessage\
    \ = Expand( 'Dimension '%sDim%' does not exist.' );\n            LogOutput( 'ERROR', Expand(\
    \ cMsgErrorContent ) );\n        ElseIF( sDimIsUsed@='');\n            DimensionDestroy(\
    \ sDim );\n        Else;\n            nErrors = 1;\n            sMessage = 'The dimension\
    \ ' | sDim | ' could not be destroyed as it is being used for ' | NumberToString(nDimIsUsed)\
    \  | ' cube(s) :' | sDimIsUsed;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        Endif;\n    Else;\n        # Create subset of dimensions using Wildcard\
    \ to loop through dimensions in pDim with wildcard\n        sDimExp = '''|sDim|''';\n  \
    \      sMdx = '{TM1FILTERBYPATTERN( EXCEPT ( EXCEPT ( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ), TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) , '}ElementAttributes_*') ) ,'| sDimExp | ')}';\n        If( SubsetExists( '}Dimensions'\
    \ , cTempSub ) = 1 );\n            # If a delimited list of dim names includes wildcards\
    \ then we may have to re-use the subset multiple times\n            SubsetMDXSet( '}Dimensions'\
    \ , cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\n     \
    \   EndIf;\n        \n        # Loop through dimensions in subset created based on wildcard\n\
    \        nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n        While( nCountDim\
    \ >= 1 );\n            sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim\
    \ );\n            # check if dim is used in a cube\n            sDimIsUsed ='';\n      \
    \      nDimIsUsed = 0;\n            nCubes = DimSiz( '}Cubes' );\n            nCube = 1;\n\
    \            While(nCube <= nCubes);\n                sCube = DimNm( '}Cubes' , nCube );\n\
    \                nDim = 1;\n                While(TabDim(sCube,nDim)@<>'' & Subst( sCube\
    \ , 1 , 1) @<>'}' );\n                    sDimInCube = TABDIM(sCube,nDim);\n           \
    \         If(sDimInCube@=sDim);\n                        sDimIsUsed = sDimIsUsed | sCube\
    \ | ' ';\n                        nDimIsUsed = nDimIsUsed+1;\n                    EndIf;\n\
    \                    nDim = nDim + 1;\n                End;\n                nCube = nCube\
    \ + 1;\n            End;  \n            # Delete if it exists and is not being used in a\
    \ cube\n            If( DimensionExists(sDim) = 0 );\n                nErrors = 1;\n   \
    \             sMessage = Expand( 'Dimension %sDim% does not exist.' );\n               \
    \ LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n            ElseIF( sDimIsUsed@='');\n\
    \                DimensionDestroy( sDim );\n            Else;\n                nErrors =\
    \ 1;\n                sMessage = 'The dimension ' | sDim | ' could not be destroyed as it\
    \ is being used for ' | NumberToString(nDimIsUsed)  | ' cube(s) :' | sDimIsUsed;\n     \
    \           LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            Endif;\n\
    \            IF( SubsetGetSize( '}Dimensions' , cTempSub ) < nCountDim - 1 );\n        \
    \      nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n            ELSE;\n     \
    \       nCountDim = nCountDim - 1;\n            ENDIF;\n        End;\n    EndIf;\n   \n\
    End;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted dimensions %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Erstellen Sie einen IBM Turbo Integrator Prozess, der Dimensionen löscht, wobei
    eine Dimension, eine Liste von Dimensionen oder ein Satz von Dimensionen durch Übereinstimmung
    mit einem Platzhalter-namen angegeben wird. Dieser Prozess ist für die Entwicklung oder
    das Prototyping gedacht. Verwenden Sie ihn während der aktiven agilen Entwicklung, um Dimensionen
    aufgrund von Umbenennungen, geänderten Anforderungen usw. zu entfernen oder um unbenutzte
    Dimensionen vor dem System-Go-Live zu bereinigen. Beachten Sie, dass ein gültiger Dimensionsname
    pDim oder eine Liste davon obligatorisch ist, ansonsten wird der Prozess abgebrochen. Attributdimensionen
    sind bewusst ausgeschlossen, da diese automatisch entfernt werden, wenn die Basisdimension
    gelöscht wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will clone the source dimension Hierarchy.\n\
    \n# Use case: Mostly in Development.\n# 1/ Create a duplicate of an existing hierarchy for\
    \ testing.\n\n# Note:\n# Valid source dimension name (pSrcDim) and target dimension (pTgtDim)\
    \ names are mandatory otherwise the process will abort.\n# Valid source hierarchy name (pSrcHier)\
    \ is mandatory otherwise the process will abort.\n\n# Caution:\n# - Target hierarchy cannot\
    \ be `Leaves`.\n# - If the target dimension Hierarchy exists then it will be overwritten.\n\
    #EndRegion @DOC\n\n### Global Varaibales ###\nStringGlobalVariable ('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode = 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp      \
    \  = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%,\
    \ pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%.';\ncLangDim\
    \          = '}Cultures';\nnNumLang          = DimSiz( cLangDim );\n\nnProcessSameNamedHier\
    \ = 0;\nsEpilogTgtHier = '';\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan(\
    \ ':', pSrcDim ) > 0 & pSrcHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pSrcHier\
    \       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long( pSrcDim ) );\n    pSrcDim    \
    \    = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\nEndIf;\n\n## Validate Source dimension\n\
    IF( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No source dimension specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIF( DimensionExists(\
    \ pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid source dimension: ' | pSrcDim;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Source\
    \ hierarchy\nIF( Trim( pSrcHier ) @= '' );\n    pSrcHier = pSrcDim;\nElseIF(HierarchyExists(pSrcDim,pSrcHier\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Target\
    \ dimension\nIF( Trim( pTgtDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No target dimension\
    \ specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( Scan(\
    \ ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pTgtHier\
    \       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim    \
    \    = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\nIf ( DimensionExists( pTgtDim\
    \ ) = 0 );\n  DimensionCreate( pTgtDim );\n  ### In this case clone source hierarchy into\
    \ same-named hierarchy of the new target dimension first. This will allow attributes to\
    \ be processed in the data tab.\n  nProcessSameNamedHier = 1;\nEndIf;\n\n# Validate target\
    \ hierarchy\nIf( pSrcDim @= pTgtDim);\n    If( pTgtHier @= '' % pTgtHier @= pSrcHier );\n\
    \        pTgtHier = pSrcHier | '_Clone';\n    EndIf;\nElseIf(pTgtHier @= '');\n    If( nProcessSameNamedHier\
    \ = 1 );\n      sEpilogTgtHier = pTgtHier;\n      pTgtHier = pTgtDim;\n    Else;\n     \
    \ pTgtHier = pSrcHier;\n    EndIf;\nElseIf( nProcessSameNamedHier = 1 );\n    sEpilogTgtHier\
    \ = pTgtHier;\n    pTgtHier = pTgtDim;\nEndif;\n\npTgtHier = Trim(pTgtHier);\n\nIF(pTgtHier\
    \ @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Leaves is an invalid selection for Target\
    \ Hierarchy: ' | pTgtDim |':'|pTgtHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( DimensionExists( pTgtDim ) = 0 );\n    If( pUnwind >= 1 );\n     \
    \   pUnwind = 2;\n    EndIf;\nElseIf( HierarchyExists( pTgtDim, pTgtHier ) = 0 );\n    If(\
    \ pUnwind >= 1 );\n        pUnwind = 2;\n    EndIf;\nEndIf;    \n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create target dimension Hierarchy\
    \ ###\nIf( HierarchyExists( pTgtDim, pTgtHier) = 0 );\n    HierarchyCreate( pTgtDim, pTgtHier\
    \ );\nElse;\n    IF(pUnwind = 1 );\n      nRet = ExecuteProcess('}bedrock.hier.unwind',\n\
    \        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pDim', pTgtDim,\n        'pHier', pTgtHier,\n        'pConsol', '*',\n       \
    \ 'pRecursive', 1\n        );\n    ELSEIF(pUnwind = 2 );\n      #Do nothing\n    ELSEIF(pUnwind\
    \ = 0 );\n      HierarchyDeleteAllElements( pTgtDim, pTgtHier );\n    EndIf;\nEndIf;\n \
    \ \nIf(pSrcDim @=pSrcHier);\n   sDimHier = pSrcDim;\n Else;\n   sDimHier =pSrcDim|':'|pSrcHier;\n\
    \ Endif;\n  \n### Set the target Sort Order ###\nsSortElementsType     = CELLGETS( '}DimensionProperties',\
    \ sDimHier, 'SORTELEMENTSTYPE');\nsSortElementsSense    = CELLGETS( '}DimensionProperties',\
    \ sDimHier, 'SORTELEMENTSSENSE');\nsSortComponentsType   = CELLGETS( '}DimensionProperties',\
    \ sDimHier, 'SORTCOMPONENTSTYPE');\nsSortComponentsSense  = CELLGETS( '}DimensionProperties',\
    \ sDimHier, 'SORTCOMPONENTSSENSE');\n\nHierarchySortOrder(pTgtDim, pTgtHier, sSortComponentsType,\
    \ sSortComponentsSense, sSortElementsType , sSortElementsSense);\n\nnSourceHierSize = DimSiz(pSrcDim|':'|pSrcHier);\n\
    \nnIndex = 1;\nWHILE( nIndex <= nSourceHierSize );\n  sElName = ElementName(pSrcDim, pSrcHier,\
    \ nIndex);\n  sElType = ElementType(pSrcDim, pSrcHier, sElName);\n  HierarchyElementInsert(pTgtDim,\
    \ pTgtHier, '', sElName, sElType);\n  nIndex = nIndex + 1;\nEND;\n\n### Assign Data Source\
    \ ###\n\nDatasourceNameForServer     = pSrcDim|':'|pSrcHier;\nDataSourceType           \
    \   = 'SUBSET';\nDatasourceDimensionSubset   = 'ALL';\n\n### Replicate Attributes ###\n\n\
    # Note: DType on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\nsAttrDim\
    \        = '}ElementAttributes_' | pSrcDim;\nsAttrLoc        = '}LocalizedElementAttributes_'\
    \ | pSrcDim;\nsAttrTragetDim  = '}ElementAttributes_' | pTgtDim;\nsAttrLocTarget  = '}LocalizedElementAttributes_'\
    \ | pTgtDim;\n\nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n  nNumAttrs = DimSiz(\
    \ sAttrDim );\n  nCount = 1;\n  While( nCount <= nNumAttrs );\n    sAttrName = DimNm( sAttrDim,\
    \ nCount );\n    sAttrType = SubSt(DType( sAttrDim, sAttrName ), 2, 1 );\n      If ( DimensionExists(\
    \ sAttrTragetDim ) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n      \
    \ ElseIF(DimIx(sAttrTragetDim, sAttrName) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType\
    \ );\n      Endif;\n    nCount = nCount + 1;\n  End;\nEndIf;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Add\
    \ Elements to target dimension ###\n\nsElType = ElementType(pSrcDim, pSrcHier, vEle);\n\n\
    IF( sElType @= 'C' & ElementComponentCount( pSrcDim, pSrcHier, vEle  ) > 0 );\n    nChildren\
    \ = ElementComponentCount( pSrcDim, pSrcHier, vEle );\n    nCount = 1;\n    While( nCount\
    \ <= nChildren );\n        sChildElement = ElementComponent( pSrcDim, pSrcHier, vEle, nCount\
    \ );\n        sChildWeight = ElementWeight( pSrcDim,pSrcHier, vEle, sChildElement );\n \
    \       HierarchyElementComponentAdd(pTgtDim, pTgtHier, vEle, sChildElement, sChildWeight);\n\
    \        nCount = nCount + 1;\n    End;\nEndIf;\n\n### End MetaData ###\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Check for\
    \ errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n    \
    \  ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Replicate Attributes\
    \ ###\n# Note: DTYPE on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\
    \nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n\n    nAttr = 1;\n    While( nAttr\
    \ <= nNumAttrs );\n        sAttrName = DimNm( sAttrDim, nAttr );\n        sAttrType = SubSt(\
    \ DTYPE( sAttrDim, sAttrName ), 2, 1 );\n        \n        If( sAttrType @= 'S' % sAttrType\
    \ @= 'A' );\n            sAttrVal = ElementAttrS( pSrcDim, pSrcHier, vEle, sAttrName );\n\
    \            \n            If( sAttrVal @<> '' );\n                If( CellIsUpdateable(\
    \ '}ElementAttributes_' | pTgtDim, pTgtHier:vEle, sAttrName ) = 1 );\n                 \
    \   If( sAttrType @= 'A' );\n                        ElementAttrPutS( sAttrVal, pTgtDim,\
    \ pTgtHier, vEle, sAttrName, 1 );\n                    Else;\n                        ElementAttrPutS(\
    \ sAttrVal, pTgtDim, pTgtHier, vEle, sAttrName );\n                    EndIf;\n        \
    \        EndIf;\n            EndIf;\n        Else;\n            nAttrVal = ElementAttrN(\
    \ pSrcDim, pSrcHier, vEle, sAttrName );\n            If( nAttrVal <> 0 );\n            \
    \    If( CellIsUpdateable( '}ElementAttributes_' | pTgtDim, pTgtHier:vEle, sAttrName ) =\
    \ 1 );\n                    ElementAttrPutN( nAttrVal, pTgtDim, pTgtHier, vEle, sAttrName\
    \ );\n                EndIf;\n            EndIf;  \n        EndIf;\n        # check for\
    \ localized attributes\n        If( CubeExists( sAttrLoc ) = 1 );\n            nLang = 1;\n\
    \            While( nLang <= nNumLang );\n                sLang       = DimNm( cLangDim,\
    \ nLang );\n                If( sAttrType @= 'A' % sAttrType @= 'S' );\n               \
    \     sAttrVal    = ElementAttrS( pSrcDim, pSrcHier, vEle, sAttrName );\n              \
    \      sAttrValLoc = ElementAttrSL( pSrcDim, pSrcHier, vEle, sAttrName, sLang );\n     \
    \               If( sAttrValLoc @= sAttrVal ); sAttrValLoc = ''; EndIf;\n              \
    \  Else;\n                    nAttrVal    = ElementAttrN( pSrcDim, pSrcHier, vEle, sAttrName\
    \ );\n                    nAttrValLoc = ElementAttrNL( pSrcDim, pSrcHier, vEle, sAttrName,\
    \ sLang );\n                EndIf;\n                If( CubeExists( sAttrLocTarget ) = 0\
    \ );\n                    If( sAttrType @= 'A' );\n                        ElementAttrPutS(\
    \ sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang, 1 );\n                    ElseIf(\
    \ sAttrType @= 'N' );\n                        ElementAttrPutN( nAttrValLoc, pTgtDim, pTgtHier,\
    \ vEle, sAttrName, sLang );\n                    Else;\n                        ElementAttrPutS(\
    \ sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n                    EndIf;\n\
    \                ElseIf(CubeExists( sAttrLocTarget ) = 1 );\n                    If( CellIsUpdateable(\
    \ sAttrLocTarget, pTgtHier:vEle, sLang, sAttrName ) = 1 );\n                        If(\
    \ sAttrType @= 'A' );\n                            ElementAttrPutS( sAttrValLoc, pTgtDim,\
    \ pTgtHier, vEle, sAttrName, sLang, 1 );\n                        ElseIf( sAttrType @= 'N'\
    \ );\n                            ElementAttrPutN( nAttrValLoc, pTgtDim, pTgtHier, vEle,\
    \ sAttrName, sLang );\n                        Else;\n                            ElementAttrPutS(\
    \ sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n                        EndIf;\n\
    \                    EndIf;\n                EndIf;\n                nLang   = nLang + 1;\n\
    \            End;\n        EndIf;\n        nAttr = nAttr + 1;\n    End;\n\nEndIf;\n\n###\
    \ End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\nIf(pTgtDim @=pTgtHier);\n    sTargetDimHier = pTgtDim;\nElse;\n    sTargetDimHier\
    \ =pTgtDim|':'|pTgtHier;\nEndIf;\n\n### Set the target Sort Order ###\n  CELLPUTS( sSortElementsType,\
    \ '}DimensionProperties', sTargetDimHier, 'SORTELEMENTSTYPE');\n  CELLPUTS( sSortElementsSense,\
    \ '}DimensionProperties', sTargetDimHier, 'SORTELEMENTSSENSE');\n  CELLPUTS( sSortComponentsType,\
    \ '}DimensionProperties',sTargetDimHier, 'SORTCOMPONENTSTYPE');\n  CELLPUTS( sSortComponentsSense,\
    \ '}DimensionProperties', sTargetDimHier, 'SORTCOMPONENTSSENSE');\n  \n### If a new dimension\
    \ has been created, call the process recursively to clone the alternate hierarchy, after\
    \ the same named hierarchy has been processed\nIf( nProcessSameNamedHier = 1 );\n  nRet\
    \ = EXECUTEPROCESS('}bedrock.hier.clone',\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    'pSrcDim', pSrcDim,\n    'pSrcHier',pSrcHier,\n    'pTgtDim',\
    \ pTgtDim,\n    'pTgtHier', sEpilogTgtHier,\n    'pAttr', pAttr,\n    'pUnwind', pUnwind\n\
    \    );\nEndIf;\n  \n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully cloned the %pSrcDim%:%pSrcHier% dimension:hierarchy to %pTgtDim%:%pTgtHier%'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Create an IBM Turbo Integrator process that deletes dimensions specified by a wildcard
    name match, including a single dimension, a list of dimensions, or a set of dimensions.
    This process is intended for development or prototyping. Use it during active agile development
    to remove dimensions due to renaming, change of requirements, etc., or to clean up unused
    dimensions prior to system Go-Live. Note that a valid dimension name pDim or list thereof
    is mandatory; otherwise, the process will abort. Attribute dimensions are deliberately excluded
    because they are automatically cleaned up by removing the base dimension.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will clone the source dimension Hierarchy.\n\
    \n# Use case: Mostly in Development.\n# 1/ Create a duplicate of an existing hierarchy for\
    \ testing.\n\n# Note:\n# Valid source dimension name (pSrcDim) and target dimension (pTgtDim)\
    \ names are mandatory otherwise the process will abort.\n# Valid source hierarchy name (pSrcHier)\
    \ is mandatory otherwise the process will abort.\n\n# Caution:\n# - Target hierarchy cannot\
    \ be `Leaves`.\n# - If the target dimension Hierarchy exists then it will be overwritten.\n\
    #EndRegion @DOC\n\n### Global Varaibales ###\nStringGlobalVariable ('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode = 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp      \
    \  = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%,\
    \ pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%.';\ncLangDim\
    \          = '}Cultures';\nnNumLang          = DimSiz( cLangDim );\n\nnProcessSameNamedHier\
    \ = 0;\nsEpilogTgtHier = '';\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan(\
    \ ':', pSrcDim ) > 0 & pSrcHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pSrcHier\
    \       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long( pSrcDim ) );\n    pSrcDim    \
    \    = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\nEndIf;\n\n## Validate Source dimension\n\
    IF( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No source dimension specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIF( DimensionExists(\
    \ pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid source dimension: ' | pSrcDim;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Source\
    \ hierarchy\nIF( Trim( pSrcHier ) @= '' );\n    pSrcHier = pSrcDim;\nElseIF(HierarchyExists(pSrcDim,pSrcHier\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Target\
    \ dimension\nIF( Trim( pTgtDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No target dimension\
    \ specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( Scan(\
    \ ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pTgtHier\
    \       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim    \
    \    = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\nIf ( DimensionExists( pTgtDim\
    \ ) = 0 );\n  DimensionCreate( pTgtDim );\n  ### In this case clone source hierarchy into\
    \ same-named hierarchy of the new target dimension first. This will allow attributes to\
    \ be processed in the data tab.\n  nProcessSameNamedHier = 1;\nEndIf;\n\n# Validate target\
    \ hierarchy\nIf( pSrcDim @= pTgtDim);\n    If( pTgtHier @= '' % pTgtHier @= pSrcHier );\n\
    \        pTgtHier = pSrcHier | '_Clone';\n    EndIf;\nElseIf(pTgtHier @= '');\n    If( nProcessSameNamedHier\
    \ = 1 );\n      sEpilogTgtHier = pTgtHier;\n      pTgtHier = pTgtDim;\n    Else;\n     \
    \ pTgtHier = pSrcHier;\n    EndIf;\nElseIf( nProcessSameNamedHier = 1 );\n    sEpilogTgtHier\
    \ = pTgtHier;\n    pTgtHier = pTgtDim;\nEndif;\n\npTgtHier = Trim(pTgtHier);\n\nIF(pTgtHier\
    \ @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Leaves is an invalid selection for Target\
    \ Hierarchy: ' | pTgtDim |':'|pTgtHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( DimensionExists( pTgtDim ) = 0 );\n    If( pUnwind >= 1 );\n     \
    \   pUnwind = 2;\n    EndIf;\nElseIf( HierarchyExists( pTgtDim, pTgtHier ) = 0 );\n    If(\
    \ pUnwind >= 1 );\n        pUnwind = 2;\n    EndIf;\nEndIf;    \n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create target dimension Hierarchy\
    \ ###\nIf( HierarchyExists( pTgtDim, pTgtHier) = 0 );\n    HierarchyCreate( pTgtDim, pTgtHier\
    \ );\nElse;\n    IF(pUnwind = 1 );\n      nRet = ExecuteProcess('}bedrock.hier.unwind',\n\
    \        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pDim', pTgtDim,\n        'pHier', pTgtHier,\n        'pConsol', '*',\n       \
    \ 'pRecursive', 1\n        );\n    ELSEIF(pUnwind = 2 );\n      #Do nothing\n    ELSEIF(pUnwind\
    \ = 0 );\n      HierarchyDeleteAllElements( pTgtDim, pTgtHier );\n    EndIf;\nEndIf;\n \
    \ \nIf(pSrcDim @=pSrcHier);\n   sDimHier = pSrcDim;\n Else;\n   sDimHier =pSrcDim|':'|pSrcHier;\n\
    \ Endif;\n  \n### Set the target Sort Order ###\nsSortElementsType     = CELLGETS( '}DimensionProperties',\
    \ sDimHier, 'SORTELEMENTSTYPE');\nsSortElementsSense    = CELLGETS( '}DimensionProperties',\
    \ sDimHier, 'SORTELEMENTSSENSE');\nsSortComponentsType   = CELLGETS( '}DimensionProperties',\
    \ sDimHier, 'SORTCOMPONENTSTYPE');\nsSortComponentsSense  = CELLGETS( '}DimensionProperties',\
    \ sDimHier, 'SORTCOMPONENTSSENSE');\n\nHierarchySortOrder(pTgtDim, pTgtHier, sSortComponentsType,\
    \ sSortComponentsSense, sSortElementsType , sSortElementsSense);\n\nnSourceHierSize = DimSiz(pSrcDim|':'|pSrcHier);\n\
    \nnIndex = 1;\nWHILE( nIndex <= nSourceHierSize );\n  sElName = ElementName(pSrcDim, pSrcHier,\
    \ nIndex);\n  sElType = ElementType(pSrcDim, pSrcHier, sElName);\n  HierarchyElementInsert(pTgtDim,\
    \ pTgtHier, '', sElName, sElType);\n  nIndex = nIndex + 1;\nEND;\n\n### Assign Data Source\
    \ ###\n\nDatasourceNameForServer     = pSrcDim|':'|pSrcHier;\nDataSourceType           \
    \   = 'SUBSET';\nDatasourceDimensionSubset   = 'ALL';\n\n### Replicate Attributes ###\n\n\
    # Note: DType on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\nsAttrDim\
    \        = '}ElementAttributes_' | pSrcDim;\nsAttrLoc        = '}LocalizedElementAttributes_'\
    \ | pSrcDim;\nsAttrTragetDim  = '}ElementAttributes_' | pTgtDim;\nsAttrLocTarget  = '}LocalizedElementAttributes_'\
    \ | pTgtDim;\n\nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n  nNumAttrs = DimSiz(\
    \ sAttrDim );\n  nCount = 1;\n  While( nCount <= nNumAttrs );\n    sAttrName = DimNm( sAttrDim,\
    \ nCount );\n    sAttrType = SubSt(DType( sAttrDim, sAttrName ), 2, 1 );\n      If ( DimensionExists(\
    \ sAttrTragetDim ) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n      \
    \ ElseIF(DimIx(sAttrTragetDim, sAttrName) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType\
    \ );\n      Endif;\n    nCount = nCount + 1;\n  End;\nEndIf;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Add\
    \ Elements to target dimension ###\n\nsElType = ElementType(pSrcDim, pSrcHier, vEle);\n\n\
    IF( sElType @= 'C' & ElementComponentCount( pSrcDim, pSrcHier, vEle  ) > 0 );\n    nChildren\
    \ = ElementComponentCount( pSrcDim, pSrcHier, vEle );\n    nCount = 1;\n    While( nCount\
    \ <= nChildren );\n        sChildElement = ElementComponent( pSrcDim, pSrcHier, vEle, nCount\
    \ );\n        sChildWeight = ElementWeight( pSrcDim,pSrcHier, vEle, sChildElement );\n \
    \       HierarchyElementComponentAdd(pTgtDim, pTgtHier, vEle, sChildElement, sChildWeight);\n\
    \        nCount = nCount + 1;\n    End;\nEndIf;\n\n### End MetaData ###\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Check for\
    \ errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n    \
    \  ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Replicate Attributes\
    \ ###\n# Note: DTYPE on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\
    \nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n\n    nAttr = 1;\n    While( nAttr\
    \ <= nNumAttrs );\n        sAttrName = DimNm( sAttrDim, nAttr );\n        sAttrType = SubSt(\
    \ DTYPE( sAttrDim, sAttrName ), 2, 1 );\n        \n        If( sAttrType @= 'S' % sAttrType\
    \ @= 'A' );\n            sAttrVal = ElementAttrS( pSrcDim, pSrcHier, vEle, sAttrName );\n\
    \            \n            If( sAttrVal @<> '' );\n                If( CellIsUpdateable(\
    \ '}ElementAttributes_' | pTgtDim, pTgtHier:vEle, sAttrName ) = 1 );\n                 \
    \   If( sAttrType @= 'A' );\n                        ElementAttrPutS( sAttrVal, pTgtDim,\
    \ pTgtHier, vEle, sAttrName, 1 );\n                    Else;\n                        ElementAttrPutS(\
    \ sAttrVal, pTgtDim, pTgtHier, vEle, sAttrName );\n                    EndIf;\n        \
    \        EndIf;\n            EndIf;\n        Else;\n            nAttrVal = ElementAttrN(\
    \ pSrcDim, pSrcHier, vEle, sAttrName );\n            If( nAttrVal <> 0 );\n            \
    \    If( CellIsUpdateable( '}ElementAttributes_' | pTgtDim, pTgtHier:vEle, sAttrName ) =\
    \ 1 );\n                    ElementAttrPutN( nAttrVal, pTgtDim, pTgtHier, vEle, sAttrName\
    \ );\n                EndIf;\n            EndIf;  \n        EndIf;\n        # check for\
    \ localized attributes\n        If( CubeExists( sAttrLoc ) = 1 );\n            nLang = 1;\n\
    \            While( nLang <= nNumLang );\n                sLang       = DimNm( cLangDim,\
    \ nLang );\n                If( sAttrType @= 'A' % sAttrType @= 'S' );\n               \
    \     sAttrVal    = ElementAttrS( pSrcDim, pSrcHier, vEle, sAttrName );\n              \
    \      sAttrValLoc = ElementAttrSL( pSrcDim, pSrcHier, vEle, sAttrName, sLang );\n     \
    \               If( sAttrValLoc @= sAttrVal ); sAttrValLoc = ''; EndIf;\n              \
    \  Else;\n                    nAttrVal    = ElementAttrN( pSrcDim, pSrcHier, vEle, sAttrName\
    \ );\n                    nAttrValLoc = ElementAttrNL( pSrcDim, pSrcHier, vEle, sAttrName,\
    \ sLang );\n                EndIf;\n                If( CubeExists( sAttrLocTarget ) = 0\
    \ );\n                    If( sAttrType @= 'A' );\n                        ElementAttrPutS(\
    \ sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang, 1 );\n                    ElseIf(\
    \ sAttrType @= 'N' );\n                        ElementAttrPutN( nAttrValLoc, pTgtDim, pTgtHier,\
    \ vEle, sAttrName, sLang );\n                    Else;\n                        ElementAttrPutS(\
    \ sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n                    EndIf;\n\
    \                ElseIf(CubeExists( sAttrLocTarget ) = 1 );\n                    If( CellIsUpdateable(\
    \ sAttrLocTarget, pTgtHier:vEle, sLang, sAttrName ) = 1 );\n                        If(\
    \ sAttrType @= 'A' );\n                            ElementAttrPutS( sAttrValLoc, pTgtDim,\
    \ pTgtHier, vEle, sAttrName, sLang, 1 );\n                        ElseIf( sAttrType @= 'N'\
    \ );\n                            ElementAttrPutN( nAttrValLoc, pTgtDim, pTgtHier, vEle,\
    \ sAttrName, sLang );\n                        Else;\n                            ElementAttrPutS(\
    \ sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n                        EndIf;\n\
    \                    EndIf;\n                EndIf;\n                nLang   = nLang + 1;\n\
    \            End;\n        EndIf;\n        nAttr = nAttr + 1;\n    End;\n\nEndIf;\n\n###\
    \ End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\nIf(pTgtDim @=pTgtHier);\n    sTargetDimHier = pTgtDim;\nElse;\n    sTargetDimHier\
    \ =pTgtDim|':'|pTgtHier;\nEndIf;\n\n### Set the target Sort Order ###\n  CELLPUTS( sSortElementsType,\
    \ '}DimensionProperties', sTargetDimHier, 'SORTELEMENTSTYPE');\n  CELLPUTS( sSortElementsSense,\
    \ '}DimensionProperties', sTargetDimHier, 'SORTELEMENTSSENSE');\n  CELLPUTS( sSortComponentsType,\
    \ '}DimensionProperties',sTargetDimHier, 'SORTCOMPONENTSTYPE');\n  CELLPUTS( sSortComponentsSense,\
    \ '}DimensionProperties', sTargetDimHier, 'SORTCOMPONENTSSENSE');\n  \n### If a new dimension\
    \ has been created, call the process recursively to clone the alternate hierarchy, after\
    \ the same named hierarchy has been processed\nIf( nProcessSameNamedHier = 1 );\n  nRet\
    \ = EXECUTEPROCESS('}bedrock.hier.clone',\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    'pSrcDim', pSrcDim,\n    'pSrcHier',pSrcHier,\n    'pTgtDim',\
    \ pTgtDim,\n    'pTgtHier', sEpilogTgtHier,\n    'pAttr', pAttr,\n    'pUnwind', pUnwind\n\
    \    );\nEndIf;\n  \n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully cloned the %pSrcDim%:%pSrcHier% dimension:hierarchy to %pTgtDim%:%pTgtHier%'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der es ermöglicht, ein spezifiziertes
    C-Level Element oder ALLE Konsolidierungen in einer Dimensionshierarchie zu löschen. Dieser
    Prozess sollte sowohl während der Entwicklung als auch in der Produktion verwendbar sein.
    Der Nutzer muss sicherstellen, dass ein gültiger Dimensionsname (pDim) angegeben wird, andernfalls
    soll der Prozess abgebrochen werden. Kontrolldimensionen sind von dieser Operation ausgeschlossen.
    Wenn keine Hierarchie (pHier) angegeben wird, sollte standardmäßig pDim verwendet werden.
    Andernfalls muss pHier gültig sein, andernfalls bricht der Prozess ab. Alle konsolidierten
    Elemente in der Hierarchie sollen gelöscht werden, wenn das konsolidierte Element (pEle)
    als * angegeben ist, andernfalls sollte es gültige C-Level Elemente enthalten. Achtung:
    Die Zielhierarchie (pHier) darf nicht ''Leaves'' sein.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete a specified C-Level item **or**\
    \ ALL consolidations in the dimension hierarchy. \n\n# Use case: Could be used during development\
    \ or in production.\n# 1/ Delete a specific or all C-Level items in a hierarchy.\n\n# Note:\n\
    # Valid dimension name (pDim) is mandatory otherwise the process will abort. Control dimensions\
    \ are excluded.\n# The hierarchy (pHier) will default to pDim if not specified, otherwise\
    \ it must be valid else the process will abort.\n# **ALL** consoldidated items in hierarchy\
    \ will be deleted if consolidated item (pEle) is specified as \\*, otherwise it needs to\
    \ contain valid c-level item(s). \n# Caution: Target hierarchy (pHier) cannot be `Leaves`.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncTimeStamp\
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%, pDelim:%pDelim%.';\n\n##\
    \ LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) >\
    \ 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error\
    \ by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan(\
    \ ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim )\
    \ - 1 );\nEndIf;\n\n## Validate Dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n\
    \    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension:\
    \ ' | pDim | ' does not exist on server.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier @= 'Leaves' );\n    nErrors = 1;\n   \
    \ sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n## Validate Elements\nIF(pEle @= '' );\n    nErrors =\
    \ 1;\n    sMessage = 'Element cannot be empty. Use * for all elements';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\nIf( Trim( pHier ) @= '' );\n\
    \    sHier = pDim;\nElse;\n    sHier = pHier;\nEndIf;\n\nIf( HierarchyExists( pDim, sHier\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'The Hierarchy ' | sHier | ' does not exist.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors > 0 );\n  If( pStrictErrorHandling =\
    \ 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsEles =\
    \ pEle;\nnDelimiterIndex = 1;\nWhile( nDelimiterIndex <> 0 );\n    \n    nDelimiterIndex\
    \ = Scan( pDelim, sEles );\n    If( nDelimiterIndex = 0 );\n        sEle = sEles;\n    Else;\n\
    \        sEle = Trim( SubSt( sEles, 1, nDelimiterIndex - 1 ) );\n        sEles = Trim( Subst(\
    \ sEles, nDelimiterIndex + Long(pDelim), Long( sEles ) ) );\n    EndIf;\n  \n    # Check\
    \ if a wildcard has been used to specify the Element name.\n    # If it hasn't then just\
    \ delete the Element if it exists\n    If( sEle @= '*' );\n        nElementIndex = Dimsiz(pDim|':'|sHier);\n\
    \        While( nElementIndex >= 1 );\n            sEle = ElementName( pDim, sHier, nElementIndex\
    \ );\n            sElType = ElementType( pDim, sHier, sEle );\n            If( sElType @=\
    \ 'C' );\n                HierarchyElementDelete( pDim, sHier,sEle );\n            EndIf;\n\
    \            nElementIndex = nElementIndex - 1;\n        End;\n    ElseIf( Scan( '*', sEle\
    \ ) = 0);\n        If( HierarchyElementExists( pDim,sHier, sEle ) = 1 );\n            sElType\
    \ = ElementType( pDim, sHier, sEle ); \n            If( sElType @='C' );\n             \
    \   HierarchyElementDelete( pDim, sHier,sEle );\n            EndIf;\n        Else;\n   \
    \         nErrors = 1;\n            sMessage = 'The Hierarchy ' | sHier | ' does not have\
    \ element ' | sEle;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \        EndIf;\n    Else;\n        # Wildcard search string\n        sEle    = '''|sEle|''';\n\
    \        sProc   = '}bedrock.hier.sub.create.bymdx';\n        sMdx    = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |pDim|':'|sHier |' ])},'| sEle| ')}';\n        ExecuteProcess('}bedrock.hier.sub.create.bymdx',\n\
    \          'pLogOutput', pLogOutput,\n          'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        \t'pDim', pDim,\n        \t'pHier', sHier,\n        \t'pSub', cTempSub,\n     \
    \   \t'pMDXExpr', sMdx,\n        \t'pConvertToStatic', 1,\n        \t'pTemp', 1\n      \
    \  );\n        nCount = HierarchySubsetGetSize(pDim, sHier, cTempSub);\n        While( nCount\
    \ >= 1 );\n            sElement = HierarchySubsetGetElementName(pDim, sHier, cTempSub, nCount);\n\
    \            sElType = ElementType( pDim, sHier, sElement );\n            If( sElType @=\
    \ 'C' );\n                HierarchyElementDelete( pDim, sHier,sElement );\n            EndIf;\
    \  \n            nCount = nCount - 1;\n        End;\n    EndIf;\n\nEnd;\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted the appropriate consolidated elements in hierarchy %pDim%:%pHier%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that allows for the deletion of a specified
    C-Level item or ALL consolidations in a dimension hierarchy. This process should be usable
    both during development and in production. The user must ensure that a valid dimension name
    (pDim) is provided, otherwise the process should abort. Control dimensions are excluded
    from this operation. If no hierarchy (pHier) is specified, pDim should be used by default.
    Otherwise, pHier must be valid, or the process will abort. All consolidated items in the
    hierarchy should be deleted if the consolidated item (pEle) is specified as *, otherwise
    it should contain valid C-Level items. Caution: The target hierarchy (pHier) cannot be ''Leaves''.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete a specified C-Level item **or**\
    \ ALL consolidations in the dimension hierarchy. \n\n# Use case: Could be used during development\
    \ or in production.\n# 1/ Delete a specific or all C-Level items in a hierarchy.\n\n# Note:\n\
    # Valid dimension name (pDim) is mandatory otherwise the process will abort. Control dimensions\
    \ are excluded.\n# The hierarchy (pHier) will default to pDim if not specified, otherwise\
    \ it must be valid else the process will abort.\n# **ALL** consoldidated items in hierarchy\
    \ will be deleted if consolidated item (pEle) is specified as \\*, otherwise it needs to\
    \ contain valid c-level item(s). \n# Caution: Target hierarchy (pHier) cannot be `Leaves`.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncTimeStamp\
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%, pDelim:%pDelim%.';\n\n##\
    \ LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) >\
    \ 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error\
    \ by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan(\
    \ ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim )\
    \ - 1 );\nEndIf;\n\n## Validate Dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n\
    \    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension:\
    \ ' | pDim | ' does not exist on server.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier @= 'Leaves' );\n    nErrors = 1;\n   \
    \ sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n## Validate Elements\nIF(pEle @= '' );\n    nErrors =\
    \ 1;\n    sMessage = 'Element cannot be empty. Use * for all elements';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\nIf( Trim( pHier ) @= '' );\n\
    \    sHier = pDim;\nElse;\n    sHier = pHier;\nEndIf;\n\nIf( HierarchyExists( pDim, sHier\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'The Hierarchy ' | sHier | ' does not exist.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors > 0 );\n  If( pStrictErrorHandling =\
    \ 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsEles =\
    \ pEle;\nnDelimiterIndex = 1;\nWhile( nDelimiterIndex <> 0 );\n    \n    nDelimiterIndex\
    \ = Scan( pDelim, sEles );\n    If( nDelimiterIndex = 0 );\n        sEle = sEles;\n    Else;\n\
    \        sEle = Trim( SubSt( sEles, 1, nDelimiterIndex - 1 ) );\n        sEles = Trim( Subst(\
    \ sEles, nDelimiterIndex + Long(pDelim), Long( sEles ) ) );\n    EndIf;\n  \n    # Check\
    \ if a wildcard has been used to specify the Element name.\n    # If it hasn't then just\
    \ delete the Element if it exists\n    If( sEle @= '*' );\n        nElementIndex = Dimsiz(pDim|':'|sHier);\n\
    \        While( nElementIndex >= 1 );\n            sEle = ElementName( pDim, sHier, nElementIndex\
    \ );\n            sElType = ElementType( pDim, sHier, sEle );\n            If( sElType @=\
    \ 'C' );\n                HierarchyElementDelete( pDim, sHier,sEle );\n            EndIf;\n\
    \            nElementIndex = nElementIndex - 1;\n        End;\n    ElseIf( Scan( '*', sEle\
    \ ) = 0);\n        If( HierarchyElementExists( pDim,sHier, sEle ) = 1 );\n            sElType\
    \ = ElementType( pDim, sHier, sEle ); \n            If( sElType @='C' );\n             \
    \   HierarchyElementDelete( pDim, sHier,sEle );\n            EndIf;\n        Else;\n   \
    \         nErrors = 1;\n            sMessage = 'The Hierarchy ' | sHier | ' does not have\
    \ element ' | sEle;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \        EndIf;\n    Else;\n        # Wildcard search string\n        sEle    = '''|sEle|''';\n\
    \        sProc   = '}bedrock.hier.sub.create.bymdx';\n        sMdx    = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |pDim|':'|sHier |' ])},'| sEle| ')}';\n        ExecuteProcess('}bedrock.hier.sub.create.bymdx',\n\
    \          'pLogOutput', pLogOutput,\n          'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        \t'pDim', pDim,\n        \t'pHier', sHier,\n        \t'pSub', cTempSub,\n     \
    \   \t'pMDXExpr', sMdx,\n        \t'pConvertToStatic', 1,\n        \t'pTemp', 1\n      \
    \  );\n        nCount = HierarchySubsetGetSize(pDim, sHier, cTempSub);\n        While( nCount\
    \ >= 1 );\n            sElement = HierarchySubsetGetElementName(pDim, sHier, cTempSub, nCount);\n\
    \            sElType = ElementType( pDim, sHier, sElement );\n            If( sElType @=\
    \ 'C' );\n                HierarchyElementDelete( pDim, sHier,sElement );\n            EndIf;\
    \  \n            nCount = nCount - 1;\n        End;\n    EndIf;\n\nEnd;\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted the appropriate consolidated elements in hierarchy %pDim%:%pHier%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der wie folgt lautet: Der Prozess
    fügt das konsolidierte Element pTgtConsol in die Dimensionshierarchie hinzu. Anwendungsfall:
    Für die Entwicklung gedacht, kann aber auch in der Produktion verwendet werden. 1/ Erstelle
    eine neue Hierarchie für Tests. 2/ Erstelle eine neue Hierarchie, um neue geschäftliche
    Anforderungen zu reflektieren. Hinweis: Wenn das Quell-Elternelement (pSrcConsol) definiert
    ist, werden alle seine Blattelemente in das Ziel-Elternelement konsolidiert. Andernfalls
    werden alle Blattelemente der Dimensionshierarchie in die Konsolidierung des Ziel-Elternelements
    aufgenommen. Gültige Namen für die Quell-Dimension (pDim), Hierarchie (pHier) und das Ziel-Elternelement
    (pTgtConsol) sind obligatorisch, andernfalls wird der Prozess abgebrochen. Das Gewicht aller
    hinzugefügten Elemente in die Konsolidierung des Ziel-Elternelements wird gemäß dem Wert
    des Parameters pWeight zugewiesen. Achtung: Wenn das Zielelement pTgtConsol in der Hierarchie
    existiert, wird es überschrieben.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Start Prolog ###\n\n#Region @DOC\n# Description:\n# This process will add consolidated\
    \ element pTgtConsol in the dimension hierarchy. \n\n# Use case: Intended for Development\
    \ but could be used in production too.\n# 1/ Create a new hierarchy for testing.\n# 2/ Create\
    \ a new hierarchy to reflect new business needs.\n\n# Note:\n# If source parent element\
    \ (pSrcConsol) is defined then all its leaf elements will be copied to target\n# parent\
    \ element consolidation. Otherwise all leaf elements in the dimension hierarchy will be\
    \ \n# added into target parent element consolidation.\n# Valid source dimension name (pDim),\
    \ hierarchy (pHier) and taget parent element (pTgtConsol)\n# are mandatory otherwise the\
    \ process will abort.\n# Weight of all added elements into target parent consolidation will\
    \ be assigned accoring to\n# pWeight parameter value.\n\n# Caution: If the target element\
    \ pTgtConsol exists in the hierarchy, then it will be overwritten.\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pDim=%pDim%, pHier=%pHier%, pSrcConsol=%pSrcConsol%, pTgtConsol=%pTgtConsol%.';\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim )\
    \ > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim,\
    \ Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\nIF( Trim( pDim ) @= '' );\n    ## No dimension nominated.\n    nErrors\
    \ = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\nIf( DimensionExists( pDim) = 0 );\n    ## Dimension does\
    \ not exist in the model.\n    nErrors = 1;\n    sMessage = 'The dimension does not exist\
    \ in the model: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\nIF( SUBST( pDim, 1, 1 ) @= '}' );\n    ## Nominated dimension is a system dimension.\n\
    \    nErrors = 1;\n    sMessage = 'Can not modify a system dimension with this Bedrock.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate hierarchy\n\
    IF( Trim( pHier  ) @= '' );\n    pHier = pDim;\nEndIf;\n\nIF( HierarchyExists(pDim, pHier\
    \ ) = 0 % pHier @= 'Leaves');\n    nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy:\
    \ ' | pDim |':'|pHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n## Validate consolidation Parameter\npTgtConsol = Trim( pTgtConsol );\nIf( pTgtConsol\
    \ @= '');\n    nErrors = 1;\n    sMessage = 'No target parent element supplied.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( pTgtConsol @= pSrcConsol );\n \
    \   nErrors = 1;\n    sMessage = 'Target and source consolidations can''t be the same elements:\
    \ ' | pTgtConsol |':'| pSrcConsol;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n\n## Validate Member Consolidation\npSrcConsol = Trim( pSrcConsol );\nIF(\
    \ pSrcConsol @<> '' );\n    ## A source consolidation has been nominated.\n    IF(  ElementIndex(\
    \ pDim, pHier, pSrcConsol ) = 0 );\n    ## The Member Consolidation does not exist in the\
    \ dimension.\n        nErrors = 1;\n        sMessage = Expand('Source consolidation %pSrcConsol%\
    \ does not exist in the dimension:hierarchy: %pDim%:%pHier%.');\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    ENDIF;\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### UNWIND CONSOLIDATION ###\nIF( ElementIndex(\
    \ pDim, pHier, pTgtConsol ) > 0 );\n  ExecuteProcess('}bedrock.hier.unwind'\n    ,'pStrictErrorHandling',\
    \ pStrictErrorHandling\n    ,'pDim', pDim\n    ,'pHier',pHier\n    ,'pConsol', pTgtConsol\n\
    \    ,'pRecursive', 0\n  );\nElse;\n    HierarchyElementInsert( pDim, pHier, '', pTgtConsol,\
    \ 'C' );\nENDIF;\n\n### Assign Datasource ###\nDatasourceNameForServer = pDim|':'|pHier;\n\
    DataSourceDimensionSubset = 'All';\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Start Metadata ###\n\
    \n### VALIDATE RECORD ###\n\nsElType = ElementType( pDim, pHier, vElement );\nIF( sElType\
    \ @<> 'N' );\n  ## The element is not a 'N' element.\n  ITEMSKIP;\nENDIF;\n\nIF( pSrcConsol\
    \ @<> '' );\n  ## A member consolidation is been used.\n  IF( ElementIsAncestor( pDim, pHier,\
    \ pSrcConsol, vElement ) = 0 );\n  ## The element is not a member of the nominated consolidation.\n\
    \    ITEMSKIP;\n  ENDIF;\nENDIF;  \n\n### BUILD CONSOLIDATION ###\n\nIf( nErrors = 0 );\n\
    \  HierarchyElementComponentAdd( pDim, pHier, pTgtConsol, vElement, pWeight );\nEndIf;\n\
    \n### End Metadata ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created a consolidation %pTgtConsol% in\
    \ the hierarchy %pDim%:%pHier%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n### End Epilog ###"
- question: 'Create an IBM Turbo Integrator process as follows: This process will add the consolidated
    element pTgtConsol in the dimension hierarchy. Use case: Intended for Development but could
    be used in production too. 1/ Create a new hierarchy for testing. 2/ Create a new hierarchy
    to reflect new business needs. Note: If the source parent element (pSrcConsol) is defined,
    then all its leaf elements will be copied to the target parent element consolidation. Otherwise,
    all leaf elements in the dimension hierarchy will be added into the target parent element
    consolidation. Valid source dimension name (pDim), hierarchy (pHier), and target parent
    element (pTgtConsol) are mandatory, otherwise, the process will abort. Weight of all added
    elements into target parent consolidation will be assigned according to the pWeight parameter
    value. Caution: If the target element pTgtConsol exists in the hierarchy, then it will be
    overwritten.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Start Prolog ###\n\n#Region @DOC\n# Description:\n# This process will add consolidated\
    \ element pTgtConsol in the dimension hierarchy. \n\n# Use case: Intended for Development\
    \ but could be used in production too.\n# 1/ Create a new hierarchy for testing.\n# 2/ Create\
    \ a new hierarchy to reflect new business needs.\n\n# Note:\n# If source parent element\
    \ (pSrcConsol) is defined then all its leaf elements will be copied to target\n# parent\
    \ element consolidation. Otherwise all leaf elements in the dimension hierarchy will be\
    \ \n# added into target parent element consolidation.\n# Valid source dimension name (pDim),\
    \ hierarchy (pHier) and taget parent element (pTgtConsol)\n# are mandatory otherwise the\
    \ process will abort.\n# Weight of all added elements into target parent consolidation will\
    \ be assigned accoring to\n# pWeight parameter value.\n\n# Caution: If the target element\
    \ pTgtConsol exists in the hierarchy, then it will be overwritten.\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pDim=%pDim%, pHier=%pHier%, pSrcConsol=%pSrcConsol%, pTgtConsol=%pTgtConsol%.';\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim )\
    \ > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim,\
    \ Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\nIF( Trim( pDim ) @= '' );\n    ## No dimension nominated.\n    nErrors\
    \ = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\nIf( DimensionExists( pDim) = 0 );\n    ## Dimension does\
    \ not exist in the model.\n    nErrors = 1;\n    sMessage = 'The dimension does not exist\
    \ in the model: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\nIF( SUBST( pDim, 1, 1 ) @= '}' );\n    ## Nominated dimension is a system dimension.\n\
    \    nErrors = 1;\n    sMessage = 'Can not modify a system dimension with this Bedrock.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate hierarchy\n\
    IF( Trim( pHier  ) @= '' );\n    pHier = pDim;\nEndIf;\n\nIF( HierarchyExists(pDim, pHier\
    \ ) = 0 % pHier @= 'Leaves');\n    nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy:\
    \ ' | pDim |':'|pHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n## Validate consolidation Parameter\npTgtConsol = Trim( pTgtConsol );\nIf( pTgtConsol\
    \ @= '');\n    nErrors = 1;\n    sMessage = 'No target parent element supplied.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( pTgtConsol @= pSrcConsol );\n \
    \   nErrors = 1;\n    sMessage = 'Target and source consolidations can''t be the same elements:\
    \ ' | pTgtConsol |':'| pSrcConsol;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n\n## Validate Member Consolidation\npSrcConsol = Trim( pSrcConsol );\nIF(\
    \ pSrcConsol @<> '' );\n    ## A source consolidation has been nominated.\n    IF(  ElementIndex(\
    \ pDim, pHier, pSrcConsol ) = 0 );\n    ## The Member Consolidation does not exist in the\
    \ dimension.\n        nErrors = 1;\n        sMessage = Expand('Source consolidation %pSrcConsol%\
    \ does not exist in the dimension:hierarchy: %pDim%:%pHier%.');\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    ENDIF;\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### UNWIND CONSOLIDATION ###\nIF( ElementIndex(\
    \ pDim, pHier, pTgtConsol ) > 0 );\n  ExecuteProcess('}bedrock.hier.unwind'\n    ,'pStrictErrorHandling',\
    \ pStrictErrorHandling\n    ,'pDim', pDim\n    ,'pHier',pHier\n    ,'pConsol', pTgtConsol\n\
    \    ,'pRecursive', 0\n  );\nElse;\n    HierarchyElementInsert( pDim, pHier, '', pTgtConsol,\
    \ 'C' );\nENDIF;\n\n### Assign Datasource ###\nDatasourceNameForServer = pDim|':'|pHier;\n\
    DataSourceDimensionSubset = 'All';\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Start Metadata ###\n\
    \n### VALIDATE RECORD ###\n\nsElType = ElementType( pDim, pHier, vElement );\nIF( sElType\
    \ @<> 'N' );\n  ## The element is not a 'N' element.\n  ITEMSKIP;\nENDIF;\n\nIF( pSrcConsol\
    \ @<> '' );\n  ## A member consolidation is been used.\n  IF( ElementIsAncestor( pDim, pHier,\
    \ pSrcConsol, vElement ) = 0 );\n  ## The element is not a member of the nominated consolidation.\n\
    \    ITEMSKIP;\n  ENDIF;\nENDIF;  \n\n### BUILD CONSOLIDATION ###\n\nIf( nErrors = 0 );\n\
    \  HierarchyElementComponentAdd( pDim, pHier, pTgtConsol, vElement, pWeight );\nEndIf;\n\
    \n### End Metadata ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created a consolidation %pTgtConsol% in\
    \ the hierarchy %pDim%:%pHier%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess mit den folgenden Anforderungen: Dieser
    Prozess soll eine neue Hierarchie ''pHier'' in der Zieldimension ''pDim'' erstellen. Der
    Anwendungsfall ist primär für die Entwicklung gedacht, kann jedoch auch in der Produktion
    eingesetzt werden. Der Prozess umfasst folgende Schritte: 1) Erstelle eine neue Hierarchie
    zum Testen. 2) Erstelle eine neue Hierarchie, um neue geschäftliche Anforderungen zu reflektieren.
    Hinweis: Falls die Dimension ''pDim'' nicht existiert, soll sie erstellt werden.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a new hierarchy pHier in target\
    \ dimension pDim.\n\n# Use case: Intended for Development but could be used in production\
    \ too.\n# 1/ Create a new hierarchy for testing.\n# 2/ Create a new hierarchy to reflect\
    \ new business needs.\n\n# Note:\n# If dimension pDim doesn't exist, it will be created.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName%\
    \ Message:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim,\
    \ pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim       \
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIf( Trim( pDim ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @=\
    \ '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n# Set up hierachy if not provided\nIf( Trim( pHier ) @= '' );\n  pHier\
    \ = pDim;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\nnDimDelimiterIndex\
    \ = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract\
    \ 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex\
    \ = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long(\
    \ sDims ) ) );\n    EndIf;\n    \n    ###Creating Dimension if not exist, where no wildcard\n\
    \    If( Scan( '*', sDim ) = 0 & Scan( '?', sDim ) = 0 & Scan( pDelim, sDim ) = 0 & DimensionExists(\
    \ sDim ) = 0 );\n      DimensionCreate( sDim );\n      If( pLogOutput = 1 );\n        sMessage\
    \ = Expand( 'Creating  Dimension %sDim%' );\n        LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n      EndIf;\n    EndIf;\n    \n      # Create subset of dimensions using Wildcard\
    \ to loop through dimensions in pDim with wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart\
    \ = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL(\
    \ [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n    IF( sMdx @= ''); \n      sMdx = sMdxPart;\
    \ \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n\nIf( SubsetExists(\
    \ '}Dimensions' , cTempSub ) = 1 );\n    # If a delimited list of dim names includes wildcards\
    \ then we may have to re-use the subset multiple times\n    SubsetMDXSet( '}Dimensions'\
    \ , cTempSub, sMDX );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n\
    \    SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\nEndIf;\n\n# Loop through dimensions\
    \ in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions' , cTempSub\
    \ );\nWhile( nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSub,\
    \ nCountDim );\n    # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n  \
    \      nErrors = 1;\n        sMessage = Expand( 'Dimension %sDim% does not exist.' );\n\
    \        LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n    Else;\n        If( pLogOutput\
    \ = 1 );\n          sMessage = Expand( 'Dimension %sDim% being processed....' );\n     \
    \     LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n        EndIf;\n        # Loop through\
    \ hierarchies in pHier\n        sHierarchies              = pHier;\n        nDelimiterIndexA\
    \    = 1;\n        While( nDelimiterIndexA <> 0 );\n\n            nDelimiterIndexA = Scan(\
    \ pDelim, sHierarchies );\n            If( nDelimiterIndexA = 0 );\n                sHierarchy\
    \   = sHierarchies;\n            Else;\n                sHierarchy   = Trim( SubSt( sHierarchies,\
    \ 1, nDelimiterIndexA - 1 ) );\n                sHierarchies  = Trim( Subst( sHierarchies,\
    \ nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n            EndIf;\n     \
    \       ###Creating Hierarchy\n            If( HierarchyExists( sDim, sHierarchy ) = 1 &\
    \ sDim @<> sHierarchy );\n                nErrors = 1;\n                sMessage = 'The\
    \ Hierachy ' | pHier | ' already exists.';\n                LogOutput( cMsgErrorLevel, sMessage\
    \ );\n            ElseIf( sDim @<> sHierarchy );\n                HierarchyCreate( sDim\
    \ , sHierarchy );\n                If( pLogOutput = 1 );\n                  sMessage = Expand(\
    \ 'Creating hierarchy %sHierarchy% in Dimension %sDim%' );\n                  LogOutput(\
    \ 'INFO', Expand( cMsgInfoContent ) );\n                EndIf;\n            EndIf;\n   \
    \     End;\n    EndIf;\n    \n    nCountDim = nCountDim - 1;\nEnd;\n  \n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction     = Expand( 'Process:%cThisProcName%\
    \ successfully created the %pHier% hierarchy in the %pDim% dimension.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process with the following requirements: This process
    should create a new hierarchy ''pHier'' in target dimension ''pDim''. The use case is primarily
    intended for development but can also be used in production. The process includes the following
    steps: 1) Create a new hierarchy for testing. 2) Create a new hierarchy to reflect new business
    needs. Note: If the dimension ''pDim'' does not exist, it should be created.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a new hierarchy pHier in target\
    \ dimension pDim.\n\n# Use case: Intended for Development but could be used in production\
    \ too.\n# 1/ Create a new hierarchy for testing.\n# 2/ Create a new hierarchy to reflect\
    \ new business needs.\n\n# Note:\n# If dimension pDim doesn't exist, it will be created.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName%\
    \ Message:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim,\
    \ pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim       \
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIf( Trim( pDim ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @=\
    \ '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n# Set up hierachy if not provided\nIf( Trim( pHier ) @= '' );\n  pHier\
    \ = pDim;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\nnDimDelimiterIndex\
    \ = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract\
    \ 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex\
    \ = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long(\
    \ sDims ) ) );\n    EndIf;\n    \n    ###Creating Dimension if not exist, where no wildcard\n\
    \    If( Scan( '*', sDim ) = 0 & Scan( '?', sDim ) = 0 & Scan( pDelim, sDim ) = 0 & DimensionExists(\
    \ sDim ) = 0 );\n      DimensionCreate( sDim );\n      If( pLogOutput = 1 );\n        sMessage\
    \ = Expand( 'Creating  Dimension %sDim%' );\n        LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n      EndIf;\n    EndIf;\n    \n      # Create subset of dimensions using Wildcard\
    \ to loop through dimensions in pDim with wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart\
    \ = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL(\
    \ [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n    IF( sMdx @= ''); \n      sMdx = sMdxPart;\
    \ \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n\nIf( SubsetExists(\
    \ '}Dimensions' , cTempSub ) = 1 );\n    # If a delimited list of dim names includes wildcards\
    \ then we may have to re-use the subset multiple times\n    SubsetMDXSet( '}Dimensions'\
    \ , cTempSub, sMDX );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n\
    \    SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\nEndIf;\n\n# Loop through dimensions\
    \ in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions' , cTempSub\
    \ );\nWhile( nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSub,\
    \ nCountDim );\n    # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n  \
    \      nErrors = 1;\n        sMessage = Expand( 'Dimension %sDim% does not exist.' );\n\
    \        LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n    Else;\n        If( pLogOutput\
    \ = 1 );\n          sMessage = Expand( 'Dimension %sDim% being processed....' );\n     \
    \     LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n        EndIf;\n        # Loop through\
    \ hierarchies in pHier\n        sHierarchies              = pHier;\n        nDelimiterIndexA\
    \    = 1;\n        While( nDelimiterIndexA <> 0 );\n\n            nDelimiterIndexA = Scan(\
    \ pDelim, sHierarchies );\n            If( nDelimiterIndexA = 0 );\n                sHierarchy\
    \   = sHierarchies;\n            Else;\n                sHierarchy   = Trim( SubSt( sHierarchies,\
    \ 1, nDelimiterIndexA - 1 ) );\n                sHierarchies  = Trim( Subst( sHierarchies,\
    \ nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n            EndIf;\n     \
    \       ###Creating Hierarchy\n            If( HierarchyExists( sDim, sHierarchy ) = 1 &\
    \ sDim @<> sHierarchy );\n                nErrors = 1;\n                sMessage = 'The\
    \ Hierachy ' | pHier | ' already exists.';\n                LogOutput( cMsgErrorLevel, sMessage\
    \ );\n            ElseIf( sDim @<> sHierarchy );\n                HierarchyCreate( sDim\
    \ , sHierarchy );\n                If( pLogOutput = 1 );\n                  sMessage = Expand(\
    \ 'Creating hierarchy %sHierarchy% in Dimension %sDim%' );\n                  LogOutput(\
    \ 'INFO', Expand( cMsgInfoContent ) );\n                EndIf;\n            EndIf;\n   \
    \     End;\n    EndIf;\n    \n    nCountDim = nCountDim - 1;\nEnd;\n  \n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction     = Expand( 'Process:%cThisProcName%\
    \ successfully created the %pHier% hierarchy in the %pDim% dimension.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n\n\n### End Epilog ###"
- question: 'Dieser IBM Turbo Integrator Prozess dient dazu, eine neue Dimensionenhierarchie
    basierend auf Attributwerten zu erstellen. Zu beachten ist, dass ein gültiger Dimensionsname
    (pDim) und Attributname (pAttr) zwingend erforderlich sind, andernfalls wird der Prozess
    abgebrochen. Vorsicht: Es wird angenommen, dass jedes Element __nur einmal__ innerhalb der
    Hierarchie existiert. Dies sollte außer in Ausnahmefällen zutreffen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a new dimension hierarchy from\
    \ attribute values.\n\n# Note:\n# Valid dimension name (pDim) and attribute name (pAttr)\
    \ are mandatory, otherwise the\n# process will abort.\n\n# Caution: It is assumed each element\
    \ exists __only once__ within the hierarchy. This should hold true except in exceptional\
    \ circumstances.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp      \
    \  = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncSubset           = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pSrcHier:%pSrcHier%,\
    \ pTgtHier:%pTgtHier%, pAttr:%pAttr%, pTopNode:%pTopNode%, pPrefix:%pPrefix%, pSuffix:%pSuffix%,\
    \ pSkipBlank:%pSkipBlank%, pUnallocated:%pUnallocated%.';\ncAttributeDim     = '}ElementAttributes_'\
    \ | pDim;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':',\
    \ pDim ) > 0 & pSrcHier @= '' );\n    # A hierarchy has been passed as dimension. Handle\
    \ the input error by splitting dim:hier into dimension & hierarchy\n    pSrcHier       =\
    \ SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1,\
    \ Scan( ':', pDim ) - 1 );\nEndIf;\n\nIF( Trim ( pSrcHier ) @= Trim ( pTgtHier ));\n   \
    \ nErrors = 1;\n    sMessage = 'Source and target Herarchy can not be the same';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;    \n    \n## Validate dimension\n\
    If( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists(\
    \ pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension: ' | pDim | ' does not exist.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate Hierarchy\n\
    IF( Trim( pSrcHier  ) @= '' );\n    pSrcHier = Trim( pDim );\nEndIf;\n\nIF( HierarchyExists(\
    \ pDim, pSrcHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy:\
    \ ' | pDim |':'|pSrcHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\npnew =DType( cAttributeDim, pAttr );\n## Validate attribute\nIf( Trim( pAttr )\
    \ @= '' );\n    nErrors = 1;\n    sMessage = 'No attribute specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimIx( cAttributeDim, pAttr ) =\
    \ 0 );\n    nErrors = 1;\n    sMessage = 'Attribute: ' | pAttr | ' does not exists in dimension:\
    \ ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DType(\
    \ cAttributeDim, pAttr ) @<> 'AS' & DType( cAttributeDim, pAttr ) @<> 'AN');\n    ### as\
    \ alias values are all unique, not applicable for creating hierarchy\n    nErrors = 1;\n\
    \    sMessage = 'Only string and numeric attributes may be used for this process.';\n  \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n##  Validate Top\
    \ node name\nIF( Trim( pTopNode  ) @= '' );\n    sTopNode = 'All ' | pAttr;\nElseIF( Subst(Trim(\
    \ pTopNode ),1,7 ) @= '<pAttr>'  );\n    sTopNode = pAttr | ' ' | Subst( pTopNode, 8, Long(\
    \ pTopNode ) );\nElseIF( Subst( pTopNode, Long( pTopNode )-7, 8 ) @= '<pAttr>'  );\n   \
    \ sTopNode = Subst( pTopNode, 1, Long( pTopNode )-8 )  | ' ' | pAttr;\nElseIF( Scan( '<pAttr>',\
    \ pTopNode ) >0 );\n    sTopNode = Subst( pTopNode, 1, Scan( '<pAttr>', pTopNode )-1 ) |\
    \ pAttr | Subst( pTopNode, Scan( '<pAttr>', pTopNode )+7,Long(pTopNode) );\nElse;\t\n  \
    \  sTopNode = pTopNode;\nEndIf;\n\n##  Validate Unallocated node name\nIF( Trim( pUnallocated\
    \  ) @= '' );\n    pUnallocated = 'Unallocated';\nElseIF( Subst(Trim( pUnallocated ),1,7\
    \ ) @= '<pAttr>'  );\n    pUnallocated = pAttr | ' ' | Subst( pUnallocated, 8, Long( pUnallocated\
    \ ) );\nElseIF( Subst( pUnallocated, Long( pUnallocated )-7, 8 ) @= '<pAttr>'  );\n    pUnallocated\
    \ = Subst( pUnallocated, 1, Long( pUnallocated )-8 )  | ' ' | pAttr;\nElseIF( Scan( '<pAttr>',\
    \ pUnallocated ) >0 );\n    pUnallocated = Subst( pUnallocated, 1, Scan( '<pAttr>', pUnallocated\
    \ )-1 ) | pAttr | Subst( pUnallocated, Scan( '<pAttr>', pUnallocated )+7,Long(pUnallocated)\
    \ );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Modify\
    \ attribute for hierarchy name\nsAttribute = Trim(pAttr);\n#If Attribute name has ':' then\
    \ delete as Hierachy names are not allowed with ':' \nIf(Scan(':', sAttribute) > 0);\n \
    \       nStart = 0;\n        WHILE ( nStart <> 1 );\n            nSpecialChar = SCAN ( ':',\
    \ sAttribute );\n        \tIF ( nSpecialChar <> 0 );\n        \t\tsAttribute  = DELET (sAttribute\
    \ , nSpecialChar, 1 );\n        \tELSE;\n        \t\tnStart = 1;\n        \tENDIF;\n   \
    \     END;\nEndIf;\n\n### Create target dimension Hierarchy ###\nIf(pTgtHier @= '');\n \
    \ sTargetHierarchy = sAttribute;\nElse;\n  sTargetHierarchy = pTgtHier;\nEndIf;\n\nIf( HierarchyExists(\
    \ pDim, sTargetHierarchy ) = 0 );\n    HierarchyCreate( pDim, sTargetHierarchy );\nElse;\n\
    \  IF ( pUnwind = 1 );\n    ExecuteProcess('}bedrock.hier.unwind',\n       'pLogOutput',\
    \ pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n       'pDim', pDim,\n\
    \       'pHier', sTargetHierarchy,\n       'pConsol', '*',\n       'pRecursive', 0,\n  \
    \     'pDelim', '&'\n      );\n  Else;   \n    HierarchyDeleteAllElements( pDim, sTargetHierarchy\
    \ );\n  Endif;  \nEndIf;\n\n#Target consol does not exist then add element to dimension.\n\
    If( ElementIndex(pDim, sTargetHierarchy, sTopNode) = 0);\n    HierarchyElementinsert(pDim,\
    \ sTargetHierarchy, '',sTopNode, 'C');\nEndif;\n\n### Format Prefix and Suffix with trailing\
    \ or leading ' ' ###\nIF( pPrefix @<> '' );\n    IF( SUBST( pPrefix, Long( pPrefix), 1)\
    \ @<> ' ' );\n        sPrefix = pPrefix | ' ';\n    ELSE;\n        sPrefix = pPrefix;\n\
    \    ENDIF;\nENDIF;\n\nIF( pSuffix @<> '' );\n    IF( SUBST( pSuffix, 1, 1) @<> ' ' );\n\
    \        sSuffix = ' ' | pSuffix;\n    ELSE;\n        sSuffix = pSuffix;\n    ENDIF;\nENDIF;\n\
    \n\n### Assign Data Source ###\nDatasourceNameForServer   = pDim|':'|pSrcHier;\nDatasourceNameForClient\
    \   = pDim|':'|pSrcHier;\nDataSourceType            = 'SUBSET';\nDatasourceDimensionSubset\
    \ = 'ALL';\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Check for errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Skip\
    \ if the Element is not leaf element\nIf( ElementType(pDim, pSrcHier, vEle) @<> 'N' );\n\
    \    ItemSkip;\nEndif;\n\n# Skip if top node\nIf( vEle @= sTopNode );\n    ItemSkip;\nENDIF;\n\
    \nIf( DType( cAttributeDim, pAttr ) @= 'AS' );\n  sAttrVal = ElementAttrS(pDim, pSrcHier,\
    \ vEle, pAttr);\nElse; \n  sAttrVal = NumberToString(ElementAttrN(pDim, pSrcHier, vEle,\
    \ pAttr));\nEndIf; \nsParent = sAttrVal;\n\n# Manage not populated attribute.\nIf( sParent\
    \ @= '' & pSkipBlank = 0 );\n    ItemSkip;\nElseIf( sParent @= '' & pSkipBlank <> 0 ); \
    \ \n    sParent = pUnallocated;\nEndIf;\n\n#If parent does not exist AND allow insertion\
    \ of new parents is TRUE then insert new consol\n## Add the attribute value to the top node.\n\
    \  \n  sElPar = sPrefix | sParent | sSuffix;\n\n  HierarchyElementinsert(pDim, sTargetHierarchy,\
    \ '',sElPar, 'C');\n  HierarchyElementComponentAdd(pDim, sTargetHierarchy, sTopNode, sElPar,\
    \ 1);\n  \n  HierarchyElementinsert(pDim, sTargetHierarchy, '',vEle, 'N' );\n  HierarchyElementComponentAdd(pDim,\
    \ sTargetHierarchy, sElPar, vEle, 1);\n\n### End Metadata ###\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully created the %sTargetHierarchy%\
    \ hierarchy in the %pDim% dimension.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'This IBM Turbo Integrator process is designed to create a new dimension hierarchy
    based on attribute values. Please note that a valid dimension name (pDim) and attribute
    name (pAttr) are mandatory; otherwise, the process will abort. Caution: It is assumed that
    each element exists __only once__ within the hierarchy. This should hold true except in
    exceptional circumstances.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a new dimension hierarchy from\
    \ attribute values.\n\n# Note:\n# Valid dimension name (pDim) and attribute name (pAttr)\
    \ are mandatory, otherwise the\n# process will abort.\n\n# Caution: It is assumed each element\
    \ exists __only once__ within the hierarchy. This should hold true except in exceptional\
    \ circumstances.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp      \
    \  = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncSubset           = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pSrcHier:%pSrcHier%,\
    \ pTgtHier:%pTgtHier%, pAttr:%pAttr%, pTopNode:%pTopNode%, pPrefix:%pPrefix%, pSuffix:%pSuffix%,\
    \ pSkipBlank:%pSkipBlank%, pUnallocated:%pUnallocated%.';\ncAttributeDim     = '}ElementAttributes_'\
    \ | pDim;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':',\
    \ pDim ) > 0 & pSrcHier @= '' );\n    # A hierarchy has been passed as dimension. Handle\
    \ the input error by splitting dim:hier into dimension & hierarchy\n    pSrcHier       =\
    \ SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1,\
    \ Scan( ':', pDim ) - 1 );\nEndIf;\n\nIF( Trim ( pSrcHier ) @= Trim ( pTgtHier ));\n   \
    \ nErrors = 1;\n    sMessage = 'Source and target Herarchy can not be the same';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;    \n    \n## Validate dimension\n\
    If( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists(\
    \ pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension: ' | pDim | ' does not exist.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate Hierarchy\n\
    IF( Trim( pSrcHier  ) @= '' );\n    pSrcHier = Trim( pDim );\nEndIf;\n\nIF( HierarchyExists(\
    \ pDim, pSrcHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy:\
    \ ' | pDim |':'|pSrcHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\npnew =DType( cAttributeDim, pAttr );\n## Validate attribute\nIf( Trim( pAttr )\
    \ @= '' );\n    nErrors = 1;\n    sMessage = 'No attribute specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimIx( cAttributeDim, pAttr ) =\
    \ 0 );\n    nErrors = 1;\n    sMessage = 'Attribute: ' | pAttr | ' does not exists in dimension:\
    \ ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DType(\
    \ cAttributeDim, pAttr ) @<> 'AS' & DType( cAttributeDim, pAttr ) @<> 'AN');\n    ### as\
    \ alias values are all unique, not applicable for creating hierarchy\n    nErrors = 1;\n\
    \    sMessage = 'Only string and numeric attributes may be used for this process.';\n  \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n##  Validate Top\
    \ node name\nIF( Trim( pTopNode  ) @= '' );\n    sTopNode = 'All ' | pAttr;\nElseIF( Subst(Trim(\
    \ pTopNode ),1,7 ) @= '<pAttr>'  );\n    sTopNode = pAttr | ' ' | Subst( pTopNode, 8, Long(\
    \ pTopNode ) );\nElseIF( Subst( pTopNode, Long( pTopNode )-7, 8 ) @= '<pAttr>'  );\n   \
    \ sTopNode = Subst( pTopNode, 1, Long( pTopNode )-8 )  | ' ' | pAttr;\nElseIF( Scan( '<pAttr>',\
    \ pTopNode ) >0 );\n    sTopNode = Subst( pTopNode, 1, Scan( '<pAttr>', pTopNode )-1 ) |\
    \ pAttr | Subst( pTopNode, Scan( '<pAttr>', pTopNode )+7,Long(pTopNode) );\nElse;\t\n  \
    \  sTopNode = pTopNode;\nEndIf;\n\n##  Validate Unallocated node name\nIF( Trim( pUnallocated\
    \  ) @= '' );\n    pUnallocated = 'Unallocated';\nElseIF( Subst(Trim( pUnallocated ),1,7\
    \ ) @= '<pAttr>'  );\n    pUnallocated = pAttr | ' ' | Subst( pUnallocated, 8, Long( pUnallocated\
    \ ) );\nElseIF( Subst( pUnallocated, Long( pUnallocated )-7, 8 ) @= '<pAttr>'  );\n    pUnallocated\
    \ = Subst( pUnallocated, 1, Long( pUnallocated )-8 )  | ' ' | pAttr;\nElseIF( Scan( '<pAttr>',\
    \ pUnallocated ) >0 );\n    pUnallocated = Subst( pUnallocated, 1, Scan( '<pAttr>', pUnallocated\
    \ )-1 ) | pAttr | Subst( pUnallocated, Scan( '<pAttr>', pUnallocated )+7,Long(pUnallocated)\
    \ );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Modify\
    \ attribute for hierarchy name\nsAttribute = Trim(pAttr);\n#If Attribute name has ':' then\
    \ delete as Hierachy names are not allowed with ':' \nIf(Scan(':', sAttribute) > 0);\n \
    \       nStart = 0;\n        WHILE ( nStart <> 1 );\n            nSpecialChar = SCAN ( ':',\
    \ sAttribute );\n        \tIF ( nSpecialChar <> 0 );\n        \t\tsAttribute  = DELET (sAttribute\
    \ , nSpecialChar, 1 );\n        \tELSE;\n        \t\tnStart = 1;\n        \tENDIF;\n   \
    \     END;\nEndIf;\n\n### Create target dimension Hierarchy ###\nIf(pTgtHier @= '');\n \
    \ sTargetHierarchy = sAttribute;\nElse;\n  sTargetHierarchy = pTgtHier;\nEndIf;\n\nIf( HierarchyExists(\
    \ pDim, sTargetHierarchy ) = 0 );\n    HierarchyCreate( pDim, sTargetHierarchy );\nElse;\n\
    \  IF ( pUnwind = 1 );\n    ExecuteProcess('}bedrock.hier.unwind',\n       'pLogOutput',\
    \ pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n       'pDim', pDim,\n\
    \       'pHier', sTargetHierarchy,\n       'pConsol', '*',\n       'pRecursive', 0,\n  \
    \     'pDelim', '&'\n      );\n  Else;   \n    HierarchyDeleteAllElements( pDim, sTargetHierarchy\
    \ );\n  Endif;  \nEndIf;\n\n#Target consol does not exist then add element to dimension.\n\
    If( ElementIndex(pDim, sTargetHierarchy, sTopNode) = 0);\n    HierarchyElementinsert(pDim,\
    \ sTargetHierarchy, '',sTopNode, 'C');\nEndif;\n\n### Format Prefix and Suffix with trailing\
    \ or leading ' ' ###\nIF( pPrefix @<> '' );\n    IF( SUBST( pPrefix, Long( pPrefix), 1)\
    \ @<> ' ' );\n        sPrefix = pPrefix | ' ';\n    ELSE;\n        sPrefix = pPrefix;\n\
    \    ENDIF;\nENDIF;\n\nIF( pSuffix @<> '' );\n    IF( SUBST( pSuffix, 1, 1) @<> ' ' );\n\
    \        sSuffix = ' ' | pSuffix;\n    ELSE;\n        sSuffix = pSuffix;\n    ENDIF;\nENDIF;\n\
    \n\n### Assign Data Source ###\nDatasourceNameForServer   = pDim|':'|pSrcHier;\nDatasourceNameForClient\
    \   = pDim|':'|pSrcHier;\nDataSourceType            = 'SUBSET';\nDatasourceDimensionSubset\
    \ = 'ALL';\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Check for errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Skip\
    \ if the Element is not leaf element\nIf( ElementType(pDim, pSrcHier, vEle) @<> 'N' );\n\
    \    ItemSkip;\nEndif;\n\n# Skip if top node\nIf( vEle @= sTopNode );\n    ItemSkip;\nENDIF;\n\
    \nIf( DType( cAttributeDim, pAttr ) @= 'AS' );\n  sAttrVal = ElementAttrS(pDim, pSrcHier,\
    \ vEle, pAttr);\nElse; \n  sAttrVal = NumberToString(ElementAttrN(pDim, pSrcHier, vEle,\
    \ pAttr));\nEndIf; \nsParent = sAttrVal;\n\n# Manage not populated attribute.\nIf( sParent\
    \ @= '' & pSkipBlank = 0 );\n    ItemSkip;\nElseIf( sParent @= '' & pSkipBlank <> 0 ); \
    \ \n    sParent = pUnallocated;\nEndIf;\n\n#If parent does not exist AND allow insertion\
    \ of new parents is TRUE then insert new consol\n## Add the attribute value to the top node.\n\
    \  \n  sElPar = sPrefix | sParent | sSuffix;\n\n  HierarchyElementinsert(pDim, sTargetHierarchy,\
    \ '',sElPar, 'C');\n  HierarchyElementComponentAdd(pDim, sTargetHierarchy, sTopNode, sElPar,\
    \ 1);\n  \n  HierarchyElementinsert(pDim, sTargetHierarchy, '',vEle, 'N' );\n  HierarchyElementComponentAdd(pDim,\
    \ sTargetHierarchy, sElPar, vEle, 1);\n\n### End Metadata ###\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully created the %sTargetHierarchy%\
    \ hierarchy in the %pDim% dimension.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine alternative Hierarchie aus
    einem konsolidierten Element und seinen untergeordneten Elementen in der Standardhierarchie
    erstellt. Beachte, dass der gültige Quell-Dimensionsname (pSrcDim) und die Quelldimension
    (pSubset) zwingend erforderlich sind. Andernfalls wird der Prozess abgebrochen. Wird ein
    Quell-Hierarchiename (pSrcHier) angegeben, muss dieser ebenfalls gültig sein, sonst bricht
    der Prozess ab. Achte darauf, dass die Zielhierarchie nicht `Leaves` genannt werden kann
    und falls die Zielhierarchie bereits existiert, wird sie überschrieben. Nutze diesen Prozess,
    um eine neue Hierarchie für Tests oder zur Anpassung an neue geschäftliche Anforderungen
    zu erstellen.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make an aternative hierarchy from a\
    \ consolidated element and its children in default hierarchy.\n\n# Use case: Intended for\
    \ Development but could be used in production too.\n# 1/ Create a new hierarchy for testing.\n\
    # 2/ Create a new hierarchy to reflect new business needs.\n\n# Note:\n# Valid source dimension\
    \ name (pSrcDim) and source subset (pSubset) are mandatory, otherwise the process will abort.\n\
    # If a source hierarchy name (pSrcHier) is specified, it needs to be valid, otherwise the\
    \ process will abort.\n\n# Caution:\n# - Target hierarchy cannot be `Leaves`.\n# - If the\
    \ target Hierarchy already exists, then it will be overwritten.\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%, pConsol:%pConsol%, pTgtDim:%pTgtDim%,\
    \ pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%, pRemove:%pRemove%.';\ncHierAttr\
    \         = 'Bedrock.Descendant';\ncAttrVal          = 'Descendant';\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= '' );\n    #\
    \ A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim )\
    \ + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim )\
    \ - 1 );\nEndIf;\n\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim\
    \ ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n\
    # Validate source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate\
    \ source Hierarchy\nIF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim,\
    \ pSrcHier) = 0);\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n\n## Validate consolidation\n\
    pConsol = Trim( pConsol );\nIf( pConsol @<> '' );\n    If( ElementIndex ( pSrcDim, pSrcHier,\
    \ pConsol ) = 0 );\n        nErrors = 1;\n        sMessage = 'The ' | pConsol | ' consolidation\
    \ does not exist in the '| pSrcDim |' dimension:Hierarchy ' | pSrcDim |':'| pSrcHier;\n\
    \        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate\
    \ target Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\nEndif;\n\nIF( DimensionExists(\
    \ pTgtDim ) = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n### Create target dimension\
    \ Hierarchy ###\nIF(pTgtHier @= '');\n    pTgtHier = pTgtDim;\nEndIf;\n\n##########################################\n\
    # Bedrock subprocesses\n\n#create subset\nExecuteProcess('}bedrock.hier.sub.create',\n \
    \ 'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\
    \t'pHier', pSrcHier,\n\t'pSub', cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp', 1\n);\n\nExecuteProcess('}bedrock.hier.create.fromsubset',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pSrcDim',pSrcDim,\n\
    \  'pSrcHier', pSrcHier,\n  'pSubset', cTempSub,\n  'pTgtDim', pTgtDim,\n  'pTgtHier', pTgtHier,\n\
    \  'pAttr', pAttr,\n  'pUnwind', pUnwind\n);\n\nIF(pRemove = 1);\n  ExecuteProcess('}bedrock.hier.unwind',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\
    \t'pConsol', pConsol,\n\t'pRecursive', 1\n);\n\n  ExecuteProcess('}bedrock.hier.emptyconsols.delete',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\
    \t'pHier', pSrcHier\n);\n\nEndif;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n\n\n#Section Epilog\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned dimension:hierarchy\
    \ %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based on the %pConsol% consolidated element.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates an alternative hierarchy from
    a consolidated element and its children in the default hierarchy. Note that a valid source
    dimension name (pSrcDim) and source subset (pSubset) are mandatory, otherwise the process
    will abort. If a source hierarchy name (pSrcHier) is specified, it needs to be valid, otherwise
    the process will abort. Be cautious that the target hierarchy cannot be called `Leaves`
    and, if the target hierarchy already exists, it will be overwritten. Use this process to
    create a new hierarchy for testing or to reflect new business needs.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make an aternative hierarchy from a\
    \ consolidated element and its children in default hierarchy.\n\n# Use case: Intended for\
    \ Development but could be used in production too.\n# 1/ Create a new hierarchy for testing.\n\
    # 2/ Create a new hierarchy to reflect new business needs.\n\n# Note:\n# Valid source dimension\
    \ name (pSrcDim) and source subset (pSubset) are mandatory, otherwise the process will abort.\n\
    # If a source hierarchy name (pSrcHier) is specified, it needs to be valid, otherwise the\
    \ process will abort.\n\n# Caution:\n# - Target hierarchy cannot be `Leaves`.\n# - If the\
    \ target Hierarchy already exists, then it will be overwritten.\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%, pConsol:%pConsol%, pTgtDim:%pTgtDim%,\
    \ pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%, pRemove:%pRemove%.';\ncHierAttr\
    \         = 'Bedrock.Descendant';\ncAttrVal          = 'Descendant';\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= '' );\n    #\
    \ A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim )\
    \ + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim )\
    \ - 1 );\nEndIf;\n\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim\
    \ ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n\
    # Validate source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate\
    \ source Hierarchy\nIF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim,\
    \ pSrcHier) = 0);\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n\n## Validate consolidation\n\
    pConsol = Trim( pConsol );\nIf( pConsol @<> '' );\n    If( ElementIndex ( pSrcDim, pSrcHier,\
    \ pConsol ) = 0 );\n        nErrors = 1;\n        sMessage = 'The ' | pConsol | ' consolidation\
    \ does not exist in the '| pSrcDim |' dimension:Hierarchy ' | pSrcDim |':'| pSrcHier;\n\
    \        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate\
    \ target Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\nEndif;\n\nIF( DimensionExists(\
    \ pTgtDim ) = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n### Create target dimension\
    \ Hierarchy ###\nIF(pTgtHier @= '');\n    pTgtHier = pTgtDim;\nEndIf;\n\n##########################################\n\
    # Bedrock subprocesses\n\n#create subset\nExecuteProcess('}bedrock.hier.sub.create',\n \
    \ 'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\
    \t'pHier', pSrcHier,\n\t'pSub', cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp', 1\n);\n\nExecuteProcess('}bedrock.hier.create.fromsubset',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pSrcDim',pSrcDim,\n\
    \  'pSrcHier', pSrcHier,\n  'pSubset', cTempSub,\n  'pTgtDim', pTgtDim,\n  'pTgtHier', pTgtHier,\n\
    \  'pAttr', pAttr,\n  'pUnwind', pUnwind\n);\n\nIF(pRemove = 1);\n  ExecuteProcess('}bedrock.hier.unwind',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\
    \t'pConsol', pConsol,\n\t'pRecursive', 1\n);\n\n  ExecuteProcess('}bedrock.hier.emptyconsols.delete',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\
    \t'pHier', pSrcHier\n);\n\nEndif;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n\n\n#Section Epilog\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned dimension:hierarchy\
    \ %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based on the %pConsol% consolidated element.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine alternative Hierarchie aus
    einem konsolidierten Element und seinen Kindern in der Standardhierarchie erstellt. Der
    Anwendungsfall umfasst sowohl Entwicklungs- als auch Produktionsszenarien, indem entweder
    eine neue Hierarchie für Testzwecke oder zur Abbildung neuer Geschäftsanforderungen geschaffen
    wird. Beachte, dass ein gültiger Quell-Dimensionsname (pSrcDim) und ein Quell-Subset (pSubset)
    erforderlich sind, andernfalls wird der Prozess abgebrochen. Falls ein Quell-Hierarchiename
    (pSrcHier) angegeben wird, muss dieser ebenfalls gültig sein, um einen Abbruch zu vermeiden.
    Wichtig: Die Zielhierarchie darf nicht ''Leaves'' sein und bestehende Zielhierarchien werden
    überschrieben.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make an aternative hierarchy from a\
    \ consolidated element and its children in default hierarchy.\n\n# Use case: Intended for\
    \ Development but could be used in production too.\n# 1/ Create a new hierarchy for testing.\n\
    # 2/ Create a new hierarchy to reflect new business needs.\n\n# Note:\n# Valid source dimension\
    \ name (pSrcDim) and source subset (pSubset) are mandatory, otherwise the process will abort.\n\
    # If a source hierarchy name (pSrcHier) is specified, it needs to be valid, otherwise the\
    \ process will abort.\n\n# Caution:\n# - Target hierarchy cannot be `Leaves`.\n# - If the\
    \ target Hierarchy already exists, then it will be overwritten.\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%, pConsol:%pConsol%, pTgtDim:%pTgtDim%,\
    \ pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%, pRemove:%pRemove%, pAliasSwap:%pAliasSwap%.';\n\
    cHierAttr         = 'Bedrock.Descendant';\ncAttrVal          = 'Descendant';\n\n## LogOutput\
    \ parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \n### Validate Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @=\
    \ '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting\
    \ dim:hier into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim\
    \ ) + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim\
    \ ) - 1 );\nEndIf;\n\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim\
    \ ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n\
    # Validate source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate\
    \ source Hierarchy\nIF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim,\
    \ pSrcHier) = 0);\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n\n## Validate consolidation\n\
    pConsol = Trim( pConsol );\nIf( pConsol @<> '' );\n    If( ElementIndex ( pSrcDim, pSrcHier,\
    \ pConsol ) = 0 );\n        nErrors = 1;\n        sMessage = 'The ' | pConsol | ' consolidation\
    \ does not exist in the '| pSrcDim |' dimension:Hierarchy ' | pSrcDim |':'| pSrcHier;\n\
    \        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n\
    ## Validate Attribute\nIf( pAliasSwap @= '' );\n    nErrors = 1;\n    sMessage = 'The name\
    \ of the attribute to swap not specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;  \n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate\
    \ target Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\nEndif;\n\nIF( DimensionExists(\
    \ pTgtDim ) = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n### Create target dimension\
    \ Hierarchy ###\nIF(pTgtHier @= '');\n    pTgtHier = pTgtDim;\nEndIf;\n\n##########################################\n\
    # Bedrock subprocesses\n\n\n#create subset\nExecuteProcess('}bedrock.hier.sub.create',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\
    \t'pHier', pSrcHier,\n\t'pSub', cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp', 1\n);\n\ncTempDim\
    \ = pSrcDim|'_'| cTimeStamp |'_'| cRandomInt;\n\nExecuteProcess('}bedrock.hier.create.fromsubset',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pSrcDim',pSrcDim,\n\
    \  'pSrcHier', pSrcHier,\n  'pSubset', cTempSub,\n  'pTgtDim', cTempDim,\n  'pTgtHier',\
    \ cTempDim,\n  'pAttr', 1,\n  'pUnwind', 0\n);\n\nExecuteProcess('}bedrock.dim.attr.create',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pDim',cTempDim,\n\
    \  'pAttr', cTempDim,\n  'pAttrType','A'\n);\n\nExecuteProcess('}bedrock.cube.data.copy',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pCube',\
    \ '}ElementAttributes_'|cTempDim,\n  'pEleMapping','}ElementAttributes_'|cTempDim|':'|pAliasSwap|'->'|cTempDim\n\
    );\n\nExecuteProcess('}bedrock.dim.attr.swapalias',\n  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n  'pDim',cTempDim,\n  'pAlias', cTempDim\n);\n\nExecuteProcess('}bedrock.hier.sub.create',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',\
    \ cTempDim,\n\t'pHier', cTempDim,\n\t'pSub', cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp',\
    \ 0\n);\n\nExecuteProcess('}bedrock.hier.create.fromsubset',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n  'pSrcDim', cTempDim,\n  'pSrcHier',\
    \ cTempDim,\n  'pSubset', cTempSub,\n  'pTgtDim', pTgtDim,\n  'pTgtHier', pTgtHier,\n  'pAttr',\
    \ pAttr,\n  'pUnwind', pUnwind\n);\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\nExecuteProcess('}bedrock.dim.attr.delete',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pDim',\
    \ pTgtDim,\n  'pAttr', cTempDim\n);\n\nExecuteProcess('}bedrock.dim.delete',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim', cTempDim\n);\n\n\nIF(pRemove\
    \ = 1);\n  ExecuteProcess('}bedrock.hier.unwind',\n  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier,\n\t'pConsol', pConsol,\n\
    \t'pRecursive', 1\n);\n\n  ExecuteProcess('}bedrock.hier.emptyconsols.delete',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier\n\
    );\n\nEndif;\n\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n \
    \   sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully cloned dimension:hierarchy %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based\
    \ on the %pConsol% consolidated element.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Develop an IBM Turbo Integrator process that creates an alternative hierarchy from
    a consolidated element and its children in the default hierarchy. The use case involves
    both development and production scenarios, either by creating a new hierarchy for testing
    purposes or to reflect new business needs. Note that a valid source dimension name (pSrcDim)
    and source subset (pSubset) are mandatory, otherwise, the process will abort. If a source
    hierarchy name (pSrcHier) is specified, it also needs to be valid to avoid aborting. Caution:
    The target hierarchy cannot be ''Leaves'' and existing target hierarchies will be overwritten.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make an aternative hierarchy from a\
    \ consolidated element and its children in default hierarchy.\n\n# Use case: Intended for\
    \ Development but could be used in production too.\n# 1/ Create a new hierarchy for testing.\n\
    # 2/ Create a new hierarchy to reflect new business needs.\n\n# Note:\n# Valid source dimension\
    \ name (pSrcDim) and source subset (pSubset) are mandatory, otherwise the process will abort.\n\
    # If a source hierarchy name (pSrcHier) is specified, it needs to be valid, otherwise the\
    \ process will abort.\n\n# Caution:\n# - Target hierarchy cannot be `Leaves`.\n# - If the\
    \ target Hierarchy already exists, then it will be overwritten.\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%, pConsol:%pConsol%, pTgtDim:%pTgtDim%,\
    \ pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%, pRemove:%pRemove%, pAliasSwap:%pAliasSwap%.';\n\
    cHierAttr         = 'Bedrock.Descendant';\ncAttrVal          = 'Descendant';\n\n## LogOutput\
    \ parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \n### Validate Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @=\
    \ '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting\
    \ dim:hier into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim\
    \ ) + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim\
    \ ) - 1 );\nEndIf;\n\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim\
    \ ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n\
    # Validate source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate\
    \ source Hierarchy\nIF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim,\
    \ pSrcHier) = 0);\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n\n## Validate consolidation\n\
    pConsol = Trim( pConsol );\nIf( pConsol @<> '' );\n    If( ElementIndex ( pSrcDim, pSrcHier,\
    \ pConsol ) = 0 );\n        nErrors = 1;\n        sMessage = 'The ' | pConsol | ' consolidation\
    \ does not exist in the '| pSrcDim |' dimension:Hierarchy ' | pSrcDim |':'| pSrcHier;\n\
    \        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n\
    ## Validate Attribute\nIf( pAliasSwap @= '' );\n    nErrors = 1;\n    sMessage = 'The name\
    \ of the attribute to swap not specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;  \n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate\
    \ target Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\nEndif;\n\nIF( DimensionExists(\
    \ pTgtDim ) = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n### Create target dimension\
    \ Hierarchy ###\nIF(pTgtHier @= '');\n    pTgtHier = pTgtDim;\nEndIf;\n\n##########################################\n\
    # Bedrock subprocesses\n\n\n#create subset\nExecuteProcess('}bedrock.hier.sub.create',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\
    \t'pHier', pSrcHier,\n\t'pSub', cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp', 1\n);\n\ncTempDim\
    \ = pSrcDim|'_'| cTimeStamp |'_'| cRandomInt;\n\nExecuteProcess('}bedrock.hier.create.fromsubset',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pSrcDim',pSrcDim,\n\
    \  'pSrcHier', pSrcHier,\n  'pSubset', cTempSub,\n  'pTgtDim', cTempDim,\n  'pTgtHier',\
    \ cTempDim,\n  'pAttr', 1,\n  'pUnwind', 0\n);\n\nExecuteProcess('}bedrock.dim.attr.create',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pDim',cTempDim,\n\
    \  'pAttr', cTempDim,\n  'pAttrType','A'\n);\n\nExecuteProcess('}bedrock.cube.data.copy',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pCube',\
    \ '}ElementAttributes_'|cTempDim,\n  'pEleMapping','}ElementAttributes_'|cTempDim|':'|pAliasSwap|'->'|cTempDim\n\
    );\n\nExecuteProcess('}bedrock.dim.attr.swapalias',\n  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n  'pDim',cTempDim,\n  'pAlias', cTempDim\n);\n\nExecuteProcess('}bedrock.hier.sub.create',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',\
    \ cTempDim,\n\t'pHier', cTempDim,\n\t'pSub', cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp',\
    \ 0\n);\n\nExecuteProcess('}bedrock.hier.create.fromsubset',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n  'pSrcDim', cTempDim,\n  'pSrcHier',\
    \ cTempDim,\n  'pSubset', cTempSub,\n  'pTgtDim', pTgtDim,\n  'pTgtHier', pTgtHier,\n  'pAttr',\
    \ pAttr,\n  'pUnwind', pUnwind\n);\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\nExecuteProcess('}bedrock.dim.attr.delete',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pDim',\
    \ pTgtDim,\n  'pAttr', cTempDim\n);\n\nExecuteProcess('}bedrock.dim.delete',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim', cTempDim\n);\n\n\nIF(pRemove\
    \ = 1);\n  ExecuteProcess('}bedrock.hier.unwind',\n  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier,\n\t'pConsol', pConsol,\n\
    \t'pRecursive', 1\n);\n\n  ExecuteProcess('}bedrock.hier.emptyconsols.delete',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier\n\
    );\n\nEndif;\n\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n \
    \   sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully cloned dimension:hierarchy %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based\
    \ on the %pConsol% consolidated element.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine Kopie eines bestehenden
    Dimensions-Subsets erstellt und es als neue Dimension-Hierarchie anlegt. Der Prozess ist
    für Entwicklungszwecke gedacht, kann jedoch auch in der Produktion eingesetzt werden. Erstelle
    eine neue Hierarchie für Tests oder um neuen geschäftlichen Anforderungen gerecht zu werden.
    Beachte, dass der Name der Quelldimension (pSrcDim) und das Quell-Subset (pSubset) zwingend
    erforderlich sind; andernfalls bricht der Prozess ab. Wenn ein Name der Quellhierarchie
    (pSrcHier) angegeben wird, muss dieser gültig sein, ansonsten wird der Prozess abgebrochen.
    Vorsicht: Die Zielhierarchie kann nicht ''Leaves'' sein. Wenn die Zielhierarchie bereits
    existiert, wird sie überschrieben.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make a copy of an existing dimension\
    \ subset, creating it as a new dimension hierarchy.\n\n# Use case: Intended for Development\
    \ but could be used in production too.\n# 1. Create a new hierarchy for testing.\n# 2. Create\
    \ a new hierarchy to reflect new business needs.\n\n# Note:\n# Valid source dimension name\
    \ (pSrcDim) and source subset (pSubset) are mandatory, otherwise the process will abort.\n\
    # If a source hierarchy name (pSrcHier) is specified, it needs to be valid, otherwise the\
    \ process will abort.\n\n# Caution:\n# - Target hierarchy cannot be Leaves.\n# - If the\
    \ target Hierarchy already exists, then it will be overwritten.\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%, pSubset:%pSubset%, pTgtDim:%pTgtDim%,\
    \ pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%, pFlat:%pFlat%.';\ncHierAttr   \
    \      = 'Bedrock.Descendant';\ncAttrVal          = 'Descendant';\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= '' );\n    #\
    \ A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim )\
    \ + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim )\
    \ - 1 );\nEndIf;\n\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim\
    \ ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n\
    # Validate source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n   If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate\
    \ source Hierarchy\nIF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim,\
    \ pSrcHier) = 0);\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n## Validate Source\
    \ Subset\nIF(HierarchySubsetExists( pSrcDim, pSrcHier, pSubset) = 0 );\n    sMessage = 'No\
    \ valid source subset: ' | pSubset;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nELSE;\n    cSubset = pSubset;\n    nSubsetSize = HierarchySubsetGetSize( pSrcDim,\
    \ pSrcHier, pSubset );\nENDIF;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Validate target Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\n\
    Endif;\n\nIF( DimensionExists( pTgtDim ) = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n\
    ### Create target dimension Hierarchy ###\nIF(pTgtHier @= '');\n    pTgtHier = pTgtDim;\n\
    EndIf;\n\n\nIf( HierarchyExists(pTgtDim, pTgtHier) = 0 );\n    HierarchyCreate( pTgtDim,\
    \ pTgtHier );\nElse;\n    IF(pUnwind = 1 );\n        ExecuteProcess( '}bedrock.hier.unwind',\
    \ 'pLogOutput', 0,\n            'pStrictErrorHandling', pStrictErrorHandling,\n        \
    \    'pDim', pTgtDim, 'pHier', pTgtHier, 'pConsol', '*',\n            'pRecursive', 1\n\
    \        );\n    ELSEIF(\n        pUnwind = 2 );\n        #Do nothing\n    ELSE;\n     \
    \   HierarchyDeleteAllElements( pTgtDim, pTgtHier );\n    EndIf;\nEndIf;\n\n### Assign Data\
    \ Source ###\nDatasourceNameForServer = pSrcDim|':'|pSrcHier;\nDatasourceNameForClient =\
    \ pSrcDim|':'|pSrcHier;\nDataSourceType = 'SUBSET';\nDatasourceDimensionSubset = cSubset;\n\
    \n### Set Descendent attribute value\nAttrDelete( pSrcDim, cHierAttr );\nAttrInsert( pSrcDim,\
    \ '', cHierAttr, 'S' );\n\n# Disable excessive transaction logging of the attributes cube\
    \ if it is logged\nsAttrCube = '}ElementAttributes_' | pSrcDim;\nnAttrCubeLogChanges = CubeGetLogChanges(sAttrCube);\n\
    If( nAttrCubeLogChanges = 1 );\n   CubeSetLogChanges( sAttrCube, 0 );\nEndIf;\n\nnIndex\
    \ = 1;\nnLimit = HierarchySubsetGetSize( pSrcDim, pSrcHier, pSubset );\nWHILE( nIndex <=\
    \ nLimit);\n    sElName = SubsetGetElementName( pSrcDim|':'|pSrcHier, pSubset, nIndex );\n\
    \    ElementAttrPuts( cAttrVal, pSrcDim, pSrcHier, sElName, cHierAttr );\n    sElType =\
    \ ElementType( pSrcDim, pSrcHier, sElName );\n    HierarchyElementInsert(pTgtDim, pTgtHier,\
    \ '',sElName, sELType);\n    nIndex = nIndex + 1;\nEND;\n\n# Re-enable transaction logging\
    \ setting of the attributes cube if required\nIf( nAttrCubeLogChanges = 1 );\n   CubeSetLogChanges(\
    \ sAttrCube, 1 );\nEndIf;\n\n### Replicate Attributes ###\n# Note: DType on Attr dim returns\
    \ 'AS', 'AN' or 'AA' need to strip off leading 'A'\n \nsAttrDim = '}ElementAttributes_'\
    \ | pSrcDim;\nsLastAttr = '';\nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n    nNumAttrs\
    \ = DimSiz( sAttrDim );\n    nCount = 1;\n    While( nCount <= nNumAttrs );\n        sAttrName\
    \ = DimNm( sAttrDim, nCount );\n        sAttrType = SubSt(DType( sAttrDim, sAttrName ),\
    \ 2, 1 );\n        AttrInsert( pTgtDim, sLastAttr, sAttrName, sAttrType );\n        sLastAttr\
    \ = sAttrName;\n        nCount = nCount + 1;\n    End;\nEndIf;\n \n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling =\
    \ 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nIf (pFlat\
    \ = 1);\n    ##Creating the Flat hierarchy subset in the target dimension\n    sElType =\
    \ ElementType(pSrcDim, pSrcHier, vElement);\n    ## Add the element to the target dimension.\n\
    \    ## 'C' elements can't be inserted as 'N' elements in the same dimension\n    IF(pTgtdim\
    \ @= pSrcDim);\n        IF(sElType @<> 'C' );\n            HierarchyElementInsert( pTgtDim,\
    \ pTgtHier, '', vElement, sElType );\n        Else;\n            If( pLogOutput = 1 );\n\
    \                sMessage = 'Name conflict! Cannot create leaf element %vElement% in dimension\
    \ %pTgtDim% as C element with same name already exists.';\n                LogOutput( 'WARN',\
    \ Expand( cMsgErrorContent ) );\n            EndIf;\n        EndIf;\n    Else;\n       \
    \ IF(sElType @= 'C' );\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement,\
    \ 'N' );\n        Else;\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement,\
    \ sElType );\n        EndIf;\n    EndIf;\nElse;\n    nIndex = 1;\n    nLimit = ElementComponentCount(\
    \ pSrcDim, pSrcHier, vElement );\n    WHILE( nIndex <= nLimit );\n        sElName = ElementComponent(\
    \ pSrcDim, pSrcHier, vElement, nIndex );\n        sDecendant = ElementAttrS(pSrcDim, pSrcHier,\
    \ sElName, cHierAttr);\n        IF(\n            sDecendant @= cAttrVal);\n            nElWeight\
    \ = ElementWeight( pSrcDim, pSrcHier, vElement, sElName );\n            HierarchyElementComponentAdd(\
    \ pTgtDim, pTgtHier, vElement, sElName, nElWeight );\n        ENDIF;\n        nIndex = nIndex\
    \ + 1;\n    END;\nEndif;\n\n### End MetaData ###\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n\n### Check for errors in prolog\
    \ ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n\n### Replicate Attributes ###\n\n# Note: DTYPE\
    \ on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\nIf( pAttr = 1\
    \ );\n\n    nCount = 1;\n    While( nCount <= nNumAttrs );\n        sAttrName = DimNm( sAttrDim,\
    \ nCount );\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ), 2, 1 );\n        If(\
    \ sAttrType @= 'S' % sAttrType @= 'A' );\n            sAttrVal = ElementAttrS(pSrcDim, pSrcHier,\
    \ vElement, sAttrName);\n            If( sAttrVal @<> '' );\n                ElementAttrPutS(\
    \ sAttrVal, pTgtDim,pTgtHier, vElement, sAttrName,1 );\n            EndIf;\n        Else;\n\
    \            nAttrVal = ElementAttrN(pSrcDim, pSrcHier, vElement, sAttrName);\n        \
    \    If( nAttrVal <> 0 );\n                ElementAttrPutN( nAttrVal, pTgtDim, pTgtHier,\
    \ vElement, sAttrName );\n            EndIf;\n        EndIf;\n        nCount = nCount +\
    \ 1;\n    End;\n\n  EndIf;\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Set Target dimension sort order\
    \ ###\n\nIf(pSrcDim @= pSrcHier);\n    sSourceElement = pSrcDim;\nElse;\n    sSourceElement\
    \ = pSrcDim|':'|pSrcHier;\nEndif;\nIf(pTgtDim @= pTgtHier);\n    sTargetElement = pTgtDim;\n\
    Else;\n    sTargetElement = pTgtDim|':'|pTgtHier;\nEndif;\n\nsCube = '}DimensionProperties';\n\
    IF(CubeExists ( sCube ) = 1 );\n  sEleMapping = '}Dimensions' |'¦'|sSourceElement|'->'|sTargetElement;\n\
    \  ExecuteProcess( '}bedrock.cube.data.copy',\n  'pLogOutput', pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n  'pCube', sCube,\n  'pSrcView', '',\n  'pTgtView', '',\n  'pFilter',\
    \  '',\n  'pEleMapping', sEleMapping,\n  'pMappingDelim','->',\n  'pFactor', 1,\n  'pDimDelim',\
    \ '&',\n  'pEleStartDelim', '¦',\n  'pEleDelim', '+',\n  'pSuppressRules', 0 ,\n  'pCumulate',\
    \ 0 ,\n  'pZeroSource', 0, \n  'pZeroTarget', 1,\n  'pTemp', 1\n   );\nENDIF;\n  \nsCube\
    \ = '}HierarchyProperties';\nIF(CubeExists ( sCube ) = 1 );\n  sEleMapping = '}Dimensions'\
    \ |'¦'|sSourceElement|'->'|sTargetElement;\n  ExecuteProcess( '}bedrock.cube.data.copy',\n\
    \  'pLogOutput', pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pCube',\
    \ sCube,\n  'pSrcView', '',\n  'pTgtView', '',\n  'pFilter',  '',\n  'pEleMapping', sEleMapping,\n\
    \  'pMappingDelim','->',\n  'pFactor', 1,\n  'pDimDelim', '&',\n  'pEleStartDelim', '¦',\n\
    \  'pEleDelim', '+',\n  'pSuppressRules', 0 ,\n  'pCumulate', 0 ,\n  'pZeroSource', 0, \n\
    \  'pZeroTarget', 1,\n  'pTemp', 1\n   );\nENDIF;\n\n\n### Set Descendent attribute value\n\
    AttrDelete( pSrcDim, cHierAttr );\nIf( pAttr = 1 );\n    AttrDelete( pTgtDim, cHierAttr\
    \ );\nENDIF;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n   \
    \ sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully cloned dimension:hierarchy %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based\
    \ on the %pSubset% subset.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that makes a copy of an existing dimension
    subset and creates it as a new dimension hierarchy. The process is intended for development
    purposes but can also be used in production. Create a new hierarchy for testing or to reflect
    new business needs. Note that a valid source dimension name (pSrcDim) and source subset
    (pSubset) are mandatory; otherwise, the process will abort. If a source hierarchy name (pSrcHier)
    is specified, it must be valid; otherwise, the process will abort. Caution: The target hierarchy
    cannot be ''Leaves''. If the target hierarchy already exists, it will be overwritten.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make a copy of an existing dimension\
    \ subset, creating it as a new dimension hierarchy.\n\n# Use case: Intended for Development\
    \ but could be used in production too.\n# 1. Create a new hierarchy for testing.\n# 2. Create\
    \ a new hierarchy to reflect new business needs.\n\n# Note:\n# Valid source dimension name\
    \ (pSrcDim) and source subset (pSubset) are mandatory, otherwise the process will abort.\n\
    # If a source hierarchy name (pSrcHier) is specified, it needs to be valid, otherwise the\
    \ process will abort.\n\n# Caution:\n# - Target hierarchy cannot be Leaves.\n# - If the\
    \ target Hierarchy already exists, then it will be overwritten.\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%, pSubset:%pSubset%, pTgtDim:%pTgtDim%,\
    \ pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%, pFlat:%pFlat%.';\ncHierAttr   \
    \      = 'Bedrock.Descendant';\ncAttrVal          = 'Descendant';\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= '' );\n    #\
    \ A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim )\
    \ + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim )\
    \ - 1 );\nEndIf;\n\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim\
    \ ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n\
    # Validate source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n   If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate\
    \ source Hierarchy\nIF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim,\
    \ pSrcHier) = 0);\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n## Validate Source\
    \ Subset\nIF(HierarchySubsetExists( pSrcDim, pSrcHier, pSubset) = 0 );\n    sMessage = 'No\
    \ valid source subset: ' | pSubset;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nELSE;\n    cSubset = pSubset;\n    nSubsetSize = HierarchySubsetGetSize( pSrcDim,\
    \ pSrcHier, pSubset );\nENDIF;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Validate target Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\n\
    Endif;\n\nIF( DimensionExists( pTgtDim ) = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n\
    ### Create target dimension Hierarchy ###\nIF(pTgtHier @= '');\n    pTgtHier = pTgtDim;\n\
    EndIf;\n\n\nIf( HierarchyExists(pTgtDim, pTgtHier) = 0 );\n    HierarchyCreate( pTgtDim,\
    \ pTgtHier );\nElse;\n    IF(pUnwind = 1 );\n        ExecuteProcess( '}bedrock.hier.unwind',\
    \ 'pLogOutput', 0,\n            'pStrictErrorHandling', pStrictErrorHandling,\n        \
    \    'pDim', pTgtDim, 'pHier', pTgtHier, 'pConsol', '*',\n            'pRecursive', 1\n\
    \        );\n    ELSEIF(\n        pUnwind = 2 );\n        #Do nothing\n    ELSE;\n     \
    \   HierarchyDeleteAllElements( pTgtDim, pTgtHier );\n    EndIf;\nEndIf;\n\n### Assign Data\
    \ Source ###\nDatasourceNameForServer = pSrcDim|':'|pSrcHier;\nDatasourceNameForClient =\
    \ pSrcDim|':'|pSrcHier;\nDataSourceType = 'SUBSET';\nDatasourceDimensionSubset = cSubset;\n\
    \n### Set Descendent attribute value\nAttrDelete( pSrcDim, cHierAttr );\nAttrInsert( pSrcDim,\
    \ '', cHierAttr, 'S' );\n\n# Disable excessive transaction logging of the attributes cube\
    \ if it is logged\nsAttrCube = '}ElementAttributes_' | pSrcDim;\nnAttrCubeLogChanges = CubeGetLogChanges(sAttrCube);\n\
    If( nAttrCubeLogChanges = 1 );\n   CubeSetLogChanges( sAttrCube, 0 );\nEndIf;\n\nnIndex\
    \ = 1;\nnLimit = HierarchySubsetGetSize( pSrcDim, pSrcHier, pSubset );\nWHILE( nIndex <=\
    \ nLimit);\n    sElName = SubsetGetElementName( pSrcDim|':'|pSrcHier, pSubset, nIndex );\n\
    \    ElementAttrPuts( cAttrVal, pSrcDim, pSrcHier, sElName, cHierAttr );\n    sElType =\
    \ ElementType( pSrcDim, pSrcHier, sElName );\n    HierarchyElementInsert(pTgtDim, pTgtHier,\
    \ '',sElName, sELType);\n    nIndex = nIndex + 1;\nEND;\n\n# Re-enable transaction logging\
    \ setting of the attributes cube if required\nIf( nAttrCubeLogChanges = 1 );\n   CubeSetLogChanges(\
    \ sAttrCube, 1 );\nEndIf;\n\n### Replicate Attributes ###\n# Note: DType on Attr dim returns\
    \ 'AS', 'AN' or 'AA' need to strip off leading 'A'\n \nsAttrDim = '}ElementAttributes_'\
    \ | pSrcDim;\nsLastAttr = '';\nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n    nNumAttrs\
    \ = DimSiz( sAttrDim );\n    nCount = 1;\n    While( nCount <= nNumAttrs );\n        sAttrName\
    \ = DimNm( sAttrDim, nCount );\n        sAttrType = SubSt(DType( sAttrDim, sAttrName ),\
    \ 2, 1 );\n        AttrInsert( pTgtDim, sLastAttr, sAttrName, sAttrType );\n        sLastAttr\
    \ = sAttrName;\n        nCount = nCount + 1;\n    End;\nEndIf;\n \n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling =\
    \ 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nIf (pFlat\
    \ = 1);\n    ##Creating the Flat hierarchy subset in the target dimension\n    sElType =\
    \ ElementType(pSrcDim, pSrcHier, vElement);\n    ## Add the element to the target dimension.\n\
    \    ## 'C' elements can't be inserted as 'N' elements in the same dimension\n    IF(pTgtdim\
    \ @= pSrcDim);\n        IF(sElType @<> 'C' );\n            HierarchyElementInsert( pTgtDim,\
    \ pTgtHier, '', vElement, sElType );\n        Else;\n            If( pLogOutput = 1 );\n\
    \                sMessage = 'Name conflict! Cannot create leaf element %vElement% in dimension\
    \ %pTgtDim% as C element with same name already exists.';\n                LogOutput( 'WARN',\
    \ Expand( cMsgErrorContent ) );\n            EndIf;\n        EndIf;\n    Else;\n       \
    \ IF(sElType @= 'C' );\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement,\
    \ 'N' );\n        Else;\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement,\
    \ sElType );\n        EndIf;\n    EndIf;\nElse;\n    nIndex = 1;\n    nLimit = ElementComponentCount(\
    \ pSrcDim, pSrcHier, vElement );\n    WHILE( nIndex <= nLimit );\n        sElName = ElementComponent(\
    \ pSrcDim, pSrcHier, vElement, nIndex );\n        sDecendant = ElementAttrS(pSrcDim, pSrcHier,\
    \ sElName, cHierAttr);\n        IF(\n            sDecendant @= cAttrVal);\n            nElWeight\
    \ = ElementWeight( pSrcDim, pSrcHier, vElement, sElName );\n            HierarchyElementComponentAdd(\
    \ pTgtDim, pTgtHier, vElement, sElName, nElWeight );\n        ENDIF;\n        nIndex = nIndex\
    \ + 1;\n    END;\nEndif;\n\n### End MetaData ###\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n\n### Check for errors in prolog\
    \ ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n\n### Replicate Attributes ###\n\n# Note: DTYPE\
    \ on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\nIf( pAttr = 1\
    \ );\n\n    nCount = 1;\n    While( nCount <= nNumAttrs );\n        sAttrName = DimNm( sAttrDim,\
    \ nCount );\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ), 2, 1 );\n        If(\
    \ sAttrType @= 'S' % sAttrType @= 'A' );\n            sAttrVal = ElementAttrS(pSrcDim, pSrcHier,\
    \ vElement, sAttrName);\n            If( sAttrVal @<> '' );\n                ElementAttrPutS(\
    \ sAttrVal, pTgtDim,pTgtHier, vElement, sAttrName,1 );\n            EndIf;\n        Else;\n\
    \            nAttrVal = ElementAttrN(pSrcDim, pSrcHier, vElement, sAttrName);\n        \
    \    If( nAttrVal <> 0 );\n                ElementAttrPutN( nAttrVal, pTgtDim, pTgtHier,\
    \ vElement, sAttrName );\n            EndIf;\n        EndIf;\n        nCount = nCount +\
    \ 1;\n    End;\n\n  EndIf;\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Set Target dimension sort order\
    \ ###\n\nIf(pSrcDim @= pSrcHier);\n    sSourceElement = pSrcDim;\nElse;\n    sSourceElement\
    \ = pSrcDim|':'|pSrcHier;\nEndif;\nIf(pTgtDim @= pTgtHier);\n    sTargetElement = pTgtDim;\n\
    Else;\n    sTargetElement = pTgtDim|':'|pTgtHier;\nEndif;\n\nsCube = '}DimensionProperties';\n\
    IF(CubeExists ( sCube ) = 1 );\n  sEleMapping = '}Dimensions' |'¦'|sSourceElement|'->'|sTargetElement;\n\
    \  ExecuteProcess( '}bedrock.cube.data.copy',\n  'pLogOutput', pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n  'pCube', sCube,\n  'pSrcView', '',\n  'pTgtView', '',\n  'pFilter',\
    \  '',\n  'pEleMapping', sEleMapping,\n  'pMappingDelim','->',\n  'pFactor', 1,\n  'pDimDelim',\
    \ '&',\n  'pEleStartDelim', '¦',\n  'pEleDelim', '+',\n  'pSuppressRules', 0 ,\n  'pCumulate',\
    \ 0 ,\n  'pZeroSource', 0, \n  'pZeroTarget', 1,\n  'pTemp', 1\n   );\nENDIF;\n  \nsCube\
    \ = '}HierarchyProperties';\nIF(CubeExists ( sCube ) = 1 );\n  sEleMapping = '}Dimensions'\
    \ |'¦'|sSourceElement|'->'|sTargetElement;\n  ExecuteProcess( '}bedrock.cube.data.copy',\n\
    \  'pLogOutput', pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pCube',\
    \ sCube,\n  'pSrcView', '',\n  'pTgtView', '',\n  'pFilter',  '',\n  'pEleMapping', sEleMapping,\n\
    \  'pMappingDelim','->',\n  'pFactor', 1,\n  'pDimDelim', '&',\n  'pEleStartDelim', '¦',\n\
    \  'pEleDelim', '+',\n  'pSuppressRules', 0 ,\n  'pCumulate', 0 ,\n  'pZeroSource', 0, \n\
    \  'pZeroTarget', 1,\n  'pTemp', 1\n   );\nENDIF;\n\n\n### Set Descendent attribute value\n\
    AttrDelete( pSrcDim, cHierAttr );\nIf( pAttr = 1 );\n    AttrDelete( pTgtDim, cHierAttr\
    \ );\nENDIF;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n   \
    \ sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully cloned dimension:hierarchy %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based\
    \ on the %pSubset% subset.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine Dimension oder Hierarchie
    (oder eine Liste davon) löscht. Anwendungsfall: Gedacht für Entwicklung/Prototyping, um
    ungenutzte Dimensionen/Hierarchien nach dem Go-Live zu bereinigen. Hinweis: Ein gültiger
    Dimensionsname (pDim) ist zwingend erforderlich, sonst wird der Prozess abgebrochen. Wenn
    keine Hierarchie (pHier) angegeben ist, wird die Dimension gelöscht, sofern sie nicht von
    einem regulären Würfel verwendet wird. Bei Angabe einer Hierarchie muss diese gültig sein,
    andernfalls wird der Prozess abgebrochen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a dimension or hierarchy (or a list\
    \ thereof).\n\n# Use case: Intended for development/prototyping.\n# 1/ Clean up unused dimension/hierarchies\
    \ after Go Live.\n\n# Note:\n# Naturally, a valid dimension name (pDim) is mandatory otherwise\
    \ the process will abort.\n# If no hierarchy (pHier) is specified the dimension will be\
    \ deleted if not in use by a **regular** cube.\n# If a hierarchy is specified, it must be\
    \ valid otherwise the process will abort.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp      \
    \  = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pDelim:%pDelim%.';\
    \ \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*', pDim )\
    \ = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier\
    \ @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting\
    \ dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim )\
    \ + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\
    \nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( Scan( '*', pDim ) =\
    \ 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & DimensionExists( pDim ) = 0 );\n\
    \    nErrors = 1;\n    sMessage = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  ## use same name\
    \ as Dimension. Since wildcards are allowed this is managed inside the code below\nElseIf(\
    \ Trim( pHier ) @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid hierarchy: 'Leaves'.';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(  Scan( '*', pHier )\
    \ = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pDim ) = 0 & Scan(\
    \ '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Trim( pHier ) @= Trim( pDim ) );\n  nErrors\
    \ = 1;\n  sMessage = 'Cannot delete same named hierarchy: '}bedrock.dim.delete' process\
    \ should be used for this purpose';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @=\
    \ '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n\nIF( Scan( '*', pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim,\
    \ pHier ) = 0 & Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0\
    \ );\n    If( HierarchyExists( pDim, pHier ) = 0 );\n        nError = 1;\n        sMessage\
    \ = 'The Hierachy '' | pHier | '' is not available in '' | pDim | '' dimension' ;\n    \
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n        HierarchyDestroy(\
    \ pDim  ,pHier );\n    Endif;\nElseIf( pHier @= 'Leaves');\n    nError = 1;\n    sMessage\
    \ = 'The Hierachy is Leaves and can not be destroyed';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElse;\n    # Loop through dimensions in pDim\n    sDims = pDim;\n\
    \    nDimDelimiterIndex = 1;\n    sMdx = '';\n    # Get 1st dimension\n    While( nDimDelimiterIndex\
    \ <> 0 );\n        # Extract 1st dimension > sDim\n        nDimDelimiterIndex = Scan( pDelim,\
    \ sDims );\n        If( nDimDelimiterIndex = 0 );\n            sDim = sDims;\n        Else;\n\
    \            sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n            sDims\
    \ = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n        EndIf;\n\
    \        \n          # Create subset of dimensions using Wildcard to loop through dimensions\
    \ in pDim with wildcard\n        sDimExp = '''|sDim|''';\n        sMdxPart = '{TM1FILTERBYPATTERN(\
    \ EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) , '*:*') ) ,'| sDimExp | ')}';\n        IF( sMdx @= ''); \n          sMdx = sMdxPart;\
    \ \n        ELSE;\n          sMdx = sMdx | ' + ' | sMdxPart;\n        ENDIF;\n    End;\n\
    \    \n    If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n        # If a delimited\
    \ list of dim names includes wildcards then we may have to re-use the subset multiple times\n\
    \        SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n    Else;\n        # temp subset,\
    \ therefore no need to destroy in epilog\n        SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions'\
    \ , 1 );\n    EndIf;\n    \n    # Loop through dimensions in subset created based on wildcard\n\
    \    nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n    While( nCountDim >= 1 );\n\
    \        sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim );\n        #\
    \ Validate dimension name\n        If( DimensionExists(sDim) = 0 );\n            nErrors\
    \ = 1;\n            sMessage = Expand( 'Dimension %sDim% does not exist.' );\n         \
    \   LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            If( pLogOutput\
    \ = 1 );\n              sMessage = Expand( 'Dimension %sDim% being processed....' );\n \
    \             LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n            EndIf;\n    \
    \        # Loop through hierarchies in pHier\n            If( Trim( pHier ) @= '' );\n \
    \             ### Use main hierarchy for each dimension if pHier is empty\n            \
    \  sHierarchies = sDim;\n            Else;\n              sHierarchies              = pHier;\n\
    \            EndIf;\n            nDelimiterIndexA    = 1;\n            sHierDim        \
    \    = '}Hierarchies_'|sDim ;\n            sMdxHier = '';\n            While( nDelimiterIndexA\
    \ <> 0 );\n    \n                nDelimiterIndexA = Scan( pDelim, sHierarchies );\n    \
    \            If( nDelimiterIndexA = 0 );\n                    sHierarchy   = sHierarchies;\n\
    \                Else;\n                    sHierarchy   = Trim( SubSt( sHierarchies, 1,\
    \ nDelimiterIndexA - 1 ) );\n                    sHierarchies  = Trim( Subst( sHierarchies,\
    \ nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n                EndIf;\n \
    \               \n                # Create subset of Hierarchies using Wildcard\n      \
    \          sHierExp = '''|sDim|':'|sHierarchy|''';\n                sMdxHierPart = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp | ')}';\n                IF( sMdxHier @=\
    \ ''); \n                  sMdxHier = sMdxHierPart; \n                ELSE;\n          \
    \        sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n                ENDIF;\n         \
    \   End;\n    \n            If( SubsetExists( sHierDim, cTempSub ) = 1 );\n            \
    \    # If a delimited list of attr names includes wildcards then we may have to re-use the\
    \ subset multiple times\n                SubsetMDXSet( sHierDim, cTempSub, sMdxHier );\n\
    \            Else;\n                # temp subset, therefore no need to destroy in epilog\n\
    \                SubsetCreatebyMDX( cTempSub, sMdxHier, sHierDim, 1 );\n            EndIf;\n\
    \        \n            # Loop through subset of hierarchies created based on wildcard\n\
    \            nCountHier = SubsetGetSize( sHierDim, cTempSub );\n            While( nCountHier\
    \ >= 1 );\n                sCurrHier = SubsetGetElementName( sHierDim, cTempSub, nCountHier\
    \ );\n                sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier)\
    \ );\n                \n                # Validate hierarchy name in dimension\n       \
    \         If( Dimix( sHierDim , sCurrHier ) = 0 );\n                    sMessage = Expand('The\
    \ %sCurrHier% hierarchy does NOT exist in the %sDim% dimension.');\n                   \
    \ LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n                Else;\n            \
    \      If( pLogOutput = 1 );\n                    sMessage = Expand( 'Hierarchy %sCurrHierName%\
    \ in Dimension %sDim% being processed....' );\n                    LogOutput( 'INFO', Expand(\
    \ cMsgInfoContent ) );\n                  EndIf;\n                  If( Trim( sCurrHierName\
    \ ) @= Trim( sDim ) );\n                      ## Do not remove main hierarchy\n        \
    \          ElseIf( sCurrHierName @= 'Leaves');\n                      If( pLogOutput = 1\
    \ );\n                        sMessage = 'The Hierachy is Leaves and can not be destroyed';\n\
    \                        LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n             \
    \         EndIf;\n                  Else;\n                      HierarchyDestroy( sDim,\
    \ sCurrHierName );\n                      If( pLogOutput = 1 );\n                      \
    \  sMessage = Expand( 'Destroying hierarchy %sCurrHierName% in Dimension %sDim%' );\n  \
    \                    LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n                 \
    \ EndIf;\n                  Endif;\n                Endif;\n              \n           \
    \     nCountHier = nCountHier - 1;\n            End;\n                \n        EndIf;\n\
    \        \n        nCountDim = nCountDim - 1;\n    End;\nEndIf;\n\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction     = Expand( 'Process:%cThisProcName%\
    \ successfully deleted the dimension:hierarchy %pDim%:%pHier%' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that deletes a dimension or hierarchy (or
    a list thereof). Use case: Intended for development/prototyping to clean up unused dimensions/hierarchies
    after Go-Live. Note: A valid dimension name (pDim) is mandatory; otherwise, the process
    will abort. If no hierarchy (pHier) is specified, the dimension will be deleted if not in
    use by a regular cube. If a hierarchy is specified, it must be valid; otherwise, the process
    will abort.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a dimension or hierarchy (or a list\
    \ thereof).\n\n# Use case: Intended for development/prototyping.\n# 1/ Clean up unused dimension/hierarchies\
    \ after Go Live.\n\n# Note:\n# Naturally, a valid dimension name (pDim) is mandatory otherwise\
    \ the process will abort.\n# If no hierarchy (pHier) is specified the dimension will be\
    \ deleted if not in use by a **regular** cube.\n# If a hierarchy is specified, it must be\
    \ valid otherwise the process will abort.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp      \
    \  = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pDelim:%pDelim%.';\
    \ \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*', pDim )\
    \ = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier\
    \ @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting\
    \ dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim )\
    \ + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\
    \nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( Scan( '*', pDim ) =\
    \ 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & DimensionExists( pDim ) = 0 );\n\
    \    nErrors = 1;\n    sMessage = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  ## use same name\
    \ as Dimension. Since wildcards are allowed this is managed inside the code below\nElseIf(\
    \ Trim( pHier ) @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid hierarchy: 'Leaves'.';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(  Scan( '*', pHier )\
    \ = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pDim ) = 0 & Scan(\
    \ '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Trim( pHier ) @= Trim( pDim ) );\n  nErrors\
    \ = 1;\n  sMessage = 'Cannot delete same named hierarchy: '}bedrock.dim.delete' process\
    \ should be used for this purpose';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @=\
    \ '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n\nIF( Scan( '*', pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim,\
    \ pHier ) = 0 & Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0\
    \ );\n    If( HierarchyExists( pDim, pHier ) = 0 );\n        nError = 1;\n        sMessage\
    \ = 'The Hierachy '' | pHier | '' is not available in '' | pDim | '' dimension' ;\n    \
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n        HierarchyDestroy(\
    \ pDim  ,pHier );\n    Endif;\nElseIf( pHier @= 'Leaves');\n    nError = 1;\n    sMessage\
    \ = 'The Hierachy is Leaves and can not be destroyed';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElse;\n    # Loop through dimensions in pDim\n    sDims = pDim;\n\
    \    nDimDelimiterIndex = 1;\n    sMdx = '';\n    # Get 1st dimension\n    While( nDimDelimiterIndex\
    \ <> 0 );\n        # Extract 1st dimension > sDim\n        nDimDelimiterIndex = Scan( pDelim,\
    \ sDims );\n        If( nDimDelimiterIndex = 0 );\n            sDim = sDims;\n        Else;\n\
    \            sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n            sDims\
    \ = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n        EndIf;\n\
    \        \n          # Create subset of dimensions using Wildcard to loop through dimensions\
    \ in pDim with wildcard\n        sDimExp = '''|sDim|''';\n        sMdxPart = '{TM1FILTERBYPATTERN(\
    \ EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) , '*:*') ) ,'| sDimExp | ')}';\n        IF( sMdx @= ''); \n          sMdx = sMdxPart;\
    \ \n        ELSE;\n          sMdx = sMdx | ' + ' | sMdxPart;\n        ENDIF;\n    End;\n\
    \    \n    If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n        # If a delimited\
    \ list of dim names includes wildcards then we may have to re-use the subset multiple times\n\
    \        SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n    Else;\n        # temp subset,\
    \ therefore no need to destroy in epilog\n        SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions'\
    \ , 1 );\n    EndIf;\n    \n    # Loop through dimensions in subset created based on wildcard\n\
    \    nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n    While( nCountDim >= 1 );\n\
    \        sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim );\n        #\
    \ Validate dimension name\n        If( DimensionExists(sDim) = 0 );\n            nErrors\
    \ = 1;\n            sMessage = Expand( 'Dimension %sDim% does not exist.' );\n         \
    \   LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            If( pLogOutput\
    \ = 1 );\n              sMessage = Expand( 'Dimension %sDim% being processed....' );\n \
    \             LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n            EndIf;\n    \
    \        # Loop through hierarchies in pHier\n            If( Trim( pHier ) @= '' );\n \
    \             ### Use main hierarchy for each dimension if pHier is empty\n            \
    \  sHierarchies = sDim;\n            Else;\n              sHierarchies              = pHier;\n\
    \            EndIf;\n            nDelimiterIndexA    = 1;\n            sHierDim        \
    \    = '}Hierarchies_'|sDim ;\n            sMdxHier = '';\n            While( nDelimiterIndexA\
    \ <> 0 );\n    \n                nDelimiterIndexA = Scan( pDelim, sHierarchies );\n    \
    \            If( nDelimiterIndexA = 0 );\n                    sHierarchy   = sHierarchies;\n\
    \                Else;\n                    sHierarchy   = Trim( SubSt( sHierarchies, 1,\
    \ nDelimiterIndexA - 1 ) );\n                    sHierarchies  = Trim( Subst( sHierarchies,\
    \ nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n                EndIf;\n \
    \               \n                # Create subset of Hierarchies using Wildcard\n      \
    \          sHierExp = '''|sDim|':'|sHierarchy|''';\n                sMdxHierPart = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp | ')}';\n                IF( sMdxHier @=\
    \ ''); \n                  sMdxHier = sMdxHierPart; \n                ELSE;\n          \
    \        sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n                ENDIF;\n         \
    \   End;\n    \n            If( SubsetExists( sHierDim, cTempSub ) = 1 );\n            \
    \    # If a delimited list of attr names includes wildcards then we may have to re-use the\
    \ subset multiple times\n                SubsetMDXSet( sHierDim, cTempSub, sMdxHier );\n\
    \            Else;\n                # temp subset, therefore no need to destroy in epilog\n\
    \                SubsetCreatebyMDX( cTempSub, sMdxHier, sHierDim, 1 );\n            EndIf;\n\
    \        \n            # Loop through subset of hierarchies created based on wildcard\n\
    \            nCountHier = SubsetGetSize( sHierDim, cTempSub );\n            While( nCountHier\
    \ >= 1 );\n                sCurrHier = SubsetGetElementName( sHierDim, cTempSub, nCountHier\
    \ );\n                sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier)\
    \ );\n                \n                # Validate hierarchy name in dimension\n       \
    \         If( Dimix( sHierDim , sCurrHier ) = 0 );\n                    sMessage = Expand('The\
    \ %sCurrHier% hierarchy does NOT exist in the %sDim% dimension.');\n                   \
    \ LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n                Else;\n            \
    \      If( pLogOutput = 1 );\n                    sMessage = Expand( 'Hierarchy %sCurrHierName%\
    \ in Dimension %sDim% being processed....' );\n                    LogOutput( 'INFO', Expand(\
    \ cMsgInfoContent ) );\n                  EndIf;\n                  If( Trim( sCurrHierName\
    \ ) @= Trim( sDim ) );\n                      ## Do not remove main hierarchy\n        \
    \          ElseIf( sCurrHierName @= 'Leaves');\n                      If( pLogOutput = 1\
    \ );\n                        sMessage = 'The Hierachy is Leaves and can not be destroyed';\n\
    \                        LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n             \
    \         EndIf;\n                  Else;\n                      HierarchyDestroy( sDim,\
    \ sCurrHierName );\n                      If( pLogOutput = 1 );\n                      \
    \  sMessage = Expand( 'Destroying hierarchy %sCurrHierName% in Dimension %sDim%' );\n  \
    \                    LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n                 \
    \ EndIf;\n                  Endif;\n                Endif;\n              \n           \
    \     nCountHier = nCountHier - 1;\n            End;\n                \n        EndIf;\n\
    \        \n        nCountDim = nCountDim - 1;\n    End;\nEndIf;\n\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction     = Expand( 'Process:%cThisProcName%\
    \ successfully deleted the dimension:hierarchy %pDim%:%pHier%' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der neue Elemente in einer Dimensionshierarchie
    erstellt. Wenn der Parameter pEle mit einer durch Trennzeichen getrennten Liste von Elementen
    gefüllt wird, werden mehrere Elemente erstellt. Beachte: Ein gültiger Dimensionsname (pDim)
    und eine Elementliste sind zwingend erforderlich, da der Prozess sonst abbricht. Vorsicht:
    Wenn die Zielhierarchie ''Leaves'' ist, werden keine konsolidierten Elemente erstellt.'
  answer: "#Section Prolog\n \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create new element in a dimension Hierarchy.\
    \ More elements than one will be\n# created if pEle is supplied with a delimited list of\
    \ elements.\n \n# Note:\n# Valid dimension name (pDim) and element list are mandatory, otherwise\
    \ the process will abort.\n \n# Caution: When target hierarchy is `Leaves`, no consolidated\
    \ elements will be created.\n#EndRegion @DOC\n \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n \n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\\
    s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubDim       =\
    \ cThisProcName |'_dims_'| cTimeStamp |'_'| cRandomInt;\ncTempSubHier      = cThisProcName\
    \ |'_hiers_'| cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%,\
    \ pEleType:%pEleType%, pInsertionPoint:%pInsertionPoint%, pDelim:%pDelim%.'; \n \n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \ \n### Validate Parameters ###\nnErrors = 0;\n \nIf( Scan( '*', pDim ) = 0 & Scan( '?',\
    \ pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    #\
    \ A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long(\
    \ pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n \n# Validate\
    \ dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n \n# Validate Hierarchy\n\
    If( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed\
    \ this is managed inside the code below\nEndIf;\n \n# Validate element\nIf( Trim( pEle )\
    \ @= '' );\n    nErrors = 1;\n    sMessage = 'No element specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n \n# Validate element type\nIf( pEleType @= ''\
    \ );\n    pEleType = 'N';\nEndIf;\npEleType = Upper( pEleType );\nIf( pEleType @<> 'N' &\
    \ pEleType @<> 'C' & pEleType @<> 'S' );\n    nErrors = 1;\n    sMessage = 'Invalid element\
    \ type: ' | pEleType;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \ \n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim\
    \ = '&';\nEndIf;\n \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If(\
    \ pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n \n \n# Loop through dimensions in pDim\nsDims = pDim;\nnDimDelimiterIndex = 1;\n\
    sMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension\
    \ > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex =\
    \ 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long(\
    \ sDims ) ) );\n    EndIf;\n     \n      # Create subset of dimensions using Wildcard to\
    \ loop through dimensions in pDim with wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart\
    \ = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL(\
    \ [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n    IF( sMdx @= ''); \n      sMdx = sMdxPart;\
    \ \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n \nIf( SubsetExists(\
    \ '}Dimensions' , cTempSubDim ) = 1 );\n    # If a delimited list of dim names includes\
    \ wildcards then we may have to re-use the subset multiple times\n    SubsetMDXSet( '}Dimensions'\
    \ , cTempSubDim, sMDX );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n\
    \    SubsetCreatebyMDX( cTempSubDim, sMDX, '}Dimensions' , 1 );\nEndIf;\n \n# Loop through\
    \ dimensions in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions'\
    \ , cTempSubDim );\nWhile( nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions'\
    \ , cTempSubDim, nCountDim );\n    # Validate dimension name\n    If( DimensionExists(sDim)\
    \ = 0 );\n        nErrors = 1;\n        sMessage = Expand( 'Dimension %sDim% does not exist.'\
    \ );\n        LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n    Else;\n        If(\
    \ pLogOutput = 1 );\n          sMessage = Expand( 'Dimension %sDim% being processed....'\
    \ );\n          LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n        EndIf;\n      \
    \  # Loop through hierarchies in pHier\n        If( Trim( pHier ) @= '' );\n          ###\
    \ Use main hierarchy for each dimension if pHier is empty\n          sHierarchies      =\
    \ sDim;\n        Else;\n          sHierarchies      = pHier;\n        EndIf;\n        nDelimiterIndexA\
    \    = 1;\n        sHierDim            = '}Dimensions';\n        sMdxHier            = '';\n\
    \        While( nDelimiterIndexA <> 0 );\n \n            nDelimiterIndexA = Scan( pDelim,\
    \ sHierarchies );\n            If( nDelimiterIndexA = 0 );\n                sHierarchy \
    \  = sHierarchies;\n            Else;\n                sHierarchy   = Trim( SubSt( sHierarchies,\
    \ 1, nDelimiterIndexA - 1 ) );\n                sHierarchies = Trim( Subst( sHierarchies,\
    \ nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n            EndIf;\n     \
    \        \n            ## If no wildcard specified and current hierarchy does not exist\
    \ in dimension, create it\n            If( Scan( '*', sHierarchy ) = 0 & Scan( '?', sHierarchy\
    \ ) = 0);\n              If( HierarchyExists( sDim, sHierarchy ) = 0 );\n              \
    \    HierarchyCreate( sDim, sHierarchy );\n              EndIf;\n            EndIf;\n \n\
    \            # Create subset of Hierarchies using Wildcard\n            If( sHierarchy \
    \ @= sDim );\n                sHierExp    = '''| sHierarchy |''';\n            Else;\n \
    \               sHierExp    = '''|sDim|':'|sHierarchy|''';\n            EndIf;\n       \
    \     sMdxHierPart    = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp\
    \ | ')}';\n            IF( sMdxHier    @= ''); \n              sMdxHier      = sMdxHierPart;\
    \ \n            ELSE;\n              sMdxHier      = sMdxHier | ' + ' | sMdxHierPart;\n\
    \            ENDIF;\n        End;\n        If( Trim( pHier )   @= '*' );\n          sMdxHier\
    \          = '{ UNION ( ' | sMdxHier |' , {[}Dimensions].[' | sDim | ']} )}';\n        EndIf;\n\
    \         \n        If( SubsetExists( sHierDim, cTempSubHier ) = 1 );\n            # If\
    \ a delimited list of attr names includes wildcards then we may have to re-use the subset\
    \ multiple times\n            SubsetMDXSet( sHierDim, cTempSubHier, sMdxHier );\n      \
    \  Else;\n            # temp subset, therefore no need to destroy in epilog\n          \
    \  SubsetCreatebyMDX( cTempSubHier, sMdxHier, sHierDim, 1 );\n        EndIf;\n     \n  \
    \      # Loop through subset of hierarchies created based on wildcard\n        nCountHier\
    \ = SubsetGetSize( sHierDim, cTempSubHier );\n        While( nCountHier >= 1 );\n      \
    \      sCurrHier = SubsetGetElementName( sHierDim, cTempSubHier, nCountHier );\n       \
    \     sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n   \
    \         # Validate hierarchy name in dimension\n            If( Dimix( sHierDim , sCurrHier\
    \ ) = 0 );\n                sMessage = Expand('The %sCurrHier% hierarchy does NOT exist\
    \ in the %sDim% dimension.');\n                LogOutput( 'INFO' , Expand( cMsgInfoContent\
    \ ) );\n            Else;\n              If( pLogOutput = 1 );\n                sMessage\
    \ = Expand( 'Hierarchy %sCurrHierName% in Dimension %sDim% being processed....' );\n   \
    \             LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n              EndIf;\n  \
    \             \n              # Extract, validate & add elements\n              sEles =\
    \ pEle;\n              nDelimiterIndexB = 1;\n              While( nDelimiterIndexB <> 0\
    \ );\n                   \n                  nDelimiterIndexB = Scan( pDelim, sEles );\n\
    \                  If( nDelimiterIndexB = 0 );\n                      sEle = sEles;\n  \
    \                Else;\n                      sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB\
    \ - 1 ) );\n                      sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim),\
    \ Long( sEles ) ) );\n                  EndIf;\n                   \n                  #\
    \ Add elements that don't already exist\n                  If( ElementIndex( sDim, sCurrHierName,\
    \ sEle ) <> 0 );\n                      If( pLogOutput = 1 );\n                        sMessage\
    \ = Expand( 'Element ' | sEle | ' already exist in hierarchy ' | sCurrHier);\n         \
    \               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n             \
    \         EndIf;\n                  Else;\n                      # Validate Insertion point\n\
    \                      IF( pInsertionPoint @<> '' );\n                          If( ElementIndex(\
    \ sDim, sCurrHierName, pInsertionPoint ) = 0 );\n                              If( pLogOutput\
    \ = 1 );\n                                sMessage = Expand( 'Element insertion point '\
    \ | pInsertionPoint | ' does NOT exist in dimension:hierarchy ' | sCurrHier | '. Using ''\
    \ '' as insertion point.' );\n                                LogOutput( 'INFO', Expand(\
    \ cMsgInfoContent ) );\n                              EndIf;\n                         \
    \     sInsertionPoint = '';\n                          Else;\n                         \
    \     sInsertionPoint = pInsertionPoint;\n                          EndIf;\n           \
    \           Else;\n                          sInsertionPoint = pInsertionPoint;\n      \
    \                EndIf;\n                      # Leaves hier\n                      If(\
    \ sCurrHierName @= 'Leaves' & pEleType @= 'C' );\n                          If( pLogOutput\
    \ = 1 );\n                            sMessage = Expand( 'Invalid element type for Leaves\
    \ hierarchy in dimension %sDim%: ' | pEleType );\n                            LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgInfoContent ) );\n                          EndIf;\n     \
    \                 Else;\n                          HierarchyElementInsert( sDim, sCurrHierName,\
    \ sInsertionPoint , sEle , pEleType );    \n                          If( pLogOutput = 1\
    \ );\n                            sMessage = Expand( 'Element %sEle% created in hierarchy\
    \ %sCurrHier% having type ' | pEleType );\n                            LogOutput( 'INFO',\
    \ Expand( cMsgInfoContent ) );\n                          EndIf;\n                     \
    \ EndIf;\n                  Endif;\n              End;\n          Endif;\n           \n\
    \            nCountHier = nCountHier - 1;\n        End;\n             \n    EndIf;\n   \
    \  \n    nCountDim = nCountDim - 1;\nEnd;\n \n \n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction     = Expand( 'Process:%cThisProcName% inserted element(s) %pEle%\
    \ with type %pEleType% into %pDim%:%pHier%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n\n### End Epilog\
    \ ###"
- question: 'Create an IBM Turbo Integrator process that creates new elements in a dimension
    hierarchy. More than one element will be created if the parameter pEle is supplied with
    a delimited list of elements. Note: A valid dimension name (pDim) and element list are mandatory,
    otherwise the process will abort. Caution: When the target hierarchy is ''Leaves'', no consolidated
    elements will be created.'
  answer: "#Section Prolog\n \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create new element in a dimension Hierarchy.\
    \ More elements than one will be\n# created if pEle is supplied with a delimited list of\
    \ elements.\n \n# Note:\n# Valid dimension name (pDim) and element list are mandatory, otherwise\
    \ the process will abort.\n \n# Caution: When target hierarchy is `Leaves`, no consolidated\
    \ elements will be created.\n#EndRegion @DOC\n \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n \n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\\
    s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubDim       =\
    \ cThisProcName |'_dims_'| cTimeStamp |'_'| cRandomInt;\ncTempSubHier      = cThisProcName\
    \ |'_hiers_'| cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%,\
    \ pEleType:%pEleType%, pInsertionPoint:%pInsertionPoint%, pDelim:%pDelim%.'; \n \n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \ \n### Validate Parameters ###\nnErrors = 0;\n \nIf( Scan( '*', pDim ) = 0 & Scan( '?',\
    \ pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    #\
    \ A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long(\
    \ pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n \n# Validate\
    \ dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n \n# Validate Hierarchy\n\
    If( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed\
    \ this is managed inside the code below\nEndIf;\n \n# Validate element\nIf( Trim( pEle )\
    \ @= '' );\n    nErrors = 1;\n    sMessage = 'No element specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n \n# Validate element type\nIf( pEleType @= ''\
    \ );\n    pEleType = 'N';\nEndIf;\npEleType = Upper( pEleType );\nIf( pEleType @<> 'N' &\
    \ pEleType @<> 'C' & pEleType @<> 'S' );\n    nErrors = 1;\n    sMessage = 'Invalid element\
    \ type: ' | pEleType;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \ \n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim\
    \ = '&';\nEndIf;\n \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If(\
    \ pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n \n \n# Loop through dimensions in pDim\nsDims = pDim;\nnDimDelimiterIndex = 1;\n\
    sMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension\
    \ > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex =\
    \ 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long(\
    \ sDims ) ) );\n    EndIf;\n     \n      # Create subset of dimensions using Wildcard to\
    \ loop through dimensions in pDim with wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart\
    \ = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL(\
    \ [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n    IF( sMdx @= ''); \n      sMdx = sMdxPart;\
    \ \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n \nIf( SubsetExists(\
    \ '}Dimensions' , cTempSubDim ) = 1 );\n    # If a delimited list of dim names includes\
    \ wildcards then we may have to re-use the subset multiple times\n    SubsetMDXSet( '}Dimensions'\
    \ , cTempSubDim, sMDX );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n\
    \    SubsetCreatebyMDX( cTempSubDim, sMDX, '}Dimensions' , 1 );\nEndIf;\n \n# Loop through\
    \ dimensions in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions'\
    \ , cTempSubDim );\nWhile( nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions'\
    \ , cTempSubDim, nCountDim );\n    # Validate dimension name\n    If( DimensionExists(sDim)\
    \ = 0 );\n        nErrors = 1;\n        sMessage = Expand( 'Dimension %sDim% does not exist.'\
    \ );\n        LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n    Else;\n        If(\
    \ pLogOutput = 1 );\n          sMessage = Expand( 'Dimension %sDim% being processed....'\
    \ );\n          LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n        EndIf;\n      \
    \  # Loop through hierarchies in pHier\n        If( Trim( pHier ) @= '' );\n          ###\
    \ Use main hierarchy for each dimension if pHier is empty\n          sHierarchies      =\
    \ sDim;\n        Else;\n          sHierarchies      = pHier;\n        EndIf;\n        nDelimiterIndexA\
    \    = 1;\n        sHierDim            = '}Dimensions';\n        sMdxHier            = '';\n\
    \        While( nDelimiterIndexA <> 0 );\n \n            nDelimiterIndexA = Scan( pDelim,\
    \ sHierarchies );\n            If( nDelimiterIndexA = 0 );\n                sHierarchy \
    \  = sHierarchies;\n            Else;\n                sHierarchy   = Trim( SubSt( sHierarchies,\
    \ 1, nDelimiterIndexA - 1 ) );\n                sHierarchies = Trim( Subst( sHierarchies,\
    \ nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n            EndIf;\n     \
    \        \n            ## If no wildcard specified and current hierarchy does not exist\
    \ in dimension, create it\n            If( Scan( '*', sHierarchy ) = 0 & Scan( '?', sHierarchy\
    \ ) = 0);\n              If( HierarchyExists( sDim, sHierarchy ) = 0 );\n              \
    \    HierarchyCreate( sDim, sHierarchy );\n              EndIf;\n            EndIf;\n \n\
    \            # Create subset of Hierarchies using Wildcard\n            If( sHierarchy \
    \ @= sDim );\n                sHierExp    = '''| sHierarchy |''';\n            Else;\n \
    \               sHierExp    = '''|sDim|':'|sHierarchy|''';\n            EndIf;\n       \
    \     sMdxHierPart    = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp\
    \ | ')}';\n            IF( sMdxHier    @= ''); \n              sMdxHier      = sMdxHierPart;\
    \ \n            ELSE;\n              sMdxHier      = sMdxHier | ' + ' | sMdxHierPart;\n\
    \            ENDIF;\n        End;\n        If( Trim( pHier )   @= '*' );\n          sMdxHier\
    \          = '{ UNION ( ' | sMdxHier |' , {[}Dimensions].[' | sDim | ']} )}';\n        EndIf;\n\
    \         \n        If( SubsetExists( sHierDim, cTempSubHier ) = 1 );\n            # If\
    \ a delimited list of attr names includes wildcards then we may have to re-use the subset\
    \ multiple times\n            SubsetMDXSet( sHierDim, cTempSubHier, sMdxHier );\n      \
    \  Else;\n            # temp subset, therefore no need to destroy in epilog\n          \
    \  SubsetCreatebyMDX( cTempSubHier, sMdxHier, sHierDim, 1 );\n        EndIf;\n     \n  \
    \      # Loop through subset of hierarchies created based on wildcard\n        nCountHier\
    \ = SubsetGetSize( sHierDim, cTempSubHier );\n        While( nCountHier >= 1 );\n      \
    \      sCurrHier = SubsetGetElementName( sHierDim, cTempSubHier, nCountHier );\n       \
    \     sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n   \
    \         # Validate hierarchy name in dimension\n            If( Dimix( sHierDim , sCurrHier\
    \ ) = 0 );\n                sMessage = Expand('The %sCurrHier% hierarchy does NOT exist\
    \ in the %sDim% dimension.');\n                LogOutput( 'INFO' , Expand( cMsgInfoContent\
    \ ) );\n            Else;\n              If( pLogOutput = 1 );\n                sMessage\
    \ = Expand( 'Hierarchy %sCurrHierName% in Dimension %sDim% being processed....' );\n   \
    \             LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n              EndIf;\n  \
    \             \n              # Extract, validate & add elements\n              sEles =\
    \ pEle;\n              nDelimiterIndexB = 1;\n              While( nDelimiterIndexB <> 0\
    \ );\n                   \n                  nDelimiterIndexB = Scan( pDelim, sEles );\n\
    \                  If( nDelimiterIndexB = 0 );\n                      sEle = sEles;\n  \
    \                Else;\n                      sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB\
    \ - 1 ) );\n                      sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim),\
    \ Long( sEles ) ) );\n                  EndIf;\n                   \n                  #\
    \ Add elements that don't already exist\n                  If( ElementIndex( sDim, sCurrHierName,\
    \ sEle ) <> 0 );\n                      If( pLogOutput = 1 );\n                        sMessage\
    \ = Expand( 'Element ' | sEle | ' already exist in hierarchy ' | sCurrHier);\n         \
    \               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n             \
    \         EndIf;\n                  Else;\n                      # Validate Insertion point\n\
    \                      IF( pInsertionPoint @<> '' );\n                          If( ElementIndex(\
    \ sDim, sCurrHierName, pInsertionPoint ) = 0 );\n                              If( pLogOutput\
    \ = 1 );\n                                sMessage = Expand( 'Element insertion point '\
    \ | pInsertionPoint | ' does NOT exist in dimension:hierarchy ' | sCurrHier | '. Using ''\
    \ '' as insertion point.' );\n                                LogOutput( 'INFO', Expand(\
    \ cMsgInfoContent ) );\n                              EndIf;\n                         \
    \     sInsertionPoint = '';\n                          Else;\n                         \
    \     sInsertionPoint = pInsertionPoint;\n                          EndIf;\n           \
    \           Else;\n                          sInsertionPoint = pInsertionPoint;\n      \
    \                EndIf;\n                      # Leaves hier\n                      If(\
    \ sCurrHierName @= 'Leaves' & pEleType @= 'C' );\n                          If( pLogOutput\
    \ = 1 );\n                            sMessage = Expand( 'Invalid element type for Leaves\
    \ hierarchy in dimension %sDim%: ' | pEleType );\n                            LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgInfoContent ) );\n                          EndIf;\n     \
    \                 Else;\n                          HierarchyElementInsert( sDim, sCurrHierName,\
    \ sInsertionPoint , sEle , pEleType );    \n                          If( pLogOutput = 1\
    \ );\n                            sMessage = Expand( 'Element %sEle% created in hierarchy\
    \ %sCurrHier% having type ' | pEleType );\n                            LogOutput( 'INFO',\
    \ Expand( cMsgInfoContent ) );\n                          EndIf;\n                     \
    \ EndIf;\n                  Endif;\n              End;\n          Endif;\n           \n\
    \            nCountHier = nCountHier - 1;\n        End;\n             \n    EndIf;\n   \
    \  \n    nCountDim = nCountDim - 1;\nEnd;\n \n \n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction     = Expand( 'Process:%cThisProcName% inserted element(s) %pEle%\
    \ with type %pEleType% into %pDim%:%pHier%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n\n### End Epilog\
    \ ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der das Löschen von bestimmten oder
    allen Elementen aus einer Dimension Hierarchie ermöglicht. Elemente können über eine durch
    Trennzeichen getrennte Liste von Elementen spezifiziert werden. Jedes Mitglied der Liste
    kann genau oder durch ein Wildcard-Muster angegeben werden. Wildcards ''*'' und ''?'' sind
    erlaubt. Achtung: Wenn pEle auf ''*'' gesetzt ist, werden __alle__ Elemente in pHier gelöscht!'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete specified or all elements from\
    \ a dimension Hierarchy. Elements might be\n# specified as a delimited list of elements.\
    \ Each member in the list might be specified exactly or\n# by a wildcard pattern. Wildcards\
    \ '\\*' and '?' are accepted.\n#\n# Caution: When pEle is set to \\*, __all__ elements in\
    \ pHier will be deleted!\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\\
    s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubDim       =\
    \ cThisProcName |'_dims_'| cTimeStamp |'_'| cRandomInt;\ncTempSubHier      = cThisProcName\
    \ |'_hiers_'| cTimeStamp |'_'| cRandomInt;\ncTempSubEle       = cThisProcName |'_eles_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgInfoLevel     = 'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%,\
    \ pEle:%pEle%, pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n \
    \   LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim )\
    \ = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier   \
    \    = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate Dimension\nIf( Trim( pDim ) @= '' );\n\
    \    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank delimiter specified then convert to\
    \ default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n# Validate Hierarchy\nIf( Trim(\
    \ pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed this\
    \ is managed inside the code below\nEndIf;\n\n### Check for errors before continuing\nIf(\
    \ nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n  \
    \    ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\n\
    nDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0\
    \ );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n\
    \    If( nDimDelimiterIndex = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim(\
    \ SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex\
    \ + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n      # Create subset of dimensions\
    \ using Wildcard to loop through dimensions in pDim with wildcard\n    sDimExp = '''|sDim|''';\n\
    \    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n    IF( sMdx @= ''); \n\
    \      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n    ENDIF;\n\
    End;\n\nIf( SubsetExists( '}Dimensions' , cTempSubDim ) = 1 );\n    # If a delimited list\
    \ of dim names includes wildcards then we may have to re-use the subset multiple times\n\
    \    SubsetMDXSet( '}Dimensions' , cTempSubDim, sMDX );\nElse;\n    # temp subset, therefore\
    \ no need to destroy in epilog\n    SubsetCreatebyMDX( cTempSubDim, sMDX, '}Dimensions'\
    \ , 1 );\nEndIf;\n\n# Loop through dimensions in subset created based on wildcard\nnCountDim\
    \ = SubsetGetSize( '}Dimensions' , cTempSubDim );\nWhile( nCountDim >= 1 );\n    sDim =\
    \ SubsetGetElementName( '}Dimensions' , cTempSubDim, nCountDim );\n    # Validate dimension\
    \ name\n    If( DimensionExists(sDim) = 0 );\n        nErrors = 1;\n        sMessage = Expand(\
    \ 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage = Expand( 'Dimension\
    \ %sDim% being processed....' );\n          LogOutput( 'INFO', Expand( cMsgInfoContent )\
    \ );\n        EndIf;\n        # Loop through hierarchies in pHier\n        If( Trim( pHier\
    \ ) @= '' );\n          ### Use main hierarchy for each dimension if pHier is empty\n  \
    \        sHierarchies      = sDim;\n        Else;\n          sHierarchies      = pHier;\n\
    \        EndIf;\n        nDelimiterIndexA    = 1;\n        sHierDim            = '}Dimensions'\
    \ ;\n        sMdxHier            = '';\n        While( nDelimiterIndexA <> 0 );\n\n    \
    \        nDelimiterIndexA = Scan( pDelim, sHierarchies );\n            If( nDelimiterIndexA\
    \ = 0 );\n                sHierarchy   = sHierarchies;\n            Else;\n            \
    \    sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n          \
    \      sHierarchies = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim), Long(\
    \ sHierarchies ) ) );\n            EndIf;\n\n            # Create subset of Hierarchies\
    \ using Wildcard\n            If( sHierarchy  @= sDim );\n                sHierExp    =\
    \ '''|sDim|''';\n            Else;\n                sHierExp    = '''|sDim|':'|sHierarchy|''';\n\
    \            EndIf;\n            sMdxHierPart    = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([\
    \ ' |sHierDim| '])},'| sHierExp | ')}';\n            IF( sMdxHier    @= ''); \n        \
    \      sMdxHier      = sMdxHierPart; \n            ELSE;\n              sMdxHier      =\
    \ sMdxHier | ' + ' | sMdxHierPart;\n            ENDIF;\n        End;\n        If( Trim(\
    \ pHier )   @= '*' );\n          sMdxHier          = '{ UNION ( ' | sMdxHier |' , {[}Dimensions].['\
    \ | sDim | ']} )}';\n        EndIf;\n\n        If( SubsetExists( sHierDim, cTempSubHier\
    \ ) = 1 );\n            # If a delimited list of hier names includes wildcards then we may\
    \ have to re-use the subset multiple times\n            SubsetMDXSet( sHierDim, cTempSubHier,\
    \ sMdxHier );\n        Else;\n            # temp subset, therefore no need to destroy in\
    \ epilog\n            SubsetCreatebyMDX( cTempSubHier, sMdxHier, sHierDim, 1 );\n      \
    \  EndIf;\n    \n        # Loop through subset of hierarchies created based on wildcard\n\
    \        nCountHier = SubsetGetSize( sHierDim, cTempSubHier );\n        While( nCountHier\
    \ >= 1 );\n            sCurrHier = SubsetGetElementName( sHierDim, cTempSubHier, nCountHier\
    \ );\n            sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier)\
    \ );\n            # Validate hierarchy name in sHierDim\n            If( Dimix( sHierDim\
    \ , sCurrHier ) = 0 );\n                sMessage = Expand('The %sCurrHier% hierarchy does\
    \ NOT exist in the %sDim% dimension.');\n                LogOutput( 'INFO' , Expand( cMsgInfoContent\
    \ ) );\n            Else;\n              If( pLogOutput = 1 );\n                sMessage\
    \ = Expand( 'Hierarchy %sCurrHierName% in Dimension %sDim% being processed....' );\n   \
    \             LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n              EndIf;\n  \
    \            # Loop through hierarchy elements in pEle\n              sEles = pEle;\n  \
    \             nDelimiterIndexB = 1;\n              While( nDelimiterIndexB <> 0 );\n   \
    \               \n                  nDelimiterIndexB = Scan( pDelim, sEles );\n        \
    \          If( nDelimiterIndexB = 0 );\n                      sEle = sEles;\n          \
    \        Else;\n                      sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB - 1\
    \ ) );\n                      sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim),\
    \ Long( sEles ) ) );\n                  EndIf;\n                  \n                  #\
    \ Check if a wildcard has been used to specify the Element name.\n                  # If\
    \ it hasn't then just delete the Element if it exists\n                  If(sEle @= '*');\n\
    \                          HierarchyDeleteAllElements(sDim, sCurrHierName);\n          \
    \        ElseIf( Scan( '*', sEle ) = 0 & Scan( '?', sEle ) = 0);\n                     \
    \ If( HierarchyElementExists( sDim,sCurrHierName, sEle ) = 1 );\n                      \
    \    HierarchyElementDelete( sDim, sCurrHierName,sEle );\n                          If(\
    \ sCurrHierName @= 'Leaves' );\n                              sMessage = Expand('Element\
    \ %sEle% deleted from LEAVES hierarchy in dimension %sDim%. This action removes the element\
    \ from all hierarchies!');\n                              LogOutput( cMsgInfoLevel, Expand(\
    \ cMsgInfoContent ) );\n                          ElseIf( pLogOutput = 1 );\n          \
    \                    sMessage = Expand( 'Element %sEle% deleted from hierarchy %sCurrHierName%\
    \ in dimension %sDim%.' );\n                              LogOutput( cMsgInfoLevel, Expand(\
    \ cMsgInfoContent ) );\n                          EndIf;\n                      Else;\n\
    \                          If( pLogOutput >= 1 );\n                              sMessage\
    \ = Expand('The Hierarchy %sCurrHier% does not contain element %sEle%.');\n            \
    \                  LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n            \
    \              EndIf;\n                      Endif;\n                  Else;\n         \
    \             # Wildcard search string\n                      sEle = '''|sEle|''';\n   \
    \                   sProc = '}bedrock.hier.sub.create.bymdx';\n                      sMdxEle\
    \ = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' | sCurrHier |' ])},'| sEle| ')}';\n\n      \
    \                If( HierarchySubsetExists( sDim, sCurrHierName, cTempSubEle ) = 1 );\n\
    \                          # If a delimited list of ele names includes wildcards then we\
    \ may have to re-use the subset multiple times\n                          HierarchySubsetMDXSet(\
    \ sDim, sCurrHierName, cTempSubEle, sMDXEle );\n                      Else;\n          \
    \                # temp subset, therefore no need to destroy in epilog\n               \
    \           SubsetCreatebyMDX( cTempSubEle, sMDXEle, sCurrHier, 1 );\n                 \
    \     EndIf;\n\n                      # Loop through subset of hierarchy elements created\
    \ based on wildcard\n                      nCountElems = HierarchySubsetGetSize(sDim, sCurrHierName,\
    \ cTempSubEle);\n                      While( nCountElems >= 1 );\n                    \
    \      sElement = HierarchySubsetGetElementName(sDim, sCurrHierName, cTempSubEle, nCountElems);\n\
    \                          HierarchyElementDelete( sDim, sCurrHierName,sElement );\n   \
    \                       If( pLogOutput = 1 );\n                              sMessage =\
    \ Expand( 'Element %sElement% deleted from hierarchy %sCurrHierName% in dimension %sDim%.'\
    \ );\n                              LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent )\
    \ );\n                          EndIf;\n                          nCountElems = nCountElems\
    \ - 1;\n                      End;\n                  EndIf;\n              \n         \
    \     End;\n          Endif;\n          \n            nCountHier = nCountHier - 1;\n   \
    \     End;\n            \n    EndIf;\n    \n    nCountDim = nCountDim - 1;\nEnd;\n\n\n\n\
    ### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \      = Expand( 'Process:%cThisProcName% successfully deleted the appropriate elements\
    \ in hierarchy %pDim%:%pHier%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Develop an IBM Turbo Integrator process that allows for the deletion of specified
    or all elements from a dimension hierarchy. Elements can be specified as a delimited list
    of elements. Each member in the list may be specified exactly or by a wildcard pattern.
    Wildcards ''*'' and ''?'' are accepted. Caution: When pEle is set to ''*'', __all__ elements
    in pHier will be deleted!'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete specified or all elements from\
    \ a dimension Hierarchy. Elements might be\n# specified as a delimited list of elements.\
    \ Each member in the list might be specified exactly or\n# by a wildcard pattern. Wildcards\
    \ '\\*' and '?' are accepted.\n#\n# Caution: When pEle is set to \\*, __all__ elements in\
    \ pHier will be deleted!\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\\
    s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubDim       =\
    \ cThisProcName |'_dims_'| cTimeStamp |'_'| cRandomInt;\ncTempSubHier      = cThisProcName\
    \ |'_hiers_'| cTimeStamp |'_'| cRandomInt;\ncTempSubEle       = cThisProcName |'_eles_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgInfoLevel     = 'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%,\
    \ pEle:%pEle%, pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n \
    \   LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim )\
    \ = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier   \
    \    = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate Dimension\nIf( Trim( pDim ) @= '' );\n\
    \    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank delimiter specified then convert to\
    \ default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n# Validate Hierarchy\nIf( Trim(\
    \ pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed this\
    \ is managed inside the code below\nEndIf;\n\n### Check for errors before continuing\nIf(\
    \ nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n  \
    \    ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\n\
    nDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0\
    \ );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n\
    \    If( nDimDelimiterIndex = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim(\
    \ SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex\
    \ + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n      # Create subset of dimensions\
    \ using Wildcard to loop through dimensions in pDim with wildcard\n    sDimExp = '''|sDim|''';\n\
    \    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n    IF( sMdx @= ''); \n\
    \      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n    ENDIF;\n\
    End;\n\nIf( SubsetExists( '}Dimensions' , cTempSubDim ) = 1 );\n    # If a delimited list\
    \ of dim names includes wildcards then we may have to re-use the subset multiple times\n\
    \    SubsetMDXSet( '}Dimensions' , cTempSubDim, sMDX );\nElse;\n    # temp subset, therefore\
    \ no need to destroy in epilog\n    SubsetCreatebyMDX( cTempSubDim, sMDX, '}Dimensions'\
    \ , 1 );\nEndIf;\n\n# Loop through dimensions in subset created based on wildcard\nnCountDim\
    \ = SubsetGetSize( '}Dimensions' , cTempSubDim );\nWhile( nCountDim >= 1 );\n    sDim =\
    \ SubsetGetElementName( '}Dimensions' , cTempSubDim, nCountDim );\n    # Validate dimension\
    \ name\n    If( DimensionExists(sDim) = 0 );\n        nErrors = 1;\n        sMessage = Expand(\
    \ 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage = Expand( 'Dimension\
    \ %sDim% being processed....' );\n          LogOutput( 'INFO', Expand( cMsgInfoContent )\
    \ );\n        EndIf;\n        # Loop through hierarchies in pHier\n        If( Trim( pHier\
    \ ) @= '' );\n          ### Use main hierarchy for each dimension if pHier is empty\n  \
    \        sHierarchies      = sDim;\n        Else;\n          sHierarchies      = pHier;\n\
    \        EndIf;\n        nDelimiterIndexA    = 1;\n        sHierDim            = '}Dimensions'\
    \ ;\n        sMdxHier            = '';\n        While( nDelimiterIndexA <> 0 );\n\n    \
    \        nDelimiterIndexA = Scan( pDelim, sHierarchies );\n            If( nDelimiterIndexA\
    \ = 0 );\n                sHierarchy   = sHierarchies;\n            Else;\n            \
    \    sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n          \
    \      sHierarchies = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim), Long(\
    \ sHierarchies ) ) );\n            EndIf;\n\n            # Create subset of Hierarchies\
    \ using Wildcard\n            If( sHierarchy  @= sDim );\n                sHierExp    =\
    \ '''|sDim|''';\n            Else;\n                sHierExp    = '''|sDim|':'|sHierarchy|''';\n\
    \            EndIf;\n            sMdxHierPart    = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([\
    \ ' |sHierDim| '])},'| sHierExp | ')}';\n            IF( sMdxHier    @= ''); \n        \
    \      sMdxHier      = sMdxHierPart; \n            ELSE;\n              sMdxHier      =\
    \ sMdxHier | ' + ' | sMdxHierPart;\n            ENDIF;\n        End;\n        If( Trim(\
    \ pHier )   @= '*' );\n          sMdxHier          = '{ UNION ( ' | sMdxHier |' , {[}Dimensions].['\
    \ | sDim | ']} )}';\n        EndIf;\n\n        If( SubsetExists( sHierDim, cTempSubHier\
    \ ) = 1 );\n            # If a delimited list of hier names includes wildcards then we may\
    \ have to re-use the subset multiple times\n            SubsetMDXSet( sHierDim, cTempSubHier,\
    \ sMdxHier );\n        Else;\n            # temp subset, therefore no need to destroy in\
    \ epilog\n            SubsetCreatebyMDX( cTempSubHier, sMdxHier, sHierDim, 1 );\n      \
    \  EndIf;\n    \n        # Loop through subset of hierarchies created based on wildcard\n\
    \        nCountHier = SubsetGetSize( sHierDim, cTempSubHier );\n        While( nCountHier\
    \ >= 1 );\n            sCurrHier = SubsetGetElementName( sHierDim, cTempSubHier, nCountHier\
    \ );\n            sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier)\
    \ );\n            # Validate hierarchy name in sHierDim\n            If( Dimix( sHierDim\
    \ , sCurrHier ) = 0 );\n                sMessage = Expand('The %sCurrHier% hierarchy does\
    \ NOT exist in the %sDim% dimension.');\n                LogOutput( 'INFO' , Expand( cMsgInfoContent\
    \ ) );\n            Else;\n              If( pLogOutput = 1 );\n                sMessage\
    \ = Expand( 'Hierarchy %sCurrHierName% in Dimension %sDim% being processed....' );\n   \
    \             LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n              EndIf;\n  \
    \            # Loop through hierarchy elements in pEle\n              sEles = pEle;\n  \
    \             nDelimiterIndexB = 1;\n              While( nDelimiterIndexB <> 0 );\n   \
    \               \n                  nDelimiterIndexB = Scan( pDelim, sEles );\n        \
    \          If( nDelimiterIndexB = 0 );\n                      sEle = sEles;\n          \
    \        Else;\n                      sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB - 1\
    \ ) );\n                      sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim),\
    \ Long( sEles ) ) );\n                  EndIf;\n                  \n                  #\
    \ Check if a wildcard has been used to specify the Element name.\n                  # If\
    \ it hasn't then just delete the Element if it exists\n                  If(sEle @= '*');\n\
    \                          HierarchyDeleteAllElements(sDim, sCurrHierName);\n          \
    \        ElseIf( Scan( '*', sEle ) = 0 & Scan( '?', sEle ) = 0);\n                     \
    \ If( HierarchyElementExists( sDim,sCurrHierName, sEle ) = 1 );\n                      \
    \    HierarchyElementDelete( sDim, sCurrHierName,sEle );\n                          If(\
    \ sCurrHierName @= 'Leaves' );\n                              sMessage = Expand('Element\
    \ %sEle% deleted from LEAVES hierarchy in dimension %sDim%. This action removes the element\
    \ from all hierarchies!');\n                              LogOutput( cMsgInfoLevel, Expand(\
    \ cMsgInfoContent ) );\n                          ElseIf( pLogOutput = 1 );\n          \
    \                    sMessage = Expand( 'Element %sEle% deleted from hierarchy %sCurrHierName%\
    \ in dimension %sDim%.' );\n                              LogOutput( cMsgInfoLevel, Expand(\
    \ cMsgInfoContent ) );\n                          EndIf;\n                      Else;\n\
    \                          If( pLogOutput >= 1 );\n                              sMessage\
    \ = Expand('The Hierarchy %sCurrHier% does not contain element %sEle%.');\n            \
    \                  LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n            \
    \              EndIf;\n                      Endif;\n                  Else;\n         \
    \             # Wildcard search string\n                      sEle = '''|sEle|''';\n   \
    \                   sProc = '}bedrock.hier.sub.create.bymdx';\n                      sMdxEle\
    \ = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' | sCurrHier |' ])},'| sEle| ')}';\n\n      \
    \                If( HierarchySubsetExists( sDim, sCurrHierName, cTempSubEle ) = 1 );\n\
    \                          # If a delimited list of ele names includes wildcards then we\
    \ may have to re-use the subset multiple times\n                          HierarchySubsetMDXSet(\
    \ sDim, sCurrHierName, cTempSubEle, sMDXEle );\n                      Else;\n          \
    \                # temp subset, therefore no need to destroy in epilog\n               \
    \           SubsetCreatebyMDX( cTempSubEle, sMDXEle, sCurrHier, 1 );\n                 \
    \     EndIf;\n\n                      # Loop through subset of hierarchy elements created\
    \ based on wildcard\n                      nCountElems = HierarchySubsetGetSize(sDim, sCurrHierName,\
    \ cTempSubEle);\n                      While( nCountElems >= 1 );\n                    \
    \      sElement = HierarchySubsetGetElementName(sDim, sCurrHierName, cTempSubEle, nCountElems);\n\
    \                          HierarchyElementDelete( sDim, sCurrHierName,sElement );\n   \
    \                       If( pLogOutput = 1 );\n                              sMessage =\
    \ Expand( 'Element %sElement% deleted from hierarchy %sCurrHierName% in dimension %sDim%.'\
    \ );\n                              LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent )\
    \ );\n                          EndIf;\n                          nCountElems = nCountElems\
    \ - 1;\n                      End;\n                  EndIf;\n              \n         \
    \     End;\n          Endif;\n          \n            nCountHier = nCountHier - 1;\n   \
    \     End;\n            \n    EndIf;\n    \n    nCountDim = nCountDim - 1;\nEnd;\n\n\n\n\
    ### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \      = Expand( 'Process:%cThisProcName% successfully deleted the appropriate elements\
    \ in hierarchy %pDim%:%pHier%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der es ermöglicht, ein Element entweder
    zu einer Konsolidierung hinzuzufügen oder daraus zu entfernen. Der Prozess sollte folgende
    Eingabeparameter akzeptieren: gültiger Dimensionsname (pDim), Konsolidierungselementname
    (pTgtConsol) und Elementname (pEle). Der Prozess muss einen Modus (Add oder Remove) nutzen,
    um das Element entsprechend zu verwalten. Beachte, dass die Zielhierarchie nicht ''Leaves''
    sein darf und der Prozess bei ungültigen Eingaben abbricht.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Add or Remove Element from a Consolidation\
    \ in a Hierarchy.\n\n# Note:\n# Valid dimension name (pDim), consolidated element name (pTgtConsol)\
    \ and element name (pEle)\n# otherwise the process will abort. Mode can be either Add to\
    \ add or Remove to remove the element\n# from a consolidation. \n\n# Caution: Target hierarchy\
    \ cannot be `Leaves`.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo\
    \        = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%,\
    \ pTgtConsol:%pTgtConsol%, pMode:%pMode%, pWeight:%pWeight%.';\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n \
    \   pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists(\
    \ pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension ' | pDim | ' does not exist\
    \ on server.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate Hierarchy\nIf( Trim( pHier ) @= '' );\n    sHier = Trim( pDim );\nElse;\n   \
    \ sHier = Trim( pHier );\nEndIf;\nIf( sHier @= 'Leaves' );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid  Hierarchy: ' | pDim |':'|sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( HierarchyExists( pDim, sHier ) = 0 );\n    nErrors = 1;\n    sMessage =\
    \ 'The Hierachy ' | sHier | ' does not exist in dimension ' | pDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Element\nIf( Trim( pEle ) @= '' );\n\
    \    nErrors = 1;\n    sMessage = 'No element specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( ElementIndex ( pDim, sHier, pEle ) = 0 );\n   \
    \ nErrors = 1;\n    sMessage = 'Element: ' | pEle | ' does not exist in dimension: ' | pDim|':'|\
    \ sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ target consol\nIf( ElementIndex ( pDim, sHier, pTgtConsol ) = 0  );\n    nErrors = 1;\n\
    \    sMessage = 'Consolidated Element: ' | pTgtConsol | ' does not exist in dimension: '\
    \ | pDim|':'| sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ ElementType( pDim, sHier, pTgtConsol ) @<> 'C' );\n    nErrors = 1;\n    sMessage = 'Target\
    \ Consolidation: ' | pTgtConsol | ' has incorrect element type.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\nIf( ElementIsAncestor( pDim, sHier, pEle, pTgtConsol\
    \ ) = 1 );\n    nErrors = 1;\n    sMessage = 'Cannot add element: ' | pEle | ' to consolidation:\
    \ ' | pTgtConsol | ' due to circular reference.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate action\nIf( pMode @<> 'Add' & pMode @<> 'Remove'\
    \ );\n    nErrors = 1;\n    sMessage = 'Invalid action: ' | pMode | '. Valid actions are\
    \ Add or Remove';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Insert\
    \ Element into consolidation ###\nIf( pMode @= 'Add' );\n    HierarchyElementComponentAdd(\
    \ pDim, sHier, pTgtConsol, pEle, pWeight );\nEndIf;\n\n### Remove Element from consolidation\
    \ ###\nIf( pMode @= 'Remove' );\n    # Check that element is actually a child of target\
    \ consol\n    If( ElementIsComponent ( pDim, sHier, pEle, pTgtConsol ) = 1 );\n        HierarchyElementComponentDelete(\
    \ pDim, sHier, pTgtConsol, pEle );\n    Else;\n        nErrors = 1;\n        sMessage =\
    \ 'Element: ' | pEle | ' is not a child of consolidation: ' | pTgtConsol;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### If errors occurred terminate process with a major error status ###\nIf( nErrors >\
    \ 0 );\n    sMessage = 'the process incurred at least 1 major error and consequently aborted.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for\
    \ details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    EndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName% successfully\
    \ %pMode%ed element %pEle% to/from %pTgtConsol% in the %pDim%:%pHier% dimension:hierarchy.'\
    \ );\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode\
    \  = 1;\nIf( pLogoutput = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \nEndIf;\n\
    \n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that allows adding or removing an element
    from a consolidation within a hierarchy. The process should accept the following input parameters:
    valid dimension name (pDim), consolidated element name (pTgtConsol), and element name (pEle).
    The process must utilize a mode (Add or Remove) to manage the element accordingly. Note
    that the target hierarchy cannot be ''Leaves'' and the process should abort on invalid inputs.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Add or Remove Element from a Consolidation\
    \ in a Hierarchy.\n\n# Note:\n# Valid dimension name (pDim), consolidated element name (pTgtConsol)\
    \ and element name (pEle)\n# otherwise the process will abort. Mode can be either Add to\
    \ add or Remove to remove the element\n# from a consolidation. \n\n# Caution: Target hierarchy\
    \ cannot be `Leaves`.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo\
    \        = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%,\
    \ pTgtConsol:%pTgtConsol%, pMode:%pMode%, pWeight:%pWeight%.';\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n \
    \   pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists(\
    \ pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension ' | pDim | ' does not exist\
    \ on server.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate Hierarchy\nIf( Trim( pHier ) @= '' );\n    sHier = Trim( pDim );\nElse;\n   \
    \ sHier = Trim( pHier );\nEndIf;\nIf( sHier @= 'Leaves' );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid  Hierarchy: ' | pDim |':'|sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( HierarchyExists( pDim, sHier ) = 0 );\n    nErrors = 1;\n    sMessage =\
    \ 'The Hierachy ' | sHier | ' does not exist in dimension ' | pDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Element\nIf( Trim( pEle ) @= '' );\n\
    \    nErrors = 1;\n    sMessage = 'No element specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( ElementIndex ( pDim, sHier, pEle ) = 0 );\n   \
    \ nErrors = 1;\n    sMessage = 'Element: ' | pEle | ' does not exist in dimension: ' | pDim|':'|\
    \ sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ target consol\nIf( ElementIndex ( pDim, sHier, pTgtConsol ) = 0  );\n    nErrors = 1;\n\
    \    sMessage = 'Consolidated Element: ' | pTgtConsol | ' does not exist in dimension: '\
    \ | pDim|':'| sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ ElementType( pDim, sHier, pTgtConsol ) @<> 'C' );\n    nErrors = 1;\n    sMessage = 'Target\
    \ Consolidation: ' | pTgtConsol | ' has incorrect element type.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\nIf( ElementIsAncestor( pDim, sHier, pEle, pTgtConsol\
    \ ) = 1 );\n    nErrors = 1;\n    sMessage = 'Cannot add element: ' | pEle | ' to consolidation:\
    \ ' | pTgtConsol | ' due to circular reference.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate action\nIf( pMode @<> 'Add' & pMode @<> 'Remove'\
    \ );\n    nErrors = 1;\n    sMessage = 'Invalid action: ' | pMode | '. Valid actions are\
    \ Add or Remove';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Insert\
    \ Element into consolidation ###\nIf( pMode @= 'Add' );\n    HierarchyElementComponentAdd(\
    \ pDim, sHier, pTgtConsol, pEle, pWeight );\nEndIf;\n\n### Remove Element from consolidation\
    \ ###\nIf( pMode @= 'Remove' );\n    # Check that element is actually a child of target\
    \ consol\n    If( ElementIsComponent ( pDim, sHier, pEle, pTgtConsol ) = 1 );\n        HierarchyElementComponentDelete(\
    \ pDim, sHier, pTgtConsol, pEle );\n    Else;\n        nErrors = 1;\n        sMessage =\
    \ 'Element: ' | pEle | ' is not a child of consolidation: ' | pTgtConsol;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### If errors occurred terminate process with a major error status ###\nIf( nErrors >\
    \ 0 );\n    sMessage = 'the process incurred at least 1 major error and consequently aborted.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for\
    \ details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    EndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName% successfully\
    \ %pMode%ed element %pEle% to/from %pTgtConsol% in the %pDim%:%pHier% dimension:hierarchy.'\
    \ );\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode\
    \  = 1;\nIf( pLogoutput = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \nEndIf;\n\
    \n\n### End Epilog ###"
- question: "Entwickle einen IBM Turbo Integrator Prozess, der alle Elemente in ausgewählten\
    \ Dimensionen und Hierarchien überprüft und eine CSV-Datei erstellt, die alle Elemente mit\
    \ ungewöhnlichen Zeichen auflistet. Beachte, dass Steuerdimensionen ignoriert werden. Die\
    \ Parameter des Prozesses sind: \n\n- pDim: Gib an, welche Dimensionen validiert werden\
    \ sollen. Verwende Wildcards wie `*` und `?` für Muster oder eine Liste von Dimensionen\
    \ mit einem Trennzeichen. Der Stern `*` verarbeitet alle Dimensionen. \n- pHier: Gib an,\
    \ welche Hierarchien validiert werden sollen. Verwende `*` für alle Hierarchien oder spezifische\
    \ Muster. Beachte, dass bei Angabe von Hierarchien pDim nicht als Liste oder mit Wildcards\
    \ verwendet werden sollte. \n- pDelim: Bestimme das Trennzeichen, um mehrere Dimensionen\
    \ oder Hierarchien zu trennen. Der Standard ist `&`, aber dies kann angepasst werden. \n\
    - pFirst: Wenn `1`, werden alle Anforderungen für alle Zeichen überprüft, sonst werden strenge\
    \ Anforderungen für das erste Zeichen ignoriert.'"
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will review all elements in selected dimensions\
    \ (you can specify a single dimension,\n# multiple dimensions or wildcards to match dimensions)\
    \ and hierarchies and will generate a `csv` \n# file listing all elements with unusual characters.\n\
    # Control dimensions are ignored.\n\n# Note:\n# - pDim: Specify which dimensions to validate.\
    \ When specifying a dimension name, wildcards can\n#   be specified by using the `*` and\
    \ `?` characters. A list of dimensions can also be entered with\n#   a delimiter (e.g. `v*&plan*`\
    \ will process all dimensions starting with `v` and `plan`). If \n#   * is entered then\
    \ it ignores anything entered for hierarchy (pHier) and processes all dimensions\n# - pHier:\
    \ Specify which hierarchies to validate. To validate ALL hierachies, enter *. \n#   When\
    \ specifying a hierarchy name, wildcards can be specified by using the\n#   `*` and `?`\
    \ characters. A list of hierachies can also be entered with a delimiter. If pHier\n#   has\
    \ a value then it does not make sense that pDim can be set up as a list or with wildcards.\n\
    # - pDelim: The delimiter is used when specifying multiple dimensions or multiple hierachies.\
    \ The\n#   default delimiter is `&`. Any delimiter can be used by specifying a value for\
    \ pDelim. Choose\n#   a delimiter that won't be used in either the wildcard search strings\
    \ or dimension names.\n# - pFirst:\n#   - When set to `1`: all requirements for all characters\
    \ are validated.\n#   - ELSE: ignores stringent requirements for 1st character.\n#EndRegion\
    \ @DOC\n\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncSubset           = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName%\
    \ : %sMessage% : %cUserName%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pFirst:%pFirst%, pDelim:%pDelim%';\ncDim              = '}Dimensions';\n\
    cFile             = GetProcessErrorFileDirectory | 'Element Issues.csv';\n\n# Variables\n\
    nMeta             = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan(\
    \ '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim )\
    \ > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim,\
    \ Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n\
    \    sMessage = 'No dimension specified. Use * to process all dimensions';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate hierarchy\nIf( Trim(\
    \ pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed, this\
    \ is managed inside the code below\nEndIf;\n\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\
    \n## Validate dimension\nIF( Trim( pDim ) @= '*' );\n    sMDX                = Expand('{\
    \ TM1SUBSETALL( [}Dimensions] ) }');\nElseIf( Trim( pHier ) @= '*' );\n    IF( Scan( pDelim\
    \ , pDim )>0 );\n        # delimiter in pDim. Seperate and add MDX for each part separately\n\
    \        sMDX            = '{ ';\n        sDims           = Trim( pDim );\n        nDelimiterIndex\
    \ = 1;\n        While( nDelimiterIndex <> 0 );    \n            nDelimiterIndex = Scan(\
    \ pDelim, sDims );\n            If( nDelimiterIndex = 0 );\n                sDim       \
    \     = sDims;\n            ELSE;\n                sDim            = Trim( SubSt( sDims,\
    \ 1, nDelimiterIndex - 1 ) );\n                sDims           = Trim( Subst( sDims, nDelimiterIndex\
    \ + Long(pDelim), Long( sDims ) ) );\n            ENDIF;\n            IF(DimensionExists(sDim)=1\
    \ );\n                sMDX            = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%sDim%*')}');\n            ELSEIF(Scan( '*', sDim )=0 & Scan( '?', sDim )=0 );\n \
    \               #nErrors = 1;\n                sMessage= Expand('Dimension %sDim% does not\
    \ exist.');\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \            ELSE;\n                sMDX            = sMDX | IF(Long(sMDX)>4,\n        \
    \                                    Expand(',TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%sDim%')'),\n                                            Expand(' TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%sDim%')')); \n            ENDIF;\n        END;\n    \
    \    sMDX                    = sMDX | ' }';\n    ELSE;\n        IF(DimensionExists(pDim)=1\
    \ );\n            sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%pDim%*')}');\n        ELSEIF(Scan( '*', pDim )=0 & Scan( '?', pDim )=0 );\n     \
    \       nErrors = 1;\n            sMessage= Expand('Dimension %pDim% does not exist.');\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ELSE;\n \
    \           sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%pDim%')}');\n        ENDIF;\n    ENDIF;\n    \nElseIf( HierarchyExists( pDim , pHier\
    \ ) = 1 & Trim( pHier ) @<>'' );\n    sMDX = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL(\
    \ [}Dimensions] ) ,'%pDim%:%pHier%')}');\n    \nElseIf( Scan( pDelim  , pHier )>0 % Scan(\
    \ '*'     , pHier )>0 % Scan( '?'     , pHier )>0);\n    sMDX            = '{ ';\n    IF(\
    \ Scan( pDelim  , pHier )>0 );\n        # delimiter in pHier. Seperate and add MDX for each\
    \ part separately\n        sHiers           = Trim( pHier );\n        nDelimiterIndex =\
    \ 1;\n        While( nDelimiterIndex <> 0 );    \n            nDelimiterIndex = Scan( pDelim,\
    \ sHiers );\n            If( nDelimiterIndex = 0 );\n                sHier            =\
    \ sHiers;\n            ELSE;\n                sHier            = Trim( SubSt( sHiers, 1,\
    \ nDelimiterIndex - 1 ) );\n                sHiers           = Trim( Subst( sHiers, nDelimiterIndex\
    \ + Long(pDelim), Long( sHiers ) ) );\n            ENDIF;\n            IF(HierarchyExists(\
    \ pDim, sHier )=1 );\n                sMDX            = sMDX | IF(Long(sMDX)>4,\n      \
    \                                      Expand(',TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%pDim%:%sHier%')'),\n                                            Expand(' TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')')); \n            ELSEIF(Scan( '*', sHier\
    \ )=0 & Scan( '?', sHier )=0 );\n                nErrors = 1;\n                sMessage=\
    \ Expand('Dimension:Hierarchy %pDim%:%sHier% does not exist.');\n                LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            ELSE;\n                sMDX\
    \            = sMDX | IF(Long(sMDX)>4,\n                                            Expand(',TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')'),\n                                \
    \            Expand(' TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')'));\
    \ \n            ENDIF;\n                \n        END;\n        sMDX                   \
    \ = sMDX | ' }';\n    ELSE;\n        # No delimiters but with wildcards in hierachy\n  \
    \      IF(HierarchyExists( pDim, pHier )=1 );\n            sMDX                = Expand('{TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%pHier%')}');\n        ELSEIF(Scan( '*', pHier\
    \ )=0 & Scan( '?', pHier )=0 );\n            nErrors = 1;\n            sMessage= Expand('Dimension:Hierarchy\
    \ %pDim%:%pHier% does not exist.');\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        ELSE;\n            sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL(\
    \ [}Dimensions] ) ,'%pDim%:%pHier%')}');\n        ENDIF;\n        \n    ENDIF;\n\nElseIf(\
    \ Trim( pHier ) @='' );\n    ## Use main hierarchy for each dimension processed\n    pHier\
    \ = Trim( pDim );\n    sMDX            = '{ ';\n    IF( Scan( pDelim  , pHier )>0 );\n \
    \       # delimiter in pHier. Seperate and add MDX for each part separately\n        sHiers\
    \           = Trim( pHier );\n        nDelimiterIndex = 1;\n        While( nDelimiterIndex\
    \ <> 0 );    \n            nDelimiterIndex = Scan( pDelim, sHiers );\n            If( nDelimiterIndex\
    \ = 0 );\n                sHier            = sHiers;\n            ELSE;\n              \
    \  sHier            = Trim( SubSt( sHiers, 1, nDelimiterIndex - 1 ) );\n               \
    \ sHiers           = Trim( Subst( sHiers, nDelimiterIndex + Long(pDelim), Long( sHiers )\
    \ ) );\n            ENDIF;\n            IF(HierarchyExists( sHier, sHier )=1 );\n      \
    \          sMDX            = sMDX | IF(Long(sMDX)>4,\n                                 \
    \           Expand(',TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')'),\n                            \
    \                Expand(' TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')')); \n            ELSEIF(Scan( '*',\
    \ sHier )=0 & Scan( '?', sHier )=0 );\n                nErrors = 1;\n                sMessage=\
    \ Expand('Dimension:Hierarchy %sHier%:%sHier% does not exist.');\n                LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            ELSE;\n                sMDX\
    \            = sMDX | IF(Long(sMDX)>4,\n                                            Expand(',TM1FILTERBYPATTERN(\
    \ EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) , '*:*') ) ,'%sHier%')'),\n                                            Expand(' TM1FILTERBYPATTERN(\
    \ EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) , '*:*') ) ,'%sHier%')')); \n            ENDIF;\n                \n        END;\n  \
    \      sMDX                    = sMDX | ' }';\n    ELSE;\n        # No delimiters but with\
    \ wildcards in hierachy\n        IF(HierarchyExists( pDim, pHier )=1 );\n            sMDX\
    \                = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) ,\
    \ TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%pDim%')}');\n        ELSEIF(Scan(\
    \ '*', pHier )=0 & Scan( '?', pHier )=0 );\n            nErrors = 1;\n            sMessage=\
    \ Expand('Dimension:Hierarchy %pDim%:%pHier% does not exist.');\n            LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ELSE;\n            sMDX       \
    \         = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%pDim%')}');\n        ENDIF;\n        \n  \
    \  ENDIF;\n    \nELSE;\n    nErrors = 1;\n    sMessage= Expand('Dimension:Hierarchy %pDim%:%pHier%\
    \ does not exist.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n    DatasourceType = 'NULL';\n\
    \    ProcessBreak;\nEndIf;\n\n# Create temporary subset\nSubsetCreatebyMDX(cSubset, sMDX\
    \ , 1 );\n\n### Set data source for process ### \nDatasourceType              = 'SUBSET';\n\
    DatasourceNameForServer     = cDim; \nDatasourceNameForClient     = cDim;\nDatasourceDimensionSubset\
    \   = cSubset;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# Validates characters in elements\n\n# Increment\
    \ nMeta\nnMeta           = nMeta + 1;\n\n# Output 1st line\nIF( nMeta = 1 );\n    sOutput\
    \     = 'Dimension:Hierarchy'' |','| ''Element''  |','| ''Type'' |','| ''Comments';\n  \
    \  TextOutput ( cFile , sOutput );\nEndIf;\n\n### Skip Control dimensions###\nIF(Subst(vDim\
    \ , 1 , 1 ) @= '}' );\n    ItemSkip;\nENDIF;\n\n# Set Dim name & hierachy name\nIF( SCAN(\
    \ ':' , vDim )=0 );\n    sDim        = vDim ;\n    sHier       = sDim ;\nELSE;\n    sDim\
    \        = SUBST( vDim, 1 , SCAN( ':' , vDim ) -1 );\n    sHier       = SUBST( vDim, SCAN(\
    \ ':' , vDim ) +1, 99 );\nENDIF;\n\nnDimSize        = ElementCount( sDim , sHier );\nnCount\
    \          = 1;\nWhile( nCount <= nDimSize );\n    sEle        = ElementName( sDim , sHier\
    \ , nCount );\n    sEleType    = ElementType( sDim , sHier , sEle );\n    sEleNew     =\
    \ '';\n    nEleSiz     = Long(sEle);\n    nChar       = 1;\n    While( nChar <= nEleSiz\
    \ & ElementIndex( sDim , sHier , sEle ) > 0 );\n        sChar       = NumberToString( nChar\
    \ );\n        sEleChar    = Subst( sEle , nChar , 1 );\n        nCode       = CODE( sEle\
    \ , nChar );\n        sCode       = NumberToString( nCode );\n        IF( vDim @= sDim );\n\
    \            IF( nChar=1 & pFirst=1 & (nCode=39 % nCode=45 % nCode=91 % nCode=34 % nCode=64\
    \ % nCode=33 % nCode=43 % nCode=123 % nCode=37));\n                sOutput = Expand('%vDim%'\
    \ , %sEle% , %sEleType% ,Has an illegal 1st character '%sEleChar%' with an AscII code of\
    \ %sCode%.');\n                TextOutput ( cFile , sOutput );\n            EndIf;\n   \
    \         IF( sEleChar@='/' % sEleChar@='|' % sEleChar@=''' % sEleChar@='' % sEleChar@='>'\
    \ % \n                sEleChar@='<' % sEleChar@=':' % sEleChar@='?' % sEleChar@='*');  \
    \   \n                sOutput = Expand('%vDim%' , %sEle% , %sEleType% ,Has a forbidden character\
    \ #%sChar% '%sEleChar%' with an AscII code of %sCode%.');\n                TextOutput (\
    \ cFile , sOutput );\n            ENDIF;\n        ELSEIF( ElementType( sDim, sHier, sEle)@='C'\
    \ % pHier@<>'' );\n            IF( nChar=1 & pFirst=1 & (nCode=39 % nCode=45 % nCode=91\
    \ % nCode=34 % nCode=64 % nCode=33 % nCode=43 % nCode=123 % nCode=37));\n              \
    \  sOutput = Expand('%vDim%' , %sEle% , %sEleType% ,Has an illegal 1st character '%sEleChar%'\
    \ with an AscII code of %sCode%.');\n                TextOutput ( cFile , sOutput );\n \
    \           EndIf;\n            IF( sEleChar@='/' % sEleChar@='|' % sEleChar@=''' % sEleChar@=''\
    \ % sEleChar@='>' % \n                sEleChar@='<' % sEleChar@=':' % sEleChar@='?' % sEleChar@='*');\
    \     \n                sOutput = Expand('%vDim%' , %sEle% , %sEleType% ,Has a forbidden\
    \ character #%sChar% '%sEleChar%' with an AscII code of %sCode%.');\n                TextOutput\
    \ ( cFile , sOutput );\n            ENDIF;\n        ENDIF;\n\n        nChar       = nChar\
    \ + 1;\n    End;\n    \n    nCount      = nCount + 1;\nEnd;\n\n### End MetaData ###\n#Section\
    \ Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    ### If errors occurred terminate process with a major error status ###\nIf( nErrors <> 0\
    \ );\n  sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% incurred\
    \ at least 1 major error and consequently aborted.' );\n  nProcessReturnCode = 0;\n  LogOutput(\
    \ 'ERROR', Expand( sProcessReturnCode | ' Please see above lines in this file for more details.'\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  EndIf;\nEndIf;\n\n#Return\
    \ Code\nsProcessAction      = Expand( 'Process:%cThisProcName% has validated all the elements\
    \ for %pDim% dimension and generated a csv report: %cFile%.' );\nsProcessReturnCode  = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode  = 1;\nIF ( pLogoutput\
    \ = 1 );\n  LogOutput('INFO', sProcessAction );   \nENDIF;\n\n### End Epilog ###"
- question: "Develop an IBM Turbo Integrator process that reviews all elements in selected dimensions\
    \ and hierarchies, generating a CSV file listing all elements with unusual characters. Note\
    \ that control dimensions are ignored. The parameters of the process are: \n\n- pDim: Specify\
    \ which dimensions to validate. Use wildcards like `*` and `?` for patterns or a list of\
    \ dimensions with a delimiter. A `*` processes all dimensions. \n- pHier: Specify which\
    \ hierarchies to validate. Use `*` for all hierarchies or specific patterns. Note that if\
    \ hierarchies are specified, pDim should not be set up as a list or with wildcards. \n-\
    \ pDelim: Determine the delimiter to separate multiple dimensions or hierarchies. The default\
    \ is `&`, but this can be customized. \n- pFirst: When `1`, all requirements for all characters\
    \ are validated, otherwise stringent requirements for the first character are ignored.'"
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will review all elements in selected dimensions\
    \ (you can specify a single dimension,\n# multiple dimensions or wildcards to match dimensions)\
    \ and hierarchies and will generate a `csv` \n# file listing all elements with unusual characters.\n\
    # Control dimensions are ignored.\n\n# Note:\n# - pDim: Specify which dimensions to validate.\
    \ When specifying a dimension name, wildcards can\n#   be specified by using the `*` and\
    \ `?` characters. A list of dimensions can also be entered with\n#   a delimiter (e.g. `v*&plan*`\
    \ will process all dimensions starting with `v` and `plan`). If \n#   * is entered then\
    \ it ignores anything entered for hierarchy (pHier) and processes all dimensions\n# - pHier:\
    \ Specify which hierarchies to validate. To validate ALL hierachies, enter *. \n#   When\
    \ specifying a hierarchy name, wildcards can be specified by using the\n#   `*` and `?`\
    \ characters. A list of hierachies can also be entered with a delimiter. If pHier\n#   has\
    \ a value then it does not make sense that pDim can be set up as a list or with wildcards.\n\
    # - pDelim: The delimiter is used when specifying multiple dimensions or multiple hierachies.\
    \ The\n#   default delimiter is `&`. Any delimiter can be used by specifying a value for\
    \ pDelim. Choose\n#   a delimiter that won't be used in either the wildcard search strings\
    \ or dimension names.\n# - pFirst:\n#   - When set to `1`: all requirements for all characters\
    \ are validated.\n#   - ELSE: ignores stringent requirements for 1st character.\n#EndRegion\
    \ @DOC\n\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncSubset           = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName%\
    \ : %sMessage% : %cUserName%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pFirst:%pFirst%, pDelim:%pDelim%';\ncDim              = '}Dimensions';\n\
    cFile             = GetProcessErrorFileDirectory | 'Element Issues.csv';\n\n# Variables\n\
    nMeta             = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan(\
    \ '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim )\
    \ > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim,\
    \ Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n\
    \    sMessage = 'No dimension specified. Use * to process all dimensions';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate hierarchy\nIf( Trim(\
    \ pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed, this\
    \ is managed inside the code below\nEndIf;\n\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\
    \n## Validate dimension\nIF( Trim( pDim ) @= '*' );\n    sMDX                = Expand('{\
    \ TM1SUBSETALL( [}Dimensions] ) }');\nElseIf( Trim( pHier ) @= '*' );\n    IF( Scan( pDelim\
    \ , pDim )>0 );\n        # delimiter in pDim. Seperate and add MDX for each part separately\n\
    \        sMDX            = '{ ';\n        sDims           = Trim( pDim );\n        nDelimiterIndex\
    \ = 1;\n        While( nDelimiterIndex <> 0 );    \n            nDelimiterIndex = Scan(\
    \ pDelim, sDims );\n            If( nDelimiterIndex = 0 );\n                sDim       \
    \     = sDims;\n            ELSE;\n                sDim            = Trim( SubSt( sDims,\
    \ 1, nDelimiterIndex - 1 ) );\n                sDims           = Trim( Subst( sDims, nDelimiterIndex\
    \ + Long(pDelim), Long( sDims ) ) );\n            ENDIF;\n            IF(DimensionExists(sDim)=1\
    \ );\n                sMDX            = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%sDim%*')}');\n            ELSEIF(Scan( '*', sDim )=0 & Scan( '?', sDim )=0 );\n \
    \               #nErrors = 1;\n                sMessage= Expand('Dimension %sDim% does not\
    \ exist.');\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \            ELSE;\n                sMDX            = sMDX | IF(Long(sMDX)>4,\n        \
    \                                    Expand(',TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%sDim%')'),\n                                            Expand(' TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%sDim%')')); \n            ENDIF;\n        END;\n    \
    \    sMDX                    = sMDX | ' }';\n    ELSE;\n        IF(DimensionExists(pDim)=1\
    \ );\n            sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%pDim%*')}');\n        ELSEIF(Scan( '*', pDim )=0 & Scan( '?', pDim )=0 );\n     \
    \       nErrors = 1;\n            sMessage= Expand('Dimension %pDim% does not exist.');\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ELSE;\n \
    \           sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%pDim%')}');\n        ENDIF;\n    ENDIF;\n    \nElseIf( HierarchyExists( pDim , pHier\
    \ ) = 1 & Trim( pHier ) @<>'' );\n    sMDX = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL(\
    \ [}Dimensions] ) ,'%pDim%:%pHier%')}');\n    \nElseIf( Scan( pDelim  , pHier )>0 % Scan(\
    \ '*'     , pHier )>0 % Scan( '?'     , pHier )>0);\n    sMDX            = '{ ';\n    IF(\
    \ Scan( pDelim  , pHier )>0 );\n        # delimiter in pHier. Seperate and add MDX for each\
    \ part separately\n        sHiers           = Trim( pHier );\n        nDelimiterIndex =\
    \ 1;\n        While( nDelimiterIndex <> 0 );    \n            nDelimiterIndex = Scan( pDelim,\
    \ sHiers );\n            If( nDelimiterIndex = 0 );\n                sHier            =\
    \ sHiers;\n            ELSE;\n                sHier            = Trim( SubSt( sHiers, 1,\
    \ nDelimiterIndex - 1 ) );\n                sHiers           = Trim( Subst( sHiers, nDelimiterIndex\
    \ + Long(pDelim), Long( sHiers ) ) );\n            ENDIF;\n            IF(HierarchyExists(\
    \ pDim, sHier )=1 );\n                sMDX            = sMDX | IF(Long(sMDX)>4,\n      \
    \                                      Expand(',TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%pDim%:%sHier%')'),\n                                            Expand(' TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')')); \n            ELSEIF(Scan( '*', sHier\
    \ )=0 & Scan( '?', sHier )=0 );\n                nErrors = 1;\n                sMessage=\
    \ Expand('Dimension:Hierarchy %pDim%:%sHier% does not exist.');\n                LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            ELSE;\n                sMDX\
    \            = sMDX | IF(Long(sMDX)>4,\n                                            Expand(',TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')'),\n                                \
    \            Expand(' TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')'));\
    \ \n            ENDIF;\n                \n        END;\n        sMDX                   \
    \ = sMDX | ' }';\n    ELSE;\n        # No delimiters but with wildcards in hierachy\n  \
    \      IF(HierarchyExists( pDim, pHier )=1 );\n            sMDX                = Expand('{TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%pHier%')}');\n        ELSEIF(Scan( '*', pHier\
    \ )=0 & Scan( '?', pHier )=0 );\n            nErrors = 1;\n            sMessage= Expand('Dimension:Hierarchy\
    \ %pDim%:%pHier% does not exist.');\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        ELSE;\n            sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL(\
    \ [}Dimensions] ) ,'%pDim%:%pHier%')}');\n        ENDIF;\n        \n    ENDIF;\n\nElseIf(\
    \ Trim( pHier ) @='' );\n    ## Use main hierarchy for each dimension processed\n    pHier\
    \ = Trim( pDim );\n    sMDX            = '{ ';\n    IF( Scan( pDelim  , pHier )>0 );\n \
    \       # delimiter in pHier. Seperate and add MDX for each part separately\n        sHiers\
    \           = Trim( pHier );\n        nDelimiterIndex = 1;\n        While( nDelimiterIndex\
    \ <> 0 );    \n            nDelimiterIndex = Scan( pDelim, sHiers );\n            If( nDelimiterIndex\
    \ = 0 );\n                sHier            = sHiers;\n            ELSE;\n              \
    \  sHier            = Trim( SubSt( sHiers, 1, nDelimiterIndex - 1 ) );\n               \
    \ sHiers           = Trim( Subst( sHiers, nDelimiterIndex + Long(pDelim), Long( sHiers )\
    \ ) );\n            ENDIF;\n            IF(HierarchyExists( sHier, sHier )=1 );\n      \
    \          sMDX            = sMDX | IF(Long(sMDX)>4,\n                                 \
    \           Expand(',TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')'),\n                            \
    \                Expand(' TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')')); \n            ELSEIF(Scan( '*',\
    \ sHier )=0 & Scan( '?', sHier )=0 );\n                nErrors = 1;\n                sMessage=\
    \ Expand('Dimension:Hierarchy %sHier%:%sHier% does not exist.');\n                LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            ELSE;\n                sMDX\
    \            = sMDX | IF(Long(sMDX)>4,\n                                            Expand(',TM1FILTERBYPATTERN(\
    \ EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) , '*:*') ) ,'%sHier%')'),\n                                            Expand(' TM1FILTERBYPATTERN(\
    \ EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) , '*:*') ) ,'%sHier%')')); \n            ENDIF;\n                \n        END;\n  \
    \      sMDX                    = sMDX | ' }';\n    ELSE;\n        # No delimiters but with\
    \ wildcards in hierachy\n        IF(HierarchyExists( pDim, pHier )=1 );\n            sMDX\
    \                = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) ,\
    \ TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%pDim%')}');\n        ELSEIF(Scan(\
    \ '*', pHier )=0 & Scan( '?', pHier )=0 );\n            nErrors = 1;\n            sMessage=\
    \ Expand('Dimension:Hierarchy %pDim%:%pHier% does not exist.');\n            LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ELSE;\n            sMDX       \
    \         = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%pDim%')}');\n        ENDIF;\n        \n  \
    \  ENDIF;\n    \nELSE;\n    nErrors = 1;\n    sMessage= Expand('Dimension:Hierarchy %pDim%:%pHier%\
    \ does not exist.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n    DatasourceType = 'NULL';\n\
    \    ProcessBreak;\nEndIf;\n\n# Create temporary subset\nSubsetCreatebyMDX(cSubset, sMDX\
    \ , 1 );\n\n### Set data source for process ### \nDatasourceType              = 'SUBSET';\n\
    DatasourceNameForServer     = cDim; \nDatasourceNameForClient     = cDim;\nDatasourceDimensionSubset\
    \   = cSubset;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# Validates characters in elements\n\n# Increment\
    \ nMeta\nnMeta           = nMeta + 1;\n\n# Output 1st line\nIF( nMeta = 1 );\n    sOutput\
    \     = 'Dimension:Hierarchy'' |','| ''Element''  |','| ''Type'' |','| ''Comments';\n  \
    \  TextOutput ( cFile , sOutput );\nEndIf;\n\n### Skip Control dimensions###\nIF(Subst(vDim\
    \ , 1 , 1 ) @= '}' );\n    ItemSkip;\nENDIF;\n\n# Set Dim name & hierachy name\nIF( SCAN(\
    \ ':' , vDim )=0 );\n    sDim        = vDim ;\n    sHier       = sDim ;\nELSE;\n    sDim\
    \        = SUBST( vDim, 1 , SCAN( ':' , vDim ) -1 );\n    sHier       = SUBST( vDim, SCAN(\
    \ ':' , vDim ) +1, 99 );\nENDIF;\n\nnDimSize        = ElementCount( sDim , sHier );\nnCount\
    \          = 1;\nWhile( nCount <= nDimSize );\n    sEle        = ElementName( sDim , sHier\
    \ , nCount );\n    sEleType    = ElementType( sDim , sHier , sEle );\n    sEleNew     =\
    \ '';\n    nEleSiz     = Long(sEle);\n    nChar       = 1;\n    While( nChar <= nEleSiz\
    \ & ElementIndex( sDim , sHier , sEle ) > 0 );\n        sChar       = NumberToString( nChar\
    \ );\n        sEleChar    = Subst( sEle , nChar , 1 );\n        nCode       = CODE( sEle\
    \ , nChar );\n        sCode       = NumberToString( nCode );\n        IF( vDim @= sDim );\n\
    \            IF( nChar=1 & pFirst=1 & (nCode=39 % nCode=45 % nCode=91 % nCode=34 % nCode=64\
    \ % nCode=33 % nCode=43 % nCode=123 % nCode=37));\n                sOutput = Expand('%vDim%'\
    \ , %sEle% , %sEleType% ,Has an illegal 1st character '%sEleChar%' with an AscII code of\
    \ %sCode%.');\n                TextOutput ( cFile , sOutput );\n            EndIf;\n   \
    \         IF( sEleChar@='/' % sEleChar@='|' % sEleChar@=''' % sEleChar@='' % sEleChar@='>'\
    \ % \n                sEleChar@='<' % sEleChar@=':' % sEleChar@='?' % sEleChar@='*');  \
    \   \n                sOutput = Expand('%vDim%' , %sEle% , %sEleType% ,Has a forbidden character\
    \ #%sChar% '%sEleChar%' with an AscII code of %sCode%.');\n                TextOutput (\
    \ cFile , sOutput );\n            ENDIF;\n        ELSEIF( ElementType( sDim, sHier, sEle)@='C'\
    \ % pHier@<>'' );\n            IF( nChar=1 & pFirst=1 & (nCode=39 % nCode=45 % nCode=91\
    \ % nCode=34 % nCode=64 % nCode=33 % nCode=43 % nCode=123 % nCode=37));\n              \
    \  sOutput = Expand('%vDim%' , %sEle% , %sEleType% ,Has an illegal 1st character '%sEleChar%'\
    \ with an AscII code of %sCode%.');\n                TextOutput ( cFile , sOutput );\n \
    \           EndIf;\n            IF( sEleChar@='/' % sEleChar@='|' % sEleChar@=''' % sEleChar@=''\
    \ % sEleChar@='>' % \n                sEleChar@='<' % sEleChar@=':' % sEleChar@='?' % sEleChar@='*');\
    \     \n                sOutput = Expand('%vDim%' , %sEle% , %sEleType% ,Has a forbidden\
    \ character #%sChar% '%sEleChar%' with an AscII code of %sCode%.');\n                TextOutput\
    \ ( cFile , sOutput );\n            ENDIF;\n        ENDIF;\n\n        nChar       = nChar\
    \ + 1;\n    End;\n    \n    nCount      = nCount + 1;\nEnd;\n\n### End MetaData ###\n#Section\
    \ Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    ### If errors occurred terminate process with a major error status ###\nIf( nErrors <> 0\
    \ );\n  sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% incurred\
    \ at least 1 major error and consequently aborted.' );\n  nProcessReturnCode = 0;\n  LogOutput(\
    \ 'ERROR', Expand( sProcessReturnCode | ' Please see above lines in this file for more details.'\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  EndIf;\nEndIf;\n\n#Return\
    \ Code\nsProcessAction      = Expand( 'Process:%cThisProcName% has validated all the elements\
    \ for %pDim% dimension and generated a csv report: %cFile%.' );\nsProcessReturnCode  = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode  = 1;\nIF ( pLogoutput\
    \ = 1 );\n  LogOutput('INFO', sProcessAction );   \nENDIF;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der alle konsolidierten Elemente
    ohne untergeordnete Elemente in der Zielhierarchie löscht. Verwende diesen Prozess, um Konsolidierungen
    nach Änderungen in der Dimension aufzuräumen. Wichtig: Eine gültige Zieldimension (pDim)
    muss angegeben werden, sonst wird der Prozess abgebrochen. Achtung: Die Zielhierarchie (pHier)
    darf nicht ''Leaves'' sein.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete all consolidated elements with\
    \ no children in the target Hierarchy.\n\n# Use case:\n# - Service process to clean-up consolidations\
    \ after dimension changes.\n\n# Note:\n# Valid target dimension (pDim) must be supplied\
    \ otherwise the process will terminate.\n\n# Caution: Target hierarchy (pHier) cannot be\
    \ `Leaves`.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%.' ;  \ncMsgInfoContent = 'User:%cUserName%\
    \ Process:%cThisProcName% Message:%sMessage%';\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim,\
    \ pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim       \
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Hierarchy\nIf( Trim(\
    \ pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed this\
    \ is managed inside the code below\nEndIf;\n\n# If blank delimiter specified then convert\
    \ to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before\
    \ continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\n\
    sDims = pDim;\nnDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex\
    \ <> 0 );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims\
    \ );\n    If( nDimDelimiterIndex = 0 );\n        sDim = sDims;\n    Else;\n        sDim\
    \ = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims = Trim( Subst( sDims,\
    \ nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n      # Create\
    \ subset of dimensions using Wildcard to loop through dimensions in pDim with wildcard\n\
    \    sDimExp = '''|sDim|''';\n    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp\
    \ | ')}';\n    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx\
    \ | ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n\nIf( SubsetExists( '}Dimensions' , cTempSub )\
    \ = 1 );\n    # If a delimited list of dim names includes wildcards then we may have to\
    \ re-use the subset multiple times\n    SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n\
    Else;\n    # temp subset, therefore no need to destroy in epilog\n    SubsetCreatebyMDX(\
    \ cTempSub, sMDX, '}Dimensions' , 1 );\nEndIf;\n\n# Loop through dimensions in subset created\
    \ based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\nWhile( nCountDim\
    \ >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim );\n   \
    \ # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n        nErrors = 1;\n\
    \        sMessage = Expand( 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR',\
    \ Expand( cMsgErrorContent ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage\
    \ = Expand( 'Dimension %sDim% being processed....' );\n          LogOutput( 'INFO', Expand(\
    \ cMsgInfoContent ) );\n        EndIf;\n        # Loop through hierarchies in pHier\n  \
    \      If( Trim( pHier ) @= '' );\n          ### Use main hierarchy for each dimension if\
    \ pHier is empty\n          sHierarchies = sDim;\n        Else;\n          sHierarchies\
    \              = pHier;\n        EndIf;\n        nDelimiterIndexA    = 1;\n        sHierDim\
    \            = '}Dimensions';\n        \n        sMdxHier = '';\n        While( nDelimiterIndexA\
    \ <> 0 );\n\n            nDelimiterIndexA = Scan( pDelim, sHierarchies );\n            If(\
    \ nDelimiterIndexA = 0 );\n                sHierarchy   = sHierarchies;\n            Else;\n\
    \                sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n\
    \                sHierarchies  = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim),\
    \ Long( sHierarchies ) ) );\n            EndIf;\n            \n            ## If no wildcard\
    \ specified and current hierarchy does not exist in dimension, create it\n            If(\
    \ Scan( '*', sHierarchy ) = 0 & Scan( '?', sHierarchy ) = 0);\n              If( HierarchyExists(\
    \ sDim, sHierarchy ) = 0 );\n                  HierarchyCreate( sDim, sHierarchy );\n  \
    \            EndIf;\n            EndIf;\n\n            # Create subset of Hierarchies using\
    \ Wildcard\n            If( sHierarchy @= sDim );\n                sHierExp = '''| sHierarchy\
    \ |''';\n            Else;\n                sHierExp = '''|sDim|':'|sHierarchy|''';\n  \
    \          EndIf;\n            sMdxHierPart = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim|\
    \ '])},'| sHierExp | ')}';\n            IF( sMdxHier @= ''); \n              sMdxHier =\
    \ sMdxHierPart; \n            ELSE;\n              sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n\
    \            ENDIF;\n        End;\n        IF(Trim(pHier) @= '*');\n          sMdxHier =\
    \ '{ UNION ( ' | sMdxHier |' , {[}Dimensions].[' | sDim | ']} )}';\n        ENDIF;\n   \
    \     \n        If( SubsetExists( sHierDim, cTempSub ) = 1 );\n            # If a delimited\
    \ list of attr names includes wildcards then we may have to re-use the subset multiple times\n\
    \            SubsetMDXSet( sHierDim, cTempSub, sMdxHier );\n        Else;\n            #\
    \ temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub,\
    \ sMdxHier, sHierDim, 1 );\n        EndIf;\n    \n        # Loop through subset of hierarchies\
    \ created based on wildcard\n        nCountHier = SubsetGetSize( sHierDim, cTempSub );\n\
    \        While( nCountHier >= 1 );\n            sCurrHier = SubsetGetElementName( sHierDim,\
    \ cTempSub, nCountHier );\n            sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1,\
    \ Long(sCurrHier) );\n            # Validate hierarchy name in dimension\n            If(\
    \ Dimix( sHierDim , sCurrHier ) = 0 );\n                sMessage = Expand('The %sCurrHier%\
    \ hierarchy does NOT exist in the %sDim% dimension.');\n                LogOutput( 'INFO'\
    \ , Expand( cMsgInfoContent ) );\n            Else;\n              If( pLogOutput = 1 );\n\
    \                sMessage = Expand( 'Hierarchy %sCurrHierName% in Dimension %sDim% being\
    \ processed....' );\n                LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n \
    \             EndIf;\n              \n              ### Go through dimension and delete\
    \ consols with no children ###\n              nElementCount       = ElementCount( sDim,\
    \ sCurrHierName );\n              While( nElementCount >= 1 );\n                  sElement\
    \        = ElementName( sDim, sCurrHierName, nElementCount );\n                  sElementType\
    \    = ElementType( sDim, sCurrHierName, sElement );\n                  If( sElementType\
    \ @= 'C' );\n                      nChildCount = ElementComponentCount( sDim, sCurrHierName,\
    \ sElement );\n                      If( nChildCount = 0 );\n                          HierarchyElementDelete(\
    \ sDim, sCurrHierName, sElement );\n                      EndIf;\n                  EndIf;\n\
    \                  nElementCount = nElementCount - 1;\n              End;\n\n          Endif;\n\
    \          \n            nCountHier = nCountHier - 1;\n        End;\n            \n    EndIf;\n\
    \    \n    nCountDim = nCountDim - 1;\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted all C\
    \ level items that did not have children.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Develop an IBM Turbo Integrator process that deletes all consolidated elements
    with no children in the target hierarchy. Use this process to clean up consolidations after
    dimension changes. Note: A valid target dimension (pDim) must be supplied, otherwise the
    process will terminate. Caution: The target hierarchy (pHier) cannot be ''Leaves''.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete all consolidated elements with\
    \ no children in the target Hierarchy.\n\n# Use case:\n# - Service process to clean-up consolidations\
    \ after dimension changes.\n\n# Note:\n# Valid target dimension (pDim) must be supplied\
    \ otherwise the process will terminate.\n\n# Caution: Target hierarchy (pHier) cannot be\
    \ `Leaves`.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%.' ;  \ncMsgInfoContent = 'User:%cUserName%\
    \ Process:%cThisProcName% Message:%sMessage%';\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim,\
    \ pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim       \
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Hierarchy\nIf( Trim(\
    \ pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed this\
    \ is managed inside the code below\nEndIf;\n\n# If blank delimiter specified then convert\
    \ to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before\
    \ continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\n\
    sDims = pDim;\nnDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex\
    \ <> 0 );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims\
    \ );\n    If( nDimDelimiterIndex = 0 );\n        sDim = sDims;\n    Else;\n        sDim\
    \ = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims = Trim( Subst( sDims,\
    \ nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n      # Create\
    \ subset of dimensions using Wildcard to loop through dimensions in pDim with wildcard\n\
    \    sDimExp = '''|sDim|''';\n    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp\
    \ | ')}';\n    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx\
    \ | ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n\nIf( SubsetExists( '}Dimensions' , cTempSub )\
    \ = 1 );\n    # If a delimited list of dim names includes wildcards then we may have to\
    \ re-use the subset multiple times\n    SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n\
    Else;\n    # temp subset, therefore no need to destroy in epilog\n    SubsetCreatebyMDX(\
    \ cTempSub, sMDX, '}Dimensions' , 1 );\nEndIf;\n\n# Loop through dimensions in subset created\
    \ based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\nWhile( nCountDim\
    \ >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim );\n   \
    \ # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n        nErrors = 1;\n\
    \        sMessage = Expand( 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR',\
    \ Expand( cMsgErrorContent ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage\
    \ = Expand( 'Dimension %sDim% being processed....' );\n          LogOutput( 'INFO', Expand(\
    \ cMsgInfoContent ) );\n        EndIf;\n        # Loop through hierarchies in pHier\n  \
    \      If( Trim( pHier ) @= '' );\n          ### Use main hierarchy for each dimension if\
    \ pHier is empty\n          sHierarchies = sDim;\n        Else;\n          sHierarchies\
    \              = pHier;\n        EndIf;\n        nDelimiterIndexA    = 1;\n        sHierDim\
    \            = '}Dimensions';\n        \n        sMdxHier = '';\n        While( nDelimiterIndexA\
    \ <> 0 );\n\n            nDelimiterIndexA = Scan( pDelim, sHierarchies );\n            If(\
    \ nDelimiterIndexA = 0 );\n                sHierarchy   = sHierarchies;\n            Else;\n\
    \                sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n\
    \                sHierarchies  = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim),\
    \ Long( sHierarchies ) ) );\n            EndIf;\n            \n            ## If no wildcard\
    \ specified and current hierarchy does not exist in dimension, create it\n            If(\
    \ Scan( '*', sHierarchy ) = 0 & Scan( '?', sHierarchy ) = 0);\n              If( HierarchyExists(\
    \ sDim, sHierarchy ) = 0 );\n                  HierarchyCreate( sDim, sHierarchy );\n  \
    \            EndIf;\n            EndIf;\n\n            # Create subset of Hierarchies using\
    \ Wildcard\n            If( sHierarchy @= sDim );\n                sHierExp = '''| sHierarchy\
    \ |''';\n            Else;\n                sHierExp = '''|sDim|':'|sHierarchy|''';\n  \
    \          EndIf;\n            sMdxHierPart = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim|\
    \ '])},'| sHierExp | ')}';\n            IF( sMdxHier @= ''); \n              sMdxHier =\
    \ sMdxHierPart; \n            ELSE;\n              sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n\
    \            ENDIF;\n        End;\n        IF(Trim(pHier) @= '*');\n          sMdxHier =\
    \ '{ UNION ( ' | sMdxHier |' , {[}Dimensions].[' | sDim | ']} )}';\n        ENDIF;\n   \
    \     \n        If( SubsetExists( sHierDim, cTempSub ) = 1 );\n            # If a delimited\
    \ list of attr names includes wildcards then we may have to re-use the subset multiple times\n\
    \            SubsetMDXSet( sHierDim, cTempSub, sMdxHier );\n        Else;\n            #\
    \ temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub,\
    \ sMdxHier, sHierDim, 1 );\n        EndIf;\n    \n        # Loop through subset of hierarchies\
    \ created based on wildcard\n        nCountHier = SubsetGetSize( sHierDim, cTempSub );\n\
    \        While( nCountHier >= 1 );\n            sCurrHier = SubsetGetElementName( sHierDim,\
    \ cTempSub, nCountHier );\n            sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1,\
    \ Long(sCurrHier) );\n            # Validate hierarchy name in dimension\n            If(\
    \ Dimix( sHierDim , sCurrHier ) = 0 );\n                sMessage = Expand('The %sCurrHier%\
    \ hierarchy does NOT exist in the %sDim% dimension.');\n                LogOutput( 'INFO'\
    \ , Expand( cMsgInfoContent ) );\n            Else;\n              If( pLogOutput = 1 );\n\
    \                sMessage = Expand( 'Hierarchy %sCurrHierName% in Dimension %sDim% being\
    \ processed....' );\n                LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n \
    \             EndIf;\n              \n              ### Go through dimension and delete\
    \ consols with no children ###\n              nElementCount       = ElementCount( sDim,\
    \ sCurrHierName );\n              While( nElementCount >= 1 );\n                  sElement\
    \        = ElementName( sDim, sCurrHierName, nElementCount );\n                  sElementType\
    \    = ElementType( sDim, sCurrHierName, sElement );\n                  If( sElementType\
    \ @= 'C' );\n                      nChildCount = ElementComponentCount( sDim, sCurrHierName,\
    \ sElement );\n                      If( nChildCount = 0 );\n                          HierarchyElementDelete(\
    \ sDim, sCurrHierName, sElement );\n                      EndIf;\n                  EndIf;\n\
    \                  nElementCount = nElementCount - 1;\n              End;\n\n          Endif;\n\
    \          \n            nCountHier = nCountHier - 1;\n        End;\n            \n    EndIf;\n\
    \    \n    nCountDim = nCountDim - 1;\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted all C\
    \ level items that did not have children.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der alle Dimensionselemente in einer
    Hierarchie in eine Datei exportiert. Die Exportdatei soll alle Daten enthalten, die zur
    vollständigen Rekonstruktion der Dimension benötigt werden. Ein benutzerdefiniertes Trennzeichen
    (angegeben durch ein Zeichen oder dessen ASCII-Code) kann verwendet werden. Das Dateiformat
    ist wie folgt: Die erste Zeile enthält Metadaten der Datei mit einer Zusammenfassung der
    Dimension, der Hierarchie, der Anzahl der Elemente und dem Datum/Zeitpunkt der Dateierstellung.
    Die zweite Zeile gibt die Quelldimension und Hierarchie an. Die dritte Zeile zeigt die Sortierreihenfolge
    der Dimension. Die vierte und fünfte Zeile sind für zukünftige Entwicklungen reserviert.
    Die sechste Zeile ist die Kopfzeile für den Elementexport. Ab der siebten Zeile folgen die
    Elementeexportdaten. Dieser Prozess sollte dazu verwendet werden, ein Backup der Dimension
    vor Veränderungen in der produktiven Umgebung zu erstellen oder eine schnelle Replikation
    einer großen Dimension zu ermöglichen. Dabei sind ein gültiger Dimensionsname (pDim), die
    Einhaltung einer Kopfzeile (pTitleRecord) und das Legacy-Exportformat (pLegacy) zwingend
    erforderlich, andernfalls wird der Prozess abgebrochen. Falls erforderlich, kann ein benutzerdefiniertes
    Trennzeichen durch Angabe des Parameters pDelim als einzelnes Zeichen oder als 3-stellige
    (dezimal) ASCII-Code verwendet werden. Zum Beispiel, um TAB als Trennzeichen zu verwenden,
    verwende 009. Achtung: Der Prozess wurde in Bedrock4 neu gestaltet, kann jedoch Dimensionsexporte
    aus früheren Versionen von Bedrock im Legacy-Modus (pLegacy = 1) verarbeiten.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Export all Dimension elements in a Hierarchy\
    \ to a File. Export file maintains\n# all data that can be used to completely reconstruct\
    \ the dimension. Custom record delimiter\n# (specified by a character or its ASCII code)\
    \ can be used.\n# __Format of the file:__  \n# - 1st line: File metadata contains summary\
    \ information about the dimension, hierarchy, number of\n#   elements and date/time when\
    \ file was generated.\n# - 2nd line: Source dimension and hierarchy.\n# - 3rd line: Dimension\
    \ sort order.\n# - 4th and 5th line: Reserved for future development.\n# - 6th line: Header\
    \ for elements export.\n# - 7th line and forth: Elements export data.\n\n# Use case:\n#\
    \ 1. Backup of dimension before changes in productive environment.\n# 2. Quick replication\
    \ of a large dimension.\n\n# Note:\n# Valid dimension name (pDim), inclusion of header (pTitleRecord)\
    \ and legacy export format (pLegacy)\n# are mandatory otherwise the process will abort.\n\
    # If needed, custom delimiter might be used by specifying parameter pDelim value as either\
    \ exactly one\n# character or as a 3-digit (decimal) ASCII code. For example to use TAB\
    \ as a delimiter, use 009.\n\n# Caution: Process was redesigned in Bedrock4 but is able\
    \ to process dimension extracts from prior\n# versions of Bedrock in legacy mode (pLegacy\
    \ = 1).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%,\
    \ pTitleRecord:%pTitleRecord%, pDelim:%pDelim%, pQuote:%pQuote%, pLegacy:%pLegacy%.';\n\
    cCubeS1         = '}DimensionProperties';\ncType           = 'Type-';\ncParent         =\
    \ 'Parent-';\ncIndex          = 'Index-';\ncWeight         = 'Weight-';\ncAttrName     \
    \  = 'Attr Name-';\ncAttrValue      = 'Attr Value-';\ncLenASCIICode = 3;\n\npDelim  = TRIM(pDelim);\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Initialise ###\nnRecordCount = 0;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim       \
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n\
    \  nErrors = 1;\n  sMessage = 'Dimension: ' | pDim | ' does not exist.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Hierarchy\nIf( Trim( pHier ) @= ''\
    \ );\n  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIf( HierarchyExists( pDim, sHier\
    \ ) = 0 );\n  nErrors = 1;\n  sMessage = 'The Hierachy ' | sHier | ' does not exist.';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate export\
    \ path\nIf( Trim( pTgtDir ) @= '' );\n    pTgtDir     = GetProcessErrorFileDirectory;\n\
    \    sMessage    = 'Target folder defaulted to error file directory.';\n    LogOutput( 'INFO',\
    \ Expand( cMsgErrorContent ) );\nEndIf;\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim\
    \ );\n    pTgtDir = SubSt( pTgtDir, 1, Long( pTgtDir ) -1 );\nEndIf;\nIf( FileExists( pTgtDir\
    \ ) = 0 );\n    nErrors     = 1;\n    sMessage    = 'Invalid export path specified. Folder\
    \ does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    pTgtDir         = pTgtDir | sOSDelim;\n\n# Validate export filename\nIf( pTgtFile @= ''\
    \ );\n    pTgtFile        = pDim | If( pLegacy = 1,'',' '|sHier ) | '_Export.csv';\nElseIf(\
    \ Scan( '.', pTgtFile ) = 0 );\n    # No file extension specified\n    pTgtFile        =\
    \ pTgtFile | '.csv';\nEndIf;\n\n# Validate file delimiter & quote character\nIf( pDelim\
    \ @= '' );\n    pDelim = ',';\nElse;\n    # If length of pDelim is exactly 3 chars and each\
    \ of them is decimal digit, then the pDelim is entered as ASCII code\n    nValid = 0;\n\
    \    If ( LONG(pDelim) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode\
    \ );\n        If( CODE( pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim, nChar )<=CODE( '9',\
    \ 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n\
    \        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber(\
    \ pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\
    If( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is\
    \ exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII\
    \ code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n  \
    \    While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0',\
    \ 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n\
    \          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n\
    \    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote\
    \ = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate Character Set\nIf(Trim(\
    \ pCharacterSet ) @= '' );\n  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n# Construct full\
    \ export filename including path\nsFilename       = pTgtDir | pTgtFile;\nsAttrDimName  \
    \  = '}ElementAttributes_' | pDim ;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Assign Data Source ###\nDatasourceNameForServer     = pDim | IF(pHier@='','',':'|pHier)\
    \ ;\nDatasourceNameForClient     = DatasourceNameForServer ;\nDataSourceType           \
    \   = 'SUBSET';\nDatasourceDimensionSubset   = 'ALL';\nDatasourceAsciiDelimiter= pDelim;\n\
    DatasourceAsciiQuoteCharacter = pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n# Set the output character\
    \ set\nSetOutputCharacterSet( sFileName, pCharacterSet );\n\n### Record Count\nnRecordCount\
    \ = nRecordCount + 1;\n\n### Export Header Information\n## Line 1: File Metadata information\n\
    If( nRecordCount = 1 & pTitleRecord = 1 );\n    TextOutput( sFilename, 'Export from dimension\
    \ Hierarchy: ' | pDim|':'|sHier | ', all elements in index order. Total elements=' |\n \
    \                NumberToString( ElementCount( pDim, sHier ) ) | '. On ' | Date( Now, 1\
    \ ) | ' at ' | Time );\n\n## Line 2: Source Dimension\n    TextOutput( sFilename, pDim,\
    \ sHier  );\n\n## Line 3: Sort Order Information\n    sSortElementType    = CELLGETS( cCubeS1,\
    \ pDim, 'SORTELEMENTSTYPE' );\n    sSortComponentType  = CELLGETS( cCubeS1, pDim, 'SORTCOMPONENTSTYPE'\
    \ );\n    sSortElementSense   = CELLGETS( cCubeS1, pDim, 'SORTELEMENTSSENSE' );\n    sSortComponentSense\
    \ = CELLGETS( cCubeS1, pDim, 'SORTCOMPONENTSSENSE' );\n    If( pLegacy = 1 );\n        TextOutput(\
    \ sFilename, sSortElementType , sSortComponentType , sSortElementSense , sSortComponentSense\
    \  );\n    Else;\n        TextOutput( sFilename, 'Sort parameters :', sSortElementType ,\
    \ sSortComponentType , sSortElementSense , sSortComponentSense  );\n    EndIf;\n    \n##\
    \ Line 4 (and 5?): Header Information\n    If( pLegacy = 1 );\n            TextOutput( sFilename,\
    \ 'Reserved' );\n    EndIf;\n    TextOutput( sFilename, 'Reserved' );\n    \n## Line 5 or\
    \ 6: Header Information\n    TextOutput( sFilename, 'Line_Type', 'Element', 'Value_1', 'Value_2',\
    \ 'Value_3' );\n\n### Attribute Information \n    If( DimensionExists( sAttrDimName ) =\
    \ 1 );\n        nIndex = 1;\n        nLimit = DIMSIZ ( sAttrDimName );\n        WHILE( nIndex\
    \ <= nLimit );\n            sElName   = DIMNM( sAttrDimName, nIndex );\n            sElType\
    \   = DTYPE( sAttrDimName, sElName);\n            TextOutput( sFilename, 'A', sElName, sElType\
    \ );\n            nIndex = nIndex + 1;\n        END; \n    EndIf;\n#    TextOutput( sFilename,\
    \ '' );\nEndIf;\n\n### Element Information\nnElIndex        = ElementIndex( pDim, sHier,\
    \ vEle );\nsElType         = ElementTYPE(  pDim, sHier, vEle );\nTextOutput( sFilename,'E',\
    \ vEle, If( pLegacy = 1,'', cType ) | sElType, If( pLegacy = 1,'', cIndex ) | NumberToString(\
    \ nElIndex ) );\n\n### Element Parents\nnElPar          = ElementParentCount( pDim, sHier,\
    \ vEle );\nIF( nElPar > 0 );\n    nIndex = 1;\n    nLimit = nElPar;\n    WHILE( nIndex <=\
    \ nLimit );\n        sElPar  = ElementParent( pDim, sHier, vEle, nIndex );\n        sElType\
    \ = ElementTYPE( pDim, sHier, sElPar );\n        nElWgt  = ElementWeight( pDim, sHier, sElPar,\
    \ vEle );\n        TextOutput( sFilename, 'P', vEle, If( pLegacy = 1,'', cParent ) | sElPar,\
    \ If( pLegacy = 1,'', cType ) | sElType, If( pLegacy = 1,'', cWeight ) | NumberToString(\
    \ nElWgt ) );\n        nIndex = nIndex + 1;\n    END;\nENDIF;\n\n### Attribute Value \n\
    IF( DimensionExists( sAttrDimName ) = 1 );\n    nIndex = 1;\n    nLimit = DIMSIZ ( sAttrDimName\
    \ );\n    WHILE( nIndex <= nLimit );\n        sElName   = DIMNM( sAttrDimName, nIndex );\n\
    \        sElType   = DTYPE( sAttrDimName, sElName);\n        IF( sElType @= 'AN' );\n  \
    \          sAttrValue = NumberToString( ElementAttrN( pDim , sHier , vEle , sElName ) );\n\
    \        ELSE;\n            sAttrValue = ElementAttrS( pDim , sHier , vEle , sElName );\n\
    \        ENDIF;\n        IF( sAttrValue @<>'' & sAttrValue @<>'0' );\n            TextOutput(\
    \ sFilename, 'V', vEle, If( pLegacy = 1,'', cAttrName ) | sElName, If( pLegacy = 1,'', cAttrValue\
    \ ) | sAttrValue );\n        EndIf;\n        nIndex = nIndex + 1;\n    END;\nENDIF;\n\n\n\
    #Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### If errors occurred terminate process with a major error status ###\nIf( nErrors >\
    \ 0 );\n    sMessage = 'the process incurred at least 1 major error and consequently aborted.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for\
    \ details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    EndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName% successfully\
    \ exported the %pDim%:%pHier% dimension:hierarchy to %sFileName%.' );\nsProcessReturnCode\
    \  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode  = 1;\nIf (\
    \ pLogoutput = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \nEndIf;\n\n\n\
    ### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that exports all dimension elements in
    a hierarchy to a file. The export file should maintain all data necessary to completely
    reconstruct the dimension. A custom record delimiter (specified by a character or its ASCII
    code) can be used. The file format is as follows: The first line contains file metadata
    with a summary of the dimension, hierarchy, number of elements, and the date/time the file
    was generated. The second line indicates the source dimension and hierarchy. The third line
    shows the dimension sort order. The fourth and fifth lines are reserved for future development.
    The sixth line is the header for elements export. From the seventh line onwards, element
    export data follows. This process should be used to create a backup of the dimension before
    changes in the production environment or to quickly replicate a large dimension. A valid
    dimension name (pDim), inclusion of a header (pTitleRecord), and legacy export format (pLegacy)
    are mandatory, otherwise the process will abort. If needed, a custom delimiter can be used
    by specifying the parameter pDelim as either exactly one character or as a 3-digit (decimal)
    ASCII code. For example, to use TAB as a delimiter, use 009. Caution: The process was redesigned
    in Bedrock4 but is able to process dimension extracts from prior versions of Bedrock in
    legacy mode (pLegacy = 1).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Export all Dimension elements in a Hierarchy\
    \ to a File. Export file maintains\n# all data that can be used to completely reconstruct\
    \ the dimension. Custom record delimiter\n# (specified by a character or its ASCII code)\
    \ can be used.\n# __Format of the file:__  \n# - 1st line: File metadata contains summary\
    \ information about the dimension, hierarchy, number of\n#   elements and date/time when\
    \ file was generated.\n# - 2nd line: Source dimension and hierarchy.\n# - 3rd line: Dimension\
    \ sort order.\n# - 4th and 5th line: Reserved for future development.\n# - 6th line: Header\
    \ for elements export.\n# - 7th line and forth: Elements export data.\n\n# Use case:\n#\
    \ 1. Backup of dimension before changes in productive environment.\n# 2. Quick replication\
    \ of a large dimension.\n\n# Note:\n# Valid dimension name (pDim), inclusion of header (pTitleRecord)\
    \ and legacy export format (pLegacy)\n# are mandatory otherwise the process will abort.\n\
    # If needed, custom delimiter might be used by specifying parameter pDelim value as either\
    \ exactly one\n# character or as a 3-digit (decimal) ASCII code. For example to use TAB\
    \ as a delimiter, use 009.\n\n# Caution: Process was redesigned in Bedrock4 but is able\
    \ to process dimension extracts from prior\n# versions of Bedrock in legacy mode (pLegacy\
    \ = 1).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n\
    cTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%,\
    \ pTitleRecord:%pTitleRecord%, pDelim:%pDelim%, pQuote:%pQuote%, pLegacy:%pLegacy%.';\n\
    cCubeS1         = '}DimensionProperties';\ncType           = 'Type-';\ncParent         =\
    \ 'Parent-';\ncIndex          = 'Index-';\ncWeight         = 'Weight-';\ncAttrName     \
    \  = 'Attr Name-';\ncAttrValue      = 'Attr Value-';\ncLenASCIICode = 3;\n\npDelim  = TRIM(pDelim);\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Initialise ###\nnRecordCount = 0;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim       \
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n\
    \  nErrors = 1;\n  sMessage = 'Dimension: ' | pDim | ' does not exist.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Hierarchy\nIf( Trim( pHier ) @= ''\
    \ );\n  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIf( HierarchyExists( pDim, sHier\
    \ ) = 0 );\n  nErrors = 1;\n  sMessage = 'The Hierachy ' | sHier | ' does not exist.';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate export\
    \ path\nIf( Trim( pTgtDir ) @= '' );\n    pTgtDir     = GetProcessErrorFileDirectory;\n\
    \    sMessage    = 'Target folder defaulted to error file directory.';\n    LogOutput( 'INFO',\
    \ Expand( cMsgErrorContent ) );\nEndIf;\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim\
    \ );\n    pTgtDir = SubSt( pTgtDir, 1, Long( pTgtDir ) -1 );\nEndIf;\nIf( FileExists( pTgtDir\
    \ ) = 0 );\n    nErrors     = 1;\n    sMessage    = 'Invalid export path specified. Folder\
    \ does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    pTgtDir         = pTgtDir | sOSDelim;\n\n# Validate export filename\nIf( pTgtFile @= ''\
    \ );\n    pTgtFile        = pDim | If( pLegacy = 1,'',' '|sHier ) | '_Export.csv';\nElseIf(\
    \ Scan( '.', pTgtFile ) = 0 );\n    # No file extension specified\n    pTgtFile        =\
    \ pTgtFile | '.csv';\nEndIf;\n\n# Validate file delimiter & quote character\nIf( pDelim\
    \ @= '' );\n    pDelim = ',';\nElse;\n    # If length of pDelim is exactly 3 chars and each\
    \ of them is decimal digit, then the pDelim is entered as ASCII code\n    nValid = 0;\n\
    \    If ( LONG(pDelim) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode\
    \ );\n        If( CODE( pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim, nChar )<=CODE( '9',\
    \ 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n\
    \        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber(\
    \ pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\
    If( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is\
    \ exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII\
    \ code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n  \
    \    While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0',\
    \ 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n\
    \          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n\
    \    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote\
    \ = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate Character Set\nIf(Trim(\
    \ pCharacterSet ) @= '' );\n  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n# Construct full\
    \ export filename including path\nsFilename       = pTgtDir | pTgtFile;\nsAttrDimName  \
    \  = '}ElementAttributes_' | pDim ;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Assign Data Source ###\nDatasourceNameForServer     = pDim | IF(pHier@='','',':'|pHier)\
    \ ;\nDatasourceNameForClient     = DatasourceNameForServer ;\nDataSourceType           \
    \   = 'SUBSET';\nDatasourceDimensionSubset   = 'ALL';\nDatasourceAsciiDelimiter= pDelim;\n\
    DatasourceAsciiQuoteCharacter = pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n# Set the output character\
    \ set\nSetOutputCharacterSet( sFileName, pCharacterSet );\n\n### Record Count\nnRecordCount\
    \ = nRecordCount + 1;\n\n### Export Header Information\n## Line 1: File Metadata information\n\
    If( nRecordCount = 1 & pTitleRecord = 1 );\n    TextOutput( sFilename, 'Export from dimension\
    \ Hierarchy: ' | pDim|':'|sHier | ', all elements in index order. Total elements=' |\n \
    \                NumberToString( ElementCount( pDim, sHier ) ) | '. On ' | Date( Now, 1\
    \ ) | ' at ' | Time );\n\n## Line 2: Source Dimension\n    TextOutput( sFilename, pDim,\
    \ sHier  );\n\n## Line 3: Sort Order Information\n    sSortElementType    = CELLGETS( cCubeS1,\
    \ pDim, 'SORTELEMENTSTYPE' );\n    sSortComponentType  = CELLGETS( cCubeS1, pDim, 'SORTCOMPONENTSTYPE'\
    \ );\n    sSortElementSense   = CELLGETS( cCubeS1, pDim, 'SORTELEMENTSSENSE' );\n    sSortComponentSense\
    \ = CELLGETS( cCubeS1, pDim, 'SORTCOMPONENTSSENSE' );\n    If( pLegacy = 1 );\n        TextOutput(\
    \ sFilename, sSortElementType , sSortComponentType , sSortElementSense , sSortComponentSense\
    \  );\n    Else;\n        TextOutput( sFilename, 'Sort parameters :', sSortElementType ,\
    \ sSortComponentType , sSortElementSense , sSortComponentSense  );\n    EndIf;\n    \n##\
    \ Line 4 (and 5?): Header Information\n    If( pLegacy = 1 );\n            TextOutput( sFilename,\
    \ 'Reserved' );\n    EndIf;\n    TextOutput( sFilename, 'Reserved' );\n    \n## Line 5 or\
    \ 6: Header Information\n    TextOutput( sFilename, 'Line_Type', 'Element', 'Value_1', 'Value_2',\
    \ 'Value_3' );\n\n### Attribute Information \n    If( DimensionExists( sAttrDimName ) =\
    \ 1 );\n        nIndex = 1;\n        nLimit = DIMSIZ ( sAttrDimName );\n        WHILE( nIndex\
    \ <= nLimit );\n            sElName   = DIMNM( sAttrDimName, nIndex );\n            sElType\
    \   = DTYPE( sAttrDimName, sElName);\n            TextOutput( sFilename, 'A', sElName, sElType\
    \ );\n            nIndex = nIndex + 1;\n        END; \n    EndIf;\n#    TextOutput( sFilename,\
    \ '' );\nEndIf;\n\n### Element Information\nnElIndex        = ElementIndex( pDim, sHier,\
    \ vEle );\nsElType         = ElementTYPE(  pDim, sHier, vEle );\nTextOutput( sFilename,'E',\
    \ vEle, If( pLegacy = 1,'', cType ) | sElType, If( pLegacy = 1,'', cIndex ) | NumberToString(\
    \ nElIndex ) );\n\n### Element Parents\nnElPar          = ElementParentCount( pDim, sHier,\
    \ vEle );\nIF( nElPar > 0 );\n    nIndex = 1;\n    nLimit = nElPar;\n    WHILE( nIndex <=\
    \ nLimit );\n        sElPar  = ElementParent( pDim, sHier, vEle, nIndex );\n        sElType\
    \ = ElementTYPE( pDim, sHier, sElPar );\n        nElWgt  = ElementWeight( pDim, sHier, sElPar,\
    \ vEle );\n        TextOutput( sFilename, 'P', vEle, If( pLegacy = 1,'', cParent ) | sElPar,\
    \ If( pLegacy = 1,'', cType ) | sElType, If( pLegacy = 1,'', cWeight ) | NumberToString(\
    \ nElWgt ) );\n        nIndex = nIndex + 1;\n    END;\nENDIF;\n\n### Attribute Value \n\
    IF( DimensionExists( sAttrDimName ) = 1 );\n    nIndex = 1;\n    nLimit = DIMSIZ ( sAttrDimName\
    \ );\n    WHILE( nIndex <= nLimit );\n        sElName   = DIMNM( sAttrDimName, nIndex );\n\
    \        sElType   = DTYPE( sAttrDimName, sElName);\n        IF( sElType @= 'AN' );\n  \
    \          sAttrValue = NumberToString( ElementAttrN( pDim , sHier , vEle , sElName ) );\n\
    \        ELSE;\n            sAttrValue = ElementAttrS( pDim , sHier , vEle , sElName );\n\
    \        ENDIF;\n        IF( sAttrValue @<>'' & sAttrValue @<>'0' );\n            TextOutput(\
    \ sFilename, 'V', vEle, If( pLegacy = 1,'', cAttrName ) | sElName, If( pLegacy = 1,'', cAttrValue\
    \ ) | sAttrValue );\n        EndIf;\n        nIndex = nIndex + 1;\n    END;\nENDIF;\n\n\n\
    #Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### If errors occurred terminate process with a major error status ###\nIf( nErrors >\
    \ 0 );\n    sMessage = 'the process incurred at least 1 major error and consequently aborted.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for\
    \ details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    EndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName% successfully\
    \ exported the %pDim%:%pHier% dimension:hierarchy to %sFileName%.' );\nsProcessReturnCode\
    \  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode  = 1;\nIf (\
    \ pLogoutput = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \nEndIf;\n\n\n\
    ### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine Dimension mit ihren Hierarchien
    in einem TurboIntegrator-Skript exportiert. Dies sollte keinen CSV-Export beinhalten, sondern
    ein fest codiertes TurboIntegrator-Skript erstellen, das die Dimension/Hierarchie mit kompletten
    Rollup-Strukturen, Attributwerten, Teilmengen und Metadateninformationen wie Sortierreihenfolge,
    MDX-Hierarchienamen, Ebenen und Bezeichnungen wiedergibt. Der Prozess sollte für die automatische
    Skripterstellung zu Migrationszwecken dienlich sein, ohne dass eine Datenquelle oder andere
    Prozessparameter benötigt werden. Dies ist besonders nützlich in Umgebungen ohne Dateisystemzugriff
    und für manuell definierte Dimensionen. Berücksichtige die folgenden Parameter: pDim zur
    Filterung der zu exportierenden Dimensionen/Hierarchien, pEle zur Einschränkung der Elemente
    für den Export, pDimInfo zur Einbeziehung von Metadaten, pAttr und pAttrVal für die Attributerstellung
    und -werte sowie pSub für Teilmengen-Definitionen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process exports a dimension hierarchies as _TurboIntegrator\
    \ script_. This is rather than creating a CSV which can be read by a generic \n# TurboIntegrator\
    \ process this process creates a _**hardcoded**_ TurboIntegrator process to create a dimension/hierarchy\
    \ complete with rollup \n# structure, attribute values, subsets and metadata information\
    \ such as sort order, MDX hierarchy names and levels and captions.\n#\n# Use case:\n# The\
    \ specific use case where this process will be useful is to automate the creation of TurboIntegrator\
    \ script for promotion/migration purposes\n# as 100% stand-alone without need for data source\
    \ o any parameters for the process. This can be useful in situations where DevOps has no\
    \ file system access\n# to an environment and for manually defined dimensions such as measures.\n\
    #\n# Note:\n# Several parameters control the scope of what is exported.\n# * pDim accepts\
    \ wildcard and lists of dimensions and/or hierarchies to filter the **}Dimensions** dimension.\
    \ There is no separate **pHier** parameter for this process\n# * pEle accepts wildcard and\
    \ lists of _elements_. This can be used to limit the scope of the export of dimension structure\
    \ and attribute values to a subset of elements\n# * pDimInfo 1/0 numeric Boolean whether\
    \ to include metadata relevant to the dimensions/hierarchies defined in pDim from }DimensionProperties,\
    \ }HierarchyProperties and }DimensionAttributes\n# * pAttr 1/0 numeric Boolean whether to\
    \ include attribute creation\n# * pAttrVal 1/0 numeric Boolean whether to include attribute\
    \ values (for the elements defined in pEle )\n# * pSub 1/0 numeric Boolean whether to include\
    \ subset definitions for dynamic and static subsets\n# * There is no Boolean for exporting\
    \ dimension structure, this is determined by pEle. To export all elements use pEle='*'.\
    \ To suppress export of rollup structure (and attribute values) use pEle=''\n# * 2 scripts\
    \ are produced. One to copy/paste into prolog and one for epilog as Direct functions are\
    \ not used for creation of elements and parent-child relationships\n#\n# Caution: \n# This\
    \ process is designed for _**smaller (typically manually defined) dimensions**_. No check\
    \ is implemented for upper limit of the set of elements defined by pEle if run on a large\
    \ \n# dimension then the export script will be correspondingly large. \n#EndRegion @DOC\n\
    \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncTimeStampPrint\
    \ = TimSt( Now, '\\Y-\\m-\\d \\h:\\i:\\s' );\ncRandomInt      = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo\
    \        = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pEle:%pEle%, pDelim:%pDelim%,\
    \ pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%, pTitleRecord:%pTitleRecord%, pDimInfo:%pDimInfo%,\
    \ pAttr:%pAttr%, pAttrVal:%pAttrVal%, pSub:%pSub%';\ncCubeS1         = '}DimensionProperties';\n\
    pDelim          = Trim( pDelim );\ncLenASCIICode   = 3;\ncHashLine       = '#################################################################################################';\n\
    sAttrDone       = '';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Initialise ###\nnRecordCount = 0;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\n## Validate Source dimension\nIF( Trim( pDim ) @= '' );\n\
    \    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 &\
    \ Scan( pDelim, pDim ) = 0 & DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate element\nIf( pEle @<> '');\n    If( Scan( '*', pEle ) = 0 &\
    \ Scan( '?', pEle ) = 0 & Scan( pDelim, pEle ) = 0 & DimIx( pDim, pEle ) = 0 );\n      \
    \  nErrors = 1;\n        sMessage = 'Item ' | pEle | ' does NOT exist. Please enter a valid\
    \ element in the ' |pDim| ' dimension.';  \n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Endif;\nEndif;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n# Validate export path\nIf( Trim( pTgtDir ) @= '' );\n    pTgtDir     =\
    \ GetProcessErrorFileDirectory;\n    sMessage    = 'Target folder defaulted to error file\
    \ directory.';\n    LogOutput( 'INFO', Expand( cMsgErrorContent ) );\nEndIf;\nIf( SubSt(\
    \ pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n    pTgtDir     = SubSt( pTgtDir, 1, Long(\
    \ pTgtDir ) -1 );\nEndIf;\nIf( FileExists( pTgtDir ) = 0 );\n    nErrors     = 1;\n    sMessage\
    \    = 'Invalid export path specified. Folder does not exist.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\npTgtDir         = pTgtDir | sOSDelim;\n\n# Validate\
    \ export filename\nIf( pTgtFile    @= '' );\n    pTgtFile1   = 'bedrock_dimension_script_prolog.txt';\n\
    \    pTgtFile2   = 'bedrock_dimension_script_epilog.txt';\nElse;\n    If( SubSt( pTgtFile,\
    \ Long( pTgtFile ) - 4, 1 ) @= '.' );\n        pTgtFile = SubSt( pTgtFile, 1, Long( pTgtFile\
    \ ) - 5 );\n    EndIf;\n    If( SubSt( pTgtFile, Long( pTgtFile ), 1 ) @= '_' );\n     \
    \   pTgtFile = SubSt( pTgtFile, 1, Long( pTgtFile ) - 1 );\n    EndIf;\n    pTgtFile1  \
    \ = pTgtFile | '_prolog.txt';\n    pTgtFile2   = pTgtFile | '_epilog.txt';\n\nEndIf;\n\n\
    # Validate file delimiter & quote character\nIf( pDelim @= '' );\n    pDelim      = '&';\n\
    Else;\n    # If length of pDelim is exactly 3 chars and each of them is decimal digit, then\
    \ the pDelim is entered as ASCII code\n    nValid      = 0;\n    If ( LONG(pDelim) = cLenASCIICode\
    \ );\n      nChar     = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pDelim,\
    \ nChar )>=CODE( '0', 1 ) & CODE( pDelim, nChar )<=CODE( '9', 1 ) );\n          nValid =\
    \ 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar   = nChar + 1;\n\
    \      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim    = Char( StringToNumber(\
    \ pDelim ) );\n    Else;\n      pDelim    = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\n\
    EndIf;\n\n# Validate Character Set\nIf(Trim( pCharacterSet ) @= '' );\n  pCharacterSet =\
    \ 'TM1CS_UTF8';\nEndIf;\n\n# Use no quote character \npQuote          = '';\n\n# Construct\
    \ full export filename including path\nsFileName       = pTgtDir | pTgtFile1;\nsFileName2\
    \      = pTgtDir | pTgtFile2;\n\n# If blank delimiter specified then convert to default\n\
    If( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\n\
    nDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0\
    \ );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n\
    \    If( nDimDelimiterIndex = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim(\
    \ SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex\
    \ + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n    # Create subset of dimensions\
    \ using Wildcard to loop through dimensions in pDim with wildcard\n    sDimExp = '''|sDim|''';\n\
    \    sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions].[}Dimensions] ),\
    \ %sDimExp% )}');\n    If( sMdx @= ''); \n        sMdx = sMdxPart; \n    Else;\n       \
    \ sMdx = sMdx | ' + ' | sMdxPart;\n    EndIf;\nEnd;\n\nIf( SubsetExists( '}Dimensions' ,\
    \ cTempSub ) = 1 );\n    # If a delimited list of dim names includes wildcards then we may\
    \ have to re-use the subset multiple times\n    SubsetMDXSet( '}Dimensions' , cTempSub,\
    \ sMDX );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n    SubsetCreatebyMDX(\
    \ cTempSub, sMDX, '}Dimensions' , 1 );\nEndIf;\n\n# Assign Data Source\nDataSourceType \
    \                 = 'SUBSET';\nDatasourceNameForServer         = '}Dimensions';\nDatasourceDimensionSubset\
    \       = cTempSub;\nDatasourceASCIIQuoteCharacter   = pQuote;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n \n\n# Set the output character set\nSetOutputCharacterSet( sFileName, pCharacterSet );\n\
    \n### Record Count\nnRecordCount = nRecordCount + 1;\n\n### Set dimension & hierarchy variables\n\
    If( Scan( ':', vDim ) = 0 );\n    sDim    = vDim;\n    sHier   = vDim;\nElse;\n    sDim\
    \    = SubSt( vDim, 1, Scan( ':', vDim ) - 1 );\n    sHier   = SubSt( vDim, Scan( ':', vDim\
    \ ) + 1, Long( vDim ) - ( Long( sDim ) + 1 ) );\nEndIf;\nsDimAttr    = '}ElementAttributes_'\
    \ | sDim;\nsDimSub     = '}Subsets_' | sDim;\n\n### Export Header Information\nIf( nRecordCount\
    \ = 1 & pTitleRecord = 1 );\n    sHeader = Expand('# Export dimensions as script pDim=%pDim%\
    \ pEle=%pEle% On %cTimeStampPrint%');\n    TextOutput( sFileName, sHeader );\n    If( (\
    \ pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists(\
    \ sDimSub ) = 1 ) );\n        sHeader = Expand('# Export dimensions as script pDim=%pDim%\
    \ pEle=%pEle% On %cTimeStampPrint%');\n        TextOutput( sFileName2, sHeader );\n    EndIf;\n\
    EndIf;\n\n### Dimension write open\nTextOutput( sFileName, '' );\nTextOutput( sFileName,\
    \ cHashLine );\nTextOutput( sFileName, Expand('#Region Dimension/Hierarchy: %vDim%') );\n\
    If( ( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists(\
    \ sDimSub ) = 1 ) );\n    TextOutput( sFileName2, '' );\n    TextOutput( sFileName2, cHashLine\
    \ );\n    TextOutput( sFileName2, Expand('#Region Dimension/Hierarchy: %vDim% (EPILOG)')\
    \ );\nEndIf;\n\n#################################################################################################\n\
    #Region Create Dimension (PROLOG)\nTextOutput( sFileName, '' );\nTextOutput( sFileName,\
    \ Expand('sDimHier = ''%vDim%'';') );\nTextOutput( sFileName, Expand('sDim     = ''%sDim%'';')\
    \ );\nTextOutput( sFileName, Expand('sHier    = ''%sHier%'';') );\nTextOutput( sFileName,\
    \ Expand('sDimAttr = ''%sDimAttr%'';') );\nTextOutput( sFileName, 'If( DimensionExists(\
    \ sDim ) = 0 );');\nTextOutput( sFileName, '    DimensionCreate( sDim );');\nTextOutput(\
    \ sFileName, '    If( sDim @<> sHier );');\nTextOutput( sFileName, '        HierarchyCreate(\
    \ sDim, sHier );');\nTextOutput( sFileName, '    EndIf;' );\nTextOutput( sFileName, 'ElseIf(\
    \ sDim @<> sHier );');\nTextOutput( sFileName, '    If( HierarchyExists( sDim, sHier ) =\
    \ 0 );');\nTextOutput( sFileName, '        HierarchyCreate( sDim, sHier );');\nTextOutput(\
    \ sFileName, '    EndIf;' );\nTextOutput( sFileName, 'EndIf;' );\n#EndRegion Create Dimension\n\
    #################################################################################################\n\
    \n#################################################################################################\n\
    #Region Dimension Info (PROLOG)\nIf( pDimInfo = 1 );\n    TextOutput( sFileName, '' );\n\
    \    TextOutput( sFileName, cHashLine );\n    TextOutput( sFileName, Expand('#Region Dimension\
    \ Info: %vDim%') );\n    sSORTELEMENTSTYPE   = CellGetS( '}DimensionProperties', vDim, 'SORTELEMENTSTYPE'\
    \ );\n    sSORTCOMPONENTSTYPE = CellGetS( '}DimensionProperties', vDim, 'SORTCOMPONENTSTYPE'\
    \ );\n    sSORTELEMENTSSENSE  = CellGetS( '}DimensionProperties', vDim, 'SORTELEMENTSSENSE'\
    \ );\n    sSORTCOMPONENTSSENSE= CellGetS( '}DimensionProperties', vDim, 'SORTCOMPONENTSSENSE'\
    \ );\n    sDefHier            = CellGetS( '}DimensionProperties', vDim, 'DEFAULT_HIERARCHY'\
    \ );\n    sDefMember          = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'defaultMember'\
    \ );\n    sHierLevels         = NumberToString( CellGetN( '}HierarchyProperties', vDim,\
    \ 'hierarchy0', 'LevelsToHierarchize' ) );\n    sLevel000           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level000' );\n    sLevel001           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level001' );\n    sLevel002           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level002' );\n    sLevel003           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level003' );\n    sLevel004           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level004' );\n    sLevel005           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level005' );\n    sLevel006           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level006' );\n    sLevel007           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level007' );\n    sLevel008           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level008' );\n    sLevel009           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level009' );\n    sLevel010           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level010' );\n    sLevel011           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level011' );\n    sLevel012           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level012' );\n    sLevel013           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level013' );\n    sLevel014           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level014' );\n    sLevel015           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level015' );\n    sLevel016           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level016' );\n    sLevel017           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level017' );\n    sLevel018           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level018' );\n    sLevel019           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level019' );\n    sLevel020           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level020' );\n    TextOutput( sFileName, Expand('DimensionSortOrder(\
    \ sDimHier, ''%sSORTCOMPONENTSTYPE%'', ''%sSORTCOMPONENTSSENSE%'', ''%sSORTELEMENTSTYPE%'',\
    \ ''%sSORTELEMENTSSENSE%'' );') );\n    TextOutput( sFileName, Expand('CellPutS( ''%sDefHier%'',\
    \ ''}DimensionProperties'', sDimHier, ''DEFAULT_HIERARCHY'' );') );\n    TextOutput( sFileName,\
    \ Expand('CellPutS( ''%sDefMember%'', ''}HierarchyProperties'', sDimHier, ''hierarchy0'',\
    \ ''defaultMember'' );') );\n    TextOutput( sFileName, Expand('CellPutN( %sHierLevels%,\
    \ ''}HierarchyProperties'', sDimHier, ''hierarchy0'', ''LevelsToHierarchize'' );') );\n\
    \    nCtr                = 0;\n    While( nCtr         <= 20 );\n        sLvl          \
    \  = 'Level0' | If( nCtr < 10, '0', '' ) | NumberToString( nCtr ); \n        sLvlVal   \
    \      = Expand('%'| Expand('s%sLvl%') |'%');\n        If( sLvlVal     @<> '' );\n     \
    \       TextOutput( sFileName, Expand('CellPutS( ''%sLvlVal%'', ''}HierarchyProperties'',\
    \ sDimHier, ''hierarchy0'', ''%sLvl%'' );') );\n        EndIf;\n        nCtr           \
    \ = nCtr + 1;\n    End;\n    If( CubeExists( '}DimensionAttributes' ) = 1 );\n        nCtr\
    \            = 1;\n        While( nCtr     <= DimSiz( '}DimensionAttributes' ) );\n    \
    \        sAttr       = DimNm( '}DimensionAttributes', nCtr );\n            sAttrTyp    =\
    \ SubSt( DType( '}DimensionAttributes', sAttr ), 2, 1 );\n            sAttrVal    = If(\
    \ sAttrTyp @= 'N', NumberToString( DimensionAttrN( vDim, sAttr ) ), DimensionAttrS( vDim,\
    \ sAttr ) );\n            TextOutput( sFileName, Expand('DimensionAttrInsert( '''', ''%sAttr%'',\
    \ ''%sAttrTyp%'' );') );\n            If( sAttrTyp @= 'N' );\n                TextOutput(\
    \ sFileName, Expand('DimensionAttrPutN( %sAttrVal%, sDimHier, ''%sAttr%'' );') );\n    \
    \        Else;\n                TextOutput( sFileName, Expand('DimensionAttrPutS( ''%sAttrVal%'',\
    \ sDimHier, ''%sAttr%'' );') );\n            EndIf;\n            nCtr        = nCtr + 1;\n\
    \        End;\n    EndIf;\n    TextOutput( sFileName, Expand('#EndRegion Dimension Info:\
    \ %vDim%') );\n    TextOutput( sFileName, cHashLine );\nEndIf;\n#EndRegion Dimension Info\n\
    #################################################################################################\n\
    \n#################################################################################################\n\
    #Region Create Attributes (PROLOG)\nIf( pAttr = 1 & DimensionExists( sDimAttr ) = 1 & Scan(\
    \ sDim|pDelim, sAttrDone ) = 0 );\n    sAttrDone       = sAttrDone | sDim | pDelim;\n  \
    \  TextOutput( sFileName, '' );\n    TextOutput( sFileName, cHashLine );\n    TextOutput(\
    \ sFileName, Expand('#Region Create Attributes: %sDim%') );\n    nCtr            = 1;\n\
    \    While( nCtr     <= DimSiz( sDimAttr ) );\n        sAttr       = DimNm( sDimAttr, nCtr\
    \ );\n        sAttrTyp    = SubSt( DType( sDimAttr, sAttr ), 2, 1 );\n        # Escape potential\
    \ single apostrophes to avoid parsing errors in attribute names\n        nChar = 1;\n  \
    \      nCount = 0;\n        sAttrStrOut = '';\n        While( nChar <= LONG( sAttr ) + 1\
    \ );\n            If( nChar <= LONG( sAttr ) );\n                sChar = SUBST( sAttr, nChar,\
    \ 1 );\n            Else;\n                sChar = '';\n            EndIf;\n           \
    \ If( sChar @= '''' );\n                nCount = nCount + 1;\n            ElseIf( nCount\
    \ > 0 );\n                If( MOD( nCount, 2 ) <> 0 );\n                    sAttrStrOut\
    \ = sAttrStrOut | '''';\n                EndIf;\n                nCount = 0;\n         \
    \   EndIf;\n            sAttrStrOut = sAttrStrOut | sChar;\n            nChar = nChar +\
    \ 1;\n        End;\n        If( nCtr = 1 );\n            TextOutput( sFileName, 'If( DimensionExists(\
    \ sDimAttr ) = 0 % CubeExists( sDimAttr ) = 0 );');\n            TextOutput( sFileName,\
    \ Expand('    AttrInsert( sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\n      \
    \      TextOutput( sFileName, 'EndIf;' );\n        EndIf;\n        TextOutput( sFileName,\
    \ Expand('If( DimIx( sDimAttr, ''%sAttrStrOut%'' ) = 0 );') );\n        TextOutput( sFileName,\
    \ Expand('    AttrInsert( sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\n      \
    \  TextOutput( sFileName, 'Else;' );\n        TextOutput( sFileName, Expand('    If( DType(\
    \ sDimAttr, ''%sAttrStrOut%'' ) @<> ''A%sAttrTyp%'' );') );\n        TextOutput( sFileName,\
    \ Expand('        AttrDelete( sDim, ''%sAttrStrOut%'' );') );\n        TextOutput( sFileName,\
    \ Expand('        AttrInsert( sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\n  \
    \      TextOutput( sFileName, '    EndIf;' );\n        TextOutput( sFileName, 'EndIf;' );\n\
    \        nCtr        = nCtr + 1;\n    End;\n    TextOutput( sFileName, Expand('#EndRegion\
    \ Create Attributes: %sDim%') );\n    TextOutput( sFileName, cHashLine );\nEndIf;\n#EndRegion\
    \ Create Attributes\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Create Dimension/Hierarchy Structure (PROLOG)\nIf( pEle @<> '' );\n    sMDX = '';\n\
    \    If( pEle @= '*' );\n        sMDX = Expand('{TM1SubsetAll([%sDim%].[%sHier%])}');\n\
    \    Else;\n        # Loop through elements (inc. wildcard expressions) in pEle\n      \
    \  sEles = pEle;\n        nEleDelimiterIndex = 1;\n        # Get 1st ele\n        While(\
    \ nEleDelimiterIndex <> 0 );\n            # Extract 1st ele in sEles\n            nEleDelimiterIndex\
    \ = Scan( pDelim, sEles );\n            If( nEleDelimiterIndex = 0 );\n                sEle\
    \ = sEles;\n            Else;\n                sEle = Trim( SubSt( sEles, 1, nEleDelimiterIndex\
    \ - 1 ) );\n                sEles = Trim( Subst( sEles, nEleDelimiterIndex + Long( pDelim\
    \ ), Long( sEles ) ) );\n            EndIf;\n            If( Scan( '*', sEle ) > 0 % Scan(\
    \ '?', sEle ) > 0 );\n                # Create MDX for subset of eles using Wildcard Pattern\
    \ filter (means pEle entry MUST use principal name)\n                sEleExp = '''|sEle|''';\n\
    \                sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [%sDim%].[%sHier%]\
    \ ), %sEleExp% )}');\n            Else;\n                # Create MDX of single element\
    \ and all descendants\n                sMDXPart = Expand('{TM1DRILLDOWNMEMBER( {[%sDim%].[%sHier%].[%sEle%]},\
    \ ALL, RECURSIVE )}');\n            EndIf;\n            If( sMDX @= ''); \n            \
    \    sMDX = sMdxPart; \n            Else;\n                sMDX = sMDX | ' + ' | sMdxPart;\n\
    \            EndIf;\n        End;\n    EndIf;\n    If( SubsetExists( vDim, cTempSub ) =\
    \ 1 );\n        SubsetMDXSet( vDim, cTempSub, sMDX );\n    Else;\n        SubsetCreatebyMDX(\
    \ cTempSub, sMDX, vDim, 1 );\n    EndIf;\n    nMax = SubsetGetSize( vDim, cTempSub );\n\
    \    If( nMax >= 1 );\n        TextOutput( sFileName, '' );\n        TextOutput( sFileName,\
    \ cHashLine );\n        TextOutput( sFileName, Expand('#Region Create Elements: %vDim%')\
    \ );\n        nCtr = 1;\n        While( nCtr <= nMax );\n            # 1st insert all elements\
    \ to get correct order\n            sEle = SubsetGetElementName( vDim, cTempSub, nCtr );\n\
    \            # Escape potential single apostrophes to avoid parsing errors in element names\n\
    \            nChar = 1;\n            nCount = 0;\n            sEleStrOut = '';\n       \
    \     While( nChar <= LONG( sEle ) + 1 );\n                If( nChar <= LONG( sEle ) );\n\
    \                    sChar = SUBST( sEle, nChar, 1 );\n                Else;\n         \
    \           sChar = '';\n                EndIf;\n                If( sChar @= '''' );\n\
    \                    nCount = nCount + 1;\n                ElseIf( nCount > 0 );\n     \
    \               If( MOD( nCount, 2 ) <> 0 );\n                        sEleStrOut = sEleStrOut\
    \ | '''';\n                    EndIf;\n                    nCount = 0;\n               \
    \ EndIf;\n                sEleStrOut = sEleStrOut | sChar;\n                nChar = nChar\
    \ + 1;\n            End;\n            sEleTyp = DType( vDim, sEle );\n            TextOutput(\
    \ sFileName, Expand('DimensionElementInsert( sDimHier, '''', ''%sEleStrOut%'', ''%sEleTyp%''\
    \ );') );\n            nCtr    = nCtr + 1;\n        End;\n        nCtr = 1;\n        While(\
    \ nCtr <= nMax );\n            # 2nd loop again and create parent linkages\n           \
    \ sEle    = SubsetGetElementName( vDim, cTempSub, nCtr );\n            # Escape potential\
    \ single apostrophes to avoid parsing errors in element names\n            nChar = 1;\n\
    \            nCount = 0;\n            sEleStrOut = '';\n            While( nChar <= LONG(\
    \ sEle ) + 1 );\n                If( nChar <= LONG( sEle ) );\n                    sChar\
    \ = SUBST( sEle, nChar, 1 );\n                Else;\n                    sChar = '';\n \
    \               EndIf;\n                If( sChar @= '''' );\n                    nCount\
    \ = nCount + 1;\n                ElseIf( nCount > 0 );\n                    If( MOD( nCount,\
    \ 2 ) <> 0 );\n                        sEleStrOut = sEleStrOut | '''';\n               \
    \     EndIf;\n                    nCount = 0;\n                EndIf;\n                sEleStrOut\
    \ = sEleStrOut | sChar;\n                nChar = nChar + 1;\n            End;\n        \
    \    nPar    = 1;\n            While( nPar <= ElParN( vDim, sEle ) );\n                sPar\
    \ = ElPar( vDim, sEle, nPar );\n                # Escape potential single apostrophes to\
    \ avoid parsing errors in parent element names\n                nChar = 1;\n           \
    \     nCount = 0;\n                sParStrOut = '';\n                While( nChar <= LONG(\
    \ sPar ) + 1 );\n                    If( nChar <= LONG( sPar ) );\n                    \
    \    sChar = SUBST( sPar, nChar, 1 );\n                    Else;\n                     \
    \   sChar = '';\n                    EndIf;\n                    If( sChar @= '''' );\n\
    \                        nCount = nCount + 1;\n                    ElseIf( nCount > 0 );\n\
    \                        If( MOD( nCount, 2 ) <> 0 );\n                            sParStrOut\
    \ = sParStrOut | '''';\n                        EndIf;\n                        nCount =\
    \ 0;\n                    EndIf;\n                    sParStrOut = sParStrOut | sChar;\n\
    \                    nChar = nChar + 1;\n                End;\n                sWht = NumberToString(\
    \ ElWeight( vDim, sPar, sEle ) );\n                If( pEle @<> '*' );\n               \
    \     TextOutput( sFileName, Expand('DimensionElementInsert( sDimHier, '''', ''%sParStrOut%'',\
    \ ''C'' );') );\n                EndIf;\n                TextOutput( sFileName, Expand('DimensionElementComponentAdd(\
    \ sDimHier, ''%sParStrOut%'', ''%sEleStrOut%'', %sWht% );') );\n                nPar = nPar\
    \ + 1;\n            End;\n            nCtr     = nCtr + 1;\n        End;\n        TextOutput(\
    \ sFileName, Expand('#EndRegion Create Elements: %vDim%') );\n        TextOutput( sFileName,\
    \ cHashLine );\n    EndIf;\nEndIf;\n#EndRegion Create Structure\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Attribute Values (EPILOG)\nIf( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 &\
    \ nMax >=1 );\n    TextOutput( sFileName2, '' );\n    TextOutput( sFileName2, cHashLine\
    \ );\n    TextOutput( sFileName2, Expand('#Region Attribute Values: %vDim%') );\n    TextOutput(\
    \ sFileName2, Expand('sDimHier = ''%vDim%'';') );\n    TextOutput( sFileName2, Expand('sDim\
    \     = ''%sDim%'';') );\n    TextOutput( sFileName2, Expand('sHier    = ''%sHier%'';')\
    \ );\n    TextOutput( sFileName2, Expand('sDimAttr = ''%sDimAttr%'';') );\n    nCtr = 1;\n\
    \    While( nCtr <= nMax );\n        # loop elements again and internally loop attributes\n\
    \        sEle = SubsetGetElementName( vDim, cTempSub, nCtr );\n        # Escape potential\
    \ single apostrophes to avoid parsing errors in element names\n        nChar = 1;\n    \
    \    nCount = 0;\n        sEleStrOut = '';\n        While( nChar <= LONG( sEle ) + 1 );\n\
    \            If( nChar <= LONG( sEle ) );\n                sChar = SUBST( sEle, nChar, 1\
    \ );\n            Else;\n                sChar = '';\n            EndIf;\n            If(\
    \ sChar @= '''' );\n                nCount = nCount + 1;\n            ElseIf( nCount > 0\
    \ );\n                If( MOD( nCount, 2 ) <> 0 );\n                    sEleStrOut = sEleStrOut\
    \ | '''';\n                EndIf;\n                nCount = 0;\n            EndIf;\n   \
    \         sEleStrOut = sEleStrOut | sChar;\n            nChar = nChar + 1;\n        End;\n\
    \        sEleTyp = DType( vDim, sEle );\n        nAttr   = 1;\n        While( nAttr <= DimSiz(\
    \ sDimAttr ) );\n            sAttr       = DimNm( sDimAttr, nAttr );\n            # Escape\
    \ potential single apostrophes to avoid parsing errors in attribute names\n            nChar\
    \ = 1;\n            nCount = 0;\n            sAttrStrOut = '';\n            While( nChar\
    \ <= LONG( sAttr ) + 1 );\n                If( nChar <= LONG( sAttr ) );\n             \
    \       sChar = SUBST( sAttr, nChar, 1 );\n                Else;\n                    sChar\
    \ = '';\n                EndIf;\n                If( sChar @= '''' );\n                \
    \    nCount = nCount + 1;\n                ElseIf( nCount > 0 );\n                    If(\
    \ MOD( nCount, 2 ) <> 0 );\n                        sAttrStrOut = sAttrStrOut | '''';\n\
    \                    EndIf;\n                    nCount = 0;\n                EndIf;\n \
    \               sAttrStrOut = sAttrStrOut | sChar;\n                nChar = nChar + 1;\n\
    \            End;\n            sAttrTyp    = SubSt( DType( sDimAttr, sAttr ), 2, 1 );\n\
    \            sAttrVal    = '';\n            If( ( sDim @<> sHier & sEleTyp @<> 'N' ) & sAttrTyp\
    \ @= 'N' );\n                sAttrVal= NumberToString( ElementAttrN( sDim, sHier, sEle,\
    \ sAttr ) );\n            ElseIf( sDim @<> sHier & sEleTyp @<> 'N' );\n                sAttrVal=\
    \ ElementAttrS( sDim, sHier, sEle, sAttr );\n            ElseIf( sEleTyp @= 'N' & sAttrTyp\
    \ @= 'N' & DimIx( sDim, sEle ) = 0 );\n                sAttrVal= NumberToString( ElementAttrN(\
    \ sDim, sHier, sEle, sAttr ) );\n            ElseIf( sEleTyp @= 'N' & DimIx( sDim, sEle\
    \ ) = 0 );\n                sAttrVal= ElementAttrS( sDim, sHier, sEle, sAttr );\n      \
    \      ElseIf( sAttrTyp @= 'N' );\n                sAttrVal= NumberToString( AttrN( sDim,\
    \ sEle, sAttr ) );\n            Else;\n                sAttrVal= AttrS( sDim, sEle, sAttr\
    \ );\n            EndIf;\n            sAttrValStrOut = '';\n            If( sAttrVal @<>\
    \ '' );\n                If( sAttrTyp @<> 'N' );\n                    # Escape potential\
    \ single apostrophes to avoid parsing errors in attribute values\n                    nChar\
    \ = 1;\n                    nCount = 0;\n                    While( nChar <= LONG( sAttrVal\
    \ ) + 1 );\n                        If( nChar <= LONG( sAttrVal ) );\n                 \
    \           sChar = SUBST( sAttrVal, nChar, 1 );\n                        Else;\n      \
    \                      sChar = '';\n                        EndIf;\n                   \
    \     If( sChar @= '''' );\n                            nCount = nCount + 1;\n         \
    \               ElseIf( nCount > 0 );\n                            If( MOD( nCount, 2 )\
    \ <> 0 );\n                                sAttrValStrOut = sAttrValStrOut | '''';\n   \
    \                         EndIf;\n                            nCount = 0;\n            \
    \            EndIf;\n                        sAttrValStrOut = sAttrValStrOut | sChar;\n\
    \                        nChar = nChar + 1;\n                    End;\n                Else;\n\
    \                    # we won't need any tratment for non-string attributes\n          \
    \          sAttrValStrOut = sAttrVal;\n                EndIf;\n                If( ( sDim\
    \ @<> sHier & sEleTyp @<> 'N' ) & sAttrTyp @= 'N' );\n                    TextOutput( sFileName2,\
    \ Expand('ElementAttrPutN( %sAttrValStrOut%, sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%''\
    \ );') );\n                ElseIf( sDim @<> sHier & sEleTyp @<> 'N' );\n               \
    \     TextOutput( sFileName2, Expand('ElementAttrPutS( ''%sAttrValStrOut%'', sDim, sHier,\
    \ ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                ElseIf( sEleTyp @= 'N' &\
    \ sAttrTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\n                    TextOutput( sFileName2,\
    \ Expand('ElementAttrPutN( %sAttrValStrOut%, sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%''\
    \ );') );\n                ElseIf( sEleTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\n       \
    \             TextOutput( sFileName2, Expand('ElementAttrPutS( ''%sAttrValStrOut%'', sDim,\
    \ sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                ElseIf( sAttrTyp @=\
    \ 'N' );\n                    TextOutput( sFileName2, Expand('AttrPutN( %sAttrValStrOut%,\
    \ sDim, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                Else;\n           \
    \         TextOutput( sFileName2, Expand('AttrPutS( ''%sAttrValStrOut%'', sDim, ''%sEleStrOut%'',\
    \ ''%sAttrStrOut%'' );') );\n                EndIf;\n            EndIf;\n            nAttr\
    \ = nAttr + 1;\n        End;\n        nCtr    = nCtr + 1;\n    End;\n    TextOutput( sFileName2,\
    \ Expand('#EndRegion Attribute Values: %vDim%') );\n    TextOutput( sFileName2, cHashLine\
    \ );\nEndIf;\n#EndRegion Attribute Values\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Subsets (EPILOG)\nIf( pSub = 1 & DimensionExists( sDimSub ) = 1 );\n    If( sDim\
    \ @= vDim );\n        sMDX = Expand('{Except( {TM1SubsetAll( [%sDimSub%] )}, {TM1FilterByPattern(\
    \ {TM1SubsetAll( [%sDimSub%] )}, '*:*' )} )}');\n    Else;\n        sMDX = Expand('{TM1FilterByPattern(\
    \ {TM1SubsetAll( [%sDimSub%] )}, '%sHier%:*' )}');\n    EndIf;\n    If( SubsetExists( sDimSub,\
    \ cTempSub ) = 1 );\n        SubsetMDXSet( sDimSub, cTempSub, sMDX );\n    Else;\n     \
    \   SubsetCreatebyMDX( cTempSub, sMDX, sDimSub, 1 );\n    EndIf;\n    nMax = SubsetGetSize(\
    \ sDimSub, cTempSub );\n    If( nMax >= 1 );\n        TextOutput( sFileName2, '' );\n  \
    \      TextOutput( sFileName2, cHashLine );\n        TextOutput( sFileName2, Expand('#Region\
    \ Subsets: %vDim%') );\n        If( pAttrVal <> 1 % DimensionExists( sDimAttr ) = 0 % pEle\
    \ @= '' );\n            TextOutput( sFileName2, Expand('sDimHier = ''%vDim%'';') );\n  \
    \          TextOutput( sFileName2, Expand('sDim     = ''%sDim%'';') );\n            TextOutput(\
    \ sFileName2, Expand('sHier    = ''%sHier%'';') );\n            TextOutput( sFileName2,\
    \ Expand('sDimAttr = ''%sDimAttr%'';') );\n        EndIf;\n        nCtr = 1;\n        While(\
    \ nCtr <= nMax );\n            sSub        = SubsetGetElementName( sDimSub, cTempSub, nCtr\
    \ );\n            If( Scan( ':', sSub ) > 0 );\n                sSub    = SubSt( sSub, Scan(\
    \ ':', sSub ) + 1, Long( sSub ) );\n            EndIf;\n            sMDX        = SubsetMDXGet(\
    \ vDim, sSub );\n            # If MDX expression contains TM1SubsetBasis function then treat\
    \ it as a static subset\n            If( sMDX @<> '' & Scan( 'TM1SUBSETBASIS()', Upper(\
    \ sMDX ) ) = 0 );\n                # create by MDX\n                TextOutput( sFileName2,\
    \ Expand('If( SubsetExists( sDimHier, ''%sSub%'' ) = 0 );') );\n                TextOutput(\
    \ sFileName2, Expand('    SubsetCreatebyMDX( ''%sSub%'', ''%sMDX%'', sDimHier, 0 );') );\n\
    \                TextOutput( sFileName2, 'Else;' );\n                TextOutput( sFileName2,\
    \ Expand('    SubsetMDXSet( sDimHier, ''%sSub%'', ''%sMDX%'' );') );\n                TextOutput(\
    \ sFileName2, 'EndIf;' );\n            Else;\n                # loop members\n         \
    \       TextOutput( sFileName2, Expand('If( SubsetExists( sDimHier, ''%sSub%'' ) = 0 );')\
    \ );\n                TextOutput( sFileName2, Expand('    SubsetCreate( sDimHier, ''%sSub%''\
    \ );') );\n                TextOutput( sFileName2, 'Else;' );\n                TextOutput(\
    \ sFileName2, Expand('    SubsetDeleteAllElements( sDimHier, ''%sSub%'' );') );\n      \
    \          TextOutput( sFileName2, 'EndIf;' );\n                nEles   = SubsetGetSize(\
    \ vDim, sSub );\n                nEle    = 1;\n                While( nEle <= nEles );\n\
    \                    sEle = SubsetGetElementName( vDim, sSub, nEle );\n                \
    \    # Escape potential single apostrophes to avoid parsing errors in element names\n  \
    \                  nChar = 1;\n                    nCount = 0;\n                    sEleStrOut\
    \ = '';\n                    While( nChar <= LONG( sEle ) + 1 );\n                     \
    \   If( nChar <= LONG( sEle ) );\n                            sChar = SUBST( sEle, nChar,\
    \ 1 );\n                        Else;\n                            sChar = '';\n       \
    \                 EndIf;\n                        If( sChar @= '''' );\n               \
    \             nCount = nCount + 1;\n                        ElseIf( nCount > 0 );\n    \
    \                        If( MOD( nCount, 2 ) <> 0 );\n                                sEleStrOut\
    \ = sEleStrOut | '''';\n                            EndIf;\n                           \
    \ nCount = 0;\n                        EndIf;\n                        sEleStrOut = sEleStrOut\
    \ | sChar;\n                        nChar = nChar + 1;\n                    End;\n     \
    \               TextOutput( sFileName2, Expand('SubsetElementInsert( sDimHier, ''%sSub%'',\
    \ ''%sEleStrOut%'', 0 );') );\n                    nEle = nEle + 1;\n                End;\n\
    \            EndIf;\n            nCtr        = nCtr + 1;\n        End;\n        TextOutput(\
    \ sFileName2, Expand('#EndRegion Subsets: %vDim%') );\n        TextOutput( sFileName2, cHashLine\
    \ );\n    EndIf;\nEndIf;\n#EndRegion Subsets\n#################################################################################################\n\
    \n### Dimension write close\nTextOutput( sFileName, '' );\nTextOutput( sFileName, Expand('#EndRegion\
    \ Dimension/Hierarchy: %vDim%') );\nTextOutput( sFileName, cHashLine );\nIf( ( pAttrVal\
    \ = 1 & DimensionExists( sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists(\
    \ sDimSub ) = 1 ) );\n    TextOutput( sFileName2, '' );\n    TextOutput( sFileName2, Expand('#EndRegion\
    \ Dimension/Hierarchy: %vDim%') );\n    TextOutput( sFileName2, cHashLine );\nEndIf;\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    ### If errors occurred terminate process with a major error status ###\nIf( nErrors > 0\
    \ );\n    sMessage = 'the process incurred at least 1 major error and consequently aborted.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for\
    \ details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    EndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName% successfully\
    \ exported %pDim% dimension:hierarchy to %sFileName%.' );\nsProcessReturnCode  = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode  = 1;\nIf ( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \nEndIf;\n\n### End"
- question: 'Develop an IBM Turbo Integrator process that exports a dimension with its hierarchies
    as a TurboIntegrator script. Instead of creating a CSV file, the process should generate
    a hardcoded TurboIntegrator script for creating the dimension/hierarchy, including complete
    rollup structure, attribute values, subsets, and metadata information like sort order, MDX
    hierarchy names, levels, and captions. This process should be useful for automating script
    creation for migration purposes without requiring a data source or any parameters for the
    process. It''s particularly helpful in environments without file system access and for manually
    defined dimensions. Consider the following parameters: pDim for filtering dimensions/hierarchies
    to export, pEle for limiting elements to be exported, pDimInfo for including metadata, pAttr
    and pAttrVal for attribute creation and values, and pSub for subset definitions.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process exports a dimension hierarchies as _TurboIntegrator\
    \ script_. This is rather than creating a CSV which can be read by a generic \n# TurboIntegrator\
    \ process this process creates a _**hardcoded**_ TurboIntegrator process to create a dimension/hierarchy\
    \ complete with rollup \n# structure, attribute values, subsets and metadata information\
    \ such as sort order, MDX hierarchy names and levels and captions.\n#\n# Use case:\n# The\
    \ specific use case where this process will be useful is to automate the creation of TurboIntegrator\
    \ script for promotion/migration purposes\n# as 100% stand-alone without need for data source\
    \ o any parameters for the process. This can be useful in situations where DevOps has no\
    \ file system access\n# to an environment and for manually defined dimensions such as measures.\n\
    #\n# Note:\n# Several parameters control the scope of what is exported.\n# * pDim accepts\
    \ wildcard and lists of dimensions and/or hierarchies to filter the **}Dimensions** dimension.\
    \ There is no separate **pHier** parameter for this process\n# * pEle accepts wildcard and\
    \ lists of _elements_. This can be used to limit the scope of the export of dimension structure\
    \ and attribute values to a subset of elements\n# * pDimInfo 1/0 numeric Boolean whether\
    \ to include metadata relevant to the dimensions/hierarchies defined in pDim from }DimensionProperties,\
    \ }HierarchyProperties and }DimensionAttributes\n# * pAttr 1/0 numeric Boolean whether to\
    \ include attribute creation\n# * pAttrVal 1/0 numeric Boolean whether to include attribute\
    \ values (for the elements defined in pEle )\n# * pSub 1/0 numeric Boolean whether to include\
    \ subset definitions for dynamic and static subsets\n# * There is no Boolean for exporting\
    \ dimension structure, this is determined by pEle. To export all elements use pEle='*'.\
    \ To suppress export of rollup structure (and attribute values) use pEle=''\n# * 2 scripts\
    \ are produced. One to copy/paste into prolog and one for epilog as Direct functions are\
    \ not used for creation of elements and parent-child relationships\n#\n# Caution: \n# This\
    \ process is designed for _**smaller (typically manually defined) dimensions**_. No check\
    \ is implemented for upper limit of the set of elements defined by pEle if run on a large\
    \ \n# dimension then the export script will be correspondingly large. \n#EndRegion @DOC\n\
    \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncTimeStampPrint\
    \ = TimSt( Now, '\\Y-\\m-\\d \\h:\\i:\\s' );\ncRandomInt      = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo\
    \        = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pEle:%pEle%, pDelim:%pDelim%,\
    \ pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%, pTitleRecord:%pTitleRecord%, pDimInfo:%pDimInfo%,\
    \ pAttr:%pAttr%, pAttrVal:%pAttrVal%, pSub:%pSub%';\ncCubeS1         = '}DimensionProperties';\n\
    pDelim          = Trim( pDelim );\ncLenASCIICode   = 3;\ncHashLine       = '#################################################################################################';\n\
    sAttrDone       = '';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Initialise ###\nnRecordCount = 0;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\n## Validate Source dimension\nIF( Trim( pDim ) @= '' );\n\
    \    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 &\
    \ Scan( pDelim, pDim ) = 0 & DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate element\nIf( pEle @<> '');\n    If( Scan( '*', pEle ) = 0 &\
    \ Scan( '?', pEle ) = 0 & Scan( pDelim, pEle ) = 0 & DimIx( pDim, pEle ) = 0 );\n      \
    \  nErrors = 1;\n        sMessage = 'Item ' | pEle | ' does NOT exist. Please enter a valid\
    \ element in the ' |pDim| ' dimension.';  \n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Endif;\nEndif;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n# Validate export path\nIf( Trim( pTgtDir ) @= '' );\n    pTgtDir     =\
    \ GetProcessErrorFileDirectory;\n    sMessage    = 'Target folder defaulted to error file\
    \ directory.';\n    LogOutput( 'INFO', Expand( cMsgErrorContent ) );\nEndIf;\nIf( SubSt(\
    \ pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n    pTgtDir     = SubSt( pTgtDir, 1, Long(\
    \ pTgtDir ) -1 );\nEndIf;\nIf( FileExists( pTgtDir ) = 0 );\n    nErrors     = 1;\n    sMessage\
    \    = 'Invalid export path specified. Folder does not exist.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\npTgtDir         = pTgtDir | sOSDelim;\n\n# Validate\
    \ export filename\nIf( pTgtFile    @= '' );\n    pTgtFile1   = 'bedrock_dimension_script_prolog.txt';\n\
    \    pTgtFile2   = 'bedrock_dimension_script_epilog.txt';\nElse;\n    If( SubSt( pTgtFile,\
    \ Long( pTgtFile ) - 4, 1 ) @= '.' );\n        pTgtFile = SubSt( pTgtFile, 1, Long( pTgtFile\
    \ ) - 5 );\n    EndIf;\n    If( SubSt( pTgtFile, Long( pTgtFile ), 1 ) @= '_' );\n     \
    \   pTgtFile = SubSt( pTgtFile, 1, Long( pTgtFile ) - 1 );\n    EndIf;\n    pTgtFile1  \
    \ = pTgtFile | '_prolog.txt';\n    pTgtFile2   = pTgtFile | '_epilog.txt';\n\nEndIf;\n\n\
    # Validate file delimiter & quote character\nIf( pDelim @= '' );\n    pDelim      = '&';\n\
    Else;\n    # If length of pDelim is exactly 3 chars and each of them is decimal digit, then\
    \ the pDelim is entered as ASCII code\n    nValid      = 0;\n    If ( LONG(pDelim) = cLenASCIICode\
    \ );\n      nChar     = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pDelim,\
    \ nChar )>=CODE( '0', 1 ) & CODE( pDelim, nChar )<=CODE( '9', 1 ) );\n          nValid =\
    \ 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar   = nChar + 1;\n\
    \      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim    = Char( StringToNumber(\
    \ pDelim ) );\n    Else;\n      pDelim    = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\n\
    EndIf;\n\n# Validate Character Set\nIf(Trim( pCharacterSet ) @= '' );\n  pCharacterSet =\
    \ 'TM1CS_UTF8';\nEndIf;\n\n# Use no quote character \npQuote          = '';\n\n# Construct\
    \ full export filename including path\nsFileName       = pTgtDir | pTgtFile1;\nsFileName2\
    \      = pTgtDir | pTgtFile2;\n\n# If blank delimiter specified then convert to default\n\
    If( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\n\
    nDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0\
    \ );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n\
    \    If( nDimDelimiterIndex = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim(\
    \ SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex\
    \ + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n    # Create subset of dimensions\
    \ using Wildcard to loop through dimensions in pDim with wildcard\n    sDimExp = '''|sDim|''';\n\
    \    sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions].[}Dimensions] ),\
    \ %sDimExp% )}');\n    If( sMdx @= ''); \n        sMdx = sMdxPart; \n    Else;\n       \
    \ sMdx = sMdx | ' + ' | sMdxPart;\n    EndIf;\nEnd;\n\nIf( SubsetExists( '}Dimensions' ,\
    \ cTempSub ) = 1 );\n    # If a delimited list of dim names includes wildcards then we may\
    \ have to re-use the subset multiple times\n    SubsetMDXSet( '}Dimensions' , cTempSub,\
    \ sMDX );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n    SubsetCreatebyMDX(\
    \ cTempSub, sMDX, '}Dimensions' , 1 );\nEndIf;\n\n# Assign Data Source\nDataSourceType \
    \                 = 'SUBSET';\nDatasourceNameForServer         = '}Dimensions';\nDatasourceDimensionSubset\
    \       = cTempSub;\nDatasourceASCIIQuoteCharacter   = pQuote;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n \n\n# Set the output character set\nSetOutputCharacterSet( sFileName, pCharacterSet );\n\
    \n### Record Count\nnRecordCount = nRecordCount + 1;\n\n### Set dimension & hierarchy variables\n\
    If( Scan( ':', vDim ) = 0 );\n    sDim    = vDim;\n    sHier   = vDim;\nElse;\n    sDim\
    \    = SubSt( vDim, 1, Scan( ':', vDim ) - 1 );\n    sHier   = SubSt( vDim, Scan( ':', vDim\
    \ ) + 1, Long( vDim ) - ( Long( sDim ) + 1 ) );\nEndIf;\nsDimAttr    = '}ElementAttributes_'\
    \ | sDim;\nsDimSub     = '}Subsets_' | sDim;\n\n### Export Header Information\nIf( nRecordCount\
    \ = 1 & pTitleRecord = 1 );\n    sHeader = Expand('# Export dimensions as script pDim=%pDim%\
    \ pEle=%pEle% On %cTimeStampPrint%');\n    TextOutput( sFileName, sHeader );\n    If( (\
    \ pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists(\
    \ sDimSub ) = 1 ) );\n        sHeader = Expand('# Export dimensions as script pDim=%pDim%\
    \ pEle=%pEle% On %cTimeStampPrint%');\n        TextOutput( sFileName2, sHeader );\n    EndIf;\n\
    EndIf;\n\n### Dimension write open\nTextOutput( sFileName, '' );\nTextOutput( sFileName,\
    \ cHashLine );\nTextOutput( sFileName, Expand('#Region Dimension/Hierarchy: %vDim%') );\n\
    If( ( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists(\
    \ sDimSub ) = 1 ) );\n    TextOutput( sFileName2, '' );\n    TextOutput( sFileName2, cHashLine\
    \ );\n    TextOutput( sFileName2, Expand('#Region Dimension/Hierarchy: %vDim% (EPILOG)')\
    \ );\nEndIf;\n\n#################################################################################################\n\
    #Region Create Dimension (PROLOG)\nTextOutput( sFileName, '' );\nTextOutput( sFileName,\
    \ Expand('sDimHier = ''%vDim%'';') );\nTextOutput( sFileName, Expand('sDim     = ''%sDim%'';')\
    \ );\nTextOutput( sFileName, Expand('sHier    = ''%sHier%'';') );\nTextOutput( sFileName,\
    \ Expand('sDimAttr = ''%sDimAttr%'';') );\nTextOutput( sFileName, 'If( DimensionExists(\
    \ sDim ) = 0 );');\nTextOutput( sFileName, '    DimensionCreate( sDim );');\nTextOutput(\
    \ sFileName, '    If( sDim @<> sHier );');\nTextOutput( sFileName, '        HierarchyCreate(\
    \ sDim, sHier );');\nTextOutput( sFileName, '    EndIf;' );\nTextOutput( sFileName, 'ElseIf(\
    \ sDim @<> sHier );');\nTextOutput( sFileName, '    If( HierarchyExists( sDim, sHier ) =\
    \ 0 );');\nTextOutput( sFileName, '        HierarchyCreate( sDim, sHier );');\nTextOutput(\
    \ sFileName, '    EndIf;' );\nTextOutput( sFileName, 'EndIf;' );\n#EndRegion Create Dimension\n\
    #################################################################################################\n\
    \n#################################################################################################\n\
    #Region Dimension Info (PROLOG)\nIf( pDimInfo = 1 );\n    TextOutput( sFileName, '' );\n\
    \    TextOutput( sFileName, cHashLine );\n    TextOutput( sFileName, Expand('#Region Dimension\
    \ Info: %vDim%') );\n    sSORTELEMENTSTYPE   = CellGetS( '}DimensionProperties', vDim, 'SORTELEMENTSTYPE'\
    \ );\n    sSORTCOMPONENTSTYPE = CellGetS( '}DimensionProperties', vDim, 'SORTCOMPONENTSTYPE'\
    \ );\n    sSORTELEMENTSSENSE  = CellGetS( '}DimensionProperties', vDim, 'SORTELEMENTSSENSE'\
    \ );\n    sSORTCOMPONENTSSENSE= CellGetS( '}DimensionProperties', vDim, 'SORTCOMPONENTSSENSE'\
    \ );\n    sDefHier            = CellGetS( '}DimensionProperties', vDim, 'DEFAULT_HIERARCHY'\
    \ );\n    sDefMember          = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'defaultMember'\
    \ );\n    sHierLevels         = NumberToString( CellGetN( '}HierarchyProperties', vDim,\
    \ 'hierarchy0', 'LevelsToHierarchize' ) );\n    sLevel000           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level000' );\n    sLevel001           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level001' );\n    sLevel002           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level002' );\n    sLevel003           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level003' );\n    sLevel004           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level004' );\n    sLevel005           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level005' );\n    sLevel006           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level006' );\n    sLevel007           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level007' );\n    sLevel008           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level008' );\n    sLevel009           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level009' );\n    sLevel010           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level010' );\n    sLevel011           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level011' );\n    sLevel012           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level012' );\n    sLevel013           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level013' );\n    sLevel014           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level014' );\n    sLevel015           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level015' );\n    sLevel016           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level016' );\n    sLevel017           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level017' );\n    sLevel018           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level018' );\n    sLevel019           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level019' );\n    sLevel020           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level020' );\n    TextOutput( sFileName, Expand('DimensionSortOrder(\
    \ sDimHier, ''%sSORTCOMPONENTSTYPE%'', ''%sSORTCOMPONENTSSENSE%'', ''%sSORTELEMENTSTYPE%'',\
    \ ''%sSORTELEMENTSSENSE%'' );') );\n    TextOutput( sFileName, Expand('CellPutS( ''%sDefHier%'',\
    \ ''}DimensionProperties'', sDimHier, ''DEFAULT_HIERARCHY'' );') );\n    TextOutput( sFileName,\
    \ Expand('CellPutS( ''%sDefMember%'', ''}HierarchyProperties'', sDimHier, ''hierarchy0'',\
    \ ''defaultMember'' );') );\n    TextOutput( sFileName, Expand('CellPutN( %sHierLevels%,\
    \ ''}HierarchyProperties'', sDimHier, ''hierarchy0'', ''LevelsToHierarchize'' );') );\n\
    \    nCtr                = 0;\n    While( nCtr         <= 20 );\n        sLvl          \
    \  = 'Level0' | If( nCtr < 10, '0', '' ) | NumberToString( nCtr ); \n        sLvlVal   \
    \      = Expand('%'| Expand('s%sLvl%') |'%');\n        If( sLvlVal     @<> '' );\n     \
    \       TextOutput( sFileName, Expand('CellPutS( ''%sLvlVal%'', ''}HierarchyProperties'',\
    \ sDimHier, ''hierarchy0'', ''%sLvl%'' );') );\n        EndIf;\n        nCtr           \
    \ = nCtr + 1;\n    End;\n    If( CubeExists( '}DimensionAttributes' ) = 1 );\n        nCtr\
    \            = 1;\n        While( nCtr     <= DimSiz( '}DimensionAttributes' ) );\n    \
    \        sAttr       = DimNm( '}DimensionAttributes', nCtr );\n            sAttrTyp    =\
    \ SubSt( DType( '}DimensionAttributes', sAttr ), 2, 1 );\n            sAttrVal    = If(\
    \ sAttrTyp @= 'N', NumberToString( DimensionAttrN( vDim, sAttr ) ), DimensionAttrS( vDim,\
    \ sAttr ) );\n            TextOutput( sFileName, Expand('DimensionAttrInsert( '''', ''%sAttr%'',\
    \ ''%sAttrTyp%'' );') );\n            If( sAttrTyp @= 'N' );\n                TextOutput(\
    \ sFileName, Expand('DimensionAttrPutN( %sAttrVal%, sDimHier, ''%sAttr%'' );') );\n    \
    \        Else;\n                TextOutput( sFileName, Expand('DimensionAttrPutS( ''%sAttrVal%'',\
    \ sDimHier, ''%sAttr%'' );') );\n            EndIf;\n            nCtr        = nCtr + 1;\n\
    \        End;\n    EndIf;\n    TextOutput( sFileName, Expand('#EndRegion Dimension Info:\
    \ %vDim%') );\n    TextOutput( sFileName, cHashLine );\nEndIf;\n#EndRegion Dimension Info\n\
    #################################################################################################\n\
    \n#################################################################################################\n\
    #Region Create Attributes (PROLOG)\nIf( pAttr = 1 & DimensionExists( sDimAttr ) = 1 & Scan(\
    \ sDim|pDelim, sAttrDone ) = 0 );\n    sAttrDone       = sAttrDone | sDim | pDelim;\n  \
    \  TextOutput( sFileName, '' );\n    TextOutput( sFileName, cHashLine );\n    TextOutput(\
    \ sFileName, Expand('#Region Create Attributes: %sDim%') );\n    nCtr            = 1;\n\
    \    While( nCtr     <= DimSiz( sDimAttr ) );\n        sAttr       = DimNm( sDimAttr, nCtr\
    \ );\n        sAttrTyp    = SubSt( DType( sDimAttr, sAttr ), 2, 1 );\n        # Escape potential\
    \ single apostrophes to avoid parsing errors in attribute names\n        nChar = 1;\n  \
    \      nCount = 0;\n        sAttrStrOut = '';\n        While( nChar <= LONG( sAttr ) + 1\
    \ );\n            If( nChar <= LONG( sAttr ) );\n                sChar = SUBST( sAttr, nChar,\
    \ 1 );\n            Else;\n                sChar = '';\n            EndIf;\n           \
    \ If( sChar @= '''' );\n                nCount = nCount + 1;\n            ElseIf( nCount\
    \ > 0 );\n                If( MOD( nCount, 2 ) <> 0 );\n                    sAttrStrOut\
    \ = sAttrStrOut | '''';\n                EndIf;\n                nCount = 0;\n         \
    \   EndIf;\n            sAttrStrOut = sAttrStrOut | sChar;\n            nChar = nChar +\
    \ 1;\n        End;\n        If( nCtr = 1 );\n            TextOutput( sFileName, 'If( DimensionExists(\
    \ sDimAttr ) = 0 % CubeExists( sDimAttr ) = 0 );');\n            TextOutput( sFileName,\
    \ Expand('    AttrInsert( sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\n      \
    \      TextOutput( sFileName, 'EndIf;' );\n        EndIf;\n        TextOutput( sFileName,\
    \ Expand('If( DimIx( sDimAttr, ''%sAttrStrOut%'' ) = 0 );') );\n        TextOutput( sFileName,\
    \ Expand('    AttrInsert( sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\n      \
    \  TextOutput( sFileName, 'Else;' );\n        TextOutput( sFileName, Expand('    If( DType(\
    \ sDimAttr, ''%sAttrStrOut%'' ) @<> ''A%sAttrTyp%'' );') );\n        TextOutput( sFileName,\
    \ Expand('        AttrDelete( sDim, ''%sAttrStrOut%'' );') );\n        TextOutput( sFileName,\
    \ Expand('        AttrInsert( sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\n  \
    \      TextOutput( sFileName, '    EndIf;' );\n        TextOutput( sFileName, 'EndIf;' );\n\
    \        nCtr        = nCtr + 1;\n    End;\n    TextOutput( sFileName, Expand('#EndRegion\
    \ Create Attributes: %sDim%') );\n    TextOutput( sFileName, cHashLine );\nEndIf;\n#EndRegion\
    \ Create Attributes\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Create Dimension/Hierarchy Structure (PROLOG)\nIf( pEle @<> '' );\n    sMDX = '';\n\
    \    If( pEle @= '*' );\n        sMDX = Expand('{TM1SubsetAll([%sDim%].[%sHier%])}');\n\
    \    Else;\n        # Loop through elements (inc. wildcard expressions) in pEle\n      \
    \  sEles = pEle;\n        nEleDelimiterIndex = 1;\n        # Get 1st ele\n        While(\
    \ nEleDelimiterIndex <> 0 );\n            # Extract 1st ele in sEles\n            nEleDelimiterIndex\
    \ = Scan( pDelim, sEles );\n            If( nEleDelimiterIndex = 0 );\n                sEle\
    \ = sEles;\n            Else;\n                sEle = Trim( SubSt( sEles, 1, nEleDelimiterIndex\
    \ - 1 ) );\n                sEles = Trim( Subst( sEles, nEleDelimiterIndex + Long( pDelim\
    \ ), Long( sEles ) ) );\n            EndIf;\n            If( Scan( '*', sEle ) > 0 % Scan(\
    \ '?', sEle ) > 0 );\n                # Create MDX for subset of eles using Wildcard Pattern\
    \ filter (means pEle entry MUST use principal name)\n                sEleExp = '''|sEle|''';\n\
    \                sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [%sDim%].[%sHier%]\
    \ ), %sEleExp% )}');\n            Else;\n                # Create MDX of single element\
    \ and all descendants\n                sMDXPart = Expand('{TM1DRILLDOWNMEMBER( {[%sDim%].[%sHier%].[%sEle%]},\
    \ ALL, RECURSIVE )}');\n            EndIf;\n            If( sMDX @= ''); \n            \
    \    sMDX = sMdxPart; \n            Else;\n                sMDX = sMDX | ' + ' | sMdxPart;\n\
    \            EndIf;\n        End;\n    EndIf;\n    If( SubsetExists( vDim, cTempSub ) =\
    \ 1 );\n        SubsetMDXSet( vDim, cTempSub, sMDX );\n    Else;\n        SubsetCreatebyMDX(\
    \ cTempSub, sMDX, vDim, 1 );\n    EndIf;\n    nMax = SubsetGetSize( vDim, cTempSub );\n\
    \    If( nMax >= 1 );\n        TextOutput( sFileName, '' );\n        TextOutput( sFileName,\
    \ cHashLine );\n        TextOutput( sFileName, Expand('#Region Create Elements: %vDim%')\
    \ );\n        nCtr = 1;\n        While( nCtr <= nMax );\n            # 1st insert all elements\
    \ to get correct order\n            sEle = SubsetGetElementName( vDim, cTempSub, nCtr );\n\
    \            # Escape potential single apostrophes to avoid parsing errors in element names\n\
    \            nChar = 1;\n            nCount = 0;\n            sEleStrOut = '';\n       \
    \     While( nChar <= LONG( sEle ) + 1 );\n                If( nChar <= LONG( sEle ) );\n\
    \                    sChar = SUBST( sEle, nChar, 1 );\n                Else;\n         \
    \           sChar = '';\n                EndIf;\n                If( sChar @= '''' );\n\
    \                    nCount = nCount + 1;\n                ElseIf( nCount > 0 );\n     \
    \               If( MOD( nCount, 2 ) <> 0 );\n                        sEleStrOut = sEleStrOut\
    \ | '''';\n                    EndIf;\n                    nCount = 0;\n               \
    \ EndIf;\n                sEleStrOut = sEleStrOut | sChar;\n                nChar = nChar\
    \ + 1;\n            End;\n            sEleTyp = DType( vDim, sEle );\n            TextOutput(\
    \ sFileName, Expand('DimensionElementInsert( sDimHier, '''', ''%sEleStrOut%'', ''%sEleTyp%''\
    \ );') );\n            nCtr    = nCtr + 1;\n        End;\n        nCtr = 1;\n        While(\
    \ nCtr <= nMax );\n            # 2nd loop again and create parent linkages\n           \
    \ sEle    = SubsetGetElementName( vDim, cTempSub, nCtr );\n            # Escape potential\
    \ single apostrophes to avoid parsing errors in element names\n            nChar = 1;\n\
    \            nCount = 0;\n            sEleStrOut = '';\n            While( nChar <= LONG(\
    \ sEle ) + 1 );\n                If( nChar <= LONG( sEle ) );\n                    sChar\
    \ = SUBST( sEle, nChar, 1 );\n                Else;\n                    sChar = '';\n \
    \               EndIf;\n                If( sChar @= '''' );\n                    nCount\
    \ = nCount + 1;\n                ElseIf( nCount > 0 );\n                    If( MOD( nCount,\
    \ 2 ) <> 0 );\n                        sEleStrOut = sEleStrOut | '''';\n               \
    \     EndIf;\n                    nCount = 0;\n                EndIf;\n                sEleStrOut\
    \ = sEleStrOut | sChar;\n                nChar = nChar + 1;\n            End;\n        \
    \    nPar    = 1;\n            While( nPar <= ElParN( vDim, sEle ) );\n                sPar\
    \ = ElPar( vDim, sEle, nPar );\n                # Escape potential single apostrophes to\
    \ avoid parsing errors in parent element names\n                nChar = 1;\n           \
    \     nCount = 0;\n                sParStrOut = '';\n                While( nChar <= LONG(\
    \ sPar ) + 1 );\n                    If( nChar <= LONG( sPar ) );\n                    \
    \    sChar = SUBST( sPar, nChar, 1 );\n                    Else;\n                     \
    \   sChar = '';\n                    EndIf;\n                    If( sChar @= '''' );\n\
    \                        nCount = nCount + 1;\n                    ElseIf( nCount > 0 );\n\
    \                        If( MOD( nCount, 2 ) <> 0 );\n                            sParStrOut\
    \ = sParStrOut | '''';\n                        EndIf;\n                        nCount =\
    \ 0;\n                    EndIf;\n                    sParStrOut = sParStrOut | sChar;\n\
    \                    nChar = nChar + 1;\n                End;\n                sWht = NumberToString(\
    \ ElWeight( vDim, sPar, sEle ) );\n                If( pEle @<> '*' );\n               \
    \     TextOutput( sFileName, Expand('DimensionElementInsert( sDimHier, '''', ''%sParStrOut%'',\
    \ ''C'' );') );\n                EndIf;\n                TextOutput( sFileName, Expand('DimensionElementComponentAdd(\
    \ sDimHier, ''%sParStrOut%'', ''%sEleStrOut%'', %sWht% );') );\n                nPar = nPar\
    \ + 1;\n            End;\n            nCtr     = nCtr + 1;\n        End;\n        TextOutput(\
    \ sFileName, Expand('#EndRegion Create Elements: %vDim%') );\n        TextOutput( sFileName,\
    \ cHashLine );\n    EndIf;\nEndIf;\n#EndRegion Create Structure\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Attribute Values (EPILOG)\nIf( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 &\
    \ nMax >=1 );\n    TextOutput( sFileName2, '' );\n    TextOutput( sFileName2, cHashLine\
    \ );\n    TextOutput( sFileName2, Expand('#Region Attribute Values: %vDim%') );\n    TextOutput(\
    \ sFileName2, Expand('sDimHier = ''%vDim%'';') );\n    TextOutput( sFileName2, Expand('sDim\
    \     = ''%sDim%'';') );\n    TextOutput( sFileName2, Expand('sHier    = ''%sHier%'';')\
    \ );\n    TextOutput( sFileName2, Expand('sDimAttr = ''%sDimAttr%'';') );\n    nCtr = 1;\n\
    \    While( nCtr <= nMax );\n        # loop elements again and internally loop attributes\n\
    \        sEle = SubsetGetElementName( vDim, cTempSub, nCtr );\n        # Escape potential\
    \ single apostrophes to avoid parsing errors in element names\n        nChar = 1;\n    \
    \    nCount = 0;\n        sEleStrOut = '';\n        While( nChar <= LONG( sEle ) + 1 );\n\
    \            If( nChar <= LONG( sEle ) );\n                sChar = SUBST( sEle, nChar, 1\
    \ );\n            Else;\n                sChar = '';\n            EndIf;\n            If(\
    \ sChar @= '''' );\n                nCount = nCount + 1;\n            ElseIf( nCount > 0\
    \ );\n                If( MOD( nCount, 2 ) <> 0 );\n                    sEleStrOut = sEleStrOut\
    \ | '''';\n                EndIf;\n                nCount = 0;\n            EndIf;\n   \
    \         sEleStrOut = sEleStrOut | sChar;\n            nChar = nChar + 1;\n        End;\n\
    \        sEleTyp = DType( vDim, sEle );\n        nAttr   = 1;\n        While( nAttr <= DimSiz(\
    \ sDimAttr ) );\n            sAttr       = DimNm( sDimAttr, nAttr );\n            # Escape\
    \ potential single apostrophes to avoid parsing errors in attribute names\n            nChar\
    \ = 1;\n            nCount = 0;\n            sAttrStrOut = '';\n            While( nChar\
    \ <= LONG( sAttr ) + 1 );\n                If( nChar <= LONG( sAttr ) );\n             \
    \       sChar = SUBST( sAttr, nChar, 1 );\n                Else;\n                    sChar\
    \ = '';\n                EndIf;\n                If( sChar @= '''' );\n                \
    \    nCount = nCount + 1;\n                ElseIf( nCount > 0 );\n                    If(\
    \ MOD( nCount, 2 ) <> 0 );\n                        sAttrStrOut = sAttrStrOut | '''';\n\
    \                    EndIf;\n                    nCount = 0;\n                EndIf;\n \
    \               sAttrStrOut = sAttrStrOut | sChar;\n                nChar = nChar + 1;\n\
    \            End;\n            sAttrTyp    = SubSt( DType( sDimAttr, sAttr ), 2, 1 );\n\
    \            sAttrVal    = '';\n            If( ( sDim @<> sHier & sEleTyp @<> 'N' ) & sAttrTyp\
    \ @= 'N' );\n                sAttrVal= NumberToString( ElementAttrN( sDim, sHier, sEle,\
    \ sAttr ) );\n            ElseIf( sDim @<> sHier & sEleTyp @<> 'N' );\n                sAttrVal=\
    \ ElementAttrS( sDim, sHier, sEle, sAttr );\n            ElseIf( sEleTyp @= 'N' & sAttrTyp\
    \ @= 'N' & DimIx( sDim, sEle ) = 0 );\n                sAttrVal= NumberToString( ElementAttrN(\
    \ sDim, sHier, sEle, sAttr ) );\n            ElseIf( sEleTyp @= 'N' & DimIx( sDim, sEle\
    \ ) = 0 );\n                sAttrVal= ElementAttrS( sDim, sHier, sEle, sAttr );\n      \
    \      ElseIf( sAttrTyp @= 'N' );\n                sAttrVal= NumberToString( AttrN( sDim,\
    \ sEle, sAttr ) );\n            Else;\n                sAttrVal= AttrS( sDim, sEle, sAttr\
    \ );\n            EndIf;\n            sAttrValStrOut = '';\n            If( sAttrVal @<>\
    \ '' );\n                If( sAttrTyp @<> 'N' );\n                    # Escape potential\
    \ single apostrophes to avoid parsing errors in attribute values\n                    nChar\
    \ = 1;\n                    nCount = 0;\n                    While( nChar <= LONG( sAttrVal\
    \ ) + 1 );\n                        If( nChar <= LONG( sAttrVal ) );\n                 \
    \           sChar = SUBST( sAttrVal, nChar, 1 );\n                        Else;\n      \
    \                      sChar = '';\n                        EndIf;\n                   \
    \     If( sChar @= '''' );\n                            nCount = nCount + 1;\n         \
    \               ElseIf( nCount > 0 );\n                            If( MOD( nCount, 2 )\
    \ <> 0 );\n                                sAttrValStrOut = sAttrValStrOut | '''';\n   \
    \                         EndIf;\n                            nCount = 0;\n            \
    \            EndIf;\n                        sAttrValStrOut = sAttrValStrOut | sChar;\n\
    \                        nChar = nChar + 1;\n                    End;\n                Else;\n\
    \                    # we won't need any tratment for non-string attributes\n          \
    \          sAttrValStrOut = sAttrVal;\n                EndIf;\n                If( ( sDim\
    \ @<> sHier & sEleTyp @<> 'N' ) & sAttrTyp @= 'N' );\n                    TextOutput( sFileName2,\
    \ Expand('ElementAttrPutN( %sAttrValStrOut%, sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%''\
    \ );') );\n                ElseIf( sDim @<> sHier & sEleTyp @<> 'N' );\n               \
    \     TextOutput( sFileName2, Expand('ElementAttrPutS( ''%sAttrValStrOut%'', sDim, sHier,\
    \ ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                ElseIf( sEleTyp @= 'N' &\
    \ sAttrTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\n                    TextOutput( sFileName2,\
    \ Expand('ElementAttrPutN( %sAttrValStrOut%, sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%''\
    \ );') );\n                ElseIf( sEleTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\n       \
    \             TextOutput( sFileName2, Expand('ElementAttrPutS( ''%sAttrValStrOut%'', sDim,\
    \ sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                ElseIf( sAttrTyp @=\
    \ 'N' );\n                    TextOutput( sFileName2, Expand('AttrPutN( %sAttrValStrOut%,\
    \ sDim, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                Else;\n           \
    \         TextOutput( sFileName2, Expand('AttrPutS( ''%sAttrValStrOut%'', sDim, ''%sEleStrOut%'',\
    \ ''%sAttrStrOut%'' );') );\n                EndIf;\n            EndIf;\n            nAttr\
    \ = nAttr + 1;\n        End;\n        nCtr    = nCtr + 1;\n    End;\n    TextOutput( sFileName2,\
    \ Expand('#EndRegion Attribute Values: %vDim%') );\n    TextOutput( sFileName2, cHashLine\
    \ );\nEndIf;\n#EndRegion Attribute Values\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Subsets (EPILOG)\nIf( pSub = 1 & DimensionExists( sDimSub ) = 1 );\n    If( sDim\
    \ @= vDim );\n        sMDX = Expand('{Except( {TM1SubsetAll( [%sDimSub%] )}, {TM1FilterByPattern(\
    \ {TM1SubsetAll( [%sDimSub%] )}, '*:*' )} )}');\n    Else;\n        sMDX = Expand('{TM1FilterByPattern(\
    \ {TM1SubsetAll( [%sDimSub%] )}, '%sHier%:*' )}');\n    EndIf;\n    If( SubsetExists( sDimSub,\
    \ cTempSub ) = 1 );\n        SubsetMDXSet( sDimSub, cTempSub, sMDX );\n    Else;\n     \
    \   SubsetCreatebyMDX( cTempSub, sMDX, sDimSub, 1 );\n    EndIf;\n    nMax = SubsetGetSize(\
    \ sDimSub, cTempSub );\n    If( nMax >= 1 );\n        TextOutput( sFileName2, '' );\n  \
    \      TextOutput( sFileName2, cHashLine );\n        TextOutput( sFileName2, Expand('#Region\
    \ Subsets: %vDim%') );\n        If( pAttrVal <> 1 % DimensionExists( sDimAttr ) = 0 % pEle\
    \ @= '' );\n            TextOutput( sFileName2, Expand('sDimHier = ''%vDim%'';') );\n  \
    \          TextOutput( sFileName2, Expand('sDim     = ''%sDim%'';') );\n            TextOutput(\
    \ sFileName2, Expand('sHier    = ''%sHier%'';') );\n            TextOutput( sFileName2,\
    \ Expand('sDimAttr = ''%sDimAttr%'';') );\n        EndIf;\n        nCtr = 1;\n        While(\
    \ nCtr <= nMax );\n            sSub        = SubsetGetElementName( sDimSub, cTempSub, nCtr\
    \ );\n            If( Scan( ':', sSub ) > 0 );\n                sSub    = SubSt( sSub, Scan(\
    \ ':', sSub ) + 1, Long( sSub ) );\n            EndIf;\n            sMDX        = SubsetMDXGet(\
    \ vDim, sSub );\n            # If MDX expression contains TM1SubsetBasis function then treat\
    \ it as a static subset\n            If( sMDX @<> '' & Scan( 'TM1SUBSETBASIS()', Upper(\
    \ sMDX ) ) = 0 );\n                # create by MDX\n                TextOutput( sFileName2,\
    \ Expand('If( SubsetExists( sDimHier, ''%sSub%'' ) = 0 );') );\n                TextOutput(\
    \ sFileName2, Expand('    SubsetCreatebyMDX( ''%sSub%'', ''%sMDX%'', sDimHier, 0 );') );\n\
    \                TextOutput( sFileName2, 'Else;' );\n                TextOutput( sFileName2,\
    \ Expand('    SubsetMDXSet( sDimHier, ''%sSub%'', ''%sMDX%'' );') );\n                TextOutput(\
    \ sFileName2, 'EndIf;' );\n            Else;\n                # loop members\n         \
    \       TextOutput( sFileName2, Expand('If( SubsetExists( sDimHier, ''%sSub%'' ) = 0 );')\
    \ );\n                TextOutput( sFileName2, Expand('    SubsetCreate( sDimHier, ''%sSub%''\
    \ );') );\n                TextOutput( sFileName2, 'Else;' );\n                TextOutput(\
    \ sFileName2, Expand('    SubsetDeleteAllElements( sDimHier, ''%sSub%'' );') );\n      \
    \          TextOutput( sFileName2, 'EndIf;' );\n                nEles   = SubsetGetSize(\
    \ vDim, sSub );\n                nEle    = 1;\n                While( nEle <= nEles );\n\
    \                    sEle = SubsetGetElementName( vDim, sSub, nEle );\n                \
    \    # Escape potential single apostrophes to avoid parsing errors in element names\n  \
    \                  nChar = 1;\n                    nCount = 0;\n                    sEleStrOut\
    \ = '';\n                    While( nChar <= LONG( sEle ) + 1 );\n                     \
    \   If( nChar <= LONG( sEle ) );\n                            sChar = SUBST( sEle, nChar,\
    \ 1 );\n                        Else;\n                            sChar = '';\n       \
    \                 EndIf;\n                        If( sChar @= '''' );\n               \
    \             nCount = nCount + 1;\n                        ElseIf( nCount > 0 );\n    \
    \                        If( MOD( nCount, 2 ) <> 0 );\n                                sEleStrOut\
    \ = sEleStrOut | '''';\n                            EndIf;\n                           \
    \ nCount = 0;\n                        EndIf;\n                        sEleStrOut = sEleStrOut\
    \ | sChar;\n                        nChar = nChar + 1;\n                    End;\n     \
    \               TextOutput( sFileName2, Expand('SubsetElementInsert( sDimHier, ''%sSub%'',\
    \ ''%sEleStrOut%'', 0 );') );\n                    nEle = nEle + 1;\n                End;\n\
    \            EndIf;\n            nCtr        = nCtr + 1;\n        End;\n        TextOutput(\
    \ sFileName2, Expand('#EndRegion Subsets: %vDim%') );\n        TextOutput( sFileName2, cHashLine\
    \ );\n    EndIf;\nEndIf;\n#EndRegion Subsets\n#################################################################################################\n\
    \n### Dimension write close\nTextOutput( sFileName, '' );\nTextOutput( sFileName, Expand('#EndRegion\
    \ Dimension/Hierarchy: %vDim%') );\nTextOutput( sFileName, cHashLine );\nIf( ( pAttrVal\
    \ = 1 & DimensionExists( sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists(\
    \ sDimSub ) = 1 ) );\n    TextOutput( sFileName2, '' );\n    TextOutput( sFileName2, Expand('#EndRegion\
    \ Dimension/Hierarchy: %vDim%') );\n    TextOutput( sFileName2, cHashLine );\nEndIf;\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    ### If errors occurred terminate process with a major error status ###\nIf( nErrors > 0\
    \ );\n    sMessage = 'the process incurred at least 1 major error and consequently aborted.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for\
    \ details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    EndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName% successfully\
    \ exported %pDim% dimension:hierarchy to %sFileName%.' );\nsProcessReturnCode  = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode  = 1;\nIf ( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \nEndIf;\n\n### End"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, um Dimensionselemente aus einer Datei
    in eine angegebene Hierarchie zu importieren. Dieser Prozess soll in der Lage sein, eine
    von `}ti.hier.export` generierte Datei zu lesen. Das Dateiformat umfasst verschiedene Linien:
    Die erste Zeile enthält Metadaten der Datei mit zusammenfassenden Informationen über die
    Dimension, Hierarchie, Anzahl der Elemente und das Datum/Uhrzeit der Dateierstellung. Die
    zweite Zeile weist die Quellendimension und -hierarchie aus. Die dritte Zeile beschreibt
    die Sortierreihenfolge der Dimension. Die vierte und fünfte Zeile sind für zukünftige Entwicklungen
    reserviert. Die sechste Zeile beinhaltet den Header für den Elementeexport, während die
    siebte Zeile und folgende die exportierten Elementdaten darstellen. Anwendungsfälle für
    diesen Prozess beinhalten die Wiederherstellung einer Dimension aus einem Backup und die
    schnelle Replikation einer großen Dimension. Beachten Sie, dass ein gültiger Dimensionsname
    (pDim) zwingend erforderlich ist, andernfalls wird der Prozess abgebrochen. Falls nötig,
    kann ein benutzerdefiniertes Trennzeichen verwendet werden, indem der Parameter pDelim entsprechend
    einem einzigen Zeichen oder einem dreistelligen ASCII-Code angegeben wird. Außerdem bietet
    der pUnwind Parameter die Option, Elemente in der Zieldimension zu 2 (nichts tun oder nur
    hinzufügen), 1 (entwirren) oder 0 (löschen) festzulegen. Standardmäßig wird entwirrt, es
    sollte jedoch Vorsicht walten gelassen werden, wenn Option 0 verwendet wird, um Datenverlust
    zu vermeiden. Beachten Sie, dass der Prozess in Bedrock4 neu gestaltet wurde, aber auch
    Dimensionsextrakte aus früheren Bedrock-Versionen im Legacy-Modus (pLegacy = 1) verarbeiten
    kann.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will import Dimension elements into a specified\
    \ Hierarchy from a File. The process\n# is able to read a file generated by `}bedrock.hier.export`.\n\
    # __Format of the file:__  \n# - 1st line: File metadata contains summary information about\
    \ the dimension, hierarchy, number of\n#   elements and date/time when file was generated.\n\
    # - 2nd line: Source dimension and hierarchy.\n# - 3rd line: Dimension sort order.\n# -\
    \ 4th and 5th line: Reserved for future development.\n# - 6th line: Header for elements\
    \ export.\n# - 7th line and forth: Elements export data.\n\n# Use case:\n# 1. Restore a\
    \ dimension from a backup.\n# 2. Quick replication of a large dimension.\n\n# Note:\n# Valid\
    \ dimension name (pDim) is mandatory otherwise the process will abort.\n# If needed, custom\
    \ delimiter might be used by specifying parameter pDelim value as either exactly one\n#\
    \ character or as a 3-digit (decimal) ASCII code. For example to use TAB as a delimiter,\
    \ use 009.\n# pUnwind provides the option to 1 (unwind) or 0 (delete) elements in the target\
    \ dimension. Default is to unwind,\n# care should be taken when using option 0 otherwise\
    \ data loss may occur.\n\n# Caution: Process was redesigned in Bedrock4 but is able to process\
    \ dimension extracts from prior\n# versions of Bedrock in legacy mode (pLegacy = 1).\n#EndRegion\
    \ @DOC\n\n# This process will Create Dimension hierarchy from File.\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSrcDir:%pSrcDir%, pSrcFile:%pSrcFile%, pDelim:%pDelim%, pQuote:%pQuote%,\
    \ pLegacy:%pLegacy%, pUnwind:%pUnwind%, pConsol:%pConsol%';\ncLenASCIICode = 3;\n\npDelim\
    \  = TRIM(pDelim);\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nnMetaCount = 0;\nnDataCount = 0;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has\
    \ been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n \
    \   pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists(\
    \ pDim ) = 0 );\n    sMessage = 'Dimension: ' | pDim | ' does not exist and will be created.';\n\
    \    LogOutput( 'INFO', Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Hierarchy\n\
    sHier       = Trim( pHier );\nIf( sHier @= '' );\n    sHier     = pDim;\nElseIf( sHier @=\
    \ 'Leaves' );\n    nErrors   = 1;\n    sMessage  = 'Invalid  Hierarchy: ' | pDim |':'|sHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## Validate source\
    \ dir\nIf( Trim( pSrcDir ) @= '' );\n    pSrcDir     = GetProcessErrorFileDirectory;\n \
    \   sMessage    = 'Source folder defaulted to error file directory.';\n    LogOutput( 'INFO',\
    \ Expand( cMsgErrorContent ) );\nEndIf;\nIf( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @= sOSDelim\
    \ );\n    pSrcDir = SubSt( pSrcDir, 1, Long( pSrcDir ) -1 );\nEndIf;\nIf( FileExists( pSrcDir\
    \ ) = 0 );\n    nErrors     = 1;\n    sMessage    = 'Invalid source path specified. Folder\
    \ does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    pSrcDir         = pSrcDir | sOSDelim;\n\n# Validate legacy file format\nIf( pLegacy <> 1\
    \ );\n    pLegacy = 0;\nEndIf;\n\n# Validate export filename\nIf( pSrcFile @= '' );\n  pSrcFile\
    \      = pDim | If( pLegacy = 1, '', ' ' | sHier ) | '_Export.csv';\nElseIf( Scan( '.',\
    \ pSrcFile ) = 0 );\n    # No file extension specified\n    pSrcFile    = pSrcFile | '.csv';\n\
    EndIf;\n\n# Construct full export filename including path\nsFilename       = pSrcDir | pSrcFile;\n\
    sAttrDimName    = '}ElementAttributes_' | pDim ;\n\nIf( FileExists( sFilename ) = 0 );\n\
    \    nErrors     = 1;\n    sMessage    = 'Invalid path or file name specified. It does not\
    \ exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ unwind\nIf( pUnwind <> 0 );\n    pUnwind = 1;\nEndIf;\n\n# Validate consolidation to unwind\n\
    If( pConsol @= '' );\n    # Only check if parameter is passed as empty as this is invalid.\
    \ Validation in case of element not existng in dimension will be evaluated in the unwind\
    \ sub-process\n    pConsol = '*';\nEndIf;\n\n# Validate file delimiter & quote character\n\
    If( pDelim @= '' );\n    pDelim = ',';\nElse;\n    # If length of pDelim is exactly 3 chars\
    \ and each of them is decimal digit, then the pDelim is entered as ASCII code\n    nValid\
    \ = 0;\n    If ( LONG(pDelim) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar\
    \ <= cLenASCIICode );\n        If( CODE( pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim,\
    \ nChar )<=CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n\
    \        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0\
    \ );\n      pDelim=CHAR(StringToNumber( pDelim ));\n    Else;\n      pDelim = SubSt( Trim(\
    \ pDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote character\
    \ \nElse;\n    # If length of pQuote is exactly 3 chars and each of them is decimal digit,\
    \ then the pQuote is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode\
    \ );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote,\
    \ nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid\
    \ = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n\
    \      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote\
    \ ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Prepare\
    \ target dimension ###\nIf( HierarchyExists( pDim, sHier ) = 1 );\n    If( pUnwind = 1 );\n\
    \    ExecuteProcess('}bedrock.hier.unwind', 'pLogOutput', pLogOutput,\n      'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    \t'pDim', pDim,\n    \t'pHier', sHier,\n    \t'pConsol', pConsol,\n\
    \    \t'pRecursive', 1\n    );\n    ElseIf( pUnwind = 0 );\n        If( pDim @= pHier );\n\
    \            DimensionDeleteAllElements( pDim );\n        Else;\n            HierarchyDeleteAllElements(\
    \ pDim, pHier );\n        EndIf;\n    EndIf;\nElse;\n    ExecuteProcess('}bedrock.hier.create',\n\
    \t'pLogOutput',pLogOutput,\n\t'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pDim,\n\
    \t'pHier',sHier);\nEndIf;\n\nIf( nErrors = 0 );\n    If( HierarchyExists( pDim, pHier )\
    \ = 1 );\n        IF ( pUnwind = 1 ) ;\n            sMessage = 'Dimension unwound: ' | pDim|':'|sHier;\n\
    \        ELSEIF ( pUnwind = 0 ) ;\n            sMessage = 'Dimension rebuilt: ' | pDim|':'|sHier;\n\
    \        ENDIF ;\n    Else;\n        sMessage = 'Dimension created: ' | pDim|':'|sHier;\n\
    \    EndIf;\nElse;\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n\
    \        ProcessBreak;\n    EndIf;\nEndIf;\n\n### CONSTANTS ###\nsAttrDimName    = '}ElementAttributes_'\
    \ | pDim ;\ncCubeS1         = '}DimensionProperties';\n\n#Processbreak;\n\n### Assign Datasource\
    \ ###\nDataSourceType          = 'CHARACTERDELIMITED';\nDatasourceNameForServer = sFilename;\n\
    DatasourceNameForClient = sFilename;\nDatasourceAsciiDelimiter= pDelim;\nDatasourceAsciiQuoteCharacter\
    \ = pQuote;\n\n\n##### End Prolog #####\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\nIf( pDim @= sHier);\n    sDim = pDim;\nElse;\n    sDim = pDim|':'|sHier;\n\
    Endif;\n\n### Metadata Count\nnMetaCount = nMetaCount + 1;\n\nsVar1 = v1;\nsVar2 = v2;\n\
    sVar3 = If( pLegacy <> 1, Subst( v3 , Scan( '-' , v3 ) + 1 , Long( v3 ) ), v3 );\nsVar4\
    \ = If( pLegacy <> 1, Subst( v4 , Scan( '-' , v4 ) + 1 , Long( v4 ) ), v4 );\nsVar5 = If(\
    \ pLegacy <> 1, Subst( v5 , Scan( '-' , v5 ) + 1 , Long( v5 ) ), v5 );\n\n## Set Dimension\
    \ Sort Order\nIF( v1 @= 'Sort parameters :' );\n    CELLPUTS( sVar2, cCubeS1 , sDim, 'SORTELEMENTSTYPE'\
    \ );\n    CELLPUTS( sVar3, cCubeS1 , sDim, 'SORTCOMPONENTSTYPE' );\n    CELLPUTS( sVar4,\
    \ cCubeS1 , sDim, 'SORTELEMENTSSENSE' );\n    CELLPUTS( sVar5, cCubeS1 , sDim, 'SORTCOMPONENTSSENSE'\
    \ );\n    DimensionSortOrder( sDim, sVar3, sVar5, sVar2, sVar4 );\nElseIF( pLegacy = 1 &\
    \ nDataCount = 3 & ( sVar1 @= 'BYINPUT' % sVar1 @= 'BYNAME' % sVar1 @= 'BYHIERARCHY' % sVar1\
    \ @= 'BYLEVEL' ) );\n    CELLPUTS( sVar1, cCubeS1 , sDim, 'SORTELEMENTSTYPE' );\n    CELLPUTS(\
    \ sVar2, cCubeS1 , sDim, 'SORTCOMPONENTSTYPE' );\n    CELLPUTS( sVar3, cCubeS1 , sDim, 'SORTELEMENTSSENSE'\
    \ );\n    CELLPUTS( sVar4, cCubeS1 , sDim, 'SORTCOMPONENTSSENSE' );\n    DimensionSortOrder(\
    \ sDim, sVar2, sVar4, sVar1, sVar3 );\nENDIF;\n\n### Build dimension\nIF( V1 @= 'A' );\n\
    \    # insert attributes\n    ATTRINSERT( pDim, '', sVar2 , SUBST( sVar3, 2, 1 ) );\n  \
    \  IF( pLogOutput = 1 );\n        sMessage    = Expand('Attribute %sVar2% created in %sDim%\
    \ as type %sVar3%.');\n        LogOutput( 'INFO', Expand( cMsgErrorContent ) );  \n    ENDIF;\n\
    ELSEIF( V1 @= 'E' );\n    # insert elements\n    HierarchyElementInsert( pDim, sHier, '',\
    \ sVar2 , sVar3 );\n    IF( pLogOutput = 1 );\n        sMessage    = Expand('Inserted element\
    \ %sVar2% into %sDim% as type %sVar3%.');\n        LogOutput( 'INFO', Expand( cMsgErrorContent\
    \ ) );  \n    ENDIF;\nELSEIF( V1 @= 'P' );\n    # create rollups\n    HierarchyElementInsert(\
    \ pDim, sHier, '', sVar3 , sVar4 );\n    HierarchyElementComponentAdd( pDim, sHier, sVar3\
    \ , sVar2 , StringToNumber( sVar5 ) );\n    IF( pLogOutput = 1 );\n        sMessage    =\
    \ Expand('Inserted parent %sVar3% into %sDim% as type %sVar4%. Then added %sVar2% to %sVar3%\
    \ with a weight of %sVar5%.');\n        sMessage    = Expand('Added %sVar2% to %sVar3% with\
    \ a weight of %sVar5%.');\n        LogOutput( 'INFO', Expand( cMsgErrorContent ) );  \n\
    \    ENDIF;\n\nENDIF;\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n\
    \  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Data Count\nnDataCount = nDataCount + 1;\n\nsVar1 = v1;\nsVar2\
    \ = v2;\nsVar3 = If( pLegacy <> 1, Subst( v3 , Scan( '-' , v3 ) + 1 , Long( v3 ) ), v3 );\n\
    sVar4 = If( pLegacy <> 1, Subst( v4 , Scan( '-' , v4 ) + 1 , Long( v4 ) ), v4 );\nsVar5\
    \ = If( pLegacy <> 1, Subst( v5 , Scan( '-' , v5 ) + 1 , Long( v5 ) ), v5 );\n\nIf( pDim\
    \ @= sHier);\n    sDim = pDim;\nElse;\n    sDim = pDim|':'|sHier;\nEndif;\n\n### Load Attribute\
    \ Values ###\nIF( V1 @= 'V' );\n    sAttrType = DTYPE( sAttrDimName , sVar3 );\n    IF (\
    \ pDim @<> sHier );\n        IF ( CellIsUpdateable ( '}ElementAttributes_' | pDim, sVar2,\
    \ sVar3 ) = 0 ) ;\n            ItemSkip ;\n        ENDIF ;\n        IF( sAttrType @= 'AN'\
    \ );\n            ElementAttrPUTN( StringToNumber( sVar4 ), pDim, sHier, sVar2, sVar3 );\n\
    \        ELSEIF( sAttrType @= 'AA' );\n            ElementATTRPUTS( sVar4, pDim, sHier,\
    \ sVar2, sVar3, 1 );\n        ELSE;\n            ElementATTRPUTS( sVar4, pDim, sHier, sVar2,\
    \ sVar3 );\n        ENDIF;\n    ELSE;\n        IF ( CellIsUpdateable ( '}ElementAttributes_'\
    \ | pDim , sVar2, sVar3 ) = 0 ) ;\n            ItemSkip ;\n        ENDIF ;\n        IF(\
    \ sAttrType @= 'AN' );\n            AttrPUTN( StringToNumber( sVar4 ), pDim, sVar2, sVar3\
    \ );\n        ELSEIF( sAttrType @= 'AA' );\n            ATTRPUTS( sVar4, pDim, sVar2, sVar3,\
    \ 1 );\n        ELSE;\n            ATTRPUTS( sVar4, pDim, sVar2, sVar3 );\n        ENDIF;\
    \        \n    ENDIF;\nENDIF;\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### If errors occurred terminate process with a major\
    \ error status ###\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1\
    \ major error and consequently aborted. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted.\
    \ Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nEndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName%\
    \ successfully imported data from %sFileName% and updated the %pDim%:%pHier% dimension:hierarchy.'\
    \ );\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode\
    \  = 1;\nIf ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \n\
    EndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process to import dimension elements into a specified
    hierarchy from a file. This process should be capable of reading a file generated by `}ti.hier.export`.
    The file format includes several lines: the first line contains file metadata with summary
    information about the dimension, hierarchy, number of elements, and the date/time the file
    was generated. The second line specifies the source dimension and hierarchy. The third line
    describes the dimension''s sort order. The fourth and fifth lines are reserved for future
    development. The sixth line contains the header for elements export, while the seventh line
    onwards represents the elements export data. Use cases for this process include restoring
    a dimension from a backup and quickly replicating a large dimension. Note that a valid dimension
    name (pDim) is mandatory; otherwise, the process will abort. If needed, a custom delimiter
    can be used by specifying the pDelim parameter as either exactly one character or a three-digit
    ASCII code. Additionally, the pUnwind parameter provides the option to set elements in the
    target dimension to 2 (do nothing or add only), 1 (unwind), or 0 (delete). By default, it
    unwinds, but caution should be taken when using option 0 to prevent data loss. Note that
    the process was redesigned in Bedrock4 but can also handle dimension extracts from previous
    Bedrock versions in legacy mode (pLegacy = 1).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will import Dimension elements into a specified\
    \ Hierarchy from a File. The process\n# is able to read a file generated by `}bedrock.hier.export`.\n\
    # __Format of the file:__  \n# - 1st line: File metadata contains summary information about\
    \ the dimension, hierarchy, number of\n#   elements and date/time when file was generated.\n\
    # - 2nd line: Source dimension and hierarchy.\n# - 3rd line: Dimension sort order.\n# -\
    \ 4th and 5th line: Reserved for future development.\n# - 6th line: Header for elements\
    \ export.\n# - 7th line and forth: Elements export data.\n\n# Use case:\n# 1. Restore a\
    \ dimension from a backup.\n# 2. Quick replication of a large dimension.\n\n# Note:\n# Valid\
    \ dimension name (pDim) is mandatory otherwise the process will abort.\n# If needed, custom\
    \ delimiter might be used by specifying parameter pDelim value as either exactly one\n#\
    \ character or as a 3-digit (decimal) ASCII code. For example to use TAB as a delimiter,\
    \ use 009.\n# pUnwind provides the option to 1 (unwind) or 0 (delete) elements in the target\
    \ dimension. Default is to unwind,\n# care should be taken when using option 0 otherwise\
    \ data loss may occur.\n\n# Caution: Process was redesigned in Bedrock4 but is able to process\
    \ dimension extracts from prior\n# versions of Bedrock in legacy mode (pLegacy = 1).\n#EndRegion\
    \ @DOC\n\n# This process will Create Dimension hierarchy from File.\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSrcDir:%pSrcDir%, pSrcFile:%pSrcFile%, pDelim:%pDelim%, pQuote:%pQuote%,\
    \ pLegacy:%pLegacy%, pUnwind:%pUnwind%, pConsol:%pConsol%';\ncLenASCIICode = 3;\n\npDelim\
    \  = TRIM(pDelim);\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nnMetaCount = 0;\nnDataCount = 0;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has\
    \ been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n \
    \   pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists(\
    \ pDim ) = 0 );\n    sMessage = 'Dimension: ' | pDim | ' does not exist and will be created.';\n\
    \    LogOutput( 'INFO', Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Hierarchy\n\
    sHier       = Trim( pHier );\nIf( sHier @= '' );\n    sHier     = pDim;\nElseIf( sHier @=\
    \ 'Leaves' );\n    nErrors   = 1;\n    sMessage  = 'Invalid  Hierarchy: ' | pDim |':'|sHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## Validate source\
    \ dir\nIf( Trim( pSrcDir ) @= '' );\n    pSrcDir     = GetProcessErrorFileDirectory;\n \
    \   sMessage    = 'Source folder defaulted to error file directory.';\n    LogOutput( 'INFO',\
    \ Expand( cMsgErrorContent ) );\nEndIf;\nIf( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @= sOSDelim\
    \ );\n    pSrcDir = SubSt( pSrcDir, 1, Long( pSrcDir ) -1 );\nEndIf;\nIf( FileExists( pSrcDir\
    \ ) = 0 );\n    nErrors     = 1;\n    sMessage    = 'Invalid source path specified. Folder\
    \ does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    pSrcDir         = pSrcDir | sOSDelim;\n\n# Validate legacy file format\nIf( pLegacy <> 1\
    \ );\n    pLegacy = 0;\nEndIf;\n\n# Validate export filename\nIf( pSrcFile @= '' );\n  pSrcFile\
    \      = pDim | If( pLegacy = 1, '', ' ' | sHier ) | '_Export.csv';\nElseIf( Scan( '.',\
    \ pSrcFile ) = 0 );\n    # No file extension specified\n    pSrcFile    = pSrcFile | '.csv';\n\
    EndIf;\n\n# Construct full export filename including path\nsFilename       = pSrcDir | pSrcFile;\n\
    sAttrDimName    = '}ElementAttributes_' | pDim ;\n\nIf( FileExists( sFilename ) = 0 );\n\
    \    nErrors     = 1;\n    sMessage    = 'Invalid path or file name specified. It does not\
    \ exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ unwind\nIf( pUnwind <> 0 );\n    pUnwind = 1;\nEndIf;\n\n# Validate consolidation to unwind\n\
    If( pConsol @= '' );\n    # Only check if parameter is passed as empty as this is invalid.\
    \ Validation in case of element not existng in dimension will be evaluated in the unwind\
    \ sub-process\n    pConsol = '*';\nEndIf;\n\n# Validate file delimiter & quote character\n\
    If( pDelim @= '' );\n    pDelim = ',';\nElse;\n    # If length of pDelim is exactly 3 chars\
    \ and each of them is decimal digit, then the pDelim is entered as ASCII code\n    nValid\
    \ = 0;\n    If ( LONG(pDelim) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar\
    \ <= cLenASCIICode );\n        If( CODE( pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim,\
    \ nChar )<=CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n\
    \        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0\
    \ );\n      pDelim=CHAR(StringToNumber( pDelim ));\n    Else;\n      pDelim = SubSt( Trim(\
    \ pDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote character\
    \ \nElse;\n    # If length of pQuote is exactly 3 chars and each of them is decimal digit,\
    \ then the pQuote is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode\
    \ );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote,\
    \ nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid\
    \ = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n\
    \      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote\
    \ ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Prepare\
    \ target dimension ###\nIf( HierarchyExists( pDim, sHier ) = 1 );\n    If( pUnwind = 1 );\n\
    \    ExecuteProcess('}bedrock.hier.unwind', 'pLogOutput', pLogOutput,\n      'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    \t'pDim', pDim,\n    \t'pHier', sHier,\n    \t'pConsol', pConsol,\n\
    \    \t'pRecursive', 1\n    );\n    ElseIf( pUnwind = 0 );\n        If( pDim @= pHier );\n\
    \            DimensionDeleteAllElements( pDim );\n        Else;\n            HierarchyDeleteAllElements(\
    \ pDim, pHier );\n        EndIf;\n    EndIf;\nElse;\n    ExecuteProcess('}bedrock.hier.create',\n\
    \t'pLogOutput',pLogOutput,\n\t'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pDim,\n\
    \t'pHier',sHier);\nEndIf;\n\nIf( nErrors = 0 );\n    If( HierarchyExists( pDim, pHier )\
    \ = 1 );\n        IF ( pUnwind = 1 ) ;\n            sMessage = 'Dimension unwound: ' | pDim|':'|sHier;\n\
    \        ELSEIF ( pUnwind = 0 ) ;\n            sMessage = 'Dimension rebuilt: ' | pDim|':'|sHier;\n\
    \        ENDIF ;\n    Else;\n        sMessage = 'Dimension created: ' | pDim|':'|sHier;\n\
    \    EndIf;\nElse;\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n\
    \        ProcessBreak;\n    EndIf;\nEndIf;\n\n### CONSTANTS ###\nsAttrDimName    = '}ElementAttributes_'\
    \ | pDim ;\ncCubeS1         = '}DimensionProperties';\n\n#Processbreak;\n\n### Assign Datasource\
    \ ###\nDataSourceType          = 'CHARACTERDELIMITED';\nDatasourceNameForServer = sFilename;\n\
    DatasourceNameForClient = sFilename;\nDatasourceAsciiDelimiter= pDelim;\nDatasourceAsciiQuoteCharacter\
    \ = pQuote;\n\n\n##### End Prolog #####\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\nIf( pDim @= sHier);\n    sDim = pDim;\nElse;\n    sDim = pDim|':'|sHier;\n\
    Endif;\n\n### Metadata Count\nnMetaCount = nMetaCount + 1;\n\nsVar1 = v1;\nsVar2 = v2;\n\
    sVar3 = If( pLegacy <> 1, Subst( v3 , Scan( '-' , v3 ) + 1 , Long( v3 ) ), v3 );\nsVar4\
    \ = If( pLegacy <> 1, Subst( v4 , Scan( '-' , v4 ) + 1 , Long( v4 ) ), v4 );\nsVar5 = If(\
    \ pLegacy <> 1, Subst( v5 , Scan( '-' , v5 ) + 1 , Long( v5 ) ), v5 );\n\n## Set Dimension\
    \ Sort Order\nIF( v1 @= 'Sort parameters :' );\n    CELLPUTS( sVar2, cCubeS1 , sDim, 'SORTELEMENTSTYPE'\
    \ );\n    CELLPUTS( sVar3, cCubeS1 , sDim, 'SORTCOMPONENTSTYPE' );\n    CELLPUTS( sVar4,\
    \ cCubeS1 , sDim, 'SORTELEMENTSSENSE' );\n    CELLPUTS( sVar5, cCubeS1 , sDim, 'SORTCOMPONENTSSENSE'\
    \ );\n    DimensionSortOrder( sDim, sVar3, sVar5, sVar2, sVar4 );\nElseIF( pLegacy = 1 &\
    \ nDataCount = 3 & ( sVar1 @= 'BYINPUT' % sVar1 @= 'BYNAME' % sVar1 @= 'BYHIERARCHY' % sVar1\
    \ @= 'BYLEVEL' ) );\n    CELLPUTS( sVar1, cCubeS1 , sDim, 'SORTELEMENTSTYPE' );\n    CELLPUTS(\
    \ sVar2, cCubeS1 , sDim, 'SORTCOMPONENTSTYPE' );\n    CELLPUTS( sVar3, cCubeS1 , sDim, 'SORTELEMENTSSENSE'\
    \ );\n    CELLPUTS( sVar4, cCubeS1 , sDim, 'SORTCOMPONENTSSENSE' );\n    DimensionSortOrder(\
    \ sDim, sVar2, sVar4, sVar1, sVar3 );\nENDIF;\n\n### Build dimension\nIF( V1 @= 'A' );\n\
    \    # insert attributes\n    ATTRINSERT( pDim, '', sVar2 , SUBST( sVar3, 2, 1 ) );\n  \
    \  IF( pLogOutput = 1 );\n        sMessage    = Expand('Attribute %sVar2% created in %sDim%\
    \ as type %sVar3%.');\n        LogOutput( 'INFO', Expand( cMsgErrorContent ) );  \n    ENDIF;\n\
    ELSEIF( V1 @= 'E' );\n    # insert elements\n    HierarchyElementInsert( pDim, sHier, '',\
    \ sVar2 , sVar3 );\n    IF( pLogOutput = 1 );\n        sMessage    = Expand('Inserted element\
    \ %sVar2% into %sDim% as type %sVar3%.');\n        LogOutput( 'INFO', Expand( cMsgErrorContent\
    \ ) );  \n    ENDIF;\nELSEIF( V1 @= 'P' );\n    # create rollups\n    HierarchyElementInsert(\
    \ pDim, sHier, '', sVar3 , sVar4 );\n    HierarchyElementComponentAdd( pDim, sHier, sVar3\
    \ , sVar2 , StringToNumber( sVar5 ) );\n    IF( pLogOutput = 1 );\n        sMessage    =\
    \ Expand('Inserted parent %sVar3% into %sDim% as type %sVar4%. Then added %sVar2% to %sVar3%\
    \ with a weight of %sVar5%.');\n        sMessage    = Expand('Added %sVar2% to %sVar3% with\
    \ a weight of %sVar5%.');\n        LogOutput( 'INFO', Expand( cMsgErrorContent ) );  \n\
    \    ENDIF;\n\nENDIF;\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n\
    \  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Data Count\nnDataCount = nDataCount + 1;\n\nsVar1 = v1;\nsVar2\
    \ = v2;\nsVar3 = If( pLegacy <> 1, Subst( v3 , Scan( '-' , v3 ) + 1 , Long( v3 ) ), v3 );\n\
    sVar4 = If( pLegacy <> 1, Subst( v4 , Scan( '-' , v4 ) + 1 , Long( v4 ) ), v4 );\nsVar5\
    \ = If( pLegacy <> 1, Subst( v5 , Scan( '-' , v5 ) + 1 , Long( v5 ) ), v5 );\n\nIf( pDim\
    \ @= sHier);\n    sDim = pDim;\nElse;\n    sDim = pDim|':'|sHier;\nEndif;\n\n### Load Attribute\
    \ Values ###\nIF( V1 @= 'V' );\n    sAttrType = DTYPE( sAttrDimName , sVar3 );\n    IF (\
    \ pDim @<> sHier );\n        IF ( CellIsUpdateable ( '}ElementAttributes_' | pDim, sVar2,\
    \ sVar3 ) = 0 ) ;\n            ItemSkip ;\n        ENDIF ;\n        IF( sAttrType @= 'AN'\
    \ );\n            ElementAttrPUTN( StringToNumber( sVar4 ), pDim, sHier, sVar2, sVar3 );\n\
    \        ELSEIF( sAttrType @= 'AA' );\n            ElementATTRPUTS( sVar4, pDim, sHier,\
    \ sVar2, sVar3, 1 );\n        ELSE;\n            ElementATTRPUTS( sVar4, pDim, sHier, sVar2,\
    \ sVar3 );\n        ENDIF;\n    ELSE;\n        IF ( CellIsUpdateable ( '}ElementAttributes_'\
    \ | pDim , sVar2, sVar3 ) = 0 ) ;\n            ItemSkip ;\n        ENDIF ;\n        IF(\
    \ sAttrType @= 'AN' );\n            AttrPUTN( StringToNumber( sVar4 ), pDim, sVar2, sVar3\
    \ );\n        ELSEIF( sAttrType @= 'AA' );\n            ATTRPUTS( sVar4, pDim, sVar2, sVar3,\
    \ 1 );\n        ELSE;\n            ATTRPUTS( sVar4, pDim, sVar2, sVar3 );\n        ENDIF;\
    \        \n    ENDIF;\nENDIF;\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### If errors occurred terminate process with a major\
    \ error status ###\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1\
    \ major error and consequently aborted. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% aborted.\
    \ Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nEndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName%\
    \ successfully imported data from %sFileName% and updated the %pDim%:%pHier% dimension:hierarchy.'\
    \ );\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode\
    \  = 1;\nIf ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \n\
    EndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der alle Blattelemente (in der ''Leaves''-Hierarchie)
    der angegebenen Dimension(en) überprüft. Innerhalb der ''Leaves''-Hierarchie wird für jedes
    Element *alle Hierarchien* auf das Vorhandensein des Blattelements gescannt. Wenn das Blattelement
    in allen Hierarchien außer ''Leaves'' nicht existiert, wird das Element als Waise klassifiziert
    und der Teilmenge ''Verwaiste Blattelemente'' hinzugefügt. Zusätzlich, wenn der Parameter
    pIncludeNoParentElems gesetzt ist, werden Elemente ohne übergeordnete Elemente in der Teilmenge
    ''Keine Eltern'' der entsprechenden Hierarchie (außer ''Leaves'') innerhalb von ''Leaves''
    gespeichert. Der Name der Teilmenge kann angepasst werden und wird mit Bindestrich- und
    dem Namen der entsprechenden Hierarchie versehen. Der Hauptanwendungsbereich: 1. Primär
    zur Identifizierung von Dimensionen mit Wartungsproblemen während der Entwicklung/Prototyping
    gedacht. 2. Kann auch zur Fehlersuche in produktiven Instanzen verwendet werden.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process checks all leaf elements (in the Leaves hierarchy)\
    \ of the specified dimension(s).\n# Within the Leaves hierarchy for each element *all hierarchies*\
    \ are scanned for the existance of the leaf element.\n# If the leaf element does not exist\
    \ in all hierarchies except for Leaves then the element is classified as an orphan and added\
    \ to the \n# 'Orphan Leaf Elements' subset.\n# Additionally when running with pIncludeNoParentElems\
    \ parameter set, elements that have no parent will be stored in No Parents subset\n# of\
    \ matching hierarchy (except `Leaves`) within Leaves. The subset name might be accomodated\
    \ and will be suffixed by dash and name of the matching hierarchy.\n#\n# Use case: \n# 1.\
    \ Primarily intended to identify dimensions with maintenance issues during development/prototyping.\n\
    # 2. Can also be used for trouble-shooting in productive instances.\n#\n#EndRegion @DOC\n\
    \n### Global Variables\n\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants\ncThisProcName     = GetProcessName();\ncTimeStamp\
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub1          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cTempSub2         = cTempSub1 | '_2';\ncTempSubDim       = cThisProcName |'_Dim_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgInfoLevel\
    \     = 'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%.';\ncAll  \
    \            = '*';\ncDimDimensions    = '}Dimensions';\ncHierLeaves       = 'Leaves';\n\
    cSubMissing       = 'Bedrock - Orphan Elements - Leaves';\ncSubNoParents     = 'Bedrock\
    \ - No Parents - %sHier%';\n\n### LogOutput parameters\nIF( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\nnErrors = 0;\nnDims = 0;\n\
    nDimsWithOrphans = 0;\nnDimsWithoutParents = 0;\nnElems = 0;\nnElemsMissing = 0;\nnElemsMissingParent\
    \ = 0;\nsDimPrev = '';\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim,\
    \ pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n  # A hierarchy has been passed as\
    \ dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n \
    \ pHier = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n  pDim = SubSt( pDim, 1,\
    \ Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate delimiter\nIf( Trim( pDelim ) @= '' );\n\
    \  pDelim = '&';\nEndIf;\n\nIf( Trim( pTgtSubLeaves ) @= '' );\n  pTgtSubLeaves = cSubMissing;\n\
    EndIf;\n\nIf( Trim( pTgtSubNoParents ) @= '' );\n  pTgtSubNoParents = cSubNoParents;\nElse;\n\
    \  pTgtSubNoParents = pTgtSubNoParents | ' - %sHier%';\nEndIf;\n\n### Validate dimension\n\
    If( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### If errors occurred terminate\
    \ process with a major error status ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Handle\
    \ All dimensions or a dimension list\n### We will exclude hierarchies in this step and will\
    \ filter them in connection with subsets in later steps\nIf ( TRIM( pDim ) @= cAll );\n\
    \  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}' );\nElse;\n  sDimTokenizer = TRIM( pDim );\n  sMDX = '';\n  ### Loop and\
    \ tokenize dimension list\n  While ( sDimTokenizer @<> '' );\n    nPos = SCAN( pDelim, sDimTokenizer\
    \ );\n    If ( nPos = 0 );\n      nPos = LONG( sDimTokenizer ) + 1;\n    EndIf;\n    sSearchDim\
    \ = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n    If( sMDX @= '' );\n      sMDX = Expand(\
    \ '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}, '%sSearchDim%')}' );\n    Else;\n      sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n  \
    \  EndIf;\n    ### Consume dimension and delimiter\n    sDimTokenizer = TRIM( DELET( sDimTokenizer,\
    \ 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX = Expand( '{%sMDX%}' );\nEndIf;\n\n\
    ### Create dimensions subset\nIf ( SubsetExists( cDimDimensions, cTempSub1 ) = 0 );\n  SubsetCreate(\
    \ cDimDimensions, cTempSub1, 1 );\nEndIf;\nSubsetMDXSet( cDimDimensions, cTempSub1, sMDX\
    \ );\nSubsetMDXSet( cDimDimensions, cTempSub1, '' );\n\n### Create hierachies working subset\n\
    If ( SubsetExists( cDimDimensions, cTempSub2 ) = 0 );\n  SubsetCreate( cDimDimensions, cTempSub2,\
    \ 1 );\nEndIf;\n\nDatasourceNameForServer = cDimDimensions;\nDatasourceNameForClient = cDimDimensions;\n\
    DataSourceType = 'SUBSET';\nDatasourceDimensionSubset = cTempSub1;\n#Section Metadaten\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n# Skip processing\
    \ if there is no Leaves hierarchy defined for the dimension or we are processing Leaves\n\
    If ( HierarchyExists( vDim, cHierLeaves ) = 0 );\n  ItemSkip;\nEndIf;\n\n# Summary information\
    \ printout\nIf ( sDimPrev @<> vDim );\n  If ( sDimPrev @<> '' & nElemsMissing <> 0 );\n\
    \    sElemsMissing = NumberToString( nElemsMissing );\n    If ( pLogOutput <> 0 );\n   \
    \   LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] is missing [%sElemsMissing%]\
    \ elements from [%cHierLeaves%] hierarchy in all of matching hierarchies [%pHier%]. List\
    \ of elements is available in subset [%pTgtSub%] of [%cHierLeaves%] hierarchy.' ) );\n \
    \   EndIf;\n    nDimsWithOrphans = nDimsWithOrphans + 1;\n  EndIf;\n  If ( sDimPrev @<>\
    \ '' & nElemsMissingParent <> 0 );\n    sElemsMissingParent = NumberToString( nElemsMissingParent\
    \ );\n    If ( pLogOutput <> 0 );\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%]\
    \ contains [%sElemsMissingParent%] elements that are missing parent in matching hierarchies\
    \ [%pHier%].' ) );\n    EndIf;\n    nDimsWithoutParents = nDimsWithoutParents + 1;\n  EndIf;\n\
    \  nDims = nDims + 1;\n  nElemsMissing = 0;\n  nElemsMissingParent = 0;\n  sDimPrev = vDim;\n\
    EndIf;\n\nIf( pHier @= '' );\n  sHier = vDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIf( sHier\
    \ @= cAll );\n  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), [%cDimDimensions%].CurrentMember.Name\
    \ = ''%vDim%'' OR INSTR([%cDimDimensions%].CurrentMember.Name, ''%vDim%:'' ) = 1 )}' );\n\
    \  SubsetMDXSet( cDimDimensions, cTempSub2, sMDX );\n  # Exclude Leaves from the count\n\
    \  nMaxHier = SubsetGetSize( cDimDimensions, cTempSub2 ) - 1;\nElse;\n  sMDX = Expand( '{TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimDimensions%])},\
    \ ''%vDim%:%sHier%'')}' );\n  SubsetMDXSet( cDimDimensions, cTempSub2, sMDX );\n  nMaxHier\
    \ = SubsetGetSize( cDimDimensions, cTempSub2 );\nEndIf;  \n\nIf ( nMaxHier <> 0 );\n  nElem\
    \ = 1;\n  nMaxElem = ElementCount( vDim, cHierLeaves );\n  While ( nElem <= nMaxElem );\n\
    \    sElem = ElementName( vDim, cHierLeaves, nElem );\n    nElems = 0;\n    nHier = 1;\n\
    \    While ( nHier <= nMaxHier );\n      sDimHier = SubsetGetElementName( cDimDimensions,\
    \ cTempSub2, nHier );\n      nDelimHier = SCAN( ':', sDimHier );\n      If ( nDelimHier\
    \ <> 0 );\n        sDim = SUBST( sDimHier, 1, nDelimHier - 1);\n        sHier = SUBST( sDimHier,\
    \ nDelimHier + 1, LONG( sDimHier ) - nDelimHier );\n      Else;\n        sDim = sDimHier;\n\
    \        sHier = sDimHier;\n      EndIf;\n      If ( sHier @<> cHierLeaves );\n        If\
    \ ( pIncludeNoParentElems <> 0 );\n          If(ElementIndex( sDim, sHier, sElem ) <> 0\
    \ & ElementParentCount( sDim, sHier, sElem ) = 0 & ElementLevel(sDim, sHier, sElem) = 0);\n\
    \            sTgtSubNoParents = Expand(pTgtSubNoParents);\n            If ( HierarchySubsetExists(\
    \ sDim, cHierLeaves, sTgtSubNoParents ) = 0 );\n              HierarchySubsetCreate( sDim,\
    \ cHierLeaves, sTgtSubNoParents );\n            ElseIf ( nElemsMissingParent = 0 );\n  \
    \            HierarchySubsetDeleteAllElements( sDim, cHierLeaves, sTgtSubNoParents );\n\
    \            EndIf;\n            If ( HierarchySubsetElementExists( sDim, cHierLeaves, sTgtSubNoParents,\
    \ sElem ) = 0 );\n              HierarchySubsetElementInsert( sDim, cHierLeaves, sTgtSubNoParents,\
    \ sElem, 0 );\n            EndIf;\n            If ( pLogOutput > 1 );\n              LogOutput(\
    \ cMsgInfoLevel, Expand( 'Element [%sElem%] is missing parent in [%sHier%] of dimension\
    \ [%vDim%].' ) );\n            EndIf;\n            nElemsMissingParent = nElemsMissingParent\
    \ + 1;\n          EndIf;\n        EndIf;\n        If ( ElementIndex( sDim, sHier, sElem\
    \ ) = 0 );\n          nElems = nElems + 1;\n        EndIf;\n      EndIf;\n      nHier =\
    \ nHier + 1;\n    End;\n    # We have scanned all hierarchies and if number of elements\
    \ missing equals number of hierarchies (excl. Leaves) then the element is orphan in Leaves\n\
    \    If ( nElems = nMaxHier );\n      If ( HierarchySubsetExists( sDim, cHierLeaves, pTgtSubLeaves\
    \ ) = 0 );\n        HierarchySubsetCreate( sDim, cHierLeaves, pTgtSubLeaves );\n      ElseIf\
    \ ( nElemsMissing = 0 );\n        HierarchySubsetDeleteAllElements( sDim, cHierLeaves, pTgtSubLeaves\
    \ );\n      EndIf;\n      If ( HierarchySubsetElementExists( sDim, cHierLeaves, pTgtSubLeaves,\
    \ sElem ) = 0 );\n        HierarchySubsetElementInsert( sDim, cHierLeaves, pTgtSubLeaves,\
    \ sElem, 0 );\n      EndIf;\n      If ( pLogOutput > 1 );\n        LogOutput( cMsgInfoLevel,\
    \ Expand( 'Element [%sElem%] is missing in all matching hierarchies [%pHier%] of dimension\
    \ [%vDim%] except [%cHierLeaves%].' ) );\n      EndIf;\n      nElemsMissing = nElemsMissing\
    \ + 1;\n    EndIf;\n    nElem = nElem + 1;\n  End;\nEndIf;\n\n#Section Daten\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### If errors occurred\
    \ terminate process with a major error status ###\nIf( nErrors <> 0 );\n    sMessage = 'the\
    \ process incurred at least 1 major error and consequently aborted. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nEndIf;\n\n### Return Code\nIf ( nDims <> 0\
    \ );\n  sDims = NumberToString( nDims );\n  ### Regular function - Leaves orphans\n  If\
    \ ( nDimsWithOrphans = 0 & nElemsMissing <> 0 );\n    nDimsWithOrphans = 1;\n    If ( pLogOutput\
    \ <> 0 );\n      sElemsMissing = NumberToString( nElemsMissing );\n      LogOutput( cMsgInfoLevel,\
    \ Expand( 'Dimension [%sDimPrev%] is missing [%sElemsMissing%] elements from [%cHierLeaves%]\
    \ hierarchy in all of matching hierarchies [%pHier%]. List of elements is available in subset\
    \ [%pTgtSub%] of [%cHierLeaves%] hierarchy.' ) );\n    EndIf;\n  EndIf;\n  sDimsWithOrphans\
    \ = NumberToString( nDimsWithOrphans );\n  If ( nDimsWithOrphans <> 0 );\n    sProcessAction\
    \ = Expand( 'There are orphan elements in [%sDimsWithOrphans%] dimensions out of [%sDims%]\
    \ matching.' );\n  Else;\n    sProcessAction = Expand( 'Scanned [%sDims%] dimensions, all\
    \ are OK and contain no Leaves orphans.' );\n  EndIf;\n  ### Optional function - elements\
    \ missing parents\n  If ( nDimsWithoutParents = 0 & nElemsMissingParent <> 0 );\n    nDimsWithoutParents\
    \ = 1;\n    If ( pLogOutput <> 0 );\n      sElemsMissingParents = NumberToString( nElemsMissingParent\
    \ );\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] contains [%sElemsMissingParents%]\
    \ elements that are missing parent in matching hierarchies [%pHier%].' ) );\n    EndIf;\n\
    \  EndIf;\n  sDimsWithoutParents = NumberToString( nDimsWithoutParents );\n  If ( nDimsWithoutParents\
    \ <> 0 );\n    sProcessAction = Expand( '%sProcessAction% There are elements having no parent\
    \ in [%sDimsWithoutParents%] dimensions out of [%sDims%] matching.' );\n  Else;\n    sProcessAction\
    \ = Expand( '%sProcessAction% All scanned dimensions are OK and contain no elements without\
    \ parents.' );\n  EndIf;\nElse;\n  sProcessAction = 'No dimensions/hierarchies are matching\
    \ supplied parameters.';\nEndIf;\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\nnProcessReturnCode  = 1;\nIf( pLogoutput <> 0 );\n    LogOutput( cMsgInfoLevel, Expand(\
    \ sProcessAction ) );   \nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that checks all leaf elements (in the ''Leaves''
    hierarchy) of the specified dimension(s). Within the ''Leaves'' hierarchy, for each element,
    *all hierarchies* are scanned for the existence of the leaf element. If the leaf element
    does not exist in all hierarchies except for ''Leaves'', the element is classified as an
    orphan and added to the ''Orphan Leaf Elements'' subset. Additionally, when running with
    the pIncludeNoParentElems parameter set, elements that have no parent will be stored in
    the ''No Parents'' subset of the matching hierarchy (except ''Leaves'') within Leaves. The
    subset name might be adapted and suffixed with a dash and the name of the matching hierarchy.
    Use case: 1. Primarily intended to identify dimensions with maintenance issues during development/prototyping.
    2. Can also be used for troubleshooting in productive instances.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process checks all leaf elements (in the Leaves hierarchy)\
    \ of the specified dimension(s).\n# Within the Leaves hierarchy for each element *all hierarchies*\
    \ are scanned for the existance of the leaf element.\n# If the leaf element does not exist\
    \ in all hierarchies except for Leaves then the element is classified as an orphan and added\
    \ to the \n# 'Orphan Leaf Elements' subset.\n# Additionally when running with pIncludeNoParentElems\
    \ parameter set, elements that have no parent will be stored in No Parents subset\n# of\
    \ matching hierarchy (except `Leaves`) within Leaves. The subset name might be accomodated\
    \ and will be suffixed by dash and name of the matching hierarchy.\n#\n# Use case: \n# 1.\
    \ Primarily intended to identify dimensions with maintenance issues during development/prototyping.\n\
    # 2. Can also be used for trouble-shooting in productive instances.\n#\n#EndRegion @DOC\n\
    \n### Global Variables\n\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants\ncThisProcName     = GetProcessName();\ncTimeStamp\
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub1          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cTempSub2         = cTempSub1 | '_2';\ncTempSubDim       = cThisProcName |'_Dim_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgInfoLevel\
    \     = 'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%.';\ncAll  \
    \            = '*';\ncDimDimensions    = '}Dimensions';\ncHierLeaves       = 'Leaves';\n\
    cSubMissing       = 'Bedrock - Orphan Elements - Leaves';\ncSubNoParents     = 'Bedrock\
    \ - No Parents - %sHier%';\n\n### LogOutput parameters\nIF( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\nnErrors = 0;\nnDims = 0;\n\
    nDimsWithOrphans = 0;\nnDimsWithoutParents = 0;\nnElems = 0;\nnElemsMissing = 0;\nnElemsMissingParent\
    \ = 0;\nsDimPrev = '';\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim,\
    \ pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n  # A hierarchy has been passed as\
    \ dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n \
    \ pHier = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n  pDim = SubSt( pDim, 1,\
    \ Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate delimiter\nIf( Trim( pDelim ) @= '' );\n\
    \  pDelim = '&';\nEndIf;\n\nIf( Trim( pTgtSubLeaves ) @= '' );\n  pTgtSubLeaves = cSubMissing;\n\
    EndIf;\n\nIf( Trim( pTgtSubNoParents ) @= '' );\n  pTgtSubNoParents = cSubNoParents;\nElse;\n\
    \  pTgtSubNoParents = pTgtSubNoParents | ' - %sHier%';\nEndIf;\n\n### Validate dimension\n\
    If( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### If errors occurred terminate\
    \ process with a major error status ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Handle\
    \ All dimensions or a dimension list\n### We will exclude hierarchies in this step and will\
    \ filter them in connection with subsets in later steps\nIf ( TRIM( pDim ) @= cAll );\n\
    \  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}' );\nElse;\n  sDimTokenizer = TRIM( pDim );\n  sMDX = '';\n  ### Loop and\
    \ tokenize dimension list\n  While ( sDimTokenizer @<> '' );\n    nPos = SCAN( pDelim, sDimTokenizer\
    \ );\n    If ( nPos = 0 );\n      nPos = LONG( sDimTokenizer ) + 1;\n    EndIf;\n    sSearchDim\
    \ = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n    If( sMDX @= '' );\n      sMDX = Expand(\
    \ '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}, '%sSearchDim%')}' );\n    Else;\n      sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n  \
    \  EndIf;\n    ### Consume dimension and delimiter\n    sDimTokenizer = TRIM( DELET( sDimTokenizer,\
    \ 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX = Expand( '{%sMDX%}' );\nEndIf;\n\n\
    ### Create dimensions subset\nIf ( SubsetExists( cDimDimensions, cTempSub1 ) = 0 );\n  SubsetCreate(\
    \ cDimDimensions, cTempSub1, 1 );\nEndIf;\nSubsetMDXSet( cDimDimensions, cTempSub1, sMDX\
    \ );\nSubsetMDXSet( cDimDimensions, cTempSub1, '' );\n\n### Create hierachies working subset\n\
    If ( SubsetExists( cDimDimensions, cTempSub2 ) = 0 );\n  SubsetCreate( cDimDimensions, cTempSub2,\
    \ 1 );\nEndIf;\n\nDatasourceNameForServer = cDimDimensions;\nDatasourceNameForClient = cDimDimensions;\n\
    DataSourceType = 'SUBSET';\nDatasourceDimensionSubset = cTempSub1;\n#Section Metadaten\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n# Skip processing\
    \ if there is no Leaves hierarchy defined for the dimension or we are processing Leaves\n\
    If ( HierarchyExists( vDim, cHierLeaves ) = 0 );\n  ItemSkip;\nEndIf;\n\n# Summary information\
    \ printout\nIf ( sDimPrev @<> vDim );\n  If ( sDimPrev @<> '' & nElemsMissing <> 0 );\n\
    \    sElemsMissing = NumberToString( nElemsMissing );\n    If ( pLogOutput <> 0 );\n   \
    \   LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] is missing [%sElemsMissing%]\
    \ elements from [%cHierLeaves%] hierarchy in all of matching hierarchies [%pHier%]. List\
    \ of elements is available in subset [%pTgtSub%] of [%cHierLeaves%] hierarchy.' ) );\n \
    \   EndIf;\n    nDimsWithOrphans = nDimsWithOrphans + 1;\n  EndIf;\n  If ( sDimPrev @<>\
    \ '' & nElemsMissingParent <> 0 );\n    sElemsMissingParent = NumberToString( nElemsMissingParent\
    \ );\n    If ( pLogOutput <> 0 );\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%]\
    \ contains [%sElemsMissingParent%] elements that are missing parent in matching hierarchies\
    \ [%pHier%].' ) );\n    EndIf;\n    nDimsWithoutParents = nDimsWithoutParents + 1;\n  EndIf;\n\
    \  nDims = nDims + 1;\n  nElemsMissing = 0;\n  nElemsMissingParent = 0;\n  sDimPrev = vDim;\n\
    EndIf;\n\nIf( pHier @= '' );\n  sHier = vDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIf( sHier\
    \ @= cAll );\n  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), [%cDimDimensions%].CurrentMember.Name\
    \ = ''%vDim%'' OR INSTR([%cDimDimensions%].CurrentMember.Name, ''%vDim%:'' ) = 1 )}' );\n\
    \  SubsetMDXSet( cDimDimensions, cTempSub2, sMDX );\n  # Exclude Leaves from the count\n\
    \  nMaxHier = SubsetGetSize( cDimDimensions, cTempSub2 ) - 1;\nElse;\n  sMDX = Expand( '{TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimDimensions%])},\
    \ ''%vDim%:%sHier%'')}' );\n  SubsetMDXSet( cDimDimensions, cTempSub2, sMDX );\n  nMaxHier\
    \ = SubsetGetSize( cDimDimensions, cTempSub2 );\nEndIf;  \n\nIf ( nMaxHier <> 0 );\n  nElem\
    \ = 1;\n  nMaxElem = ElementCount( vDim, cHierLeaves );\n  While ( nElem <= nMaxElem );\n\
    \    sElem = ElementName( vDim, cHierLeaves, nElem );\n    nElems = 0;\n    nHier = 1;\n\
    \    While ( nHier <= nMaxHier );\n      sDimHier = SubsetGetElementName( cDimDimensions,\
    \ cTempSub2, nHier );\n      nDelimHier = SCAN( ':', sDimHier );\n      If ( nDelimHier\
    \ <> 0 );\n        sDim = SUBST( sDimHier, 1, nDelimHier - 1);\n        sHier = SUBST( sDimHier,\
    \ nDelimHier + 1, LONG( sDimHier ) - nDelimHier );\n      Else;\n        sDim = sDimHier;\n\
    \        sHier = sDimHier;\n      EndIf;\n      If ( sHier @<> cHierLeaves );\n        If\
    \ ( pIncludeNoParentElems <> 0 );\n          If(ElementIndex( sDim, sHier, sElem ) <> 0\
    \ & ElementParentCount( sDim, sHier, sElem ) = 0 & ElementLevel(sDim, sHier, sElem) = 0);\n\
    \            sTgtSubNoParents = Expand(pTgtSubNoParents);\n            If ( HierarchySubsetExists(\
    \ sDim, cHierLeaves, sTgtSubNoParents ) = 0 );\n              HierarchySubsetCreate( sDim,\
    \ cHierLeaves, sTgtSubNoParents );\n            ElseIf ( nElemsMissingParent = 0 );\n  \
    \            HierarchySubsetDeleteAllElements( sDim, cHierLeaves, sTgtSubNoParents );\n\
    \            EndIf;\n            If ( HierarchySubsetElementExists( sDim, cHierLeaves, sTgtSubNoParents,\
    \ sElem ) = 0 );\n              HierarchySubsetElementInsert( sDim, cHierLeaves, sTgtSubNoParents,\
    \ sElem, 0 );\n            EndIf;\n            If ( pLogOutput > 1 );\n              LogOutput(\
    \ cMsgInfoLevel, Expand( 'Element [%sElem%] is missing parent in [%sHier%] of dimension\
    \ [%vDim%].' ) );\n            EndIf;\n            nElemsMissingParent = nElemsMissingParent\
    \ + 1;\n          EndIf;\n        EndIf;\n        If ( ElementIndex( sDim, sHier, sElem\
    \ ) = 0 );\n          nElems = nElems + 1;\n        EndIf;\n      EndIf;\n      nHier =\
    \ nHier + 1;\n    End;\n    # We have scanned all hierarchies and if number of elements\
    \ missing equals number of hierarchies (excl. Leaves) then the element is orphan in Leaves\n\
    \    If ( nElems = nMaxHier );\n      If ( HierarchySubsetExists( sDim, cHierLeaves, pTgtSubLeaves\
    \ ) = 0 );\n        HierarchySubsetCreate( sDim, cHierLeaves, pTgtSubLeaves );\n      ElseIf\
    \ ( nElemsMissing = 0 );\n        HierarchySubsetDeleteAllElements( sDim, cHierLeaves, pTgtSubLeaves\
    \ );\n      EndIf;\n      If ( HierarchySubsetElementExists( sDim, cHierLeaves, pTgtSubLeaves,\
    \ sElem ) = 0 );\n        HierarchySubsetElementInsert( sDim, cHierLeaves, pTgtSubLeaves,\
    \ sElem, 0 );\n      EndIf;\n      If ( pLogOutput > 1 );\n        LogOutput( cMsgInfoLevel,\
    \ Expand( 'Element [%sElem%] is missing in all matching hierarchies [%pHier%] of dimension\
    \ [%vDim%] except [%cHierLeaves%].' ) );\n      EndIf;\n      nElemsMissing = nElemsMissing\
    \ + 1;\n    EndIf;\n    nElem = nElem + 1;\n  End;\nEndIf;\n\n#Section Daten\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### If errors occurred\
    \ terminate process with a major error status ###\nIf( nErrors <> 0 );\n    sMessage = 'the\
    \ process incurred at least 1 major error and consequently aborted. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nEndIf;\n\n### Return Code\nIf ( nDims <> 0\
    \ );\n  sDims = NumberToString( nDims );\n  ### Regular function - Leaves orphans\n  If\
    \ ( nDimsWithOrphans = 0 & nElemsMissing <> 0 );\n    nDimsWithOrphans = 1;\n    If ( pLogOutput\
    \ <> 0 );\n      sElemsMissing = NumberToString( nElemsMissing );\n      LogOutput( cMsgInfoLevel,\
    \ Expand( 'Dimension [%sDimPrev%] is missing [%sElemsMissing%] elements from [%cHierLeaves%]\
    \ hierarchy in all of matching hierarchies [%pHier%]. List of elements is available in subset\
    \ [%pTgtSub%] of [%cHierLeaves%] hierarchy.' ) );\n    EndIf;\n  EndIf;\n  sDimsWithOrphans\
    \ = NumberToString( nDimsWithOrphans );\n  If ( nDimsWithOrphans <> 0 );\n    sProcessAction\
    \ = Expand( 'There are orphan elements in [%sDimsWithOrphans%] dimensions out of [%sDims%]\
    \ matching.' );\n  Else;\n    sProcessAction = Expand( 'Scanned [%sDims%] dimensions, all\
    \ are OK and contain no Leaves orphans.' );\n  EndIf;\n  ### Optional function - elements\
    \ missing parents\n  If ( nDimsWithoutParents = 0 & nElemsMissingParent <> 0 );\n    nDimsWithoutParents\
    \ = 1;\n    If ( pLogOutput <> 0 );\n      sElemsMissingParents = NumberToString( nElemsMissingParent\
    \ );\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] contains [%sElemsMissingParents%]\
    \ elements that are missing parent in matching hierarchies [%pHier%].' ) );\n    EndIf;\n\
    \  EndIf;\n  sDimsWithoutParents = NumberToString( nDimsWithoutParents );\n  If ( nDimsWithoutParents\
    \ <> 0 );\n    sProcessAction = Expand( '%sProcessAction% There are elements having no parent\
    \ in [%sDimsWithoutParents%] dimensions out of [%sDims%] matching.' );\n  Else;\n    sProcessAction\
    \ = Expand( '%sProcessAction% All scanned dimensions are OK and contain no elements without\
    \ parents.' );\n  EndIf;\nElse;\n  sProcessAction = 'No dimensions/hierarchies are matching\
    \ supplied parameters.';\nEndIf;\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\nnProcessReturnCode  = 1;\nIf( pLogoutput <> 0 );\n    LogOutput( cMsgInfoLevel, Expand(\
    \ sProcessAction ) );   \nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der die Synchronität der Leaves-Hierarchie
    in Bezug auf die Haupt- und Alternativhierarchien einer Dimension überprüft und wiederherstellt.
    Der Prozess sollte sicherstellen, dass alle Blattelemente in der Leaves-Hierarchie vorhanden
    sind, wenn diese mit den in den Parametern pDim und pHier angegebenen Dimensionen und Hierarchien
    verglichen werden. Der Vorgang sollte automatisch fehlende Blattelemente zur Leaves-Hierarchie
    hinzufügen. Nutze diesen Prozess, um während der Entwicklung oder Fehlersuche in produktiven
    Instanzen Dimensionsprobleme zu identifizieren und zu beheben.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# In certain circumstances the Leaves hierarchy can become\
    \ *out of sync* with the same named hierarchy and other alternate hierarchies\n# and *not\
    \ contain all leaf elements*. Should this happen this process will heal such dimensions\
    \ and restore the synced state where\n# the Leaves hierarchy contains the collection of\
    \ all leaf elements from all hiearchies of a dimension.  \n# For the set of dimensions and\
    \ hierarchies defined by the pDim & pHier parameters this process checks that all leaf elements\
    \ from each\n# hierarchy also exists in the Leaves hierarchy of the specified dimension(s).\n\
    #\n# If the leaf element does not exist in the Leaves hierarchy then the element is inserted\
    \ into Leaves.\n#\n# Use case: \n# 1. Primarily intended to identify dimensions with maintenance\
    \ issues during development/prototyping.\n# 2. Can also be used for trouble-shooting in\
    \ productive instances.\n#\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants\n\
    cThisProcName     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\\
    s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          =\
    \ cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncTempSubDim       = cThisProcName |'_Dim_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgInfoLevel     = 'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%.';\ncAll              = '*';\ncDimDimensions    = '}Dimensions';\n\
    cCharAny          = '?';\ncStringAny        = '*';\ncHierLeaves       = 'Leaves';\ncRollupOrphan\
    \     = 'ORPHAN LEAVES';\n\n### LogOutput parameters\nIF( pLogoutput >= 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\nsDimPrev          = '';\n\
    nErrors           = 0;\nnDims             = 0;\nnDimsChanged      = 0;\nnElems         \
    \   = 0;\nnLeaves           = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 &\
    \ Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n  # A hierarchy has\
    \ been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n  pHier = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n  pDim = SubSt(\
    \ pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate delimiter\nIf( Trim( pDelim\
    \ ) @= '' );\n  pDelim = '&';\nEndIf;\n\n### Validate dimension\nIf( Trim( pDim ) @= ''\
    \ );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### Validate reverse sync option\nIf( pReverse\
    \ <> 1 );\n  pReverse = 0;\nEndIf;\n\n### If errors occurred terminate process with a major\
    \ error status ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Handle All dimensions or a dimension\
    \ list, including all available hierarchies\nIf ( TRIM( pDim ) @= cAll );\n  sMDX1 = Expand(\
    \ '{TM1SUBSETALL([%cDimDimensions%])}' );\nElse;\n  sDimTokenizer = TRIM( pDim );\n  sMDX\
    \ = '';\n  ### Loop and tokenize dimension list\n  While ( sDimTokenizer @<> '' );\n   \
    \ nPos = SCAN( pDelim, sDimTokenizer );\n    If ( nPos = 0 );\n      nPos = LONG( sDimTokenizer\
    \ ) + 1;\n    EndIf;\n    sSearchDim = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n  \
    \  If( sMDX @= '' );\n      sMDX = Expand( '{TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])},\
    \ '%sSearchDim%*' )}' );\n    Else;\n      sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([%cDimDimensions%])}, '%sSearchDim%' )}' );\n    EndIf;\n    ### Consume\
    \ dimension and delimiter\n    sDimTokenizer = TRIM( DELET( sDimTokenizer, 1, nPos + LONG(\
    \ pDelim ) - 1 ) );\n  End;\n  sMDX1 = Expand( '{%sMDX%}' );\nEndIf;\n\n### Handle All hierarchies\
    \ or a hierarchy list\n### We will filter hierarchies in this step from base set created\
    \ previously\nIf ( TRIM( pHier ) @= cAll );\n  sMDX = sMDX1;\nElse;\n  sHierTokenizer =\
    \ TRIM( pHier );\n  If( sHierTokenizer @= '' );\n    # if pHier blank then we need only\
    \ same named hierarchies - that means to exclude elements that have : in their names\n \
    \   sMDX = Expand( '{FILTER( %sMDX1%, INSTR([%cDimDimensions%].CurrentMember.Name, '':''\
    \ ) = 0 )}' );\n  Else;\n    sMDX = '';\n    ### Loop and tokenize hierarchy list\n    While\
    \ ( sHierTokenizer @<> '' );\n      nPos = SCAN( pDelim, sHierTokenizer );\n      If ( nPos\
    \ = 0 );\n        nPos = LONG( sHierTokenizer ) + 1;\n      EndIf;\n      sSearchHier =\
    \ TRIM( SUBST( sHierTokenizer, 1, nPos - 1 ) );\n      If( sMDX @= '' );\n        sMDX =\
    \ Expand( '{TM1FILTERBYPATTERN( %sMDX1%, '*:%sSearchHier%' )}' );\n      Else;\n       \
    \ sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN( %sMDX1%, '*:%sSearchHier%' )}' );\n    \
    \  EndIf;\n      ### Consume hierarchy and delimiter\n      sHierTokenizer = TRIM( DELET(\
    \ sHierTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n    End;\n    sMDX = Expand( '{%sMDX%}'\
    \ );\n  EndIf;\nEndIf;\n\nsMDX = Expand(' {EXCEPT( %sMDX%, {TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])},\
    \ '*:Leaves' )} )}');\nsMDXF = Expand( '{ORDER( %sMDX%, [%cDimDimensions%].CurrentMember.Name,\
    \ ASC )}' );\n\n### Create dimension:hierarchy subset\nIf ( SubsetExists( cDimDimensions,\
    \ cTempSub ) = 0 );\n    SubsetCreatebyMDX( cTempSub, sMDXF, cDimDimensions, 1 );\nElse;\n\
    \    SubsetMDXSet( cDimDimensions, cTempSub, sMDXF );\nEndIf;\n\nDatasourceNameForServer\
    \ = cDimDimensions;\nDatasourceNameForClient = cDimDimensions;\nDataSourceType = 'SUBSET';\n\
    DatasourceDimensionSubset = cTempSub;\n\n### END PROLOG\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n# Get dimension & hierarchy\
    \ from vDimHier\nnDelimHier  = SCAN( ':', vDimHier );\nIf ( nDelimHier <> 0 );\n    sDim\
    \    = SUBST( vDimHier, 1, nDelimHier - 1);\n    sHier   = SUBST( vDimHier, nDelimHier +\
    \ 1, LONG( vDimHier ) - nDelimHier );\nElse;\n    sDim    = vDimHier;\n    sHier   = vDimHier;\n\
    EndIf;\n\nIf ( sHier  @= cHierLeaves );\n    ItemSkip;\nEndIf;\n\n# Set check counters\n\
    If( sDim @<> sDimPrev );\n    nDims   = nDims + 1;\nEndIf;\nnElems      = 0;\nnLeaves  \
    \   = 0;\n\n# Add leaves which exist in hierarchy but (somehow) don't exist in Leaves hierarchy\
    \ to Leaves\nnElem = 1;\nnMaxElem = ElementCount( sDim, sHier );\nWhile ( nElem <= nMaxElem\
    \ );\n    sElem = ElementName( sDim, sHier, nElem );\n    sType = ElementType( sDim, sHier,\
    \ sElem );\n    If ( ElementLevel( sDim, sHier, sElem ) = 0 & HierarchyExists( sDim, cHierLeaves\
    \ ) = 1 );\n        If ( ElementIndex( sDim, cHierLeaves, sElem ) = 0 & ( sType @= 'N' %\
    \ sType @= 'S' ) );\n            HierarchyElementInsert( sDim, cHierLeaves, '', sElem, sType\
    \ );\n            nElems = nElems + 1;\n            If ( pLogOutput <> 0 );\n          \
    \      LogOutput( cMsgInfoLevel, Expand( 'Adding element [%sElem%] of [%sType%] type into\
    \ [%cHierLeaves%], element was found in hierarchy [%sHier%].' ) );\n            EndIf;\n\
    \        EndIf;\n    EndIf;\n    nElem = nElem + 1;\nEnd;\n\n# Add leaves not existing in\
    \ hierarchy to the 'ORPHAN LEAVES' consolidation\nIf( pReverse = 1 & HierarchyExists( sDim,\
    \ cHierLeaves ) = 1 );\n    nLeaf = 1;\n    nMaxLeaves = ElementCount( sDim, cHierLeaves\
    \ );\n    While ( nLeaf <= nMaxLeaves );\n        sLeaf = ElementName( sDim, cHierLeaves,\
    \ nLeaf );\n        sType = ElementType( sDim, cHierLeaves, sLeaf );\n        If ( ElementIndex(\
    \ sDim, sHier, sLeaf ) = 0 );\n            HierarchyElementInsert( sDim, sHier, '', cRollupOrphan,\
    \ 'C' );\n            HierarchyElementInsert( sDim, sHier, '', sLeaf, sType );\n       \
    \     If( sType @= 'N' );\n                HierarchyElementComponentAdd( sDim, sHier, cRollupOrphan,\
    \ sLeaf, 1 );\n            EndIf;\n            nLeaves = nLeaves + 1;\n            If (\
    \ pLogOutput <> 0 );\n                LogOutput( cMsgInfoLevel, Expand( 'Adding leaf [%sLeaf%]\
    \ into hierarchy [%sHier%].' ) );\n            EndIf;\n        EndIf;\n        nLeaf = nLeaf\
    \ + 1;\n    End;\nEndIf;\n\n# Summary information printout\nIf( nElems  > 0 );\n    sElems\
    \  = NumberToString( nElems );\n    If ( pLogOutput <> 0 );\n        LogOutput( cMsgInfoLevel,\
    \ Expand( 'Added [%sElems%] elements from hierarchy [%sHier%] into [%cHierLeaves%] hierarchy\
    \ of [%sDim%] dimension.' ) );\n    EndIf;\nEndIf;\nIf( nLeaves > 0 );\n    sLeaves = NumberToString(\
    \ nLeaves );\n    If ( pLogOutput <> 0 );\n        LogOutput( cMsgInfoLevel, Expand( 'Added\
    \ [%sLeaves%] leaves into hierarchy [%sHier%] of [%sDim%] dimension.' ) );\n    EndIf;\n\
    EndIf;\nIf( sDim @<> sDimPrev & (nElems + nLeaves) > 0 );\n    nDimsChanged = nDimsChanged\
    \ + 1;\nEndIf;\nsDimPrev    = sDim;\n\n### END METADATA\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### If errors occurred terminate\
    \ process with a major error status ###\nIf( nErrors <> 0 );\n    sMessage = 'the process\
    \ incurred at least 1 major error and consequently aborted. Please see above lines in this\
    \ file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nEndIf;\n\n### Return Code\nIf ( nDims <> 0\
    \ );\n  sDims = NumberToString( nDims );\n  sDimsChanged = NumberToString( nDimsChanged\
    \ );\n  If ( nDimsChanged > 0 );\n    sProcessAction = Expand( 'Modified [%sDimsChanged%]\
    \ dimensions out of [%sDims%] matching the filter.' );\n  Else;\n    sProcessAction = Expand(\
    \ 'Scanned [%sDims%] dimensions, all are ok.' );\n  EndIf;\nElse;\n  sProcessAction = 'No\
    \ dimensions/hierarchies are matching supplied parameters. Nothing modified.';\nEndIf;\n\
    sProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode\
    \  = 1;\nIf( pLogoutput <> 0 );\n    LogOutput( cMsgInfoLevel, Expand( sProcessAction )\
    \ );   \nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that verifies and restores the synchronization
    of the Leaves hierarchy concerning the main and alternate hierarchies of a dimension. The
    process should ensure that all leaf elements are present in the Leaves hierarchy when compared
    with the dimensions and hierarchies specified in the pDim and pHier parameters. The operation
    should automatically insert any missing leaf elements into the Leaves hierarchy. Use this
    process to identify and resolve dimension issues during development or troubleshooting in
    productive instances.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# In certain circumstances the Leaves hierarchy can become\
    \ *out of sync* with the same named hierarchy and other alternate hierarchies\n# and *not\
    \ contain all leaf elements*. Should this happen this process will heal such dimensions\
    \ and restore the synced state where\n# the Leaves hierarchy contains the collection of\
    \ all leaf elements from all hiearchies of a dimension.  \n# For the set of dimensions and\
    \ hierarchies defined by the pDim & pHier parameters this process checks that all leaf elements\
    \ from each\n# hierarchy also exists in the Leaves hierarchy of the specified dimension(s).\n\
    #\n# If the leaf element does not exist in the Leaves hierarchy then the element is inserted\
    \ into Leaves.\n#\n# Use case: \n# 1. Primarily intended to identify dimensions with maintenance\
    \ issues during development/prototyping.\n# 2. Can also be used for trouble-shooting in\
    \ productive instances.\n#\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants\n\
    cThisProcName     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\\
    s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          =\
    \ cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncTempSubDim       = cThisProcName |'_Dim_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgInfoLevel     = 'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%.';\ncAll              = '*';\ncDimDimensions    = '}Dimensions';\n\
    cCharAny          = '?';\ncStringAny        = '*';\ncHierLeaves       = 'Leaves';\ncRollupOrphan\
    \     = 'ORPHAN LEAVES';\n\n### LogOutput parameters\nIF( pLogoutput >= 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\nsDimPrev          = '';\n\
    nErrors           = 0;\nnDims             = 0;\nnDimsChanged      = 0;\nnElems         \
    \   = 0;\nnLeaves           = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 &\
    \ Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n  # A hierarchy has\
    \ been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n  pHier = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n  pDim = SubSt(\
    \ pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate delimiter\nIf( Trim( pDelim\
    \ ) @= '' );\n  pDelim = '&';\nEndIf;\n\n### Validate dimension\nIf( Trim( pDim ) @= ''\
    \ );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### Validate reverse sync option\nIf( pReverse\
    \ <> 1 );\n  pReverse = 0;\nEndIf;\n\n### If errors occurred terminate process with a major\
    \ error status ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Handle All dimensions or a dimension\
    \ list, including all available hierarchies\nIf ( TRIM( pDim ) @= cAll );\n  sMDX1 = Expand(\
    \ '{TM1SUBSETALL([%cDimDimensions%])}' );\nElse;\n  sDimTokenizer = TRIM( pDim );\n  sMDX\
    \ = '';\n  ### Loop and tokenize dimension list\n  While ( sDimTokenizer @<> '' );\n   \
    \ nPos = SCAN( pDelim, sDimTokenizer );\n    If ( nPos = 0 );\n      nPos = LONG( sDimTokenizer\
    \ ) + 1;\n    EndIf;\n    sSearchDim = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n  \
    \  If( sMDX @= '' );\n      sMDX = Expand( '{TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])},\
    \ '%sSearchDim%*' )}' );\n    Else;\n      sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([%cDimDimensions%])}, '%sSearchDim%' )}' );\n    EndIf;\n    ### Consume\
    \ dimension and delimiter\n    sDimTokenizer = TRIM( DELET( sDimTokenizer, 1, nPos + LONG(\
    \ pDelim ) - 1 ) );\n  End;\n  sMDX1 = Expand( '{%sMDX%}' );\nEndIf;\n\n### Handle All hierarchies\
    \ or a hierarchy list\n### We will filter hierarchies in this step from base set created\
    \ previously\nIf ( TRIM( pHier ) @= cAll );\n  sMDX = sMDX1;\nElse;\n  sHierTokenizer =\
    \ TRIM( pHier );\n  If( sHierTokenizer @= '' );\n    # if pHier blank then we need only\
    \ same named hierarchies - that means to exclude elements that have : in their names\n \
    \   sMDX = Expand( '{FILTER( %sMDX1%, INSTR([%cDimDimensions%].CurrentMember.Name, '':''\
    \ ) = 0 )}' );\n  Else;\n    sMDX = '';\n    ### Loop and tokenize hierarchy list\n    While\
    \ ( sHierTokenizer @<> '' );\n      nPos = SCAN( pDelim, sHierTokenizer );\n      If ( nPos\
    \ = 0 );\n        nPos = LONG( sHierTokenizer ) + 1;\n      EndIf;\n      sSearchHier =\
    \ TRIM( SUBST( sHierTokenizer, 1, nPos - 1 ) );\n      If( sMDX @= '' );\n        sMDX =\
    \ Expand( '{TM1FILTERBYPATTERN( %sMDX1%, '*:%sSearchHier%' )}' );\n      Else;\n       \
    \ sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN( %sMDX1%, '*:%sSearchHier%' )}' );\n    \
    \  EndIf;\n      ### Consume hierarchy and delimiter\n      sHierTokenizer = TRIM( DELET(\
    \ sHierTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n    End;\n    sMDX = Expand( '{%sMDX%}'\
    \ );\n  EndIf;\nEndIf;\n\nsMDX = Expand(' {EXCEPT( %sMDX%, {TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])},\
    \ '*:Leaves' )} )}');\nsMDXF = Expand( '{ORDER( %sMDX%, [%cDimDimensions%].CurrentMember.Name,\
    \ ASC )}' );\n\n### Create dimension:hierarchy subset\nIf ( SubsetExists( cDimDimensions,\
    \ cTempSub ) = 0 );\n    SubsetCreatebyMDX( cTempSub, sMDXF, cDimDimensions, 1 );\nElse;\n\
    \    SubsetMDXSet( cDimDimensions, cTempSub, sMDXF );\nEndIf;\n\nDatasourceNameForServer\
    \ = cDimDimensions;\nDatasourceNameForClient = cDimDimensions;\nDataSourceType = 'SUBSET';\n\
    DatasourceDimensionSubset = cTempSub;\n\n### END PROLOG\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n# Get dimension & hierarchy\
    \ from vDimHier\nnDelimHier  = SCAN( ':', vDimHier );\nIf ( nDelimHier <> 0 );\n    sDim\
    \    = SUBST( vDimHier, 1, nDelimHier - 1);\n    sHier   = SUBST( vDimHier, nDelimHier +\
    \ 1, LONG( vDimHier ) - nDelimHier );\nElse;\n    sDim    = vDimHier;\n    sHier   = vDimHier;\n\
    EndIf;\n\nIf ( sHier  @= cHierLeaves );\n    ItemSkip;\nEndIf;\n\n# Set check counters\n\
    If( sDim @<> sDimPrev );\n    nDims   = nDims + 1;\nEndIf;\nnElems      = 0;\nnLeaves  \
    \   = 0;\n\n# Add leaves which exist in hierarchy but (somehow) don't exist in Leaves hierarchy\
    \ to Leaves\nnElem = 1;\nnMaxElem = ElementCount( sDim, sHier );\nWhile ( nElem <= nMaxElem\
    \ );\n    sElem = ElementName( sDim, sHier, nElem );\n    sType = ElementType( sDim, sHier,\
    \ sElem );\n    If ( ElementLevel( sDim, sHier, sElem ) = 0 & HierarchyExists( sDim, cHierLeaves\
    \ ) = 1 );\n        If ( ElementIndex( sDim, cHierLeaves, sElem ) = 0 & ( sType @= 'N' %\
    \ sType @= 'S' ) );\n            HierarchyElementInsert( sDim, cHierLeaves, '', sElem, sType\
    \ );\n            nElems = nElems + 1;\n            If ( pLogOutput <> 0 );\n          \
    \      LogOutput( cMsgInfoLevel, Expand( 'Adding element [%sElem%] of [%sType%] type into\
    \ [%cHierLeaves%], element was found in hierarchy [%sHier%].' ) );\n            EndIf;\n\
    \        EndIf;\n    EndIf;\n    nElem = nElem + 1;\nEnd;\n\n# Add leaves not existing in\
    \ hierarchy to the 'ORPHAN LEAVES' consolidation\nIf( pReverse = 1 & HierarchyExists( sDim,\
    \ cHierLeaves ) = 1 );\n    nLeaf = 1;\n    nMaxLeaves = ElementCount( sDim, cHierLeaves\
    \ );\n    While ( nLeaf <= nMaxLeaves );\n        sLeaf = ElementName( sDim, cHierLeaves,\
    \ nLeaf );\n        sType = ElementType( sDim, cHierLeaves, sLeaf );\n        If ( ElementIndex(\
    \ sDim, sHier, sLeaf ) = 0 );\n            HierarchyElementInsert( sDim, sHier, '', cRollupOrphan,\
    \ 'C' );\n            HierarchyElementInsert( sDim, sHier, '', sLeaf, sType );\n       \
    \     If( sType @= 'N' );\n                HierarchyElementComponentAdd( sDim, sHier, cRollupOrphan,\
    \ sLeaf, 1 );\n            EndIf;\n            nLeaves = nLeaves + 1;\n            If (\
    \ pLogOutput <> 0 );\n                LogOutput( cMsgInfoLevel, Expand( 'Adding leaf [%sLeaf%]\
    \ into hierarchy [%sHier%].' ) );\n            EndIf;\n        EndIf;\n        nLeaf = nLeaf\
    \ + 1;\n    End;\nEndIf;\n\n# Summary information printout\nIf( nElems  > 0 );\n    sElems\
    \  = NumberToString( nElems );\n    If ( pLogOutput <> 0 );\n        LogOutput( cMsgInfoLevel,\
    \ Expand( 'Added [%sElems%] elements from hierarchy [%sHier%] into [%cHierLeaves%] hierarchy\
    \ of [%sDim%] dimension.' ) );\n    EndIf;\nEndIf;\nIf( nLeaves > 0 );\n    sLeaves = NumberToString(\
    \ nLeaves );\n    If ( pLogOutput <> 0 );\n        LogOutput( cMsgInfoLevel, Expand( 'Added\
    \ [%sLeaves%] leaves into hierarchy [%sHier%] of [%sDim%] dimension.' ) );\n    EndIf;\n\
    EndIf;\nIf( sDim @<> sDimPrev & (nElems + nLeaves) > 0 );\n    nDimsChanged = nDimsChanged\
    \ + 1;\nEndIf;\nsDimPrev    = sDim;\n\n### END METADATA\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### If errors occurred terminate\
    \ process with a major error status ###\nIf( nErrors <> 0 );\n    sMessage = 'the process\
    \ incurred at least 1 major error and consequently aborted. Please see above lines in this\
    \ file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nEndIf;\n\n### Return Code\nIf ( nDims <> 0\
    \ );\n  sDims = NumberToString( nDims );\n  sDimsChanged = NumberToString( nDimsChanged\
    \ );\n  If ( nDimsChanged > 0 );\n    sProcessAction = Expand( 'Modified [%sDimsChanged%]\
    \ dimensions out of [%sDims%] matching the filter.' );\n  Else;\n    sProcessAction = Expand(\
    \ 'Scanned [%sDims%] dimensions, all are ok.' );\n  EndIf;\nElse;\n  sProcessAction = 'No\
    \ dimensions/hierarchies are matching supplied parameters. Nothing modified.';\nEndIf;\n\
    sProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode\
    \  = 1;\nIf( pLogoutput <> 0 );\n    LogOutput( cMsgInfoLevel, Expand( sProcessAction )\
    \ );   \nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der ein Teilmengen-Set von einer Hierarchie
    in einer Quell-Dimension zu einer Hierarchie in einer Ziel-Dimension kopiert. Beachte dabei,
    dass gültige Quell-Dimensionsnamen (pSrcDim), Quell- (pSrcSub) und Ziel-Teilmengen (pTgtSub)
    zwingend erforderlich sind, da der Prozess ansonsten abgebrochen wird. Achte darauf, dass
    die Ziel-Hierarchie nicht `Leaves` sein darf. Falls die Ziel-Dimensionen-Hierarchie bereits
    existiert, wird sie überschrieben.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will copy a subset from a Hierarchy in source\
    \ Dimension to a Hierarchy in target\n# Dimension.\n\n# Note:\n# Valid source dimension\
    \ name (pSrcDim), source (pSrcSub) and target subset (pTgtSub) are \n# mandatory otherwise\
    \ the process will abort.\n\n# Caution:\n# - Target hierarchy cannot be `Leaves`.\n# - If\
    \ the target dimension Hierarchy exists then it will be overwritten.\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters\
    \ pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%, pSrcSub:%pSrcSub%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%,\
    \ pTgtSub:%pTgtSub%, pTemp:%pTemp%, pAlias:%pAlias%.' ; \n\n## LogOutput parameters\nIF(\
    \ pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= '' );\n   \
    \ # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim )\
    \ + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim )\
    \ - 1 );\nEndIf;\n\n# Validate Source dimension\nIf( Trim( pSrcDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pSrcDim ) = 0 );\n    nErrors\
    \ = 1;\n    sMessage = 'Dimension ' | pSrcDim | ' does not exist.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Source Hierarchy\nIf( Trim( pSrcHier\
    \ ) @= '' );\n    pSrcHier = Trim( pSrcDim );\nEndIf;\n\nIf( HierarchyExists( pSrcDim ,\
    \ pSrcHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'The Hierachy ' | pSrcHier | ' does\
    \ not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate Source subset\nIf( Trim( pSrcsub ) @= '' );\n    nErrors = 1;\n    sMessage =\
    \ 'No source subset specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( HierarchySubsetExists( pSrcDim , pSrcHier, pSrcsub ) = 0 );\n    nErrors\
    \ = 1;\n    sMessage = 'Invalid source subset : ' | pSrcDim |':'| pSrcHier |':'| pSrcSub;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Scan( ':',\
    \ pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy has been passed as dimension. Handle\
    \ the input error by splitting dim:hier into dimension & hierarchy\n    pTgtHier       =\
    \ SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim        = SubSt(\
    \ pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n# Validate target dimension\nIf( Trim(\
    \ pTgtDim ) @= '' );\n    pTgtDim = Trim( pSrcDim );\nElseIf( DimensionExists( pTgtDim )\
    \ = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid target dimension: ' | pTgtDim;\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n# Validate Target\
    \ Hierarchy\nIf( Trim( pTgtHier ) @= '' );\n    pTgtHier = pTgtDim;\nElseIf( HierarchyExists(\
    \ pTgtDim, pTgtHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'The target Hierachy ' |\
    \ pTgtHier | ' does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pTgtSub ) @= '' );\n    nErrors = 1;\n  \
    \  sMessage = 'No target subset specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n\
    \    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Alias exists\nIf ( pAlias @<> '' &\
    \ \n    DimIx ( Expand ( '}ElementAttributes_%pTgtDim%' ), pAlias ) = 0\n);\n  nErrors =\
    \ 1;\n  sMessage = 'Alias does not exist in dimension %pTgtDim%.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;  \n\n# Validate alias attribute name is actually\
    \ an alias\nIf ( pAlias @<> '' & \n    Dtype ( Expand ( '}ElementAttributes_%pTgtDim%' ),\
    \ pAlias ) @<> 'AA'\n);\n  nErrors = 1;\n  sMessage = 'Attribute %pAlias% is not an alias\
    \ in dimension %pTgtDim%.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;  \n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create\
    \ Target Subset ###\nIf( HierarchySubsetExists( pTgtDim, pTgtHier, pTgtsub ) = 1 );\n  \
    \  HierarchySubsetDeleteAllElements( pTgtDim, pTgtHier, pTgtsub );\nElse;\n    HierarchySubsetCreate(\
    \ pTgtDim, pTgtHier, pTgtsub, pTemp );\nEndIf;\n\n### Set Alias ###\nIf ( pAlias @<> ''\
    \ );\n    If ( pTgtDim @= pTgtHier );\n        SubsetAliasSet( pTgtDim, pTgtsub, pAlias);\n\
    \    Else;\n        SubsetAliasSet( pTgtDim | ':' | pTgtHier, pTgtsub, pAlias);\n    EndIf;\n\
    EndIf;\n\n# HierarchySubsetMDXGet not returning anything. Thought it might also return alias\
    \ used in source subset\nsMDX = HierarchySubsetMDXGet(pSrcDim, pSrcHier, pSrcSub);\n\nnElementPosition\
    \ = 0;\n\n### Set data source for process ###\nDatasourceType              = 'SUBSET';\n\
    DatasourceNameForServer     = pSrcDim | ':' | pSrcHier;\nDatasourceDimensionSubset   = pSrcsub;\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \nIF( pTgtDim @= pSrcDim & pTgtHier @= pSrcHier);\n    nElementPosition = nElementPosition\
    \ + 1;\nElseIF( ElementIndex( pTgtDim, pTgtHier,vEle ) > 0 );\n    nElementPosition = nElementPosition\
    \ + 1;\nElse;\n    ItemReject( Expand( 'Cannot insert into subset. Element  %vEle% does\
    \ not exist in target dimension:Hierarchy %pTgtDim%:%pTgtHier%.' ) );\nEndIF;\n\nHierarchySubsetElementInsert(\
    \ pTgtDim , pTgtHier, pTgtSub , vEle , nElementPosition );\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned the %pTgtDim%:%pTgtHier%:%pTgtSub%\
    \ subset from %pSrcDim%:%pSrcHier%:%pSrcSub%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Develop an IBM Turbo Integrator process that copies a subset from a hierarchy in
    a source dimension to a hierarchy in a target dimension. Note that valid source dimension
    names (pSrcDim), source (pSrcSub), and target subsets (pTgtSub) are mandatory; otherwise,
    the process will abort. Make sure the target hierarchy cannot be `Leaves`. If the target
    dimension hierarchy exists, it will be overwritten.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will copy a subset from a Hierarchy in source\
    \ Dimension to a Hierarchy in target\n# Dimension.\n\n# Note:\n# Valid source dimension\
    \ name (pSrcDim), source (pSrcSub) and target subset (pTgtSub) are \n# mandatory otherwise\
    \ the process will abort.\n\n# Caution:\n# - Target hierarchy cannot be `Leaves`.\n# - If\
    \ the target dimension Hierarchy exists then it will be overwritten.\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters\
    \ pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%, pSrcSub:%pSrcSub%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%,\
    \ pTgtSub:%pTgtSub%, pTemp:%pTemp%, pAlias:%pAlias%.' ; \n\n## LogOutput parameters\nIF(\
    \ pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= '' );\n   \
    \ # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim )\
    \ + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim )\
    \ - 1 );\nEndIf;\n\n# Validate Source dimension\nIf( Trim( pSrcDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pSrcDim ) = 0 );\n    nErrors\
    \ = 1;\n    sMessage = 'Dimension ' | pSrcDim | ' does not exist.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Source Hierarchy\nIf( Trim( pSrcHier\
    \ ) @= '' );\n    pSrcHier = Trim( pSrcDim );\nEndIf;\n\nIf( HierarchyExists( pSrcDim ,\
    \ pSrcHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'The Hierachy ' | pSrcHier | ' does\
    \ not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate Source subset\nIf( Trim( pSrcsub ) @= '' );\n    nErrors = 1;\n    sMessage =\
    \ 'No source subset specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( HierarchySubsetExists( pSrcDim , pSrcHier, pSrcsub ) = 0 );\n    nErrors\
    \ = 1;\n    sMessage = 'Invalid source subset : ' | pSrcDim |':'| pSrcHier |':'| pSrcSub;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Scan( ':',\
    \ pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy has been passed as dimension. Handle\
    \ the input error by splitting dim:hier into dimension & hierarchy\n    pTgtHier       =\
    \ SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim        = SubSt(\
    \ pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n# Validate target dimension\nIf( Trim(\
    \ pTgtDim ) @= '' );\n    pTgtDim = Trim( pSrcDim );\nElseIf( DimensionExists( pTgtDim )\
    \ = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid target dimension: ' | pTgtDim;\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n# Validate Target\
    \ Hierarchy\nIf( Trim( pTgtHier ) @= '' );\n    pTgtHier = pTgtDim;\nElseIf( HierarchyExists(\
    \ pTgtDim, pTgtHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'The target Hierachy ' |\
    \ pTgtHier | ' does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pTgtSub ) @= '' );\n    nErrors = 1;\n  \
    \  sMessage = 'No target subset specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n\
    \    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Alias exists\nIf ( pAlias @<> '' &\
    \ \n    DimIx ( Expand ( '}ElementAttributes_%pTgtDim%' ), pAlias ) = 0\n);\n  nErrors =\
    \ 1;\n  sMessage = 'Alias does not exist in dimension %pTgtDim%.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;  \n\n# Validate alias attribute name is actually\
    \ an alias\nIf ( pAlias @<> '' & \n    Dtype ( Expand ( '}ElementAttributes_%pTgtDim%' ),\
    \ pAlias ) @<> 'AA'\n);\n  nErrors = 1;\n  sMessage = 'Attribute %pAlias% is not an alias\
    \ in dimension %pTgtDim%.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;  \n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create\
    \ Target Subset ###\nIf( HierarchySubsetExists( pTgtDim, pTgtHier, pTgtsub ) = 1 );\n  \
    \  HierarchySubsetDeleteAllElements( pTgtDim, pTgtHier, pTgtsub );\nElse;\n    HierarchySubsetCreate(\
    \ pTgtDim, pTgtHier, pTgtsub, pTemp );\nEndIf;\n\n### Set Alias ###\nIf ( pAlias @<> ''\
    \ );\n    If ( pTgtDim @= pTgtHier );\n        SubsetAliasSet( pTgtDim, pTgtsub, pAlias);\n\
    \    Else;\n        SubsetAliasSet( pTgtDim | ':' | pTgtHier, pTgtsub, pAlias);\n    EndIf;\n\
    EndIf;\n\n# HierarchySubsetMDXGet not returning anything. Thought it might also return alias\
    \ used in source subset\nsMDX = HierarchySubsetMDXGet(pSrcDim, pSrcHier, pSrcSub);\n\nnElementPosition\
    \ = 0;\n\n### Set data source for process ###\nDatasourceType              = 'SUBSET';\n\
    DatasourceNameForServer     = pSrcDim | ':' | pSrcHier;\nDatasourceDimensionSubset   = pSrcsub;\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \nIF( pTgtDim @= pSrcDim & pTgtHier @= pSrcHier);\n    nElementPosition = nElementPosition\
    \ + 1;\nElseIF( ElementIndex( pTgtDim, pTgtHier,vEle ) > 0 );\n    nElementPosition = nElementPosition\
    \ + 1;\nElse;\n    ItemReject( Expand( 'Cannot insert into subset. Element  %vEle% does\
    \ not exist in target dimension:Hierarchy %pTgtDim%:%pTgtHier%.' ) );\nEndIF;\n\nHierarchySubsetElementInsert(\
    \ pTgtDim , pTgtHier, pTgtSub , vEle , nElementPosition );\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned the %pTgtDim%:%pTgtHier%:%pTgtSub%\
    \ subset from %pSrcDim%:%pSrcHier%:%pSrcSub%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der einen statischen Teilmenge in
    einer Hierarchie einer Ziel-Dimension erstellt. Der Prozess sollte mehrere Parameter verwenden,
    um festzulegen, welche Elemente in die Teilmenge aufgenommen werden: - pConsol: Wenn angegeben,
    werden nur Elemente, die Nachkommen des Consol sind, in die Teilmenge aufgenommen. Wenn
    nicht, wird dieser Filter ignoriert. - pAttr: Wenn angegeben, werden nur Elemente mit einem
    Wert, der pAttrValue entspricht, in die Teilmenge aufgenommen. Wenn nicht, wird dieser Filter
    ignoriert. - pLevelFrom: Nur Elemente mit einem Level größer oder gleich pLevelFrom werden
    in die Teilmenge aufgenommen. - pLevelTo: Nur Elemente mit einem Level kleiner oder gleich
    pLevelTo werden in die Teilmenge aufgenommen. - pExclusions: Wenn pExclusions angegeben
    ist, werden die Elemente (getrennt durch einen Trennzeichensatz) von der Teilmenge ausgeschlossen.
    Wildcard-Zeichen ''*'' und ''?'' werden akzeptiert. - pAddToSubset: Wenn die angegebene
    Teilmenge bereits existiert, wird dieser Parameter steuern, ob Elemente der bestehenden
    Teilmenge hinzugefügt werden (Wert 1) oder eine neue Teilmenge erstellt wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Start Prolog ###\n\n#Region @DOC\n# Description:\n# This process will create a static\
    \ subset in a Hierarchy of target Dimension.\n\n# Note:\n# This process uses a number of\
    \ parameters to determine what to include in the subset:\n# - pConsol: If specified, only\
    \ elements that are descendants of the consol will be included in\n#   the subset. If blank,\
    \ then this filter will be ignored.\n# - pAttr: If specified, only elements that have a\
    \ value equivalent to pAttrValue will be included\n#   in the subset. If blank, this filter\
    \ will be ignored.\n# - pLevelFrom: Only elements with a level greater than or equal to\
    \ pLevelFrom will be included in\n#   the subset.\n# - pLevelTo: Only elements with a level\
    \ less than or equal to pLevelFrom will be included in the\n#   subset.\n# - pExclusions:\
    \ If pExclusions is specified then the elements (separated by a delimiter) will be\n#  \
    \ excluded from the subset. Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset\
    \ : If the specified subset already exists then this parameter will control whether\n# \
    \  elements will be added to the existing subset (value 1) or a new subset will be created\n\
    #   (value 0).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pConsol:%pConsol%, pAttr:%pAttr%, pAttrValue:%pAttrValue%,\
    \ pLevelFrom:%pLevelFrom%, pLevelTo:%pLevelTo%, pExclusions:%pExclusions%, pDelim:%pDelim%,\
    \ pAddToSubset:%pAddToSubset%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       =\
    \ '}ElementAttributes_' | pDim;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n   \
    \ LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors\
    \ = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim       \
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n## Validate dimension\nIF( Trim(\
    \ pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( DimensionExists( pDim ) = 0 );\n\
    \    nErrors = 1;\n    sMessage = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIf( Trim( pHier ) @= ''\
    \ );\n    sHier = pDim;\nElse;\n    sHier = pHier;\nEndIf;\nIF( sHier @= 'Leaves' );\n \
    \   nErrors = 1;\n    sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF(HierarchyExists(pDim, sHier ) =\
    \ 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate subset\n\
    IF(Trim( pSub ) @= '' );\n    nErrors = 1;\n    sMessage = 'No subset specified.';\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate consolidation\n\
    pConsol = Trim( pConsol );\nIf( pConsol @<> '' & pConsol @<> '*' );\n    If( ElementIndex\
    \ ( pDim, sHier, pConsol ) = 0 );\n        nErrors = 1;\n        sMessage = 'The ' | pConsol\
    \ | ' consolidation does not exist in the '| pDim |' dimension:Hierarchy ' | pDim |':'|\
    \ sHier;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\n\
    EndIf;\n\n## Validate attribute\npAttr = Trim( pAttr );\nIF(pAttr @<> '' );\n\n    If( DimensionExists(\
    \ cAttributeDim ) = 0 );\n        nErrors = 1;\n        sMessage = 'Dimension: ' | pDim\
    \ | ' does not have any attributes.';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\n    \n    IF(DIMIX( cAttributeDim, pAttr ) = 0 );\n        nErrors =\
    \ 1;\n        sMessage = 'The ' | pAttr |' attribute does not exist in the ' | pDim | '\
    \ dimension.';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\n\
    \    \n    sAttributeType = DType( cAttributeDim, pAttr );\n    If(sAttributeType @= 'AN'\
    \ % sAttributeType @= 'N' );\n        If(pAttrValue @= '' );\n            nAttributeValue\
    \ = 0;\n        Else;\n            nAttributeValue = StringToNumber( pAttrValue );\n   \
    \     EndIf;\n    EndIf;\n    \nEndIf;\n\n## Validate element level parameters\nIf(pLevelFrom\
    \ < 0 % pLevelTo < 0 % pLevelTo < pLevelFrom );\n    nErrors = 1;\n    sMessage = 'Element\
    \ levels must be greater than or equal to zero and level to must be greater than or equal\
    \ to level from';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate delimiter\nIF( pExclusions @<> '' & pDelim @= '' );\n    ## Set to default\
    \ parameter.\n    pDelimiter = '&';\nEndIf;\n\n## Validate add to subset\nIF( pAddToSubset\
    \ <> 0 & pAddToSubset <> 1 );\n    nErrors = 1;\n    sMessage = 'Invalid value for pAddToSubset:\
    \ ' | NumberToString( pAddToSubset ) | '. Valid values are 0 and 1';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Alias\nsDimAttr = '}ElementAttributes_'\
    \ | pDim;\nIF( pAlias @<> '' );\n    \n    IF(DimensionExists( sDimAttr ) = 0 );\n     \
    \   sMessage = 'No attributes exist for the dimension: ' | pDim;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        pAlias = '';\n    ElseIf(DIMIX( sDimAttr, pAlias\
    \ ) = 0 );\n        sMessage = 'The alias: ' | pAlias | ' does not exist as an attribute\
    \ in the dimension: ' | pDim;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        pAlias = '';\n    ElseIf(DTYPE( sDimAttr, pAlias ) @<> 'AA' );\n       \
    \ sMessage = 'The alias: ' | pAlias | ' is not an Alias type of attribute in the dimension:\
    \ ' | sDimAttr;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    \
    \    pAlias = '';\n    EndIf;\n\nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors\
    \ before preparing subset\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n   \
    \   ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Prepare subset\
    \ ###\nIF( HierarchySubsetExists( pDim,sHier, pSub ) = 1 );\n    If( pAddtoSubset <> 1 );\n\
    \        HierarchySubsetDeleteAllElements( pDim, sHier, pSub );\n        nSubsetSize = 0;\n\
    \    Else;\n        nSubsetSize = HierarchySubsetGetSize(pDim, sHier, pSub );\n    EndIf;\n\
    Else;\n    HierarchySubsetCreate( pDim, sHier, pSub, pTemp );\n    nSubsetSize = 0;\nEndIf;\n\
    \n### Set Alias ###\nIF(pAlias @<> '' );\n      HierarchySubsetAliasSet( pDim, pHier, pSub,\
    \ pAlias);\nENDIF;\n\n### Assign Datasource ###\n\nDatasourceNameForServer     = pDim|':'|sHier;\n\
    DataSourceDimensionSubset   = 'All';\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Check for errors in\
    \ prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n\n### Add elements to subset ###\n\
    \n## Check that element is a descendant of specified consolidation\nIf( pConsol @<> '' &\
    \ pConsol @<> '*' );\n  If(ElementIsAncestor(pDim, pHier, pConsol, vEle) = 0 & vEle @<>\
    \ pConsol );\n    ItemSkip;\n  EndIf;\nEndIf;\n\n## Check that element has a matching attribute\
    \ value\nIf( pAttr @<> ''  );\n  If( sAttributeType @= 'AN' % sAttributeType @= 'N' );\n\
    \    If( ElementAttrN( pDim, pHier, vEle, pAttr ) <> nAttributeValue );\n      ItemSkip;\n\
    \    EndIf;\n  Else;\n    If( ElementAttrS( pDim, pHier, vEle, pAttr ) @<> pAttrValue );\n\
    \      ItemSkip;\n    EndIf;\n  EndIf;\nEndIf;\n\n## Check that element has an appropriate\
    \ element level\nnElementLevel = ElementLevel( pDim, pHier, vEle );\nIf( nElementLevel <\
    \ pLevelFrom % nElementLevel > pLevelTo );\n  ItemSkip;\nEndIf;\n\n## Add element to subset\n\
    nSubsetSize = nSubsetSize + 1;\n\nHierarchySubsetElementInsert( pDim, pHier, pSub, vEle,\
    \ nSubsetSize );\n\n### End Metadata ###\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\n    ###\
    \ Process Exclusions ###\n    IF( nErrors = 0 & Trim( pExclusions ) @<> '' );\n        ExecuteProcess(\
    \ '}bedrock.hier.sub.exclude',\n            'pLogOutput', pLogOutput,\n            'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n            'pDim', pDim,\n            'pHier', pHier,\n      \
    \      'pSub', pSub,\n            'pExclusions', pExclusions,\n            'pDelim', pDelim\n\
    \            );\n    EndIf;\n    \n    ### Get subset size ###\n    nSubSiz = SubsetGetSize(\
    \ pDim|':'|sHier, pSub );\n    sSubSiz = NumberToString( nSubSiz );\n    If( nSubSiz = 0\
    \ );\n        nErrors = 1;\n        sMessage= 'Subset contains no elements.';\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n    \n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% created subset %pDim%:%pHier%:%pSub%\
    \ with %sSubSiz% elements. ' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in a hierarchy
    of a target dimension. The process should use several parameters to determine what elements
    to include in the subset: - pConsol: If specified, only elements that are descendants of
    the consol will be included in the subset. If blank, this filter will be ignored. - pAttr:
    If specified, only elements that have a value equivalent to pAttrValue will be included
    in the subset. If blank, this filter will be ignored. - pLevelFrom: Only elements with a
    level greater than or equal to pLevelFrom will be included in the subset. - pLevelTo: Only
    elements with a level less than or equal to pLevelTo will be included in the subset. - pExclusions:
    If pExclusions is specified, the elements (separated by a delimiter) will be excluded from
    the subset. Wildcards characters ''*'' and ''?'' are accepted. - pAddToSubset: If the specified
    subset already exists, this parameter will control whether elements are added to the existing
    subset (value 1) or a new subset is created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Start Prolog ###\n\n#Region @DOC\n# Description:\n# This process will create a static\
    \ subset in a Hierarchy of target Dimension.\n\n# Note:\n# This process uses a number of\
    \ parameters to determine what to include in the subset:\n# - pConsol: If specified, only\
    \ elements that are descendants of the consol will be included in\n#   the subset. If blank,\
    \ then this filter will be ignored.\n# - pAttr: If specified, only elements that have a\
    \ value equivalent to pAttrValue will be included\n#   in the subset. If blank, this filter\
    \ will be ignored.\n# - pLevelFrom: Only elements with a level greater than or equal to\
    \ pLevelFrom will be included in\n#   the subset.\n# - pLevelTo: Only elements with a level\
    \ less than or equal to pLevelFrom will be included in the\n#   subset.\n# - pExclusions:\
    \ If pExclusions is specified then the elements (separated by a delimiter) will be\n#  \
    \ excluded from the subset. Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset\
    \ : If the specified subset already exists then this parameter will control whether\n# \
    \  elements will be added to the existing subset (value 1) or a new subset will be created\n\
    #   (value 0).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pConsol:%pConsol%, pAttr:%pAttr%, pAttrValue:%pAttrValue%,\
    \ pLevelFrom:%pLevelFrom%, pLevelTo:%pLevelTo%, pExclusions:%pExclusions%, pDelim:%pDelim%,\
    \ pAddToSubset:%pAddToSubset%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       =\
    \ '}ElementAttributes_' | pDim;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n   \
    \ LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors\
    \ = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim       \
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n## Validate dimension\nIF( Trim(\
    \ pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( DimensionExists( pDim ) = 0 );\n\
    \    nErrors = 1;\n    sMessage = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIf( Trim( pHier ) @= ''\
    \ );\n    sHier = pDim;\nElse;\n    sHier = pHier;\nEndIf;\nIF( sHier @= 'Leaves' );\n \
    \   nErrors = 1;\n    sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF(HierarchyExists(pDim, sHier ) =\
    \ 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate subset\n\
    IF(Trim( pSub ) @= '' );\n    nErrors = 1;\n    sMessage = 'No subset specified.';\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate consolidation\n\
    pConsol = Trim( pConsol );\nIf( pConsol @<> '' & pConsol @<> '*' );\n    If( ElementIndex\
    \ ( pDim, sHier, pConsol ) = 0 );\n        nErrors = 1;\n        sMessage = 'The ' | pConsol\
    \ | ' consolidation does not exist in the '| pDim |' dimension:Hierarchy ' | pDim |':'|\
    \ sHier;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\n\
    EndIf;\n\n## Validate attribute\npAttr = Trim( pAttr );\nIF(pAttr @<> '' );\n\n    If( DimensionExists(\
    \ cAttributeDim ) = 0 );\n        nErrors = 1;\n        sMessage = 'Dimension: ' | pDim\
    \ | ' does not have any attributes.';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\n    \n    IF(DIMIX( cAttributeDim, pAttr ) = 0 );\n        nErrors =\
    \ 1;\n        sMessage = 'The ' | pAttr |' attribute does not exist in the ' | pDim | '\
    \ dimension.';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\n\
    \    \n    sAttributeType = DType( cAttributeDim, pAttr );\n    If(sAttributeType @= 'AN'\
    \ % sAttributeType @= 'N' );\n        If(pAttrValue @= '' );\n            nAttributeValue\
    \ = 0;\n        Else;\n            nAttributeValue = StringToNumber( pAttrValue );\n   \
    \     EndIf;\n    EndIf;\n    \nEndIf;\n\n## Validate element level parameters\nIf(pLevelFrom\
    \ < 0 % pLevelTo < 0 % pLevelTo < pLevelFrom );\n    nErrors = 1;\n    sMessage = 'Element\
    \ levels must be greater than or equal to zero and level to must be greater than or equal\
    \ to level from';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate delimiter\nIF( pExclusions @<> '' & pDelim @= '' );\n    ## Set to default\
    \ parameter.\n    pDelimiter = '&';\nEndIf;\n\n## Validate add to subset\nIF( pAddToSubset\
    \ <> 0 & pAddToSubset <> 1 );\n    nErrors = 1;\n    sMessage = 'Invalid value for pAddToSubset:\
    \ ' | NumberToString( pAddToSubset ) | '. Valid values are 0 and 1';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Alias\nsDimAttr = '}ElementAttributes_'\
    \ | pDim;\nIF( pAlias @<> '' );\n    \n    IF(DimensionExists( sDimAttr ) = 0 );\n     \
    \   sMessage = 'No attributes exist for the dimension: ' | pDim;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        pAlias = '';\n    ElseIf(DIMIX( sDimAttr, pAlias\
    \ ) = 0 );\n        sMessage = 'The alias: ' | pAlias | ' does not exist as an attribute\
    \ in the dimension: ' | pDim;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        pAlias = '';\n    ElseIf(DTYPE( sDimAttr, pAlias ) @<> 'AA' );\n       \
    \ sMessage = 'The alias: ' | pAlias | ' is not an Alias type of attribute in the dimension:\
    \ ' | sDimAttr;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    \
    \    pAlias = '';\n    EndIf;\n\nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors\
    \ before preparing subset\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n   \
    \   ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Prepare subset\
    \ ###\nIF( HierarchySubsetExists( pDim,sHier, pSub ) = 1 );\n    If( pAddtoSubset <> 1 );\n\
    \        HierarchySubsetDeleteAllElements( pDim, sHier, pSub );\n        nSubsetSize = 0;\n\
    \    Else;\n        nSubsetSize = HierarchySubsetGetSize(pDim, sHier, pSub );\n    EndIf;\n\
    Else;\n    HierarchySubsetCreate( pDim, sHier, pSub, pTemp );\n    nSubsetSize = 0;\nEndIf;\n\
    \n### Set Alias ###\nIF(pAlias @<> '' );\n      HierarchySubsetAliasSet( pDim, pHier, pSub,\
    \ pAlias);\nENDIF;\n\n### Assign Datasource ###\n\nDatasourceNameForServer     = pDim|':'|sHier;\n\
    DataSourceDimensionSubset   = 'All';\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Check for errors in\
    \ prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n\n### Add elements to subset ###\n\
    \n## Check that element is a descendant of specified consolidation\nIf( pConsol @<> '' &\
    \ pConsol @<> '*' );\n  If(ElementIsAncestor(pDim, pHier, pConsol, vEle) = 0 & vEle @<>\
    \ pConsol );\n    ItemSkip;\n  EndIf;\nEndIf;\n\n## Check that element has a matching attribute\
    \ value\nIf( pAttr @<> ''  );\n  If( sAttributeType @= 'AN' % sAttributeType @= 'N' );\n\
    \    If( ElementAttrN( pDim, pHier, vEle, pAttr ) <> nAttributeValue );\n      ItemSkip;\n\
    \    EndIf;\n  Else;\n    If( ElementAttrS( pDim, pHier, vEle, pAttr ) @<> pAttrValue );\n\
    \      ItemSkip;\n    EndIf;\n  EndIf;\nEndIf;\n\n## Check that element has an appropriate\
    \ element level\nnElementLevel = ElementLevel( pDim, pHier, vEle );\nIf( nElementLevel <\
    \ pLevelFrom % nElementLevel > pLevelTo );\n  ItemSkip;\nEndIf;\n\n## Add element to subset\n\
    nSubsetSize = nSubsetSize + 1;\n\nHierarchySubsetElementInsert( pDim, pHier, pSub, vEle,\
    \ nSubsetSize );\n\n### End Metadata ###\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\n    ###\
    \ Process Exclusions ###\n    IF( nErrors = 0 & Trim( pExclusions ) @<> '' );\n        ExecuteProcess(\
    \ '}bedrock.hier.sub.exclude',\n            'pLogOutput', pLogOutput,\n            'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n            'pDim', pDim,\n            'pHier', pHier,\n      \
    \      'pSub', pSub,\n            'pExclusions', pExclusions,\n            'pDelim', pDelim\n\
    \            );\n    EndIf;\n    \n    ### Get subset size ###\n    nSubSiz = SubsetGetSize(\
    \ pDim|':'|sHier, pSub );\n    sSubSiz = NumberToString( nSubSiz );\n    If( nSubSiz = 0\
    \ );\n        nErrors = 1;\n        sMessage= 'Subset contains no elements.';\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n    \n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% created subset %pDim%:%pHier%:%pSub%\
    \ with %sSubSiz% elements. ' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, um eine statische Untergruppe in
    der Hierarchie einer Dimension zu erstellen, die aus allen Elementen besteht. Verwenden
    Sie die folgenden Änderungsparameter, um zu bestimmen, was in die Untergruppe aufgenommen
    werden soll: - pExclusions: Wenn pExclusions angegeben ist, werden die Elemente (durch ein
    Trennzeichen getrennt) aus der Untergruppe ausgeschlossen. Die Platzhalterzeichen ''*''
    und ''?'' sind zulässig. - pAddToSubset: Wenn die angegebene Untergruppe bereits existiert,
    steuert dieser Parameter, ob Elemente zur vorhandenen Untergruppe hinzugefügt werden (Wert
    1) oder eine neue Untergruppe erstellt wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy\
    \ of a Dimension that consists of all elements.\n\n# Note:\n# This process uses modification\
    \ parameters to determine what to include in the subset:\n# - pExclusions: If pExclusions\
    \ is specified then the elements (separated by a delimiter) will be\n#                excluded\
    \ from the subset. Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset: If\
    \ the specified subset already exists then this parameter will control whether elements\
    \ will\n#                 be added to the existing subset (value 1) or a new subset will\
    \ be created (value 0).\n#EndRegion @DOC\n\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pAddToSubset:%pAddToSubset%, pExclusions:%pExclusions%,\
    \ pDelim:%pDelim%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_'\
    \ | pDim;\nnErrors = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n\
    \    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n\
    \                              'pStrictErrorHandling', pStrictErrorHandling,\n         \
    \                     'pDim', pDim,\n                              'pHier',pHier,\n    \
    \                          'pSub', pSub,\n                              'pExclusions', pExclusions,\n\
    \                              'pDelim', pDelim,\n                              'pAddToSubset',\
    \ pAddToSubset,\n                              'pAlias', pAlias,\n                     \
    \         'pTemp', pTemp\n                            );\n\nIf(nRet <> 0);\n nErrors = 1;\n\
    \ sMessage = 'Subset create process has errors';\n LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### If errors occurred terminate process with a major\
    \ error status ###\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process to create a static subset in the hierarchy
    of a dimension that consists of all elements. Use the following modification parameters
    to determine what to include in the subset: - pExclusions: If pExclusions is specified,
    the elements (separated by a delimiter) will be excluded from the subset. Wildcard characters
    ''*'' and ''?'' are accepted. - pAddToSubset: If the specified subset already exists, this
    parameter will control whether elements will be added to the existing subset (value 1) or
    a new subset will be created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy\
    \ of a Dimension that consists of all elements.\n\n# Note:\n# This process uses modification\
    \ parameters to determine what to include in the subset:\n# - pExclusions: If pExclusions\
    \ is specified then the elements (separated by a delimiter) will be\n#                excluded\
    \ from the subset. Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset: If\
    \ the specified subset already exists then this parameter will control whether elements\
    \ will\n#                 be added to the existing subset (value 1) or a new subset will\
    \ be created (value 0).\n#EndRegion @DOC\n\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pAddToSubset:%pAddToSubset%, pExclusions:%pExclusions%,\
    \ pDelim:%pDelim%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_'\
    \ | pDim;\nnErrors = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n\
    \    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n\
    \                              'pStrictErrorHandling', pStrictErrorHandling,\n         \
    \                     'pDim', pDim,\n                              'pHier',pHier,\n    \
    \                          'pSub', pSub,\n                              'pExclusions', pExclusions,\n\
    \                              'pDelim', pDelim,\n                              'pAddToSubset',\
    \ pAddToSubset,\n                              'pAlias', pAlias,\n                     \
    \         'pTemp', pTemp\n                            );\n\nIf(nRet <> 0);\n nErrors = 1;\n\
    \ sMessage = 'Subset create process has errors';\n LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### If errors occurred terminate process with a major\
    \ error status ###\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine statische Teilmenge in der
    Hierarchie einer Dimension erstellt, die aus allen Elementen mit einem pAttr Attributwert
    besteht, der dem pAttrValue entspricht. Beachte, dass dieser Prozess folgende Anpassungsparameter
    verwendet, um zu bestimmen, was in die Teilmenge aufgenommen wird: pAttr: Wenn angegeben,
    werden nur Elemente mit einem Wert, der pAttrValue entspricht, in die Teilmenge aufgenommen.
    Wenn leer, wird dieser Filter ignoriert. pExclusions: Wenn pExclusions angegeben ist, werden
    die Elemente (durch ein Trennzeichen getrennt) von der Teilmenge ausgeschlossen. Platzhalterzeichen
    `*` und `?` werden akzeptiert. pAddToSubset: Wenn die angegebene Teilmenge bereits existiert,
    bestimmt dieser Parameter, ob Elemente zur bestehenden Teilmenge hinzugefügt (Wert 1) oder
    eine neue Teilmenge erstellt wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy\
    \ of a Dimension that consists of all\n# elements with pAttr attribute value equivalent\
    \ to pAttrValue.\n\n# Note:\n# This process uses a modification parameters to determine\
    \ what to include in the subset:\n# - pAttr: If specified, only elements that have a value\
    \ equivalent to pAttrValue will be included\n#          in the subset. If blank, this filter\
    \ will be ignored.\n# - pExclusions: If pExclusions is specified then the elements (separated\
    \ by a delimiter) will be\n#                excluded from the subset. Wildcards characters\
    \ `*` and `?` are accepted.\n# - pAddToSubset: If the specified subset already exists then\
    \ this parameter will control whether elements will\n#                 be added to the existing\
    \ subset (value 1) or a new subset will be created (value 0).\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%,\
    \ pAttr:%pAttr%, pAttrValue:%pAttrValue%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\
    nErrors = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors\
    \ = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n\
    \                            'pStrictErrorHandling', pStrictErrorHandling,\n           \
    \                 'pDim', pDim,\n                            'pHier', pHier,\n         \
    \                   'pSub', pSub,\n                            'pAttr', pAttr,\n       \
    \                     'pAttrValue', pAttrValue,\n                            'pExclusions',\
    \ pExclusions,\n                            'pDelim', pDelim,\n                        \
    \    'pAddToSubset', pAddToSubset,\n                            'pAlias', pAlias,\n    \
    \                        'pTemp', pTemp\n                            );\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in the hierarchy
    of a dimension composed of all elements with a pAttr attribute value equivalent to pAttrValue.
    Note that this process uses the following modification parameters to determine what to include
    in the subset: pAttr: If specified, only elements that have a value equivalent to pAttrValue
    will be included in the subset. If blank, this filter will be ignored. pExclusions: If pExclusions
    is specified, the elements (separated by a delimiter) will be excluded from the subset.
    Wildcard characters `*` and `?` are accepted. pAddToSubset: If the specified subset already
    exists, this parameter will control whether elements will be added to the existing subset
    (value 1) or a new subset will be created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy\
    \ of a Dimension that consists of all\n# elements with pAttr attribute value equivalent\
    \ to pAttrValue.\n\n# Note:\n# This process uses a modification parameters to determine\
    \ what to include in the subset:\n# - pAttr: If specified, only elements that have a value\
    \ equivalent to pAttrValue will be included\n#          in the subset. If blank, this filter\
    \ will be ignored.\n# - pExclusions: If pExclusions is specified then the elements (separated\
    \ by a delimiter) will be\n#                excluded from the subset. Wildcards characters\
    \ `*` and `?` are accepted.\n# - pAddToSubset: If the specified subset already exists then\
    \ this parameter will control whether elements will\n#                 be added to the existing\
    \ subset (value 1) or a new subset will be created (value 0).\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%,\
    \ pAttr:%pAttr%, pAttrValue:%pAttrValue%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\
    nErrors = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors\
    \ = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n\
    \                            'pStrictErrorHandling', pStrictErrorHandling,\n           \
    \                 'pDim', pDim,\n                            'pHier', pHier,\n         \
    \                   'pSub', pSub,\n                            'pAttr', pAttr,\n       \
    \                     'pAttrValue', pAttrValue,\n                            'pExclusions',\
    \ pExclusions,\n                            'pDelim', pDelim,\n                        \
    \    'pAddToSubset', pAddToSubset,\n                            'pAlias', pAlias,\n    \
    \                        'pTemp', pTemp\n                            );\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der einen statischen Teilbaum in
    der Hierarchie einer Dimension erstellt, der aus allen Blattelementen besteht, die den Attributwert
    von pAttr haben, der mit dem Wert pAttrValue übereinstimmt. Beachte, dass dieser Prozess
    Modifikationsparameter verwendet, um zu bestimmen, welche Elemente in den Teilbaum aufgenommen
    werden. Diese Parameter sind: pAttr, der lediglich Elemente einbezieht, deren Attributwert
    mit pAttrValue übereinstimmt, es sei denn, pAttr ist leer. pExclusions, das spezifizierte
    Elemente (durch ein Trennzeichen getrennt) aus dem Teilbaum ausschließt, wobei auch Platzhalter
    wie ''*'' und ''?'' genutzt werden können. pAddToSubset, das steuert, ob Elemente zu einem
    bestehenden Teilbaum hinzugefügt werden, falls dieser bereits existiert (Wert 1) oder ob
    ein neuer Teilbaum erstellt wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy\
    \ of a Dimension that consists of all\n# leaf elements with pAttr attribute value equivalent\
    \ to pAttrValue.\n\n# Note:\n# This process uses a modification parameters to determine\
    \ what to include in the subset:\n# - pAttr: If specified, only elements that have a value\
    \ equivalent to pAttrValue will be included\n#          in the subset. If blank, this filter\
    \ will be ignored.\n# - pExclusions: If pExclusions is specified then the elements (separated\
    \ by a delimiter) will be\n#                excluded from the subset. Wildcards characters\
    \ `*` and `?` are accepted.\n# - pAddToSubset: If the specified subset already exists then\
    \ this parameter will control whether elements will\n#                 be added to the existing\
    \ subset (value 1) or a new subset will be created (value 0).\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\nnErrors = 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\n\
    cUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s'\
    \ );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          \
    \  = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%,\
    \ pSub:%pSub%, pAttr:%pAttr%, pAttrValue:%pAttrValue%, pExclusions:%pExclusions%, pDelim:%pDelim%,\
    \ pAddToSubset:%pAddToSubset%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       =\
    \ '}ElementAttributes_' | pDim;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n   \
    \ LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n\
    \                              'pStrictErrorHandling', pStrictErrorHandling,\n         \
    \                     'pDim', pDim,\n                              'pHier', pHier,\n   \
    \                           'pSub', pSub,\n                              'pAttr', pAttr,\n\
    \                              'pAttrValue', pAttrValue,\n                             \
    \ 'pLevelFrom', 0,\n                              'pLevelTo', 0,\n                     \
    \         'pExclusions', pExclusions,\n                              'pDelim', pDelim,\n\
    \                              'pAddToSubset', pAddToSubset,\n                         \
    \     'pAlias', pAlias,\n                              'pTemp', pTemp\n                \
    \            );\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in the hierarchy
    of a dimension consisting of all leaf elements with an attribute value of pAttr that matches
    pAttrValue. Note that this process uses modification parameters to determine which elements
    to include in the subset. These parameters are: pAttr, which only includes elements with
    an attribute value equivalent to pAttrValue, unless pAttr is blank. pExclusions, which excludes
    specified elements (separated by a delimiter) from the subset, also accepting wildcard characters
    ''*'' and ''?''. pAddToSubset, which controls whether elements are added to an existing
    subset if it already exists (value 1) or if a new subset is created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy\
    \ of a Dimension that consists of all\n# leaf elements with pAttr attribute value equivalent\
    \ to pAttrValue.\n\n# Note:\n# This process uses a modification parameters to determine\
    \ what to include in the subset:\n# - pAttr: If specified, only elements that have a value\
    \ equivalent to pAttrValue will be included\n#          in the subset. If blank, this filter\
    \ will be ignored.\n# - pExclusions: If pExclusions is specified then the elements (separated\
    \ by a delimiter) will be\n#                excluded from the subset. Wildcards characters\
    \ `*` and `?` are accepted.\n# - pAddToSubset: If the specified subset already exists then\
    \ this parameter will control whether elements will\n#                 be added to the existing\
    \ subset (value 1) or a new subset will be created (value 0).\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\nnErrors = 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\n\
    cUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s'\
    \ );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          \
    \  = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%,\
    \ pSub:%pSub%, pAttr:%pAttr%, pAttrValue:%pAttrValue%, pExclusions:%pExclusions%, pDelim:%pDelim%,\
    \ pAddToSubset:%pAddToSubset%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       =\
    \ '}ElementAttributes_' | pDim;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n   \
    \ LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n\
    \                              'pStrictErrorHandling', pStrictErrorHandling,\n         \
    \                     'pDim', pDim,\n                              'pHier', pHier,\n   \
    \                           'pSub', pSub,\n                              'pAttr', pAttr,\n\
    \                              'pAttrValue', pAttrValue,\n                             \
    \ 'pLevelFrom', 0,\n                              'pLevelTo', 0,\n                     \
    \         'pExclusions', pExclusions,\n                              'pDelim', pDelim,\n\
    \                              'pAddToSubset', pAddToSubset,\n                         \
    \     'pAlias', pAlias,\n                              'pTemp', pTemp\n                \
    \            );\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der ein statisches Teilset in einer
    Hierarchie der Zieldimension basierend auf einer Liste bereitgestellter Elemente erstellt.
    Beachte dabei: - pAddToSubset: Wenn das angegebene Teilset bereits existiert, steuert dieser
    Parameter, ob Elemente dem bestehenden Teilset hinzugefügt werden (Wert 1) oder ob ein neues
    Teilset erstellt wird (Wert 0). - pExpandConsol: Wenn die angegebene Liste von Elementen
    konsolidierte Elemente enthält, werden sie durch ihre Nachkommata auf Blattebene ersetzt.
    Achtung: Der Prozess akzeptiert keine Platzhalter in Elementnamen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy\
    \ of target Dimension based on a list of\n# supplied elements.\n\n# Note:\n# - pAddToSubset:\
    \ If the specified subset already exists then this parameter will control whether elements\
    \ will\n#                 be added to the existing subset (value 1) or a new subset will\
    \ be created (value 0).\n# - pExpandConsol: If the specified list of elements contains consolidated\
    \ elements they will be replaced with \n#                 their leaf level descendants\n\
    # Caution: Process doesn't accept wildcards in element names.\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%,\
    \ pEle:%pEle%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%, pExpandConsol:%pExpandConsol%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\
    \n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n\n### Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim\
    \ ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim,\
    \ Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\n# Validate dimension\n\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n\
    \  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \ dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n## Validate Hierarchy\n\nIF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\n\
    EndIf;\n\nIF(HierarchyExists(pDim, pHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \ dimension Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pSub ) @= '' );\n  nErrors = 1;\n  sMessage\
    \ = 'No subset specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate elements\nIf( Trim( pEle ) @= '' );\n  nErrors = 1;\n  sMessage = 'No\
    \ elements specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate delimiter\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# Validate add to\
    \ subset\nIf( pAddToSubset <> 0 & pAddToSubset <> 1 );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \ value for pAddToSubset: ' | NumberToString( pAddToSubset ) | '. Valid values are 0 and\
    \ 1';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ expand consolidations\nIf( pExpandConsol <> 0 & pExpandConsol <> 1 & pExpandConsol <>\
    \ 2 );\n  nErrors = 1;\n  sMessage = 'Invalid value for pExpandConsol: ' | NumberToString(\
    \ pExpandConsol ) | '. Valid values are 0, 1 and 2';\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n## Validate Alias\nsDimAttr = '}ElementAttributes_' |\
    \ pDim;\nIF(pAlias @<> '' );\n  IF(DimensionExists( sDimAttr ) = 0 );\n    sMessage = 'No\
    \ attributes exist for the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n  IF(DIMIX(\
    \ sDimAttr, pAlias ) = 0 );\n    sMessage = 'The Alias: ' | pAlias | ' does not exist in\
    \ the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n  IF(\n  DTYPE( sDimAttr, pAlias\
    \ ) @<> 'AA' );\n    sMessage = 'The Alias: ' | pAlias | ' is not an Alias in the dimension:\
    \ ' | sDimAttr;\n    pAlias = '';\n  EndIf;\nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0\
    \ & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0\
    \ or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Prepare subset ###\nIf( HierarchySubsetExists( pDim, pHier, pSub ) = 1 );\n  If( pAddtoSubset\
    \ <> 1 );\n    HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\n    nSubsetSize =\
    \ 0;\n  Else;\n    nSubsetSize = HierarchySubsetGetSize( pDim, pHier, pSub );\n  EndIf;\n\
    Else;\n  If( nErrors = 0 );\n    HierarchySubsetCreate( pDim, pHier, pSub, pTemp );\n  EndIf;\n\
    \  nSubsetSize = 0;\nEndIf;\n\n### Assign Alias to subset\nIF(pAlias @<> '' );\n  HierarchySubsetAliasSet(\
    \ pDim, pHier, pSub, pAlias );\nENDIF;\n\n### Insert elements ###\n\nnSubsetIndex = 1;\n\
    sElements = pEle;\nnDelimIndex = 1;\n\n# Split filter into seperate dimensions\nWhile( nDelimIndex\
    \ <> 0 & Long( sElements ) > 0 );\n\n  nDelimIndex = Scan( pDelim, sElements );\n  If( nDelimIndex\
    \ <> 0 );\n    sElement = Trim( SubSt( sElements, 1, nDelimIndex - 1 ) );\n    sElements\
    \ = Trim( SubSt( sElements, nDelimIndex + Long( pDelim ), Long( sElements ) ) );\n  Else;\n\
    \    sElement = Trim( sElements );\n  EndIf;\n\n  If( ElementIndex( pDim, pHier, sElement\
    \ ) <> 0 );\n    If( nErrors = 0 );\n      IF(ElementLevel( pDim, pHier, sElement) > 0);\n\
    \        If( pExpandConsol = 1 );\n          ExecuteProcess('}bedrock.hier.sub.create',\n\
    \                         'pStrictErrorHandling', pStrictErrorHandling,\n              \
    \           'pDim', pDim,\n                         'pHier',pHier,\n                   \
    \      'pSub', pSub,\n                         'pConsol', sElement,\n                  \
    \       'pExclusions', '',\n                         'pDelim', pDelim,\n               \
    \          'pAddToSubset', 1,\n                         'pAlias', '',\n                \
    \         'pTemp', pTemp\n                        );\n        ElseIf( pExpandConsol = 2\
    \ );\n          ExecuteProcess('}bedrock.hier.sub.create',\n                         'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n                         'pDim', pDim,\n                      \
    \   'pHier',pHier,\n                         'pSub', pSub,\n                         'pConsol',\
    \ sElement,\n                         'pLevelFrom', 0,\n                         'pLevelTo',\
    \ 0,\n                         'pExclusions', '',\n                         'pDelim', pDelim,\n\
    \                         'pAddToSubset', 1,\n                         'pAlias', '',\n \
    \                        'pTemp', pTemp\n                        );\n        Else;\n   \
    \       HierarchySubsetElementInsert( pDim, pHIer, pSub, sElement, nSubsetIndex );\n   \
    \     EndIf;\n      ELSE;\n        HierarchySubsetElementInsert( pDim, pHIer, pSub, sElement,\
    \ nSubsetIndex );\n      ENDIF;\n    EndIf;\n    nSubsetIndex = nSubsetIndex + 1;\n  EndIf;\n\
    End;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in a hierarchy
    of the target dimension based on a list of supplied elements. Note: - pAddToSubset: If the
    specified subset already exists, this parameter will control whether elements will be added
    to the existing subset (value 1) or a new subset will be created (value 0). - pExpandConsol:
    If the specified list of elements contains consolidated elements, they will be replaced
    with their leaf-level descendants. Caution: Process doesn''t accept wildcards in element
    names.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy\
    \ of target Dimension based on a list of\n# supplied elements.\n\n# Note:\n# - pAddToSubset:\
    \ If the specified subset already exists then this parameter will control whether elements\
    \ will\n#                 be added to the existing subset (value 1) or a new subset will\
    \ be created (value 0).\n# - pExpandConsol: If the specified list of elements contains consolidated\
    \ elements they will be replaced with \n#                 their leaf level descendants\n\
    # Caution: Process doesn't accept wildcards in element names.\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%,\
    \ pEle:%pEle%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%, pExpandConsol:%pExpandConsol%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\
    \n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n\n### Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim\
    \ ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim,\
    \ Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\n# Validate dimension\n\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n\
    \  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \ dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n## Validate Hierarchy\n\nIF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\n\
    EndIf;\n\nIF(HierarchyExists(pDim, pHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \ dimension Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pSub ) @= '' );\n  nErrors = 1;\n  sMessage\
    \ = 'No subset specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate elements\nIf( Trim( pEle ) @= '' );\n  nErrors = 1;\n  sMessage = 'No\
    \ elements specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate delimiter\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# Validate add to\
    \ subset\nIf( pAddToSubset <> 0 & pAddToSubset <> 1 );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \ value for pAddToSubset: ' | NumberToString( pAddToSubset ) | '. Valid values are 0 and\
    \ 1';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ expand consolidations\nIf( pExpandConsol <> 0 & pExpandConsol <> 1 & pExpandConsol <>\
    \ 2 );\n  nErrors = 1;\n  sMessage = 'Invalid value for pExpandConsol: ' | NumberToString(\
    \ pExpandConsol ) | '. Valid values are 0, 1 and 2';\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n## Validate Alias\nsDimAttr = '}ElementAttributes_' |\
    \ pDim;\nIF(pAlias @<> '' );\n  IF(DimensionExists( sDimAttr ) = 0 );\n    sMessage = 'No\
    \ attributes exist for the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n  IF(DIMIX(\
    \ sDimAttr, pAlias ) = 0 );\n    sMessage = 'The Alias: ' | pAlias | ' does not exist in\
    \ the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n  IF(\n  DTYPE( sDimAttr, pAlias\
    \ ) @<> 'AA' );\n    sMessage = 'The Alias: ' | pAlias | ' is not an Alias in the dimension:\
    \ ' | sDimAttr;\n    pAlias = '';\n  EndIf;\nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0\
    \ & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0\
    \ or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Prepare subset ###\nIf( HierarchySubsetExists( pDim, pHier, pSub ) = 1 );\n  If( pAddtoSubset\
    \ <> 1 );\n    HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\n    nSubsetSize =\
    \ 0;\n  Else;\n    nSubsetSize = HierarchySubsetGetSize( pDim, pHier, pSub );\n  EndIf;\n\
    Else;\n  If( nErrors = 0 );\n    HierarchySubsetCreate( pDim, pHier, pSub, pTemp );\n  EndIf;\n\
    \  nSubsetSize = 0;\nEndIf;\n\n### Assign Alias to subset\nIF(pAlias @<> '' );\n  HierarchySubsetAliasSet(\
    \ pDim, pHier, pSub, pAlias );\nENDIF;\n\n### Insert elements ###\n\nnSubsetIndex = 1;\n\
    sElements = pEle;\nnDelimIndex = 1;\n\n# Split filter into seperate dimensions\nWhile( nDelimIndex\
    \ <> 0 & Long( sElements ) > 0 );\n\n  nDelimIndex = Scan( pDelim, sElements );\n  If( nDelimIndex\
    \ <> 0 );\n    sElement = Trim( SubSt( sElements, 1, nDelimIndex - 1 ) );\n    sElements\
    \ = Trim( SubSt( sElements, nDelimIndex + Long( pDelim ), Long( sElements ) ) );\n  Else;\n\
    \    sElement = Trim( sElements );\n  EndIf;\n\n  If( ElementIndex( pDim, pHier, sElement\
    \ ) <> 0 );\n    If( nErrors = 0 );\n      IF(ElementLevel( pDim, pHier, sElement) > 0);\n\
    \        If( pExpandConsol = 1 );\n          ExecuteProcess('}bedrock.hier.sub.create',\n\
    \                         'pStrictErrorHandling', pStrictErrorHandling,\n              \
    \           'pDim', pDim,\n                         'pHier',pHier,\n                   \
    \      'pSub', pSub,\n                         'pConsol', sElement,\n                  \
    \       'pExclusions', '',\n                         'pDelim', pDelim,\n               \
    \          'pAddToSubset', 1,\n                         'pAlias', '',\n                \
    \         'pTemp', pTemp\n                        );\n        ElseIf( pExpandConsol = 2\
    \ );\n          ExecuteProcess('}bedrock.hier.sub.create',\n                         'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n                         'pDim', pDim,\n                      \
    \   'pHier',pHier,\n                         'pSub', pSub,\n                         'pConsol',\
    \ sElement,\n                         'pLevelFrom', 0,\n                         'pLevelTo',\
    \ 0,\n                         'pExclusions', '',\n                         'pDelim', pDelim,\n\
    \                         'pAddToSubset', 1,\n                         'pAlias', '',\n \
    \                        'pTemp', pTemp\n                        );\n        Else;\n   \
    \       HierarchySubsetElementInsert( pDim, pHIer, pSub, sElement, nSubsetIndex );\n   \
    \     EndIf;\n      ELSE;\n        HierarchySubsetElementInsert( pDim, pHIer, pSub, sElement,\
    \ nSubsetIndex );\n      ENDIF;\n    EndIf;\n    nSubsetIndex = nSubsetIndex + 1;\n  EndIf;\n\
    End;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der statische Subsets mit dem Namen
    ''Alle Ebene <nn>'' für die angegebenen Konsolidierungsebenen in einer Hierarchie einer
    Dimension erstellt. Beachte, dass die Option zum Sortieren des Subsets nur für die Sortierung
    nach den Hauptelementnamen verfügbar ist. Vorsicht: Die Zielhierarchie darf nicht ''Leaves''
    sein.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates static subsets named 'All level <nn>'\
    \ for the specified consolidation\n# levels in a Hierarchy of a Dimension.\n\n# Note:\n\
    # Option to sort subset is available only for sorting per element principal names.\n\n#\
    \ Caution: Target hierarchy cannot be `Leaves`.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSort:%pSort%,\
    \ pConvertStatic:%pConvertStatic%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim   \
    \    = '}ElementAttributes_' | pDim;\ncSubs               = '' ;\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n\n###\
    \ Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n\
    \    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long(\
    \ pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate\
    \ dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists(\
    \ pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier\
    \ @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier )\
    \ @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim,\
    \ sHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Alias\n\
    IF(pAlias @<> '' );\n\n  sDimAttr = '}ElementAttributes_' | pDim;\n  IF(\n  DimensionExists(\
    \ sDimAttr ) = 0 );\n    sMessage = 'No attributes exist for the dimension: ' | pDim;\n\
    \    pAlias = '';\n  EndIf;\n\n  IF(DIMIX( sDimAttr, pAlias ) = 0 );\n    sMessage = 'The\
    \ Alias: ' | pAlias | ' does not exist in the dimension: ' | pDim;\n    pAlias = '';\n \
    \ EndIf;\n\n  IF(DTYPE( sDimAttr, pAlias ) @<> 'AA' );\n    sMessage = 'The Alias: ' | pAlias\
    \ | ' is not an Alias in the dimension: ' | sDimAttr;\n    pAlias = '';\n  EndIf;\nENDIF;\n\
    \n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong\
    \ parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### Build Subset ###\n\nIf( nErrors = 0 );\n  nLevel\
    \ = 0;\n  nLevelMax = DnLev( pDim|':'|sHier ) - 1;\n  While( nLevel <= nLevelMax );\n  \
    \  # Loop through the levels of the dimension.\n    sLevel = NumberToString( nLevel );\n\
    \    sSubset = 'All Level ' | Fill( '0', 2 - Long( sLevel ) ) | sLevel;\n    cSubs = cSubs\
    \ | ' ' | sSubset | ','  ;\n    If( HierarchySubsetExists( pDim, sHier, sSubset ) = 1 );\n\
    \      # Need to destroy the subset because the subset may change from an MDX subset to\
    \ a Static Subset.\n      HierarchySubsetDestroy( pDim, sHier, sSubset );\n    EndIf;\n\n\
    \    # Generate MDX\n    sMDX = '{ TM1FILTERBYLEVEL( { TM1SUBSETALL( [' | pDim|':'|sHier\
    \ | '] ) }, ' | sLevel | ' ) }';\n    If( pSort = 1 );\n      sMDX = '{ TM1SORT( ' | sMDX\
    \ | ', ASC ) }';\n    EndIf;\n\n    ## Build Subset for the level.\n    If( pConvertStatic\
    \ = 1 );\n      # Convert the subset to a static subset\n      sSubsetMDX = '}' | cThisProcName\
    \ | '.' | NumberToString( Int( Rand() * 100000 ) );\n      If( HierarchySubsetExists( pDim,\
    \ pHier, sSubsetMDX ) = 1 );\n        HierarchySubsetDestroy( pDim, sHier, sSubsetMDX );\n\
    \      EndIF;\n      SubsetCreatebyMDX( sSubsetMDX, sMDX, pDim, pTemp );\n      nSubsetSize\
    \ = HierarchySubsetGetSize( pDim, sHier, sSubsetMDX );\n      nSubsetIndex = 0;\n      HierarchySubsetCreate(\
    \ pDim, sHier, sSubset, pTemp );\n      While( nSubsetIndex < nSubsetSize );\n        nSubsetIndex\
    \ = nSubsetIndex + 1;\n        sTemp =    HierarchySubsetElementGetIndex (pDim, sHier, sSubsetMDX,\
    \ '', nSubsetIndex);\n        sElement = HierarchySubsetGetElementName( pDim, sHier, sSubsetMDX,\
    \ nSubsetIndex );\n        HierarchySubsetElementInsert( pDim, sHier, sSubset, sElement,\
    \ nSubsetIndex );\n      End;\n    Else;\n      SubsetCreatebyMDX( sSubset, sMDX, pDim,\
    \ pTemp );\n    EndIf;\n\n    ### Assign Alias to subset\n    IF(pAlias @<> '' );\n    \
    \  If( nErrors = 0 );\n        HierarchySubsetAliasSet( pDim, pHier, sSubset, pAlias );\n\
    \      EndIf;\n    ENDIF;\n    nLevel = nLevel + 1;\n  End;\nEndIf;\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset(s) %cSubs% from dimension %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates static subsets named ''All
    level <nn>'' for the specified consolidation levels in a hierarchy of a dimension. Note
    that the option to sort the subset is only available for sorting by element principal names.
    Caution: The target hierarchy cannot be ''Leaves''.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates static subsets named 'All level <nn>'\
    \ for the specified consolidation\n# levels in a Hierarchy of a Dimension.\n\n# Note:\n\
    # Option to sort subset is available only for sorting per element principal names.\n\n#\
    \ Caution: Target hierarchy cannot be `Leaves`.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSort:%pSort%,\
    \ pConvertStatic:%pConvertStatic%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim   \
    \    = '}ElementAttributes_' | pDim;\ncSubs               = '' ;\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n\n###\
    \ Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n\
    \    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long(\
    \ pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate\
    \ dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists(\
    \ pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier\
    \ @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier )\
    \ @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim,\
    \ sHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Alias\n\
    IF(pAlias @<> '' );\n\n  sDimAttr = '}ElementAttributes_' | pDim;\n  IF(\n  DimensionExists(\
    \ sDimAttr ) = 0 );\n    sMessage = 'No attributes exist for the dimension: ' | pDim;\n\
    \    pAlias = '';\n  EndIf;\n\n  IF(DIMIX( sDimAttr, pAlias ) = 0 );\n    sMessage = 'The\
    \ Alias: ' | pAlias | ' does not exist in the dimension: ' | pDim;\n    pAlias = '';\n \
    \ EndIf;\n\n  IF(DTYPE( sDimAttr, pAlias ) @<> 'AA' );\n    sMessage = 'The Alias: ' | pAlias\
    \ | ' is not an Alias in the dimension: ' | sDimAttr;\n    pAlias = '';\n  EndIf;\nENDIF;\n\
    \n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong\
    \ parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### Build Subset ###\n\nIf( nErrors = 0 );\n  nLevel\
    \ = 0;\n  nLevelMax = DnLev( pDim|':'|sHier ) - 1;\n  While( nLevel <= nLevelMax );\n  \
    \  # Loop through the levels of the dimension.\n    sLevel = NumberToString( nLevel );\n\
    \    sSubset = 'All Level ' | Fill( '0', 2 - Long( sLevel ) ) | sLevel;\n    cSubs = cSubs\
    \ | ' ' | sSubset | ','  ;\n    If( HierarchySubsetExists( pDim, sHier, sSubset ) = 1 );\n\
    \      # Need to destroy the subset because the subset may change from an MDX subset to\
    \ a Static Subset.\n      HierarchySubsetDestroy( pDim, sHier, sSubset );\n    EndIf;\n\n\
    \    # Generate MDX\n    sMDX = '{ TM1FILTERBYLEVEL( { TM1SUBSETALL( [' | pDim|':'|sHier\
    \ | '] ) }, ' | sLevel | ' ) }';\n    If( pSort = 1 );\n      sMDX = '{ TM1SORT( ' | sMDX\
    \ | ', ASC ) }';\n    EndIf;\n\n    ## Build Subset for the level.\n    If( pConvertStatic\
    \ = 1 );\n      # Convert the subset to a static subset\n      sSubsetMDX = '}' | cThisProcName\
    \ | '.' | NumberToString( Int( Rand() * 100000 ) );\n      If( HierarchySubsetExists( pDim,\
    \ pHier, sSubsetMDX ) = 1 );\n        HierarchySubsetDestroy( pDim, sHier, sSubsetMDX );\n\
    \      EndIF;\n      SubsetCreatebyMDX( sSubsetMDX, sMDX, pDim, pTemp );\n      nSubsetSize\
    \ = HierarchySubsetGetSize( pDim, sHier, sSubsetMDX );\n      nSubsetIndex = 0;\n      HierarchySubsetCreate(\
    \ pDim, sHier, sSubset, pTemp );\n      While( nSubsetIndex < nSubsetSize );\n        nSubsetIndex\
    \ = nSubsetIndex + 1;\n        sTemp =    HierarchySubsetElementGetIndex (pDim, sHier, sSubsetMDX,\
    \ '', nSubsetIndex);\n        sElement = HierarchySubsetGetElementName( pDim, sHier, sSubsetMDX,\
    \ nSubsetIndex );\n        HierarchySubsetElementInsert( pDim, sHier, sSubset, sElement,\
    \ nSubsetIndex );\n      End;\n    Else;\n      SubsetCreatebyMDX( sSubset, sMDX, pDim,\
    \ pTemp );\n    EndIf;\n\n    ### Assign Alias to subset\n    IF(pAlias @<> '' );\n    \
    \  If( nErrors = 0 );\n        HierarchySubsetAliasSet( pDim, pHier, sSubset, pAlias );\n\
    \      EndIf;\n    ENDIF;\n    nLevel = nLevel + 1;\n  End;\nEndIf;\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset(s) %cSubs% from dimension %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der einen dynamischen Subset aus einem
    MDX-Ausdruck erstellt, der zu einer nicht-leeren Menge in der angegebenen Dimension evaluiert.
    Dieser Prozess ist sowohl für die Produktion als auch für die Entwicklung vorgesehen. Das
    Hauptziel ist es, einen dynamischen Subset zur Nutzung in einer Ansicht zu erstellen. Beachte,
    dass der Prozess bei ungültigem Dimensionsnamen (pDim) abbricht. Falls der MDX-Ausdruck
    nicht kompiliert oder eine leere Menge produziert, tritt ein Fehler im Prozess auf. Wenn
    die Option zum Konvertieren in statisch (pConvertToStatic) auf 1 gesetzt ist, wird der MDX-Subset
    durch einen statischen Subset ersetzt.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Create a dynamic subset from an MDX\
    \ expression that evaluates to a non-empty set in the specified dimension.\n\n# Use case:\
    \ Intended for Production & Development\n#1/ Create a dynamic subset for use in a view\n\
    \n# Note:\n# Naturally, valid dimension name (pDim) are mandatory otherwise the process\
    \ will abort.\n# If the MDX does not compile or produces an empty set, the process will\
    \ error.\n# If convert to static (pConvertToStatic) is set to 1 then the MDX subset will\
    \ be replaced by a static subset.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s'\
    \ );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName\
    \ | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile       = GetProcessErrorFileDirectory\
    \ | cTempSub | '.csv';\ncUserName       = TM1User();\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent=\
    \ 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pMDXExpr:%pMDXExpr%, pConvertToStatic:%pConvertToStatic%,\
    \ pTemp:%pTemp%, pAlias:%pAlias%.' ;\nsMDXExpr        = pMDXExpr;\n\n## LogOutput parameters\n\
    IF( pLogoutput  = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\n\nnErrors         = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n\
    \    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long(\
    \ pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate\
    \ dimension\nIf( Trim( pDim )  @= '' );\n    nErrors     = 1;\n    sMessage    = 'No dimension\
    \ specified';\n    DataSourceType= 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim       \
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIf( DimensionExists( pDim ) = 0\
    \ );\n    nErrors     = 1;\n    sMessage    = 'Invalid dimension: ' | pDim;\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n##\
    \ Validate hierarchy\nIf( Trim( pHier ) @= '' );\n    sHier = pDim;\nElse;\n    sHier =\
    \ pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, pHier ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid dimension Hierarchy: ' | pDim |':'|pHier;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pSub ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No subset specified';\n    DataSourceType = 'NULL';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate MDX\nIf( Trim( sMDXExpr\
    \ ) @= '' );\n    nErrors = 1;\n    sMessage = 'No MDX expression specified.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n##\
    \ Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong\
    \ parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate Alias exists\nIf ( pAlias @<> '' & \n    DimIx\
    \ ( Expand ( '}ElementAttributes_%pDim%' ), pAlias ) = 0\n);\n  nErrors = 1;\n  sMessage\
    \ = 'Alias does not exist in dimension %pDim%.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;  \n\n# Validate alias attribute name is actually an alias\nIf ( pAlias @<>\
    \ '' & \n    Dtype ( Expand ( '}ElementAttributes_%pDim%' ), pAlias ) @<> 'AA'  \n);\n \
    \ nErrors = 1;\n  sMessage = 'Attribute %pAlias% is not an alias in dimension %pDim%.';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n### Create Subset\
    \ ###\nIf( nErrors = 0 );\n  If( ElementCount( pDim, sHier ) = 0 & pConvertToStatic <> 0);\n\
    \    HierarchySubsetCreate( pDim, sHier, pSub );\n  Else;\n    If( HierarchySubsetExists(\
    \ pDim,sHier, pSub ) = 1 );\n        HierarchySubsetMDXSet( pDim, sHier, pSub, sMDXExpr\
    \ );\n    Else;\n        SubsetCreateByMDX( pSub, sMDXExpr, pDim|':'|sHier, pTemp );\n \
    \   EndIf;\n    If( pConvertToStatic = 1 );\n        HierarchySubsetElementInsert( pDim,\
    \ sHier, pSub, ElementName( pDim, sHier, 1 ), 1 );\n        HierarchySubsetElementDelete(\
    \ pDim, sHier, pSub, 1 );\n    EndIf;\n  EndIf;\n  \n  # Set Alias\n  If ( pAlias @<> ''\
    \ );\n      If ( pDim @= sHier );\n          SubsetAliasSet( pDim, pSub, pAlias);\n    \
    \  Else;\n          SubsetAliasSet( pDim | ':' | sHier, pSub, pAlias);\n      EndIf;\n \
    \ EndIf;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Destroy Temporary Subset ###\n\nIf( pConvertToStatic\
    \ = 1 & pTemp = 0 );\n\n  If( HierarchySubsetExists( pDim , pHier, cTempSub) = 1 );\n  \
    \  HierarchySubsetDestroy( pDim, pHier, cTempSub );\n  EndIf;\n\nEndIf;\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully created subset\
    \ %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Develop an IBM Turbo Integrator process that creates a dynamic subset from an MDX
    expression that evaluates to a non-empty set in the specified dimension. This process is
    intended for both production and development. The main goal is to create a dynamic subset
    for use in a view. Note that the process will abort if an invalid dimension name (pDim)
    is provided. If the MDX expression does not compile or produces an empty set, the process
    will error. If the convert to static option (pConvertToStatic) is set to 1, the MDX subset
    will be replaced by a static subset.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Create a dynamic subset from an MDX\
    \ expression that evaluates to a non-empty set in the specified dimension.\n\n# Use case:\
    \ Intended for Production & Development\n#1/ Create a dynamic subset for use in a view\n\
    \n# Note:\n# Naturally, valid dimension name (pDim) are mandatory otherwise the process\
    \ will abort.\n# If the MDX does not compile or produces an empty set, the process will\
    \ error.\n# If convert to static (pConvertToStatic) is set to 1 then the MDX subset will\
    \ be replaced by a static subset.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName   = GetProcessName();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s'\
    \ );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName\
    \ | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile       = GetProcessErrorFileDirectory\
    \ | cTempSub | '.csv';\ncUserName       = TM1User();\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent=\
    \ 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pMDXExpr:%pMDXExpr%, pConvertToStatic:%pConvertToStatic%,\
    \ pTemp:%pTemp%, pAlias:%pAlias%.' ;\nsMDXExpr        = pMDXExpr;\n\n## LogOutput parameters\n\
    IF( pLogoutput  = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\n\nnErrors         = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n\
    \    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long(\
    \ pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate\
    \ dimension\nIf( Trim( pDim )  @= '' );\n    nErrors     = 1;\n    sMessage    = 'No dimension\
    \ specified';\n    DataSourceType= 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim       \
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIf( DimensionExists( pDim ) = 0\
    \ );\n    nErrors     = 1;\n    sMessage    = 'Invalid dimension: ' | pDim;\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n##\
    \ Validate hierarchy\nIf( Trim( pHier ) @= '' );\n    sHier = pDim;\nElse;\n    sHier =\
    \ pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, pHier ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid dimension Hierarchy: ' | pDim |':'|pHier;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pSub ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No subset specified';\n    DataSourceType = 'NULL';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate MDX\nIf( Trim( sMDXExpr\
    \ ) @= '' );\n    nErrors = 1;\n    sMessage = 'No MDX expression specified.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n##\
    \ Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong\
    \ parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate Alias exists\nIf ( pAlias @<> '' & \n    DimIx\
    \ ( Expand ( '}ElementAttributes_%pDim%' ), pAlias ) = 0\n);\n  nErrors = 1;\n  sMessage\
    \ = 'Alias does not exist in dimension %pDim%.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;  \n\n# Validate alias attribute name is actually an alias\nIf ( pAlias @<>\
    \ '' & \n    Dtype ( Expand ( '}ElementAttributes_%pDim%' ), pAlias ) @<> 'AA'  \n);\n \
    \ nErrors = 1;\n  sMessage = 'Attribute %pAlias% is not an alias in dimension %pDim%.';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n### Create Subset\
    \ ###\nIf( nErrors = 0 );\n  If( ElementCount( pDim, sHier ) = 0 & pConvertToStatic <> 0);\n\
    \    HierarchySubsetCreate( pDim, sHier, pSub );\n  Else;\n    If( HierarchySubsetExists(\
    \ pDim,sHier, pSub ) = 1 );\n        HierarchySubsetMDXSet( pDim, sHier, pSub, sMDXExpr\
    \ );\n    Else;\n        SubsetCreateByMDX( pSub, sMDXExpr, pDim|':'|sHier, pTemp );\n \
    \   EndIf;\n    If( pConvertToStatic = 1 );\n        HierarchySubsetElementInsert( pDim,\
    \ sHier, pSub, ElementName( pDim, sHier, 1 ), 1 );\n        HierarchySubsetElementDelete(\
    \ pDim, sHier, pSub, 1 );\n    EndIf;\n  EndIf;\n  \n  # Set Alias\n  If ( pAlias @<> ''\
    \ );\n      If ( pDim @= sHier );\n          SubsetAliasSet( pDim, pSub, pAlias);\n    \
    \  Else;\n          SubsetAliasSet( pDim | ':' | sHier, pSub, pAlias);\n      EndIf;\n \
    \ EndIf;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Destroy Temporary Subset ###\n\nIf( pConvertToStatic\
    \ = 1 & pTemp = 0 );\n\n  If( HierarchySubsetExists( pDim , pHier, cTempSub) = 1 );\n  \
    \  HierarchySubsetDestroy( pDim, pHier, cTempSub );\n  EndIf;\n\nEndIf;\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully created subset\
    \ %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der ein statisches Teilset in einer
    Hierarchie einer Zieldimension erstellt, das aus allen Nachkommen eines angegebenen konsolidierten
    Elements besteht, einschließlich der konsolidierten Elemente. Dieser Prozess sollte die
    Option bieten, bestimmte Elemente basierend auf dem Parameter pExclusions auszuschließen,
    wobei die Elemente durch ein Trennzeichen getrennt werden und Platzhalterzeichen wie '*'
    und '?' zulässig sind. Zusätzlich sollte der Parameter pAddToSubset festlegen, ob bei vorhandenen
    Subsets Elemente hinzugefügt werden (Wert 1) oder ein neues Subset erstellt werden soll
    (Wert 0). Beachte, dass die Anzahl der verarbeiteten konsolidierten Ebenen auf maximal 99
    begrenzt ist.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy\
    \ of target Dimension that consists of\n# all descendants of a specified consolidated element,\
    \ including consolidated elements.\n\n# Note:\n# - pExclusions: If pExclusions is specified\
    \ then the elements (separated by a delimiter) will be\n#   excluded from the subset. Wildcards\
    \ characters `*` and `?` are accepted.\n# - pAddToSubset : If the specified subset already\
    \ exists then this parameter will control whether\n#   elements will be added to the existing\
    \ subset (value 1) or a new subset will be created\n#   (value 0).\n\n# Caution: Number\
    \ of consolidated levels that are processed is limited to maximum of 99.\n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorShell = Expand('Executing\
    \ process %cThisProcName% has failed.');\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pConsol:%pConsol%, pAddToSubset:%pAddToSubset%,\
    \ pExclusions:%pExclusions%, pDelim:%pDelim%, pAlias:%pAlias%, pTemp:%pTemp%.' ;\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \nnErrors = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n\
    \    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = \nExecuteProcess( '}bedrock.hier.sub.create',\
    \ 'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim',\
    \ pDim, 'pHier', pHier, 'pSub', pSub, 'pConsol', pConsol,\n    'pAttr', '', 'pAttrValue',\
    \ '',\n    'pLevelFrom', 0, 'pLevelTo', 999,\n    'pExclusions', pExclusions, 'pDelim',\
    \ pDelim,\n    'pAddToSubset', pAddToSubset,\n    'pAlias', pAlias, 'pTemp', pTemp\n);\n\
    \                            \nIF ( nRet <> ProcessExitNormal() );\n  sMessage = cMsgErrorShell;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  ProcessError();\nENDIF;\n\
    \n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates a static subset in a hierarchy
    of a target dimension consisting of all descendants of a specified consolidated element,
    including consolidated elements. This process should offer the option to exclude certain
    elements based on the pExclusions parameter, with elements separated by a delimiter and
    wildcard characters like '*' and '?' accepted. Additionally, the pAddToSubset parameter
    should determine whether elements will be added to an existing subset (value 1) or a new
    subset should be created (value 0). Note that the number of consolidated levels processed
    is limited to a maximum of 99.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy\
    \ of target Dimension that consists of\n# all descendants of a specified consolidated element,\
    \ including consolidated elements.\n\n# Note:\n# - pExclusions: If pExclusions is specified\
    \ then the elements (separated by a delimiter) will be\n#   excluded from the subset. Wildcards\
    \ characters `*` and `?` are accepted.\n# - pAddToSubset : If the specified subset already\
    \ exists then this parameter will control whether\n#   elements will be added to the existing\
    \ subset (value 1) or a new subset will be created\n#   (value 0).\n\n# Caution: Number\
    \ of consolidated levels that are processed is limited to maximum of 99.\n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorShell = Expand('Executing\
    \ process %cThisProcName% has failed.');\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pConsol:%pConsol%, pAddToSubset:%pAddToSubset%,\
    \ pExclusions:%pExclusions%, pDelim:%pDelim%, pAlias:%pAlias%, pTemp:%pTemp%.' ;\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \nnErrors = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n\
    \    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = \nExecuteProcess( '}bedrock.hier.sub.create',\
    \ 'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim',\
    \ pDim, 'pHier', pHier, 'pSub', pSub, 'pConsol', pConsol,\n    'pAttr', '', 'pAttrValue',\
    \ '',\n    'pLevelFrom', 0, 'pLevelTo', 999,\n    'pExclusions', pExclusions, 'pDelim',\
    \ pDelim,\n    'pAddToSubset', pAddToSubset,\n    'pAlias', pAlias, 'pTemp', pTemp\n);\n\
    \                            \nIF ( nRet <> ProcessExitNormal() );\n  sMessage = cMsgErrorShell;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  ProcessError();\nENDIF;\n\
    \n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der einen statischen Subset in einer
    Hierarchie der Zieldimension erstellt, der aus allen Blattnachfahren eines angegebenen konsolidierten
    Elements besteht. Beachte: Wenn pExclusions angegeben ist, werden die durch ein Trennzeichen
    getrennten Elemente vom Subset ausgeschlossen, wobei Platzhalterzeichen ''*'' und ''?''
    akzeptiert werden. Wenn das angegebene Subset bereits existiert, steuert der Parameter pAddToSubset,
    ob Elemente zum bestehenden Subset hinzugefügt werden (Wert 1) oder ein neues Subset erstellt
    wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy\
    \ of target Dimension that consists of\n# all leaf descendants of a specified consolidated\
    \ element.\n\n# Note:\n# - pExclusions: If pExclusions is specified then the elements (separated\
    \ by a delimiter) will be\n#   excluded from the subset. Wildcards characters `*` and `?`\
    \ are accepted.\n# - pAddToSubset : If the specified subset already exists then this parameter\
    \ will control whether\n#   elements will be added to the existing subset (value 1) or a\
    \ new subset will be created\n#   (value 0).\n\n#EndRegion @DOC\n\n##Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorShell = Expand('Executing\
    \ process %cThisProcName% has failed.');\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pConsol:%pConsol%, pAddToSubset:%pAddToSubset%,\
    \ pExclusions:%pExclusions%, pDelim:%pDelim%, pAlias:%pAlias%, pTemp:%pTemp%.' ;\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \nnErrors = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n\
    \    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = \nExecuteProcess( '}bedrock.hier.sub.create',\
    \ 'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim',\
    \ pDim, 'pHier', pHier, 'pSub', pSub, 'pConsol', pConsol,\n    'pAttr', '', 'pAttrValue',\
    \ '',\n    'pLevelFrom', 0, 'pLevelTo', 0,\n    'pExclusions', pExclusions,\n    'pDelim',\
    \ pDelim, 'pAddToSubset', pAddToSubset,\n    'pAlias', pAlias, 'pTemp', pTemp\n);\n\n  \
    \                          \nIF ( nRet <> ProcessExitNormal() );\n  sMessage = cMsgErrorShell;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  ProcessError();\nENDIF;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in a hierarchy
    of the target dimension consisting of all leaf descendants of a specified consolidated element.
    Note: If pExclusions is specified, the elements separated by a delimiter will be excluded
    from the subset, with wildcard characters ''*'' and ''?'' being accepted. If the specified
    subset already exists, the parameter pAddToSubset controls whether elements will be added
    to the existing subset (value 1) or a new subset will be created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy\
    \ of target Dimension that consists of\n# all leaf descendants of a specified consolidated\
    \ element.\n\n# Note:\n# - pExclusions: If pExclusions is specified then the elements (separated\
    \ by a delimiter) will be\n#   excluded from the subset. Wildcards characters `*` and `?`\
    \ are accepted.\n# - pAddToSubset : If the specified subset already exists then this parameter\
    \ will control whether\n#   elements will be added to the existing subset (value 1) or a\
    \ new subset will be created\n#   (value 0).\n\n#EndRegion @DOC\n\n##Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorShell = Expand('Executing\
    \ process %cThisProcName% has failed.');\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pConsol:%pConsol%, pAddToSubset:%pAddToSubset%,\
    \ pExclusions:%pExclusions%, pDelim:%pDelim%, pAlias:%pAlias%, pTemp:%pTemp%.' ;\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \nnErrors = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n\
    \    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = \nExecuteProcess( '}bedrock.hier.sub.create',\
    \ 'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim',\
    \ pDim, 'pHier', pHier, 'pSub', pSub, 'pConsol', pConsol,\n    'pAttr', '', 'pAttrValue',\
    \ '',\n    'pLevelFrom', 0, 'pLevelTo', 0,\n    'pExclusions', pExclusions,\n    'pDelim',\
    \ pDelim, 'pAddToSubset', pAddToSubset,\n    'pAlias', pAlias, 'pTemp', pTemp\n);\n\n  \
    \                          \nIF ( nRet <> ProcessExitNormal() );\n  sMessage = cMsgErrorShell;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  ProcessError();\nENDIF;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der ein statisches Subset in der
    Hierarchie einer Dimension erstellt, das aus allen Blatt-Elementen besteht. Der Prozess
    soll Modifikationsparameter verwenden, um zu bestimmen, welche Elemente im Subset enthalten
    sein sollen: - pExclusions: Wenn pExclusions angegeben wird, sollen die durch einen Trenner
    getrennten Elemente aus dem Subset ausgeschlossen werden. Platzhalterzeichen wie ''*'' und
    ''?'' sollen akzeptiert werden. - pAddToSubset: Wenn das angegebene Subset bereits existiert,
    steuert dieser Parameter, ob Elemente dem bestehenden Subset hinzugefügt werden (Wert 1)
    oder ein neues Subset erstellt wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy\
    \ of a Dimension that consists of all leaf\n# elements.\n\n# Note:\n# This process uses\
    \ modification parameters to determine what to include in the subset:\n# - pExclusions:\
    \ If pExclusions is specified then the elements (separated by a delimiter) will be\n#  \
    \              excluded from the subset. Wildcards characters `*` and `?` are accepted.\n\
    # - pAddToSubset: If the specified subset already exists then this parameter will control\
    \ whether elements will\n#                 be added to the existing subset (value 1) or\
    \ a new subset will be created (value 0).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\nnErrors = 0;\n\n###\
    \ Constants ###\ncThisProcName       = GetProcessName();\ncUserName           = TM1User();\n\
    cTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.';\ncAttributeDim       = '}ElementAttributes_' | pDim;\n\
    \n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\nnErrors = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n\
    \    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = \nExecuteProcess(\
    \ '}bedrock.hier.sub.create', 'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n\
    \    'pDim', pDim, 'pHier',pHier, 'pSub', pSub,\n    'pLevelFrom', 0, 'pLevelTo', 0,\n \
    \   'pExclusions', pExclusions, 'pAddToSubset', pAddToSubset,\n    'pDelim', pDelim, 'pAlias',\
    \ pAlias, 'pTemp', pTemp\n);\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in the hierarchy
    of a dimension consisting of all leaf elements. The process should use modification parameters
    to determine what to include in the subset: - pExclusions: If pExclusions is specified,
    elements separated by a delimiter should be excluded from the subset. Wildcard characters
    ''*'' and ''?'' should be accepted. - pAddToSubset: If the specified subset already exists,
    this parameter will control whether elements will be added to the existing subset (value
    1) or a new subset will be created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy\
    \ of a Dimension that consists of all leaf\n# elements.\n\n# Note:\n# This process uses\
    \ modification parameters to determine what to include in the subset:\n# - pExclusions:\
    \ If pExclusions is specified then the elements (separated by a delimiter) will be\n#  \
    \              excluded from the subset. Wildcards characters `*` and `?` are accepted.\n\
    # - pAddToSubset: If the specified subset already exists then this parameter will control\
    \ whether elements will\n#                 be added to the existing subset (value 1) or\
    \ a new subset will be created (value 0).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\nnErrors = 0;\n\n###\
    \ Constants ###\ncThisProcName       = GetProcessName();\ncUserName           = TM1User();\n\
    cTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.';\ncAttributeDim       = '}ElementAttributes_' | pDim;\n\
    \n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\nnErrors = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n\
    \    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = \nExecuteProcess(\
    \ '}bedrock.hier.sub.create', 'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n\
    \    'pDim', pDim, 'pHier',pHier, 'pSub', pSub,\n    'pLevelFrom', 0, 'pLevelTo', 0,\n \
    \   'pExclusions', pExclusions, 'pAddToSubset', pAddToSubset,\n    'pDelim', pDelim, 'pAlias',\
    \ pAlias, 'pTemp', pTemp\n);\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der ein statisches Subset in einer
    Hierarchie der Zieldimension erstellt, das aus allen Waisenelementen besteht. Beachte: Ein
    Waisenelement ist ein konsolidiertes Element ohne Kinder oder ein Blattelement ohne Eltern.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy\
    \ of target Dimension that consists of\n# all orphan elements.\n\n# Note:\n# Orphan element\
    \ is defined as:\n# - Consolidated element without children.\n# - Leaf element without parent.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pTemp:%pTemp%.';\
    \ \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncSubsetOrphanC = 'Orphan C Elements\
    \ (no children)';\ncSubsetOrphanN = 'Orphan N Elements (no parents)';\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n \
    \   pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0\
    \ );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier @= 'Leaves' );\n\
    \  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\n\
    Else;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors =\
    \ 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Create Subsets\
    \ ###\nIf( nErrors = 0 );\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanC ) =\
    \ 1 );\n    HierarchySubsetDeleteAllElements( pDim, sHier, cSubsetOrphanC );\n  Else;\n\
    \    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanC, pTemp );\n  EndIf;\n  If( HierarchySubsetExists(\
    \ pDim, sHier, cSubsetOrphanN ) = 1 );\n    HierarchySubsetDeleteAllElements( pDim, sHier,\
    \ cSubsetOrphanN );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanN, pTemp\
    \ );\n  EndIf;\nEndIf;\n\n### Populate subsets ###\nnElementCount = DimSiz( pDim|':'|sHier);\n\
    nElementIndex = 1;\nnLeafCount = 0;\nnConsolCount = 0;\nWhile( nElementIndex <= nElementCount\
    \ );\n  sElement = ElementName( pDim, sHier, nElementIndex );\n  If( ElementType( pDim,\
    \ sHier, sElement ) @= 'N' & ElementParent( pDim, sHier, sElement, 1 ) @= '' );\n    # N\
    \ element with no parents\n    nLeafCount = nLeafCount + 1;\n    HierarchySubsetElementInsert(\
    \ pDim, sHier, cSubsetOrphanN, sElement, nLeafCount );\n  EndIf;\n  If(ElementType(pDim,sHier,\
    \ sElement) @= 'C' & ElementComponentCount(pDim, sHier, sElement) = 0);\n    # C element\
    \ with no children\n    nConsolCount = nConsolCount + 1;\n    HierarchySubsetElementInsert(\
    \ pDim, sHier, cSubsetOrphanC, sElement, nConsolCount );\n  EndIf;\n  nElementIndex = nElementIndex\
    \ + 1;\nEnd;\n\n### Tidy up ###\n\n# If no orphans then destroy empty subsets\nIf( nErrors\
    \ = 0 );\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanN ) = 0 );\n    HierarchySubsetDestroy(\
    \ pDim, sHier, cSubsetOrphanN );\n  EndIf;\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanC\
    \ ) = 0 );\n    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanC );\n  EndIf;\nEndIf;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    If(\
    \ nLeafCount > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully\
    \ created subset %cSubsetOrphanN% from dimension %pDim%:%pHier%.' );\n       sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n\
    \       If( pLogoutput = 1 );\n           LogOutput('INFO', Expand( sProcessAction ) );\n\
    \           nProcessReturnCode = 0; \n       EndIf;\n    EndIf ;\n    \n    If( nConsolCount\
    \ > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully created\
    \ subset %cSubsetOrphanC% from dimension %pDim%:%pHier%.' );\n \n       sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n\
    \n      If( pLogoutput = 1 );\n          LogOutput('INFO', Expand( sProcessAction ) ); \
    \  \n      EndIf;\n    Endif ;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in a hierarchy
    of the target dimension consisting of all orphan elements. Note: An orphan element is defined
    as a consolidated element without children or a leaf element without parent.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy\
    \ of target Dimension that consists of\n# all orphan elements.\n\n# Note:\n# Orphan element\
    \ is defined as:\n# - Consolidated element without children.\n# - Leaf element without parent.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pTemp:%pTemp%.';\
    \ \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncSubsetOrphanC = 'Orphan C Elements\
    \ (no children)';\ncSubsetOrphanN = 'Orphan N Elements (no parents)';\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n \
    \   pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0\
    \ );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier @= 'Leaves' );\n\
    \  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\n\
    Else;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors =\
    \ 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Create Subsets\
    \ ###\nIf( nErrors = 0 );\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanC ) =\
    \ 1 );\n    HierarchySubsetDeleteAllElements( pDim, sHier, cSubsetOrphanC );\n  Else;\n\
    \    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanC, pTemp );\n  EndIf;\n  If( HierarchySubsetExists(\
    \ pDim, sHier, cSubsetOrphanN ) = 1 );\n    HierarchySubsetDeleteAllElements( pDim, sHier,\
    \ cSubsetOrphanN );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanN, pTemp\
    \ );\n  EndIf;\nEndIf;\n\n### Populate subsets ###\nnElementCount = DimSiz( pDim|':'|sHier);\n\
    nElementIndex = 1;\nnLeafCount = 0;\nnConsolCount = 0;\nWhile( nElementIndex <= nElementCount\
    \ );\n  sElement = ElementName( pDim, sHier, nElementIndex );\n  If( ElementType( pDim,\
    \ sHier, sElement ) @= 'N' & ElementParent( pDim, sHier, sElement, 1 ) @= '' );\n    # N\
    \ element with no parents\n    nLeafCount = nLeafCount + 1;\n    HierarchySubsetElementInsert(\
    \ pDim, sHier, cSubsetOrphanN, sElement, nLeafCount );\n  EndIf;\n  If(ElementType(pDim,sHier,\
    \ sElement) @= 'C' & ElementComponentCount(pDim, sHier, sElement) = 0);\n    # C element\
    \ with no children\n    nConsolCount = nConsolCount + 1;\n    HierarchySubsetElementInsert(\
    \ pDim, sHier, cSubsetOrphanC, sElement, nConsolCount );\n  EndIf;\n  nElementIndex = nElementIndex\
    \ + 1;\nEnd;\n\n### Tidy up ###\n\n# If no orphans then destroy empty subsets\nIf( nErrors\
    \ = 0 );\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanN ) = 0 );\n    HierarchySubsetDestroy(\
    \ pDim, sHier, cSubsetOrphanN );\n  EndIf;\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanC\
    \ ) = 0 );\n    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanC );\n  EndIf;\nEndIf;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    If(\
    \ nLeafCount > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully\
    \ created subset %cSubsetOrphanN% from dimension %pDim%:%pHier%.' );\n       sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n\
    \       If( pLogoutput = 1 );\n           LogOutput('INFO', Expand( sProcessAction ) );\n\
    \           nProcessReturnCode = 0; \n       EndIf;\n    EndIf ;\n    \n    If( nConsolCount\
    \ > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully created\
    \ subset %cSubsetOrphanC% from dimension %pDim%:%pHier%.' );\n \n       sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n\
    \n      If( pLogoutput = 1 );\n          LogOutput('INFO', Expand( sProcessAction ) ); \
    \  \n      EndIf;\n    Endif ;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der ein statisches Teilset in einer
    Hierarchie der Zieldimension erstellt, welches aus allen Waisenelementen besteht. Ein Waisenelement
    ist definiert als: Ein konsolidiertes Element ohne Kinder oder ein Blattelement ohne Elternteil.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy\
    \ of target Dimension that consists of\n# all orphan elements.\n\n# Note:\n# Orphan element\
    \ is defined as:\n# - Consolidated element without children.\n# - Leaf element without parent.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pTemp:%pTemp%.';\
    \ \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncSubsetOrphanC = 'Orphan C Elements\
    \ (no children)';\ncSubsetOrphanN = 'Orphan N Elements (no parents)';\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n \
    \   pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0\
    \ );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier @= 'Leaves' );\n\
    \  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\n\
    Else;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors =\
    \ 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Create Subsets\
    \ ###\nIf( nErrors = 0 );\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanC ) =\
    \ 1 );\n    HierarchySubsetDeleteAllElements( pDim, sHier, cSubsetOrphanC );\n  Else;\n\
    \    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanC, pTemp );\n  EndIf;\n  If( HierarchySubsetExists(\
    \ pDim, sHier, cSubsetOrphanN ) = 1 );\n    HierarchySubsetDeleteAllElements( pDim, sHier,\
    \ cSubsetOrphanN );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanN, pTemp\
    \ );\n  EndIf;\nEndIf;\n\n### Populate subsets ###\nnElementCount = DimSiz( pDim|':'|sHier);\n\
    nElementIndex = 1;\nnLeafCount = 0;\nnConsolCount = 0;\nWhile( nElementIndex <= nElementCount\
    \ );\n  sElement = ElementName( pDim, sHier, nElementIndex );\n  If( ElementType( pDim,\
    \ sHier, sElement ) @= 'N' & ElementParent( pDim, sHier, sElement, 1 ) @= '' );\n    # N\
    \ element with no parents\n    nLeafCount = nLeafCount + 1;\n    HierarchySubsetElementInsert(\
    \ pDim, sHier, cSubsetOrphanN, sElement, nLeafCount );\n  EndIf;\n  If(ElementType(pDim,sHier,\
    \ sElement) @= 'C' & ElementComponentCount(pDim, sHier, sElement) = 0);\n    # C element\
    \ with no children\n    nConsolCount = nConsolCount + 1;\n    HierarchySubsetElementInsert(\
    \ pDim, sHier, cSubsetOrphanC, sElement, nConsolCount );\n  EndIf;\n  nElementIndex = nElementIndex\
    \ + 1;\nEnd;\n\n### Tidy up ###\n\n# If no orphans then destroy empty subsets\nIf( nErrors\
    \ = 0 );\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanN ) = 0 );\n    HierarchySubsetDestroy(\
    \ pDim, sHier, cSubsetOrphanN );\n  EndIf;\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanC\
    \ ) = 0 );\n    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanC );\n  EndIf;\nEndIf;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    If(\
    \ nLeafCount > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully\
    \ created subset %cSubsetOrphanN% from dimension %pDim%:%pHier%.' );\n       sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n\
    \       If( pLogoutput = 1 );\n           LogOutput('INFO', Expand( sProcessAction ) );\n\
    \           nProcessReturnCode = 0; \n       EndIf;\n    EndIf ;\n    \n    If( nConsolCount\
    \ > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully created\
    \ subset %cSubsetOrphanC% from dimension %pDim%:%pHier%.' );\n \n       sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n\
    \n      If( pLogoutput = 1 );\n          LogOutput('INFO', Expand( sProcessAction ) ); \
    \  \n      EndIf;\n    Endif ;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in a Hierarchy
    of the target dimension consisting of all orphan elements. An orphan element is defined
    as: A consolidated element without children or a leaf element without a parent.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy\
    \ of target Dimension that consists of\n# all orphan elements.\n\n# Note:\n# Orphan element\
    \ is defined as:\n# - Consolidated element without children.\n# - Leaf element without parent.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pTemp:%pTemp%.';\
    \ \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncSubsetOrphanC = 'Orphan C Elements\
    \ (no children)';\ncSubsetOrphanN = 'Orphan N Elements (no parents)';\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n \
    \   pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0\
    \ );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier @= 'Leaves' );\n\
    \  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\n\
    Else;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors =\
    \ 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Create Subsets\
    \ ###\nIf( nErrors = 0 );\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanC ) =\
    \ 1 );\n    HierarchySubsetDeleteAllElements( pDim, sHier, cSubsetOrphanC );\n  Else;\n\
    \    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanC, pTemp );\n  EndIf;\n  If( HierarchySubsetExists(\
    \ pDim, sHier, cSubsetOrphanN ) = 1 );\n    HierarchySubsetDeleteAllElements( pDim, sHier,\
    \ cSubsetOrphanN );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanN, pTemp\
    \ );\n  EndIf;\nEndIf;\n\n### Populate subsets ###\nnElementCount = DimSiz( pDim|':'|sHier);\n\
    nElementIndex = 1;\nnLeafCount = 0;\nnConsolCount = 0;\nWhile( nElementIndex <= nElementCount\
    \ );\n  sElement = ElementName( pDim, sHier, nElementIndex );\n  If( ElementType( pDim,\
    \ sHier, sElement ) @= 'N' & ElementParent( pDim, sHier, sElement, 1 ) @= '' );\n    # N\
    \ element with no parents\n    nLeafCount = nLeafCount + 1;\n    HierarchySubsetElementInsert(\
    \ pDim, sHier, cSubsetOrphanN, sElement, nLeafCount );\n  EndIf;\n  If(ElementType(pDim,sHier,\
    \ sElement) @= 'C' & ElementComponentCount(pDim, sHier, sElement) = 0);\n    # C element\
    \ with no children\n    nConsolCount = nConsolCount + 1;\n    HierarchySubsetElementInsert(\
    \ pDim, sHier, cSubsetOrphanC, sElement, nConsolCount );\n  EndIf;\n  nElementIndex = nElementIndex\
    \ + 1;\nEnd;\n\n### Tidy up ###\n\n# If no orphans then destroy empty subsets\nIf( nErrors\
    \ = 0 );\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanN ) = 0 );\n    HierarchySubsetDestroy(\
    \ pDim, sHier, cSubsetOrphanN );\n  EndIf;\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanC\
    \ ) = 0 );\n    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanC );\n  EndIf;\nEndIf;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    If(\
    \ nLeafCount > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully\
    \ created subset %cSubsetOrphanN% from dimension %pDim%:%pHier%.' );\n       sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n\
    \       If( pLogoutput = 1 );\n           LogOutput('INFO', Expand( sProcessAction ) );\n\
    \           nProcessReturnCode = 0; \n       EndIf;\n    EndIf ;\n    \n    If( nConsolCount\
    \ > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully created\
    \ subset %cSubsetOrphanC% from dimension %pDim%:%pHier%.' );\n \n       sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n\
    \n      If( pLogoutput = 1 );\n          LogOutput('INFO', Expand( sProcessAction ) ); \
    \  \n      EndIf;\n    Endif ;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine Top-Level-Hierarchie durch
    N-Level-Elemente erstellt. Diese Hierarchie soll eine Teilmenge aller 'Top-Knoten'-Elemente
    enthalten, also konsolidierte Elemente, die keine Eltern haben.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n\n# This process will Create a Top Level Hierarchy by N-Level\
    \ Elements\n# that is a subset of all 'top node' elements ( Consolidated elements that have\
    \ no parents )\n\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pConvertToStatic:%pConvertToStatic%, pAlias:%pAlias%,\
    \ pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n\n### Validate\
    \ Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A\
    \ hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into\
    \ dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim\
    \ ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate\
    \ dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists(\
    \ pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier\
    \ @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier )\
    \ @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim,\
    \ sHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( DnLev( pDim|':'|sHier\
    \ ) <= 1 );\n  # Create by MDX would return empty set and fail so need to abort here\n \
    \ nErrors = 1;\n  sMessage = 'Cannot continue, dimension hierarchy is flat: ' | pDim|':'|sHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIF;\n\n# Validate subset\n\
    If( Trim( pSub ) @= '' );\n  pSub = 'Top Level Hierarchies';\nEndIf;\n\n## Validate Alias\n\
    sDimAttr = '}ElementAttributes_' | pDim;\nIF(pAlias @<> '' );\n  IF(DimensionExists( sDimAttr\
    \ ) = 0 );\n    sMessage = 'No attributes exist for the dimension: ' | pDim;\n    pAlias\
    \ = '';\n  EndIf;\n\n  IF(DIMIX( sDimAttr, pAlias ) = 0 );\n    sMessage = 'The Alias: '\
    \ | pAlias | ' does not exist in the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n\
    \  IF(DTYPE( sDimAttr, pAlias ) @<> 'AA' );\n    sMessage = 'The Alias: ' | pAlias | ' is\
    \ not an Alias in the dimension: ' | sDimAttr;\n    pAlias = '';\n  EndIf;\nENDIF;\n\n##\
    \ Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong\
    \ parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### MDX for creating subset ###\n\nsMDX = '{EXCEPT( {FILTER(\
    \ {TM1SUBSETALL( [' | pDim|':'|sHier | '] )}, MemberToStr( [' |\n       pDim|':'|sHier |\
    \ '].CurrentMember.Parent ) = '' )},' |\n       '{TM1FILTERBYLEVEL( {TM1SUBSETALL( [' |\
    \ pDim|':'|sHier | '] )},0 )} )}';\n\n### Create Subset ###\n\nIf( nErrors = 0 );\n\n  #\
    \ For a dynamic subset, the original subset MUST be destroyed first or the MDX will fail\n\
    \  If( pConvertToStatic = 0 );\n    If( HierarchySubsetExists( pDim, sHier, pSub ) = 1 );\n\
    \      HierarchySubsetDestroy( pDim, sHier, pSub );\n    EndIf;\n    SubsetCreateByMDX(\
    \ pSub, sMDX, pDim, pTemp );\n\n  # For a static subset the subset does not need to be destroyed\
    \ but its elements need to be deleted first\n  Else;\n    If( HierarchySubsetExists( pDim,\
    \ sHier, pSub ) = 1 );\n      HierarchySubsetDeleteAllElements( pDim, sHier, pSub );\n \
    \   Else;\n      HierarchySubsetCreate( pDim, sHier, pSub, pTemp );\n    EndIf;\n\n    #\
    \ Create a temporary MDX subset for processing\n    sSubsetMDX = cThisProcName |'.' | NumberToString(\
    \ Int( Rand() * 100000 ) );\n    # It is unlikely that the subset already exists due to\
    \ the random number in the subset name\n    # However, it the SubsetDestroy is included\
    \ in case the same random number is generated\n    If( HierarchySubsetExists( pDim, sHier,\
    \ sSubsetMDX ) = 1 );\n      HierarchySubsetDestroy( pDim, sHier, sSubsetMDX );\n    EndIf;\n\
    \    SubsetCreateByMDX( sSubsetMDX, sMDX, pDim, pTemp );\n\n    # Transfer the elements\
    \ from the MDX subset to the static subset\n    nSubsetSize = HierarchySubsetGetSize( pDim,\
    \ sHier,sSubsetMDX );\n    nSubsetIndex = 0;\n    While( nSubsetIndex < nSubsetSize );\n\
    \      nSubsetIndex = nSubsetIndex + 1;\n      sTemp = HierarchySubsetElementGetIndex (pDim,\
    \ sHier, sSubsetMDX, '', nSubsetIndex);\n      sElement = HierarchySubsetGetElementName(\
    \ pDim, sHier, sSubsetMDX, nSubsetIndex );\n      HierarchySubsetElementInsert( pDim, sHier,\
    \ pSub, sElement, nSubsetIndex );\n    End;\n  EndIf;\n\nEndIf;\n\n### Set Alias ##\nIF(pAlias\
    \ @<> '' );\n  If( nErrors = 0 );\n    HierarchySubsetAliasSet( pDim, pHier, pSub, pAlias\
    \ );\n  EndIf;\nENDIF;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates a top-level hierarchy by N-level
    elements. This hierarchy should be a subset of all 'top node' elements, meaning consolidated
    elements that have no parents.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n\n# This process will Create a Top Level Hierarchy by N-Level\
    \ Elements\n# that is a subset of all 'top node' elements ( Consolidated elements that have\
    \ no parents )\n\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pConvertToStatic:%pConvertToStatic%, pAlias:%pAlias%,\
    \ pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n\n### Validate\
    \ Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A\
    \ hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into\
    \ dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim\
    \ ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate\
    \ dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists(\
    \ pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier\
    \ @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier )\
    \ @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim,\
    \ sHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( DnLev( pDim|':'|sHier\
    \ ) <= 1 );\n  # Create by MDX would return empty set and fail so need to abort here\n \
    \ nErrors = 1;\n  sMessage = 'Cannot continue, dimension hierarchy is flat: ' | pDim|':'|sHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIF;\n\n# Validate subset\n\
    If( Trim( pSub ) @= '' );\n  pSub = 'Top Level Hierarchies';\nEndIf;\n\n## Validate Alias\n\
    sDimAttr = '}ElementAttributes_' | pDim;\nIF(pAlias @<> '' );\n  IF(DimensionExists( sDimAttr\
    \ ) = 0 );\n    sMessage = 'No attributes exist for the dimension: ' | pDim;\n    pAlias\
    \ = '';\n  EndIf;\n\n  IF(DIMIX( sDimAttr, pAlias ) = 0 );\n    sMessage = 'The Alias: '\
    \ | pAlias | ' does not exist in the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n\
    \  IF(DTYPE( sDimAttr, pAlias ) @<> 'AA' );\n    sMessage = 'The Alias: ' | pAlias | ' is\
    \ not an Alias in the dimension: ' | sDimAttr;\n    pAlias = '';\n  EndIf;\nENDIF;\n\n##\
    \ Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong\
    \ parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### MDX for creating subset ###\n\nsMDX = '{EXCEPT( {FILTER(\
    \ {TM1SUBSETALL( [' | pDim|':'|sHier | '] )}, MemberToStr( [' |\n       pDim|':'|sHier |\
    \ '].CurrentMember.Parent ) = '' )},' |\n       '{TM1FILTERBYLEVEL( {TM1SUBSETALL( [' |\
    \ pDim|':'|sHier | '] )},0 )} )}';\n\n### Create Subset ###\n\nIf( nErrors = 0 );\n\n  #\
    \ For a dynamic subset, the original subset MUST be destroyed first or the MDX will fail\n\
    \  If( pConvertToStatic = 0 );\n    If( HierarchySubsetExists( pDim, sHier, pSub ) = 1 );\n\
    \      HierarchySubsetDestroy( pDim, sHier, pSub );\n    EndIf;\n    SubsetCreateByMDX(\
    \ pSub, sMDX, pDim, pTemp );\n\n  # For a static subset the subset does not need to be destroyed\
    \ but its elements need to be deleted first\n  Else;\n    If( HierarchySubsetExists( pDim,\
    \ sHier, pSub ) = 1 );\n      HierarchySubsetDeleteAllElements( pDim, sHier, pSub );\n \
    \   Else;\n      HierarchySubsetCreate( pDim, sHier, pSub, pTemp );\n    EndIf;\n\n    #\
    \ Create a temporary MDX subset for processing\n    sSubsetMDX = cThisProcName |'.' | NumberToString(\
    \ Int( Rand() * 100000 ) );\n    # It is unlikely that the subset already exists due to\
    \ the random number in the subset name\n    # However, it the SubsetDestroy is included\
    \ in case the same random number is generated\n    If( HierarchySubsetExists( pDim, sHier,\
    \ sSubsetMDX ) = 1 );\n      HierarchySubsetDestroy( pDim, sHier, sSubsetMDX );\n    EndIf;\n\
    \    SubsetCreateByMDX( sSubsetMDX, sMDX, pDim, pTemp );\n\n    # Transfer the elements\
    \ from the MDX subset to the static subset\n    nSubsetSize = HierarchySubsetGetSize( pDim,\
    \ sHier,sSubsetMDX );\n    nSubsetIndex = 0;\n    While( nSubsetIndex < nSubsetSize );\n\
    \      nSubsetIndex = nSubsetIndex + 1;\n      sTemp = HierarchySubsetElementGetIndex (pDim,\
    \ sHier, sSubsetMDX, '', nSubsetIndex);\n      sElement = HierarchySubsetGetElementName(\
    \ pDim, sHier, sSubsetMDX, nSubsetIndex );\n      HierarchySubsetElementInsert( pDim, sHier,\
    \ pSub, sElement, nSubsetIndex );\n    End;\n  EndIf;\n\nEndIf;\n\n### Set Alias ##\nIF(pAlias\
    \ @<> '' );\n  If( nErrors = 0 );\n    HierarchySubsetAliasSet( pDim, pHier, pSub, pAlias\
    \ );\n  EndIf;\nENDIF;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der öffentliche Teilmengen aus ausgewählten
    Dimensionen und Hierarchien löscht. Die Dimensionen, Hierarchien und Teilmengen können als
    durch ein Trennzeichen geteilte Liste angegeben werden. Platzhalter in Form von ''*'' und
    ''?'' sind akzeptiert. Beachte die folgenden Parameter: pDim, um die Dimensionen anzugeben,
    von denen Teilmengen gelöscht werden sollen; pHier, um anzugeben, von welchen Hierarchien
    die Teilmengen gelöscht werden sollen; pSub, um die zu löschenden Teilmengen zu spezifizieren;
    pDelim, um einen benutzerdefinierten Trennzeichen zu definieren; und pMode, um entweder
    alle gefundenen Teilmengen zu zerstören oder nur zu leeren. Stelle sicher, dass du die Bedeutung
    und Verwendung jedes Parameters verstehst und Beispiele für die Platzhaltersuche bereitstellst.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes public subsets from selected dimension\
    \ and hierarchies. Dimensions, hierarchies\n# and subsets can be specified as a delimited\
    \ list. Wildcards are accepted as `*` and `?` characters.\n\n# Note:\n# - pDim: To specify\
    \ which dimensions to delete subsets from use the pDim parameter.\n#   - To delete subsets\
    \ from a single dimension only just specify that dimension name e.g. `Product`.\n#   - To\
    \ delete subsets from multiple dimensions specify each dimension name separated by a delimiter\n\
    #     e.g. `Product & Customer & Account`.\n#   - To delete subsets from all dimensions\
    \ then leave pDim parameter blank or supply `ALL`.\n#   - If any invalid dimensions are\
    \ specified they will be skipped but the process will continue to \n#     process the other\
    \ dimensions.\n#   - When specifying dimension names wildcards are permitted and all dimensions\
    \ that match the \n#     wildcard search string will be searched - for syntax see below\
    \ pSub parameter.\n# - pHier: To specify which hierarchies to delete subsets from use the\
    \ pHier parameter.\n#   - To specify default hierachy, leave parameter value empty.\n# \
    \  - To specify all available hierarchies, set parameter value to `*`.\n#   - When specifying\
    \ hierarchy names wildcards are permitted and all hierachies that match the wildcard \n\
    #     search string will be searched - for syntax see below pSub parameter.\n# - pSub: To\
    \ specify which subsets to delete use the pSub parameter.\n#   - This parameter must be\
    \ specified, a blank value will cause the process to terminate.\n#   - To delete a single\
    \ subset only just specify that subset name e.g. `SmallProducts`.\n#   - To delete multiple\
    \ subsets specify each subset name separated by a delimiter\n#     e.g. `SmallProducts &\
    \ LargeProducts`.\n# - pDelim: The delimiter is used when specifying multiple dimensions\
    \ and/or multiple subsets.\n#   - The default delimiter is `&`.\n#   - Any delimiter can\
    \ be used by specifying a value for pDelim.\n#   - Choose a delimiter that won't be used\
    \ in either the wildcard search strings or dimension names.\n# - pMode:\n#   - When set\
    \ to value less or equal to `1`: all found subsets will be destroyed.\n#   - When set to\
    \ value of `2`: all found subsets will be emptied.  \n# __Example__:\n# - When specifying\
    \ subset names wildcards are permitted and all subsets that match the wildcard \n#   search\
    \ string will be deleted:\n#     - The wildcard search string follows the same format as\
    \ wildcards used in Subset Editor.\n#     - To delete all subsets that __start__ with a\
    \ specific string use a trailing `*` e.g. `Bedrock*`.\n#     - To delete all subsets that\
    \ __end__ in a specific string use a leading `*` e.g. `*Bedrock`.\n#     - To delete all\
    \ subsets that __contain__ a specific string use leading and trailing `*`'s e.g. `*Bedrock*`.\n\
    #     - To delete a single specific subset only don't use `*`'s at all e.g. `Bedrock`.\n\
    #     - To specify multiple search stings list them all separated by a delimiter e.g. `Bedrock*\
    \ & *Temp & *Test*`.\n#     - Similarly you can use `?` as wildcard specifying one character\
    \ - usage is similar as above specified examples for `*`.\n#     - Specific subset names\
    \ and wildcard based names can both be used together e.g. `SalesByProduct;Bedrock*`\n#EndRegion\
    \ @DOC\n\n### Global Variables\n\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants\n\ncThisProcName     = GetProcessName();\ncTimeStamp\
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cTempSubDim       = cThisProcName |'_Dim_'| cTimeStamp |'_'| cRandomInt;\ncUserName    \
    \     = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pMode:%pMode%.';\ncAll  \
    \            = 'ALL';\ncDimDimensions    = '}Dimensions';\ncCharAny          = '?';\ncStringAny\
    \        = '*';\ncCharDimHier      = ':';\n\n### Flag - quit before parsing of parameters\n\
    nSkipParsing      = 0;\nsProcessAction    = '';\n\n### LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\n\
    \nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim\
    \ ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier   \
    \    = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate delimiter\nIf( Trim( pDelim ) @= ''\
    \ );\n  pDelim = '&';\nEndIf;\n\n### Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\nIf( SCAN( cCharAny, pDim ) = 0 & SCAN( cStringAny, pDim ) = 0 & SCAN(\
    \ pDelim, pDim ) = 0 & SCAN( cCharDimHier, pDim ) > 0 & pHier @= '' );\n    pHier = SubSt(\
    \ pDim, SCAN( cCharDimHier, pDim ) + 1, Long( pDim ) );\n    pDim = SubSt( pDim, 1, SCAN(\
    \ cCharDimHier, pDim ) - 1 );\nEndIf;\n\n## Validate Hierarchy\n\nIF(pHier @= 'Leaves' );\n\
    \  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @<> '' );\n  sHier = pHier;\n\
    EndIf;\n\n### Validate subset\nIf( Trim( pSub ) @= '' );\n  nErrors = 1;\n  sMessage = 'No\
    \ subsets specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  If(\
    \ pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n### Destroy subset if exactly specified in parameters - important for recursive\
    \ calls\nIf ( SCAN( cCharAny, pDim ) = 0 & SCAN( cStringAny, pDim ) = 0 & SCAN( pDelim,\
    \ pDim ) = 0 &\n     SCAN( cCharAny, pHier ) = 0 & SCAN( cStringAny, pHier ) = 0 & SCAN(\
    \ pDelim, pHier ) = 0 &\n     SCAN( cCharAny, pSub ) = 0 & SCAN( cStringAny, pSub ) = 0\
    \ & SCAN( pDelim, pSub ) = 0 );\n  If ( DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n\
    \    sMessage = Expand( 'Dimension %pDim% doesn''t exist.' );\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    Else;\n        ProcessBreak;\n    EndIf;\n  EndIf;\n  If ( pHier @<> '' & HierarchyExists(\
    \ pDim, pHier ) = 0 );\n    nErrors = 1;\n    sMessage = Expand( 'Hierarchy %pHier% doesn''t\
    \ exist in dimension %pDim%.' );\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n       \
    \ ProcessBreak;\n    EndIf;\n  EndIf;\n  If ( HierarchySubsetExists( pDim, pHier, pSub )\
    \ = 0 );\n    nErrors = 1;\n    sMessage = Expand( 'Subset %pSub% doesn''t exist in hierarchy\
    \ %pHier% of dimension %pDim%.' );\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n       \
    \ ProcessBreak;\n    EndIf;\n  EndIf;\n  If ( pHier @= '' );\n    pHier = pDim;\n  EndIf;\n\
    \  If ( pMode <= 1 );\n    HierarchySubsetDestroy( pDim, pHier, pSub );\n    sProcessAction\
    \ = Expand( 'Destroyed subset %pSub% on dimension %pDim% in hierarchy %pHier%.' );\n  ElseIf\
    \ ( pMode = 2 );\n    HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\n    sProcessAction\
    \ = Expand( 'Deleted all elements from subset %pSub% on dimension %pDim% in hierarchy %pHier%.'\
    \ );\n  EndIf;\n  ### We don't need to parse any parameters as this was exact match, so\
    \ we will finish processing\n  nSkipParsing = 1;\nEndIf;\n\n### Need to process parameters\
    \ before cleaning\nIf ( nSkipParsing = 0 );\n  \n  ### Validate all dimension case\n  If(\
    \ Trim( pDim ) @= '*' );\n    pDim = cAll;\n  EndIf;\n  \n  ### Handle All dimensions or\
    \ a dimension list\n  ### We will exclude hierarchies in this step and will filter them\
    \ in connection with subsets in later steps\n  If ( TRIM( pDim ) @= cAll );\n    sMDX =\
    \ Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}' );\n  Else;\n    sDimTokenizer = TRIM( pDim );\n    sMDX = '';\n    ###\
    \ Loop and tokenize dimension list\n    While ( sDimTokenizer @<> '' );\n      nPos = SCAN(\
    \ pDelim, sDimTokenizer );\n      If ( nPos = 0 );\n        nPos = LONG( sDimTokenizer )\
    \ + 1;\n      EndIf;\n      sSearchDim = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n\
    \      If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n  \
    \    Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n  \
    \    EndIf;\n      ### Consume dimension and delimiter\n      sDimTokenizer = TRIM( DELET(\
    \ sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n    End;\n    sMDX = Expand( '{%sMDX%}'\
    \ );\n  EndIf;\n  \n  ### Create dimensions subset\n  If ( SubsetExists( cDimDimensions,\
    \ cTempSub ) = 1 );\n    SubsetMDXSet( cDimDimensions, cTempSub, sMDX );\n  Else;\n    SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cDimDimensions, 1 );\n  EndIf;\n  nMaxDim = SubsetGetSize( cDimDimensions,\
    \ cTempSub );\n  \n  ### Loop through dimensions\n  nCurDim = 1;\n  While ( nCurDim <= nMaxDim\
    \ );\n    sCurDim = SubsetGetElementName( cDimDimensions, cTempSub, nCurDim );\n    sCurSubDim\
    \ = Expand( '}Subsets_%sCurDim%' );\n    ### We will lookup subsets in }Subsets_ dimension\
    \ of current dim\n    If ( DimensionExists( sCurSubDim ) <> 0 );\n      If ( pHier @= ''\
    \ );\n        sHier = sCurDim;\n      Else;\n        sHier = pHier;\n      EndIf;\n    \
    \  sHierTokenizer = TRIM( sHier );\n      sMDX = '';\n      ### Loop and tokenize hierarchies\
    \ list\n      While ( sHierTokenizer @<> '' );\n        nPos = SCAN( pDelim, sHierTokenizer\
    \ );\n        If ( nPos = 0 );\n          nPos = LONG( sHierTokenizer ) + 1;\n        EndIf;\n\
    \        sSearchHier = TRIM( SUBST( sHierTokenizer, 1, nPos - 1 ) );\n        sSubTokenizer\
    \ = TRIM( pSub );\n        ### Loop and tokenize subset list\n        While ( sSubTokenizer\
    \ @<> '' );\n          nPos1 = SCAN( pDelim, sSubTokenizer );\n          If ( nPos1 = 0\
    \ );\n            nPos1 = LONG( sSubTokenizer ) + 1;\n          EndIf;\n          sSearchSubset\
    \ = TRIM( SUBST( sSubTokenizer, 1, nPos1 - 1 ) );\n          If ( sSearchHier @<> '*' );\n\
    \            If ( sSearchHier @= sCurDim );\n              sSearchMDX = sSearchSubset;\n\
    \            Else;\n              sSearchMDX = Expand( '%sSearchHier%:%sSearchSubset%' );\n\
    \            EndIf;\n            If( sMDX @= '' );\n              sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL(\
    \ [%sCurSubDim%] ), '%sSearchMDX%')}' );\n            Else;\n              sMDX = Expand(\
    \ '%sMDX% + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX%')}' );\n \
    \           EndIf;\n          Else;\n            # We need to handle special case of * specified\
    \ as hierarchy filter - this is interpreted as ALL hierarchies - otherwise we would be skipping\
    \ default hierarchy\n            sSearchMDX1 = Expand( '%sSearchHier%:%sSearchSubset%' );\n\
    \            sSearchMDX2 = Expand( '%sSearchSubset%' );\n            If( sMDX @= '' );\n\
    \              sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX1%')}\
    \ + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX2%')}' );\n        \
    \    Else;\n              sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%]\
    \ ), '%sSearchMDX1%')} + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX2%')}'\
    \ );\n            EndIf;\n          EndIf;\n          ### Consume subset and delimiter\n\
    \          sSubTokenizer = TRIM( DELET( sSubTokenizer, 1, nPos1 + LONG( pDelim ) - 1 ) );\n\
    \        End;\n        ### Consume hierarchy and delimiter\n        sHierTokenizer = TRIM(\
    \ DELET( sHierTokenizer, 1, nPos + LONG( pDelim )- 1 ) );\n      End;\n      ### Query the\
    \ hierarchies/subsets\n      If ( SubsetExists( sCurSubDim, cTempSub ) = 1 );\n        SubsetMDXSet(\
    \ sCurSubDim, cTempSub, sMDX );\n      Else;\n        SubsetCreatebyMDX( cTempSub, sMDX,\
    \ sCurSubDim, 1 );\n      EndIf;\n      nMaxSubs = SubsetGetSize( sCurSubDim, cTempSub );\n\
    \      nCurSubs = nMaxSubs;\n      While ( nCurSubs >= 1 );\n        sCurSubs = SubsetGetElementName(\
    \ sCurSubDim, cTempSub, nCurSubs );\n        nColPos = SCAN( ':', sCurSubs );\n        If\
    \ ( nColPos = 0 );\n          sHierarchy = sCurDim;\n          sSubset = sCurSubs;\n   \
    \     Else;\n          sHierarchy = SUBST( sCurSubs, 1, nColPos - 1 );\n          sSubset\
    \ = SUBST( sCurSubs, nColPos + 1, LONG(sCurSubs) - nColPos ); \n        EndIf;\n       \
    \ If ( pMode <= 1 );\n          ### Recursive call to consume process error in this process\
    \ and not to broadcast it to the parent caller process\n          ExecuteProcess( cThisProcName,\n\
    \            'pStrictErrorHandling', pStrictErrorHandling,\n            'pLogOutput', pLogOutput,\n\
    \            'pDim', sCurDim,\n            'pHier', sHierarchy,\n            'pSub', sSubset,\n\
    \            'pDelim', pDelim,\n            'pMode', pMode\n          );\n        ElseIf\
    \ ( pMode = 2 );\n          ### No need for a recursive call as we suppose this call is\
    \ not going to raise a process error - this will save processing time significantly\n  \
    \        HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\n          sProcessAction\
    \ = Expand( 'Deleted all elements from subset %pSub% on dimension %pDim% in hierarchy %pHier%.'\
    \ );\n        EndIf;  \n        nCurSubs = nCurSubs - 1;\n      End;\n    EndIf;\n    nCurDim\
    \ = nCurDim + 1;\n  End;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted subset\
    \ %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Develop an IBM Turbo Integrator process that deletes public subsets from selected
    dimensions and hierarchies. Dimensions, hierarchies, and subsets can be specified as a delimited
    list, with wildcards accepted in the form of ''*'' and ''?''. Note the following parameters:
    pDim for specifying the dimensions from which subsets should be deleted; pHier for specifying
    the hierarchies from which subsets should be deleted; pSub to specify the subsets to be
    deleted; pDelim to define a custom delimiter; and pMode to either destroy or just empty
    all found subsets. Ensure you understand the significance and usage of each parameter and
    provide examples for wildcard searches.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes public subsets from selected dimension\
    \ and hierarchies. Dimensions, hierarchies\n# and subsets can be specified as a delimited\
    \ list. Wildcards are accepted as `*` and `?` characters.\n\n# Note:\n# - pDim: To specify\
    \ which dimensions to delete subsets from use the pDim parameter.\n#   - To delete subsets\
    \ from a single dimension only just specify that dimension name e.g. `Product`.\n#   - To\
    \ delete subsets from multiple dimensions specify each dimension name separated by a delimiter\n\
    #     e.g. `Product & Customer & Account`.\n#   - To delete subsets from all dimensions\
    \ then leave pDim parameter blank or supply `ALL`.\n#   - If any invalid dimensions are\
    \ specified they will be skipped but the process will continue to \n#     process the other\
    \ dimensions.\n#   - When specifying dimension names wildcards are permitted and all dimensions\
    \ that match the \n#     wildcard search string will be searched - for syntax see below\
    \ pSub parameter.\n# - pHier: To specify which hierarchies to delete subsets from use the\
    \ pHier parameter.\n#   - To specify default hierachy, leave parameter value empty.\n# \
    \  - To specify all available hierarchies, set parameter value to `*`.\n#   - When specifying\
    \ hierarchy names wildcards are permitted and all hierachies that match the wildcard \n\
    #     search string will be searched - for syntax see below pSub parameter.\n# - pSub: To\
    \ specify which subsets to delete use the pSub parameter.\n#   - This parameter must be\
    \ specified, a blank value will cause the process to terminate.\n#   - To delete a single\
    \ subset only just specify that subset name e.g. `SmallProducts`.\n#   - To delete multiple\
    \ subsets specify each subset name separated by a delimiter\n#     e.g. `SmallProducts &\
    \ LargeProducts`.\n# - pDelim: The delimiter is used when specifying multiple dimensions\
    \ and/or multiple subsets.\n#   - The default delimiter is `&`.\n#   - Any delimiter can\
    \ be used by specifying a value for pDelim.\n#   - Choose a delimiter that won't be used\
    \ in either the wildcard search strings or dimension names.\n# - pMode:\n#   - When set\
    \ to value less or equal to `1`: all found subsets will be destroyed.\n#   - When set to\
    \ value of `2`: all found subsets will be emptied.  \n# __Example__:\n# - When specifying\
    \ subset names wildcards are permitted and all subsets that match the wildcard \n#   search\
    \ string will be deleted:\n#     - The wildcard search string follows the same format as\
    \ wildcards used in Subset Editor.\n#     - To delete all subsets that __start__ with a\
    \ specific string use a trailing `*` e.g. `Bedrock*`.\n#     - To delete all subsets that\
    \ __end__ in a specific string use a leading `*` e.g. `*Bedrock`.\n#     - To delete all\
    \ subsets that __contain__ a specific string use leading and trailing `*`'s e.g. `*Bedrock*`.\n\
    #     - To delete a single specific subset only don't use `*`'s at all e.g. `Bedrock`.\n\
    #     - To specify multiple search stings list them all separated by a delimiter e.g. `Bedrock*\
    \ & *Temp & *Test*`.\n#     - Similarly you can use `?` as wildcard specifying one character\
    \ - usage is similar as above specified examples for `*`.\n#     - Specific subset names\
    \ and wildcard based names can both be used together e.g. `SalesByProduct;Bedrock*`\n#EndRegion\
    \ @DOC\n\n### Global Variables\n\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants\n\ncThisProcName     = GetProcessName();\ncTimeStamp\
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cTempSubDim       = cThisProcName |'_Dim_'| cTimeStamp |'_'| cRandomInt;\ncUserName    \
    \     = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pMode:%pMode%.';\ncAll  \
    \            = 'ALL';\ncDimDimensions    = '}Dimensions';\ncCharAny          = '?';\ncStringAny\
    \        = '*';\ncCharDimHier      = ':';\n\n### Flag - quit before parsing of parameters\n\
    nSkipParsing      = 0;\nsProcessAction    = '';\n\n### LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\n\
    \nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim\
    \ ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier   \
    \    = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate delimiter\nIf( Trim( pDelim ) @= ''\
    \ );\n  pDelim = '&';\nEndIf;\n\n### Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\nIf( SCAN( cCharAny, pDim ) = 0 & SCAN( cStringAny, pDim ) = 0 & SCAN(\
    \ pDelim, pDim ) = 0 & SCAN( cCharDimHier, pDim ) > 0 & pHier @= '' );\n    pHier = SubSt(\
    \ pDim, SCAN( cCharDimHier, pDim ) + 1, Long( pDim ) );\n    pDim = SubSt( pDim, 1, SCAN(\
    \ cCharDimHier, pDim ) - 1 );\nEndIf;\n\n## Validate Hierarchy\n\nIF(pHier @= 'Leaves' );\n\
    \  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @<> '' );\n  sHier = pHier;\n\
    EndIf;\n\n### Validate subset\nIf( Trim( pSub ) @= '' );\n  nErrors = 1;\n  sMessage = 'No\
    \ subsets specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  If(\
    \ pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n### Destroy subset if exactly specified in parameters - important for recursive\
    \ calls\nIf ( SCAN( cCharAny, pDim ) = 0 & SCAN( cStringAny, pDim ) = 0 & SCAN( pDelim,\
    \ pDim ) = 0 &\n     SCAN( cCharAny, pHier ) = 0 & SCAN( cStringAny, pHier ) = 0 & SCAN(\
    \ pDelim, pHier ) = 0 &\n     SCAN( cCharAny, pSub ) = 0 & SCAN( cStringAny, pSub ) = 0\
    \ & SCAN( pDelim, pSub ) = 0 );\n  If ( DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n\
    \    sMessage = Expand( 'Dimension %pDim% doesn''t exist.' );\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    Else;\n        ProcessBreak;\n    EndIf;\n  EndIf;\n  If ( pHier @<> '' & HierarchyExists(\
    \ pDim, pHier ) = 0 );\n    nErrors = 1;\n    sMessage = Expand( 'Hierarchy %pHier% doesn''t\
    \ exist in dimension %pDim%.' );\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n       \
    \ ProcessBreak;\n    EndIf;\n  EndIf;\n  If ( HierarchySubsetExists( pDim, pHier, pSub )\
    \ = 0 );\n    nErrors = 1;\n    sMessage = Expand( 'Subset %pSub% doesn''t exist in hierarchy\
    \ %pHier% of dimension %pDim%.' );\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n       \
    \ ProcessBreak;\n    EndIf;\n  EndIf;\n  If ( pHier @= '' );\n    pHier = pDim;\n  EndIf;\n\
    \  If ( pMode <= 1 );\n    HierarchySubsetDestroy( pDim, pHier, pSub );\n    sProcessAction\
    \ = Expand( 'Destroyed subset %pSub% on dimension %pDim% in hierarchy %pHier%.' );\n  ElseIf\
    \ ( pMode = 2 );\n    HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\n    sProcessAction\
    \ = Expand( 'Deleted all elements from subset %pSub% on dimension %pDim% in hierarchy %pHier%.'\
    \ );\n  EndIf;\n  ### We don't need to parse any parameters as this was exact match, so\
    \ we will finish processing\n  nSkipParsing = 1;\nEndIf;\n\n### Need to process parameters\
    \ before cleaning\nIf ( nSkipParsing = 0 );\n  \n  ### Validate all dimension case\n  If(\
    \ Trim( pDim ) @= '*' );\n    pDim = cAll;\n  EndIf;\n  \n  ### Handle All dimensions or\
    \ a dimension list\n  ### We will exclude hierarchies in this step and will filter them\
    \ in connection with subsets in later steps\n  If ( TRIM( pDim ) @= cAll );\n    sMDX =\
    \ Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}' );\n  Else;\n    sDimTokenizer = TRIM( pDim );\n    sMDX = '';\n    ###\
    \ Loop and tokenize dimension list\n    While ( sDimTokenizer @<> '' );\n      nPos = SCAN(\
    \ pDelim, sDimTokenizer );\n      If ( nPos = 0 );\n        nPos = LONG( sDimTokenizer )\
    \ + 1;\n      EndIf;\n      sSearchDim = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n\
    \      If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n  \
    \    Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n  \
    \    EndIf;\n      ### Consume dimension and delimiter\n      sDimTokenizer = TRIM( DELET(\
    \ sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n    End;\n    sMDX = Expand( '{%sMDX%}'\
    \ );\n  EndIf;\n  \n  ### Create dimensions subset\n  If ( SubsetExists( cDimDimensions,\
    \ cTempSub ) = 1 );\n    SubsetMDXSet( cDimDimensions, cTempSub, sMDX );\n  Else;\n    SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cDimDimensions, 1 );\n  EndIf;\n  nMaxDim = SubsetGetSize( cDimDimensions,\
    \ cTempSub );\n  \n  ### Loop through dimensions\n  nCurDim = 1;\n  While ( nCurDim <= nMaxDim\
    \ );\n    sCurDim = SubsetGetElementName( cDimDimensions, cTempSub, nCurDim );\n    sCurSubDim\
    \ = Expand( '}Subsets_%sCurDim%' );\n    ### We will lookup subsets in }Subsets_ dimension\
    \ of current dim\n    If ( DimensionExists( sCurSubDim ) <> 0 );\n      If ( pHier @= ''\
    \ );\n        sHier = sCurDim;\n      Else;\n        sHier = pHier;\n      EndIf;\n    \
    \  sHierTokenizer = TRIM( sHier );\n      sMDX = '';\n      ### Loop and tokenize hierarchies\
    \ list\n      While ( sHierTokenizer @<> '' );\n        nPos = SCAN( pDelim, sHierTokenizer\
    \ );\n        If ( nPos = 0 );\n          nPos = LONG( sHierTokenizer ) + 1;\n        EndIf;\n\
    \        sSearchHier = TRIM( SUBST( sHierTokenizer, 1, nPos - 1 ) );\n        sSubTokenizer\
    \ = TRIM( pSub );\n        ### Loop and tokenize subset list\n        While ( sSubTokenizer\
    \ @<> '' );\n          nPos1 = SCAN( pDelim, sSubTokenizer );\n          If ( nPos1 = 0\
    \ );\n            nPos1 = LONG( sSubTokenizer ) + 1;\n          EndIf;\n          sSearchSubset\
    \ = TRIM( SUBST( sSubTokenizer, 1, nPos1 - 1 ) );\n          If ( sSearchHier @<> '*' );\n\
    \            If ( sSearchHier @= sCurDim );\n              sSearchMDX = sSearchSubset;\n\
    \            Else;\n              sSearchMDX = Expand( '%sSearchHier%:%sSearchSubset%' );\n\
    \            EndIf;\n            If( sMDX @= '' );\n              sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL(\
    \ [%sCurSubDim%] ), '%sSearchMDX%')}' );\n            Else;\n              sMDX = Expand(\
    \ '%sMDX% + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX%')}' );\n \
    \           EndIf;\n          Else;\n            # We need to handle special case of * specified\
    \ as hierarchy filter - this is interpreted as ALL hierarchies - otherwise we would be skipping\
    \ default hierarchy\n            sSearchMDX1 = Expand( '%sSearchHier%:%sSearchSubset%' );\n\
    \            sSearchMDX2 = Expand( '%sSearchSubset%' );\n            If( sMDX @= '' );\n\
    \              sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX1%')}\
    \ + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX2%')}' );\n        \
    \    Else;\n              sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%]\
    \ ), '%sSearchMDX1%')} + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX2%')}'\
    \ );\n            EndIf;\n          EndIf;\n          ### Consume subset and delimiter\n\
    \          sSubTokenizer = TRIM( DELET( sSubTokenizer, 1, nPos1 + LONG( pDelim ) - 1 ) );\n\
    \        End;\n        ### Consume hierarchy and delimiter\n        sHierTokenizer = TRIM(\
    \ DELET( sHierTokenizer, 1, nPos + LONG( pDelim )- 1 ) );\n      End;\n      ### Query the\
    \ hierarchies/subsets\n      If ( SubsetExists( sCurSubDim, cTempSub ) = 1 );\n        SubsetMDXSet(\
    \ sCurSubDim, cTempSub, sMDX );\n      Else;\n        SubsetCreatebyMDX( cTempSub, sMDX,\
    \ sCurSubDim, 1 );\n      EndIf;\n      nMaxSubs = SubsetGetSize( sCurSubDim, cTempSub );\n\
    \      nCurSubs = nMaxSubs;\n      While ( nCurSubs >= 1 );\n        sCurSubs = SubsetGetElementName(\
    \ sCurSubDim, cTempSub, nCurSubs );\n        nColPos = SCAN( ':', sCurSubs );\n        If\
    \ ( nColPos = 0 );\n          sHierarchy = sCurDim;\n          sSubset = sCurSubs;\n   \
    \     Else;\n          sHierarchy = SUBST( sCurSubs, 1, nColPos - 1 );\n          sSubset\
    \ = SUBST( sCurSubs, nColPos + 1, LONG(sCurSubs) - nColPos ); \n        EndIf;\n       \
    \ If ( pMode <= 1 );\n          ### Recursive call to consume process error in this process\
    \ and not to broadcast it to the parent caller process\n          ExecuteProcess( cThisProcName,\n\
    \            'pStrictErrorHandling', pStrictErrorHandling,\n            'pLogOutput', pLogOutput,\n\
    \            'pDim', sCurDim,\n            'pHier', sHierarchy,\n            'pSub', sSubset,\n\
    \            'pDelim', pDelim,\n            'pMode', pMode\n          );\n        ElseIf\
    \ ( pMode = 2 );\n          ### No need for a recursive call as we suppose this call is\
    \ not going to raise a process error - this will save processing time significantly\n  \
    \        HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\n          sProcessAction\
    \ = Expand( 'Deleted all elements from subset %pSub% on dimension %pDim% in hierarchy %pHier%.'\
    \ );\n        EndIf;  \n        nCurSubs = nCurSubs - 1;\n      End;\n    EndIf;\n    nCurDim\
    \ = nCurDim + 1;\n  End;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted subset\
    \ %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der es ermöglicht, bestimmte Elemente
    aus einer Teilmenge in einer Hierarchie der Ziel-Dimension zu entfernen. Beachte, dass Platzhalterzeichen
    wie `*` und `?` in der Liste der auszuschließenden Elemente akzeptiert werden. Wenn ein
    Element auf Blattebene angegeben wird, wird es eigenständig entfernt. Bei Angabe eines konsolidierten
    Elements wird es zusammen mit seinen Nachkommen entfernt. Vorsicht: Die Zielhierarchie darf
    nicht ''Leaves'' sein.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will remove specified elements from a subset\
    \ in a Hierarchy of target Dimension.\n# Wildcard characters `*`and `?` are accepted in\
    \ list of elements to be excluded.\n\n# Note:\n# - If a leaf level element is specified,\
    \ it will be removed on its own.\n# - If a consolidated element is specified it will be\
    \ removed as well as its descendants.\n\n# Caution: Target hierarchy cannot be `Leaves`.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%,\
    \ pExclusions:%pExclusions%, pDelim:%pDelim%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_'\
    \ | pDim;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':',\
    \ pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the\
    \ input error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt(\
    \ pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan(\
    \ ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \ dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n## Validate Hierarchy\n\nIF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\n\
    EndIf;\n\nIf( HierarchyExists( pDim, sHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'The Hierachy\
    \ ' | sHier | ' does not exists.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pSub ) @= '' );\n  nErrors = 1;\n  sMessage\
    \ = 'No subset specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\nIf( HierarchySubsetExists( pDim,sHier, pSub ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'Invalid subset: ' | pSub | ' in dimension:Hierarchy ' | pDim |':' | sHier;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Elements\nIf( Trim(\
    \ pExclusions ) @= '' );\n  nErrors = 1;\n  sMessage = 'No Elements specified';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate delimiter\nIf( pExclusions\
    \ @<> '' & pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0\
    \ & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0\
    \ or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Process Elements ###\nIf(nErrors = 0);\n  nDelimIndex = 1;\n  sExclusions = pExclusions;\n\
    \n  While( nDelimIndex <> 0 & Long( sExclusions ) > 0 );\n\n    nDelimIndex = Scan( pDelim,\
    \ sExclusions );\n    If( nDelimIndex <> 0 );\n      sExclusion = Trim( SubSt( sExclusions,\
    \ 1, nDelimIndex - 1 ) );\n      sExclusions = Trim( SubSt( sExclusions, nDelimIndex + Long(\
    \ pDelim ), Long( sExclusions ) ) );\n    Else;\n      sExclusion = Trim( sExclusions );\n\
    \    EndIf;\n    If(Scan('*',sExclusion) = 0 & Scan('?',sExclusion) = 0);\n      # Check\
    \ that Element is present in the dimension\n      If( ElementIndex ( pDim, sHier, sExclusion\
    \ ) <> 0 );\n        sExclusion = HierarchyElementPrincipalName( pDim, sHier, sExclusion\
    \ );\n        # Work through subset and remove Element\n        nSubsetIndex = 1;\n    \
    \    nSubsetSize = HierarchySubsetGetSize( pDim, sHier, pSub );\n        While( nSubsetIndex\
    \ <= nSubsetSize );\n          sTemp = HierarchySubsetElementGetIndex (pDim, sHier, pSub,\
    \ '', nSubsetIndex);\n          sElement = HierarchySubsetGetElementName( pDim, sHier, pSub,\
    \ nSubsetIndex );\n          # If Element is found or a descendant of the Element is found\
    \ the remove from subset\n          If( sElement @= sExclusion % ElementIsAncestor( pDim,\
    \ sHier, sExclusion, sElement ) = 1 );\n            sTemp = HierarchySubsetElementGetIndex\
    \ (pDim, sHier, pSub, '', nSubsetIndex);\n            HierarchySubsetElementDelete ( pDim,\
    \ sHier, pSub, nSubsetIndex );\n            nSubsetSize = nSubsetSize - 1;\n          Else;\n\
    \            nSubsetIndex = nSubsetIndex + 1;\n          EndIf;\n        End;\n      \n\
    \      EndIf;\n    Else;\n      # Wildcard search string\n        sExclusion = '''|sExclusion|''';\n\
    \        stempSub = cThisProcName| cRandomInt;\n        sProc = '}bedrock.hier.sub.create.bymdx';\n\
    \        sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |pDim|':'|sHier |' ])},'| sExclusion|\
    \ ')}';\n        ExecuteProcess(sProc,\n                      'pStrictErrorHandling', pStrictErrorHandling,\n\
    \                    \t'pDim',pDim,\n                    \t'pHier',sHier,\n            \
    \        \t'pSub',stempSub,\n                    \t'pMDXExpr',sMdx,\n                  \
    \  \t'pConvertToStatic',1,\n                    \t'pTemp', pTemp);\n        nSubsetindex\
    \ = 1;\n        nSubsetSize = HierarchySubsetGetSize(pDim, sHier, stempSub);\n        While\
    \ (nSubsetindex <= nSubsetSize);\n          sTemp = HierarchySubsetElementGetIndex (pDim,\
    \ sHier, stempSub, '', nSubsetIndex);\n          sElement = HierarchySubsetGetElementName(pDim,\
    \ sHier, stempSub, nSubsetindex);\n          HierarchySubsetElementDelete( pDim, sHier,stempSub,nSubsetindex\
    \ );\n          nSubsetSize = nSubsetSize -1;\n          ## Delete Element from main subset\n\
    \          If(HierarchySubsetElementExists(pDim, sHier, pSub, sElement)>0);\n          \
    \  nSearchIndex = 1;\n            nSearchSize = HierarchySubsetGetSize(pDim, sHier, pSub);\n\
    \            While( nSearchIndex <= nSearchSize  );\n              sSearchElement = HierarchySubsetGetElementName(\
    \ pDim, sHier, pSub, nSearchIndex );\n               # If Element is found or a descendant\
    \ of the Element is found the remove from subset\n                If( sElement @= sSearchElement\
    \ % ElementIsAncestor( pDim, sHier, sElement, sSearchElement ) = 1 );\n                \
    \  sTemp = HierarchySubsetElementGetIndex (pDim, sHier, pSub, '', nSearchIndex);\n     \
    \             HierarchySubsetElementDelete ( pDim, sHier, pSub, nSearchIndex );\n      \
    \            nSearchSize = 0;\n                Else;\n                  nSearchIndex = nSearchIndex\
    \ + 1;\n                EndIf;\n            End;\n          Endif;\n          ######\n \
    \       End;\n        HierarchySubsetDestroy(pDim, sHier,stempSub);\n    EndIf;\n\n  End;\n\
    \nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully excluded elements from subset %pSub% from\
    \ dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that allows for removing specified elements
    from a subset in a hierarchy of the target dimension. Note that wildcard characters like
    `*` and `?` are accepted in the list of elements to be excluded. If a leaf level element
    is specified, it will be removed on its own. If a consolidated element is specified, it
    will be removed along with its descendants. Caution: The target hierarchy cannot be ''Leaves''.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will remove specified elements from a subset\
    \ in a Hierarchy of target Dimension.\n# Wildcard characters `*`and `?` are accepted in\
    \ list of elements to be excluded.\n\n# Note:\n# - If a leaf level element is specified,\
    \ it will be removed on its own.\n# - If a consolidated element is specified it will be\
    \ removed as well as its descendants.\n\n# Caution: Target hierarchy cannot be `Leaves`.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent \
    \   = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%,\
    \ pExclusions:%pExclusions%, pDelim:%pDelim%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_'\
    \ | pDim;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':',\
    \ pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the\
    \ input error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt(\
    \ pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan(\
    \ ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \ dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n## Validate Hierarchy\n\nIF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\n\
    EndIf;\n\nIf( HierarchyExists( pDim, sHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'The Hierachy\
    \ ' | sHier | ' does not exists.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pSub ) @= '' );\n  nErrors = 1;\n  sMessage\
    \ = 'No subset specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\nIf( HierarchySubsetExists( pDim,sHier, pSub ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'Invalid subset: ' | pSub | ' in dimension:Hierarchy ' | pDim |':' | sHier;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Elements\nIf( Trim(\
    \ pExclusions ) @= '' );\n  nErrors = 1;\n  sMessage = 'No Elements specified';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate delimiter\nIf( pExclusions\
    \ @<> '' & pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0\
    \ & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0\
    \ or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Process Elements ###\nIf(nErrors = 0);\n  nDelimIndex = 1;\n  sExclusions = pExclusions;\n\
    \n  While( nDelimIndex <> 0 & Long( sExclusions ) > 0 );\n\n    nDelimIndex = Scan( pDelim,\
    \ sExclusions );\n    If( nDelimIndex <> 0 );\n      sExclusion = Trim( SubSt( sExclusions,\
    \ 1, nDelimIndex - 1 ) );\n      sExclusions = Trim( SubSt( sExclusions, nDelimIndex + Long(\
    \ pDelim ), Long( sExclusions ) ) );\n    Else;\n      sExclusion = Trim( sExclusions );\n\
    \    EndIf;\n    If(Scan('*',sExclusion) = 0 & Scan('?',sExclusion) = 0);\n      # Check\
    \ that Element is present in the dimension\n      If( ElementIndex ( pDim, sHier, sExclusion\
    \ ) <> 0 );\n        sExclusion = HierarchyElementPrincipalName( pDim, sHier, sExclusion\
    \ );\n        # Work through subset and remove Element\n        nSubsetIndex = 1;\n    \
    \    nSubsetSize = HierarchySubsetGetSize( pDim, sHier, pSub );\n        While( nSubsetIndex\
    \ <= nSubsetSize );\n          sTemp = HierarchySubsetElementGetIndex (pDim, sHier, pSub,\
    \ '', nSubsetIndex);\n          sElement = HierarchySubsetGetElementName( pDim, sHier, pSub,\
    \ nSubsetIndex );\n          # If Element is found or a descendant of the Element is found\
    \ the remove from subset\n          If( sElement @= sExclusion % ElementIsAncestor( pDim,\
    \ sHier, sExclusion, sElement ) = 1 );\n            sTemp = HierarchySubsetElementGetIndex\
    \ (pDim, sHier, pSub, '', nSubsetIndex);\n            HierarchySubsetElementDelete ( pDim,\
    \ sHier, pSub, nSubsetIndex );\n            nSubsetSize = nSubsetSize - 1;\n          Else;\n\
    \            nSubsetIndex = nSubsetIndex + 1;\n          EndIf;\n        End;\n      \n\
    \      EndIf;\n    Else;\n      # Wildcard search string\n        sExclusion = '''|sExclusion|''';\n\
    \        stempSub = cThisProcName| cRandomInt;\n        sProc = '}bedrock.hier.sub.create.bymdx';\n\
    \        sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |pDim|':'|sHier |' ])},'| sExclusion|\
    \ ')}';\n        ExecuteProcess(sProc,\n                      'pStrictErrorHandling', pStrictErrorHandling,\n\
    \                    \t'pDim',pDim,\n                    \t'pHier',sHier,\n            \
    \        \t'pSub',stempSub,\n                    \t'pMDXExpr',sMdx,\n                  \
    \  \t'pConvertToStatic',1,\n                    \t'pTemp', pTemp);\n        nSubsetindex\
    \ = 1;\n        nSubsetSize = HierarchySubsetGetSize(pDim, sHier, stempSub);\n        While\
    \ (nSubsetindex <= nSubsetSize);\n          sTemp = HierarchySubsetElementGetIndex (pDim,\
    \ sHier, stempSub, '', nSubsetIndex);\n          sElement = HierarchySubsetGetElementName(pDim,\
    \ sHier, stempSub, nSubsetindex);\n          HierarchySubsetElementDelete( pDim, sHier,stempSub,nSubsetindex\
    \ );\n          nSubsetSize = nSubsetSize -1;\n          ## Delete Element from main subset\n\
    \          If(HierarchySubsetElementExists(pDim, sHier, pSub, sElement)>0);\n          \
    \  nSearchIndex = 1;\n            nSearchSize = HierarchySubsetGetSize(pDim, sHier, pSub);\n\
    \            While( nSearchIndex <= nSearchSize  );\n              sSearchElement = HierarchySubsetGetElementName(\
    \ pDim, sHier, pSub, nSearchIndex );\n               # If Element is found or a descendant\
    \ of the Element is found the remove from subset\n                If( sElement @= sSearchElement\
    \ % ElementIsAncestor( pDim, sHier, sElement, sSearchElement ) = 1 );\n                \
    \  sTemp = HierarchySubsetElementGetIndex (pDim, sHier, pSub, '', nSearchIndex);\n     \
    \             HierarchySubsetElementDelete ( pDim, sHier, pSub, nSearchIndex );\n      \
    \            nSearchSize = 0;\n                Else;\n                  nSearchIndex = nSearchIndex\
    \ + 1;\n                EndIf;\n            End;\n          Endif;\n          ######\n \
    \       End;\n        HierarchySubsetDestroy(pDim, sHier,stempSub);\n    EndIf;\n\n  End;\n\
    \nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully excluded elements from subset %pSub% from\
    \ dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der einen Subset in einer Hierarchie
    einer Dimension in eine Datei exportiert. Verwende einen benutzerdefinierten Datensatz-Trennzeichen,
    das entweder durch ein Zeichen oder seinen ASCII-Code spezifiziert wird. Das Format der
    Datei sollte folgendermaßen sein: Die erste Zeile enthält Metadaten der Datei mit einer
    Zusammenfassung der Dimension, der Hierarchie, des Subset-Namens, der Anzahl der Elemente
    und dem Datum/Zeitpunkt der Dateierstellung. Die zweite und alle folgenden Zeilen enthalten
    die Elementexportdaten. Beachte, dass ein gültiger Dimensionsname (pDim), Subset-Name (pSub)
    und die Angabe, ob ein Header enthalten sein soll (pTitleRecord), obligatorisch sind, andernfalls
    wird der Prozess abgebrochen. Das Zielverzeichnis (pTgtDir) muss existieren. Falls gewünscht,
    kann ein benutzerdefiniertes Trennzeichen verwendet werden, indem der Parameter pDelim als
    entweder ein genaues Zeichen oder als ein dreistelliger (dezimaler) ASCII-Code spezifiziert
    wird. Beispielsweise kann für ein TAB als Trennzeichen 009 genutzt werden.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Export a subset in a Hierarchy of a\
    \ Dimension to a file. Custom record delimiter\n# (specified by a character or its ASCII\
    \ code) can be used.\n# __Format of the file:__  \n# - 1st line: File metadata contains\
    \ summary information about the dimension, hierarchy, subset\n#   name, number of elements\
    \ and date/time when file was generated.\n# - 2nd line and forth: Elements export data.\n\
    \n# Note:\n# Valid dimension name (pDim), subset name (pSub), inclusion of header (pTitleRecord)\n\
    # are mandatory otherwise the process will abort. Target folder (pTgtDir) must exist.\n\
    # If needed, custom delimiter might be used by specifying parameter pDelim value as either\
    \ exactly one\n# character or as a 3-digit (decimal) ASCII code. For example to use TAB\
    \ as a delimiter, use 009.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%, pTitleRecord:%pTitleRecord%.';\
    \ \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncLenASCIICode       = 3;\n\npDelim\
    \ = TRIM(pDelim);\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\nIf(\
    \ Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier   \
    \    = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n\
    \  nErrors = 1;\n  sMessage = 'No dimension specified';\n  DataSourceType = 'NULL';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0\
    \ );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  DataSourceType = 'NULL';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate hierarchy\n\
    IF( Trim(pHier) @= '' );\n  pHier = pDim;\nEndIf;\n\nIF(\nHierarchyExists(pDim, pHier )\
    \ = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid Source Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\n\
    If( Trim( pSub ) @= '' );\n  nErrors = 1;\n  sMessage = 'No subset specified';\n    DataSourceType\
    \ = 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( HierarchySubsetExists(\
    \ pDim, pHier, pSub ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid subset: ' | pSub | '\
    \ in dimension:Hierarchy ' | pDim |':' | pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2,\
    \ 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n# Validate file path\n# Strip off trailing backslash (if present)\nIf(\
    \ SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n  pTgtDir = SubSt( pTgtDir, 1, Long(\
    \ pTgtDir ) - 1 );\nEndIf;\nIf( FileExists( pTgtDir ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'Invalid export path specified. Folder does not exist.';\n  DataSourceType = 'NULL';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npTgtDir = pTgtDir |\
    \ sOSDelim;\n\n# Validate file delimiter & quote character\nIf( pDelim @= '' );\n    pDelim\
    \ = ',';\nElse;\n    # If length of pDelim is exactly 3 chars and each of them is decimal\
    \ digit, then the pDelim is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim)\
    \ = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n      \
    \  If( CODE( pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim, nChar )<=CODE( '9', 1 ) );\n\
    \          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar\
    \ = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber(\
    \ pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\
    If( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is\
    \ exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII\
    \ code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n  \
    \    While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0',\
    \ 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n\
    \          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n\
    \    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote\
    \ = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate filename\n# If no file\
    \ name then default to Dimension.Subset.Export.csv (or Dimension.Hierarchy.Subset.Export.csv\
    \ in case of alternate hierarchy usage)\nIf( pTgtFile @= '' );\n  If( pHier @= pHier );\n\
    \    pTgtFile = pDim |'.'| pSub |'.Export.csv';\n  Else;\n    pTgtFile = pDim |'.'| pHier\
    \ |'.'| pSub |'.Export.csv';\n  EndIf;\nElse;\n  If( Scan( '.', pTgtFile ) = 0 );\n    #\
    \ No file extension specified\n    pTgtFile = pTgtFile | '.csv';\n  EndIf;\nEndIf;\nsFile\
    \ = pTgtDir | pTgtFile;\n\n# Validate Character Set\nIf(Trim( pCharacterSet ) @= '' );\n\
    \  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n### Initialise & declare variables ###\n\nnRecordCount\
    \ = 0;\n\n### Determine if alias exists ###\n\nsAttributeDim = '}ElementAttributes_' | pDim;\n\
    sAlias = '(no alias)';\nIf( DimensionExists( sAttributeDim ) = 1 );\n  nElementIndex = 1;\n\
    \  nElementCount = DimSiz( sAttributeDim );\n  While( nElementIndex <= nElementCount );\n\
    \    sAttribute = DimNm( sAttributeDim, nElementIndex );\n    If( SubSt( DType( sAttributeDim,\
    \ sAttribute ), 2, 1 ) @= 'A' );\n      sAlias = sAttribute;\n      nElementIndex = nElementCount;\n\
    \    EndIf;\n    nElementIndex = nElementIndex + 1;\n  End;\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Data Source ###\n\nDatasourceNameForServer\
    \ = pDim|':'|pHier;\nDatasourceNameForClient = pDim|':'|pHier;\nDataSourceType = 'SUBSET';\n\
    DatasourceDimensionSubset = pSub;\nDatasourceAsciiDelimiter= pDelim;\nDatasourceAsciiQuoteCharacter\
    \ = pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# Set the output character set\nSetOutputCharacterSet(\
    \ sFile, pCharacterSet );\n\n### Check for error in prolog ###\n\nIf( nErrors <> 0 );\n\
    \  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Check whether to write title records ###\n\nnRecordCount = nRecordCount\
    \ + 1;\n\nIf( nRecordCount = 1 & pTitleRecord = 1 );\n\n  nSubsetSize = HierarchySubSetGetSize(\
    \ pDim, pHier, pSub );\n\n  # Write params\n  TextOutput(\n    sFile,\n    'Export from\
    \ dimension: ' | pDim | ',Hierarchy:'|pHier|',Subset:'|pSub|\n    ', Total elements: ' |\
    \ NumberToString( nSubsetSize ) |\n    '. On ' | Date( Now, 1 ) | ' at ' | Time\n   );\n\
    \  # Write header records\n  TextOutput(\n    sFile,\n    'Subix',\n    'Element',\n   \
    \ 'Alias: ' | sAlias,\n    'Dimix',\n    'El Type',\n    'Level',\n    'Num Children',\n\
    \    'Parent 1',\n    'Weight 1',\n    'Parent 2',\n    'Weight 2',\n    'Parent 3',\n \
    \   'Weight 3',\n    'Parent 4',\n    'Weight 4',\n    'Parent 5',\n    'Weight 5'\n  );\n\
    \nEndIf;\n\n### Write dimension info to flat file ###\nsElement = HierarchyElementPrincipalName(\
    \ pDim, pHier, vElement );\nsSubix = NumberToString( nRecordCount );\nsIndex = NumberToString(\
    \ ElementIndex( pDim, pHier, vElement ) );\nsType = ElementType( pDim, PHier, vElement );\n\
    sLevel = NumberToString( ElementLevel( pDim, pHier, vElement ) );\nsChild = NumberToString(\
    \ ElementComponentCount( pDim, pHier, vElement ) );\nsParent1 = ElementParent( pDim,pHier,\
    \ vElement, 1 );\nsParent2 = ElementParent( pDim,pHier, vElement, 2 );\nsParent3 = ElementParent(\
    \ pDim,pHier, vElement, 3 );\nsParent4 = ElementParent( pDim,pHier, vElement, 4 );\nsParent5\
    \ = ElementParent( pDim,pHier, vElement, 5 );\nsParent6 = ElementParent( pDim,pHier, vElement,\
    \ 6 );\nsParent7 = ElementParent( pDim,pHier, vElement, 7 );\nsParent8 = ElementParent(\
    \ pDim,pHier, vElement, 8 );\nsWeight1 = NumberToString( ElementWeight( pDim, pHier, sParent1,\
    \ vElement ) );\nsWeight2 = NumberToString( ElementWeight( pDim, pHier, sParent2, vElement\
    \ ) );\nsWeight3 = NumberToString( ElementWeight( pDim, pHier, sParent3, vElement ) );\n\
    sWeight4 = NumberToString( ElementWeight( pDim, pHier, sParent4, vElement ) );\nsWeight5\
    \ = NumberToString( ElementWeight( pDim, pHier, sParent5, vElement ) );\nsWeight6 = NumberToString(\
    \ ElementWeight( pDim, pHier, sParent6, vElement ) );\nsWeight7 = NumberToString( ElementWeight(\
    \ pDim, pHier, sParent7, vElement ) );\nsWeight8 = NumberToString( ElementWeight( pDim,\
    \ pHier, sParent8, vElement ) );\n\nIf( sAlias @<> '(no alias)' );\n  sAliasValue = ElementAttrS(\
    \ pDim, pHier, vElement, sAlias );\nElse;\n  sAliasValue = '';\nEndIf;\n\n  TextOutput(\n\
    \    sFile,\n    sSubix,\n    sElement,\n    sAliasValue,\n    sIndex,\n    sType,\n   \
    \ sLevel,\n    sChild,\n    sParent1,\n    sWeight1,\n    sParent2,\n    sWeight2,\n   \
    \ sParent3,\n    sWeight3,\n    sParent4,\n    sWeight4,\n    sParent5,\n    sWeight5,\n\
    \    sParent6,\n    sWeight6,\n    sParent7,\n    sWeight7,\n    sParent8,\n    sWeight8\n\
    \  );\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully exported subset %pSub% from dimension\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that exports a subset in a hierarchy of
    a dimension to a file. Use a custom record delimiter specified by a character or its ASCII
    code. The file format should be as follows: The first line contains file metadata with summary
    information about the dimension, hierarchy, subset name, number of elements, and the date/time
    when the file was generated. The second and subsequent lines contain the elements export
    data. Note that a valid dimension name (pDim), subset name (pSub), and whether to include
    a header (pTitleRecord) are mandatory, otherwise the process will abort. The target folder
    (pTgtDir) must exist. If needed, a custom delimiter might be used by specifying the parameter
    pDelim value as either exactly one character or a 3-digit (decimal) ASCII code. For instance,
    to use TAB as a delimiter, use 009.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Export a subset in a Hierarchy of a\
    \ Dimension to a file. Custom record delimiter\n# (specified by a character or its ASCII\
    \ code) can be used.\n# __Format of the file:__  \n# - 1st line: File metadata contains\
    \ summary information about the dimension, hierarchy, subset\n#   name, number of elements\
    \ and date/time when file was generated.\n# - 2nd line and forth: Elements export data.\n\
    \n# Note:\n# Valid dimension name (pDim), subset name (pSub), inclusion of header (pTitleRecord)\n\
    # are mandatory otherwise the process will abort. Target folder (pTgtDir) must exist.\n\
    # If needed, custom delimiter might be used by specifying parameter pDelim value as either\
    \ exactly one\n# character or as a 3-digit (decimal) ASCII code. For example to use TAB\
    \ as a delimiter, use 009.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%, pTitleRecord:%pTitleRecord%.';\
    \ \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncLenASCIICode       = 3;\n\npDelim\
    \ = TRIM(pDelim);\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\nIf(\
    \ Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier   \
    \    = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n\
    \  nErrors = 1;\n  sMessage = 'No dimension specified';\n  DataSourceType = 'NULL';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0\
    \ );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  DataSourceType = 'NULL';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate hierarchy\n\
    IF( Trim(pHier) @= '' );\n  pHier = pDim;\nEndIf;\n\nIF(\nHierarchyExists(pDim, pHier )\
    \ = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid Source Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\n\
    If( Trim( pSub ) @= '' );\n  nErrors = 1;\n  sMessage = 'No subset specified';\n    DataSourceType\
    \ = 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( HierarchySubsetExists(\
    \ pDim, pHier, pSub ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid subset: ' | pSub | '\
    \ in dimension:Hierarchy ' | pDim |':' | pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2,\
    \ 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n# Validate file path\n# Strip off trailing backslash (if present)\nIf(\
    \ SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n  pTgtDir = SubSt( pTgtDir, 1, Long(\
    \ pTgtDir ) - 1 );\nEndIf;\nIf( FileExists( pTgtDir ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'Invalid export path specified. Folder does not exist.';\n  DataSourceType = 'NULL';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npTgtDir = pTgtDir |\
    \ sOSDelim;\n\n# Validate file delimiter & quote character\nIf( pDelim @= '' );\n    pDelim\
    \ = ',';\nElse;\n    # If length of pDelim is exactly 3 chars and each of them is decimal\
    \ digit, then the pDelim is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim)\
    \ = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n      \
    \  If( CODE( pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim, nChar )<=CODE( '9', 1 ) );\n\
    \          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar\
    \ = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber(\
    \ pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\
    If( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is\
    \ exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII\
    \ code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n  \
    \    While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0',\
    \ 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n\
    \          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n\
    \    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote\
    \ = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate filename\n# If no file\
    \ name then default to Dimension.Subset.Export.csv (or Dimension.Hierarchy.Subset.Export.csv\
    \ in case of alternate hierarchy usage)\nIf( pTgtFile @= '' );\n  If( pHier @= pHier );\n\
    \    pTgtFile = pDim |'.'| pSub |'.Export.csv';\n  Else;\n    pTgtFile = pDim |'.'| pHier\
    \ |'.'| pSub |'.Export.csv';\n  EndIf;\nElse;\n  If( Scan( '.', pTgtFile ) = 0 );\n    #\
    \ No file extension specified\n    pTgtFile = pTgtFile | '.csv';\n  EndIf;\nEndIf;\nsFile\
    \ = pTgtDir | pTgtFile;\n\n# Validate Character Set\nIf(Trim( pCharacterSet ) @= '' );\n\
    \  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n### Initialise & declare variables ###\n\nnRecordCount\
    \ = 0;\n\n### Determine if alias exists ###\n\nsAttributeDim = '}ElementAttributes_' | pDim;\n\
    sAlias = '(no alias)';\nIf( DimensionExists( sAttributeDim ) = 1 );\n  nElementIndex = 1;\n\
    \  nElementCount = DimSiz( sAttributeDim );\n  While( nElementIndex <= nElementCount );\n\
    \    sAttribute = DimNm( sAttributeDim, nElementIndex );\n    If( SubSt( DType( sAttributeDim,\
    \ sAttribute ), 2, 1 ) @= 'A' );\n      sAlias = sAttribute;\n      nElementIndex = nElementCount;\n\
    \    EndIf;\n    nElementIndex = nElementIndex + 1;\n  End;\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Data Source ###\n\nDatasourceNameForServer\
    \ = pDim|':'|pHier;\nDatasourceNameForClient = pDim|':'|pHier;\nDataSourceType = 'SUBSET';\n\
    DatasourceDimensionSubset = pSub;\nDatasourceAsciiDelimiter= pDelim;\nDatasourceAsciiQuoteCharacter\
    \ = pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# Set the output character set\nSetOutputCharacterSet(\
    \ sFile, pCharacterSet );\n\n### Check for error in prolog ###\n\nIf( nErrors <> 0 );\n\
    \  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Check whether to write title records ###\n\nnRecordCount = nRecordCount\
    \ + 1;\n\nIf( nRecordCount = 1 & pTitleRecord = 1 );\n\n  nSubsetSize = HierarchySubSetGetSize(\
    \ pDim, pHier, pSub );\n\n  # Write params\n  TextOutput(\n    sFile,\n    'Export from\
    \ dimension: ' | pDim | ',Hierarchy:'|pHier|',Subset:'|pSub|\n    ', Total elements: ' |\
    \ NumberToString( nSubsetSize ) |\n    '. On ' | Date( Now, 1 ) | ' at ' | Time\n   );\n\
    \  # Write header records\n  TextOutput(\n    sFile,\n    'Subix',\n    'Element',\n   \
    \ 'Alias: ' | sAlias,\n    'Dimix',\n    'El Type',\n    'Level',\n    'Num Children',\n\
    \    'Parent 1',\n    'Weight 1',\n    'Parent 2',\n    'Weight 2',\n    'Parent 3',\n \
    \   'Weight 3',\n    'Parent 4',\n    'Weight 4',\n    'Parent 5',\n    'Weight 5'\n  );\n\
    \nEndIf;\n\n### Write dimension info to flat file ###\nsElement = HierarchyElementPrincipalName(\
    \ pDim, pHier, vElement );\nsSubix = NumberToString( nRecordCount );\nsIndex = NumberToString(\
    \ ElementIndex( pDim, pHier, vElement ) );\nsType = ElementType( pDim, PHier, vElement );\n\
    sLevel = NumberToString( ElementLevel( pDim, pHier, vElement ) );\nsChild = NumberToString(\
    \ ElementComponentCount( pDim, pHier, vElement ) );\nsParent1 = ElementParent( pDim,pHier,\
    \ vElement, 1 );\nsParent2 = ElementParent( pDim,pHier, vElement, 2 );\nsParent3 = ElementParent(\
    \ pDim,pHier, vElement, 3 );\nsParent4 = ElementParent( pDim,pHier, vElement, 4 );\nsParent5\
    \ = ElementParent( pDim,pHier, vElement, 5 );\nsParent6 = ElementParent( pDim,pHier, vElement,\
    \ 6 );\nsParent7 = ElementParent( pDim,pHier, vElement, 7 );\nsParent8 = ElementParent(\
    \ pDim,pHier, vElement, 8 );\nsWeight1 = NumberToString( ElementWeight( pDim, pHier, sParent1,\
    \ vElement ) );\nsWeight2 = NumberToString( ElementWeight( pDim, pHier, sParent2, vElement\
    \ ) );\nsWeight3 = NumberToString( ElementWeight( pDim, pHier, sParent3, vElement ) );\n\
    sWeight4 = NumberToString( ElementWeight( pDim, pHier, sParent4, vElement ) );\nsWeight5\
    \ = NumberToString( ElementWeight( pDim, pHier, sParent5, vElement ) );\nsWeight6 = NumberToString(\
    \ ElementWeight( pDim, pHier, sParent6, vElement ) );\nsWeight7 = NumberToString( ElementWeight(\
    \ pDim, pHier, sParent7, vElement ) );\nsWeight8 = NumberToString( ElementWeight( pDim,\
    \ pHier, sParent8, vElement ) );\n\nIf( sAlias @<> '(no alias)' );\n  sAliasValue = ElementAttrS(\
    \ pDim, pHier, vElement, sAlias );\nElse;\n  sAliasValue = '';\nEndIf;\n\n  TextOutput(\n\
    \    sFile,\n    sSubix,\n    sElement,\n    sAliasValue,\n    sIndex,\n    sType,\n   \
    \ sLevel,\n    sChild,\n    sParent1,\n    sWeight1,\n    sParent2,\n    sWeight2,\n   \
    \ sParent3,\n    sWeight3,\n    sParent4,\n    sWeight4,\n    sParent5,\n    sWeight5,\n\
    \    sParent6,\n    sWeight6,\n    sParent7,\n    sWeight7,\n    sParent8,\n    sWeight8\n\
    \  );\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully exported subset %pSub% from dimension\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der alle untergeordneten Elemente
    von einer spezifischen Konsolidierung (pConsol) in einer Hierarchie in der Ziel-Dimension
    entfernt. Wenn rekursiv (pRecursive=1) angegeben ist, löst der Prozess auch alle Konsolidierungen
    auf, die Nachkommen des Ziels unabhängig von der Tiefe sind. Andernfalls werden nur die
    direkten untergeordneten Elemente der Ziel-Konsolidierung entfernt. Dies ist sinnvoll für
    Produktions- und Entwicklungsprototypen. Im Produktionskontext wird der Prozess vor dem
    Hauptaufbau der Dimension aufgerufen, um geänderte Zuordnungsbeziehungen zu berücksichtigen
    und eine doppelte Zählung zu vermeiden. Zusammen mit }ti.hier.emptyconsols.delete kann der
    Prozess auch verwendet werden, um verwaiste Rollups zu entfernen. In der Entwicklung dient
    er der manuellen Bereinigung der Dimensionen vor der Produktion. Ein gültiger Name für die
    Quelldimension (pDim) ist erforderlich, sonst wird der Prozess abgebrochen. Ein leeres pHier-Profil
    bezieht sich nur auf die gleichnamige Hierarchie jeder verarbeiteten Dimension. Ein ''*''
    im pConsol-Parameter verarbeitet alle Konsolidierungsstufen in der angegebenen Hierarchie.
    Eine durch Trennzeichen begrenzte Liste oder ein Platzhalter für pDim oder pHier oder eine
    durch Trennzeichen begrenzte Konsolidierungsliste für pConsol sorgt für rekursive Prozessaufrufe.
    Achtung: Wenn Konsolidierungen auch in nicht zusammenhängenden Konsolidierungen verwendet
    werden und rekursiv ausgewählt ist, führt dies zu verwaisten Konsolidierungen in anderen
    Rollups.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will remove all children from a specific\
    \ target consolidation (pConsol) in a Hierarchy\n# in target Dimension. If recursive (pRecursive=1),\
    \ it will also unwind all consolidations that are \n# descendants of the target regardless\
    \ of depth. If not recursive (pRecursive=0) then only immediate children\n# of the target\
    \ consolidation will be removed.\n#\n# Use case: Intended for both production and development/prototyping\
    \ scenarios.\n# 1. **Production** call prior to main dimension build process in case mapping\
    \ relationships have changed to ensure no double-counting steming from leaf elements \n\
    #    rolling into multiple parents within the same rollup or hierarhcy\n# 2. **Production**\
    \ combine with }bedrock.hier.emptyconsols.delete to remove orphaned rollups\n# 3. **Development**\
    \ manual cleanup of dimensions during prototyping or prior to going to production\n#\n#\
    \ Note:\n# * A valid source dimension name (pDim) is mandatory otherwise the process will\
    \ abort.\n# * A blank pHier parameter will process _only the same named hierarchy_ for each\
    \ of the dimensions processed.\n# * A \\* pConsol parameter will process ALL C level items\
    \ in the given hierarchy (pHier).\n# * A delimited list or wildcard for pDim or pHier or\
    \ a delimited list of consolidations for pConsol will result in recursive calls of the process.\n\
    #\n# Caution: \n# If consolidations are also used in unrelated consolidations and recursive\
    \ is selected this\n# will result in orphan consolidations in the other rollups.\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncTempSubOuter   = '}OuterLoop_' | cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncTempSubInner   = '}InnerLoop_' | cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo\
    \        = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pConsol:%pConsol%,\
    \ pRecursive:%pRecursive%, pDelim:%pDelim%.' ;\ncHierAttr       = 'Bedrock.Descendant';\n\
    cAttrVal        = 'Descendant';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan(\
    \ '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim )\
    \ > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim,\
    \ Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\n## Validate Source dimension\nIF( Trim( pDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElseIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim,\
    \ pDim ) = 0 & DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \ dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate hierarchy (can only validate hierarchy up front if dimension is fixed and doesn't\
    \ contain wildcards)\nIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim,\
    \ pDim ) = 0 & pHier @= '');\n    pHier = pDim;\nElseIf( Scan( '*', pHier ) = 0 & Scan(\
    \ '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & pHier @<> '' & DimensionExists( pDim )\
    \ = 1 & HierarchyExists( pDim, pHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \ dimension hierarchy: ' | pHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n\nIf( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards\
    \ are allowed, this is managed inside the code below\nEndIf;\n\n# Validate consol\nIf( pConsol\
    \ @<> '');\n    If( Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 & Scan( pDelim,\
    \ pConsol ) = 0 & ElementIndex( pDim, pHier, pConsol ) = 0 );\n        nErrors = 1;\n  \
    \      sMessage = 'Item ' | pConsol | ' does NOT exist. Please enter a valid consolidation\
    \ element in the ' |pDim| ':' |pHier| ' dimension:hierarchy.';  \n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    ElseIf( Scan( '*', pConsol ) = 0 & Scan( '?', pConsol\
    \ ) = 0 & Scan( pDelim, pConsol ) = 0 & ElementType( pDim, pHier, pConsol ) @<> 'C' );\n\
    \        nErrors = 1;\n        sMessage = 'Item ' | pConsol | ' is NOT a consolidated item.\
    \ Please enter a valid consolidation element in the ' |pDim| ':' |pHier| ' dimension:hierarchy.';\
    \  \n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ElseIf( Scan(\
    \ '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 & Scan( pDelim, pConsol ) = 0 & ElementComponentCount(\
    \ pDim, pHier, pConsol ) = 0 );\n        nErrors = 1;\n        sMessage = 'Invalid consolidation:\
    \ ' | pConsol | ' has no children.';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Endif;\nElseIf( Trim( pConsol ) @= '' );\n    nErrors = 1;\n    sMessage = 'No\
    \ consolidated element specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @=\
    \ '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nElse;\n  # If subset required will be set later\n  DataSourceType = 'NULL';\n\
    EndIf;\n\n### If there is no separator and wildcard in the parameters, execute the unwind\
    \ of the specific consolidated element\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) =\
    \ 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan(\
    \ pDelim, pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 & Scan( pDelim,\
    \ pConsol ) = 0 );\n\n    ### In case alias used for pConsol convert to principal name \n\
    \    If( ElementIndex( pDim, pHier, pConsol ) > 0 );\n        pConsol = HierarchyElementPrincipalName(\
    \ pDim, pHier, pConsol );\n    EndIf;\n\n    ### Turn-off Logging in the Attribute cube\n\
    \    sAttrCube = '}ElementAttributes_' | pDim;\n    If( CubeExists( sAttrCube ) = 1 );\n\
    \        nLogging = CubeGetLogChanges( sAttrCube );\n        CubeSetLogChanges( sAttrCube,\
    \ 0 );\n    EndIf;\n    \n    ### Create Temp Descendent Attribute\n    AttrDelete( pDim,\
    \ cHierAttr );\n    AttrInsert( pDim, '', cHierAttr, 'S' );\n    \n    ### Assign data source\
    \ ###\n    If( pRecursive      = 1);\n        # Set Descendent attribute value\n       \
    \ nElementIndex   = 1;\n        nElementCount   = ElementCount( pDim , pHier );\n      \
    \  While( nElementIndex <= nElementCount );\n            sElement = ElementName( pDim, pHier,\
    \ nElementIndex );\n            If( ElementIsAncestor( pDim, pHier, pConsol, sElement )\
    \ = 1 % pConsol @= sElement );\n                ElementAttrPutS( cAttrVal, pDim, pHier,\
    \ sElement, cHierAttr );\n            EndIf;\n            nElementIndex = nElementIndex\
    \ + 1;\n        End;\n        # Assign Data Source\n        DataSourceType            =\
    \ 'SUBSET';\n        DatasourceNameForServer   = pDim|':'|pHier;\n        DatasourceNameForClient\
    \   = pDim|':'|pHier;\n        DatasourceDimensionSubset = 'ALL';\n    Else;\n        ###\
    \ Remove direct children from the target consol ###\n        If( ElementComponentCount(\
    \ pDim, pHier, pConsol ) > 0 );\n            If( pLogOutput = 1 );\n                LogOutput(\
    \ 'INFO', Expand( 'Deleting all components from consolidation %pConsol% in hierarchy '%pHier%'\
    \ of '%pDim%' dimension.' ) );\n            EndIf;\n            nComp = ElementComponentCount(\
    \ pDim, pHier, pConsol );\n            While( nComp > 0 );\n                sComp = ElementComponent(\
    \ pDim, pHier, pConsol, nComp );\n                HierarchyElementComponentDelete( pDim,\
    \ pHier, pConsol, sComp );\n                nComp = nComp - 1;\n            End;\n     \
    \   EndIf;\n        # No data source, straight to Epilog\n        DataSourceType = 'NULL';\n\
    \    EndIf;\n\n### If pConsol is '*' and there is no separator and wildcard in the pDim\
    \ & pHier parameters then unwind the whole hierarchy\nElseIf( Scan( '*', pDim ) = 0 & Scan(\
    \ '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier ) = 0 & Scan( '?', pHier\
    \ ) = 0 & Scan( pDelim, pHier ) = 0 & Trim( pConsol ) @= '*' );\n\n    # as pConsol is *\
    \ wildcard it doesn't matter if recursive or not. We unwind everything. As speed enhancement\
    \ rather than removing children delete and add back C elements to empty children in one\
    \ step (not steps = count of children)\n    nMaxEle = ElementCount( pDim, pHier );\n   \
    \ nCtrEle = 1;\n    While( nCtrEle <= nMaxEle );\n        sEle = ElementName( pDim, pHier,\
    \ nCtrEle);\n        If( ElementComponentCount( pDim, pHier, sEle ) > 0 );\n           \
    \ If( nCtrEle < nMaxEle );\n                sEleNext = ElementName( pDim, pHier, nCtrEle\
    \ + 1 );\n            Else;\n                sEleNext = '';\n            EndIf;\n      \
    \      HierarchyElementDelete( pDim, pHier, sEle );\n            HierarchyElementInsert(\
    \ pDim, pHier, sEleNext, sEle, 'C' );\n        EndIf;\n        nCtrEle = nCtrEle + 1;\n\
    \    End;\n\n    # since hierarchy already fully unwound no subset; datasource = NULL\n\
    \    DataSourceType = 'NULL';\n\n## Otherwise, if there is a separator or wildcard in the\
    \ parameters, tokenize the string and self-call the process recursively.\nElse;\n    # No\
    \ data source, straight to Epilog\n    DataSourceType = 'NULL';\n    \n    # Loop through\
    \ dimensions in pDim\n    sDims = pDim;\n    nDimDelimiterIndex = 1;\n    sMdx = '';\n \
    \   # Get 1st dimension\n    While( nDimDelimiterIndex <> 0 );\n        # Extract 1st dimension\
    \ > sDim\n        nDimDelimiterIndex = Scan( pDelim, sDims );\n        If( nDimDelimiterIndex\
    \ = 0 );\n            sDim = sDims;\n        Else;\n            sDim = Trim( SubSt( sDims,\
    \ 1, nDimDelimiterIndex - 1 ) );\n            sDims = Trim( Subst( sDims, nDimDelimiterIndex\
    \ + Long(pDelim), Long( sDims ) ) );\n        EndIf;\n        \n        # Create subset\
    \ of dimensions using Wildcard to loop through dimensions in pDim with wildcard\n      \
    \  sDimExp = '''|sDim|''';\n        sMdxPart = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL(\
    \ [}Dimensions].[}Dimensions] ), TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions].[}Dimensions]\
    \ ) , '*:*') ) , %sDimExp% )}');\n        If( sMdx @= ''); \n            sMdx = sMdxPart;\
    \ \n        Else;\n            sMdx = sMdx | ' + ' | sMdxPart;\n        EndIf;\n    End;\n\
    \  \n    If( SubsetExists( '}Dimensions' , cTempSubOuter ) = 1 );\n        # If a delimited\
    \ list of dim names includes wildcards then we may have to re-use the subset multiple times\n\
    \        SubsetMDXSet( '}Dimensions' , cTempSubOuter, sMDX );\n    Else;\n        # temp\
    \ subset, therefore no need to destroy in epilog\n        SubsetCreatebyMDX( cTempSubOuter,\
    \ sMDX, '}Dimensions' , 1 );\n    EndIf;\n  \n    # Loop through dimensions in subset created\
    \ based on wildcard\n    nCountDim = SubsetGetSize( '}Dimensions' , cTempSubOuter );\n \
    \   While( nCountDim >= 1 );\n        sDim = SubsetGetElementName( '}Dimensions' , cTempSubOuter,\
    \ nCountDim );\n        # Validate dimension name\n        If( DimensionExists(sDim) = 0\
    \ );\n            nErrors = 1;\n            sMessage = Expand( 'Dimension '%sDim%' does\
    \ not exist.' );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n      \
    \  Else;\n            If( pLogOutput = 1 );\n                sMessage = Expand( 'Dimension\
    \ '%sDim%' being processed....' );\n                LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n            EndIf;\n            # Loop through hierarchies in pHier\n          \
    \  If( Trim( pHier ) @= '' );\n                ### Use main hierarchy for each dimension\
    \ if pHier is empty\n                sHierarchies  = sDim;\n            Else;\n        \
    \        sHierarchies  = pHier;\n            EndIf;\n            nDelimiterIndexA  = 1;\n\
    \            sHierDim          = '}Dimensions' ;\n            sMdxHier          = '';\n\
    \            While( nDelimiterIndexA <> 0 );\n                nDelimiterIndexA = Scan( pDelim,\
    \ sHierarchies );\n                If( nDelimiterIndexA = 0 );\n                    sHierarchy\
    \   = sHierarchies;\n                Else;\n                    sHierarchy   = Trim( SubSt(\
    \ sHierarchies, 1, nDelimiterIndexA - 1 ) );\n                    sHierarchies  = Trim(\
    \ Subst( sHierarchies, nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n    \
    \            EndIf;\n      \n                # Create subset of Hierarchies using Wildcard\n\
    \                If( sDim @= sHierarchy );\n                    sHierExp = '''| sDim |''';\n\
    \                Else;\n                    sHierExp = '''| sDim | ':' | sHierarchy|''';\n\
    \                EndIf;\n                    sMdxHierPart = Expand('{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([%sHierDim%].[%sHierDim%])}, %sHierExp% )}');\n                If( sMdxHier\
    \ @= ''); \n                    sMdxHier = sMdxHierPart; \n                Else;\n     \
    \               sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n                EndIf;\n  \
    \          End;\n          \n            # include the named hierarchy in case ALL hierachies\n\
    \            If( Trim(pHier) @= '*' );\n                sMdxHier = Expand('{[%sHierDim%].[%sHierDim%].[%sDim%]}\
    \ + %sMdxHier%');\n            EndIf;\n  \n            If( SubsetExists( sHierDim, cTempSubInner\
    \ ) = 1 );\n                # If a delimited list of hierarchy names includes wildcards\
    \ then we may have to re-use the subset multiple times\n                SubsetMDXSet( sHierDim,\
    \ cTempSubInner, sMdxHier );\n            Else;\n                # temp subset, therefore\
    \ no need to destroy in epilog\n                SubsetCreatebyMDX( cTempSubInner, sMdxHier,\
    \ sHierDim, 1 );\n            EndIf;\n\n            # Loop through subset of hierarchies\
    \ created based on wildcard\n            nCountHier = SubsetGetSize( sHierDim, cTempSubInner\
    \ );\n            While( nCountHier >= 1 );\n                sCurrHier = SubsetGetElementName(\
    \ sHierDim, cTempSubInner, nCountHier );\n                sCurrHierName = Subst( sCurrHier,\
    \ Scan(':', sCurrHier)+1, Long(sCurrHier) );\n                # Validate hierarchy name\
    \ in sHierDim\n                If( Dimix( sHierDim , sCurrHier ) = 0 );\n              \
    \      sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n\
    \                    LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n                ElseIf(\
    \ sCurrHierName @= 'Leaves' );\n                    sMessage = Expand('Skipping %sCurrHier%\
    \ hierarchy. No need to unwind!');\n                    If( pLogOutput = 1 );\n        \
    \                LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n                    EndIf;\n\
    \                Else;\n                    If( pLogOutput = 1 );\n                    \
    \    sMessage = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%' being processed....'\
    \ );\n                        LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n        \
    \            EndIf;\n                    # Loop through consolidated elements in pConsol\n\
    \                    sEles = Trim( pConsol );\n                    If( sEles @= '*' );\n\
    \                        # no need for recursive call for ALL wildcard. We can just unwind\
    \ whole hierarchy\n                        nMaxEle = ElementCount( sDim, sCurrHierName );\n\
    \                        nCtrEle = 1;\n                        While( nCtrEle <= nMaxEle\
    \ );\n                            sEle = ElementName( sDim, sCurrHierName, nCtrEle);\n \
    \                           If( ElementComponentCount( sDim, sCurrHierName, sEle ) > 0 );\n\
    \                                If( nCtrEle < nMaxEle );\n                            \
    \        sEleNext = ElementName( sDim, sCurrHierName, nCtrEle + 1 );\n                 \
    \               Else;\n                                    sEleNext = '';\n            \
    \                    EndIf;\n                                HierarchyElementDelete( sDim,\
    \ sCurrHierName, sEle );\n                                HierarchyElementInsert( sDim,\
    \ sCurrHierName, sEleNext, sEle, 'C' );\n                            EndIf;\n          \
    \                  nCtrEle = nCtrEle + 1;\n                        End;\n              \
    \      Else;\n                        # a delimited list of consolidations is given. Handle\
    \ with recursive call and temp descendents attribute\n                        nDelimiterIndexB\
    \ = 1;\n                        While( nDelimiterIndexB <> 0 );\n                      \
    \      nDelimiterIndexB = Scan( pDelim, sEles );\n                            If( nDelimiterIndexB\
    \ = 0 );\n                                sEle = sEles;\n                            Else;\n\
    \                                sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB - 1 ) );\n\
    \                                sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim),\
    \ Long( sEles ) ) );\n                            EndIf;\n                        \n   \
    \                         # Wildcard search string\n                            sEle = '''|sEle|''';\n\
    \                            sMdxEle = Expand('{TM1FILTERBYPATTERN( {TM1SUBSETALL([%sCurrHier%])},\
    \ %sEle% )}');\n      \n                            If( HierarchySubsetExists( sDim, sCurrHierName,\
    \ cTempSub ) = 1 );\n                                # If a delimited list of dim names\
    \ includes wildcards then we may have to re-use the subset multiple times\n            \
    \                    HierarchySubsetMDXSet( sDim, sCurrHierName, cTempSub, sMDXEle );\n\
    \                            Else;\n                                # temp subset, therefore\
    \ no need to destroy in epilog\n                                SubsetCreatebyMDX( cTempSub,\
    \ sMDXEle, sCurrHier, 1 );\n                            EndIf;\n      \n               \
    \             # Loop through subset of Consolidated elements created based on wildcard\n\
    \                            nCountElems = HierarchySubsetGetSize(sDim, sCurrHierName, cTempSub);\n\
    \                            While( nCountElems >= 1 );\n                              \
    \  sElement = HierarchySubsetGetElementName(sDim, sCurrHierName, cTempSub, nCountElems);\n\
    \                                ## Check that the element is consolidated and has children\n\
    \                                If( DType( sCurrHier, sElement ) @= 'C' & ElementComponentCount(\
    \ sDim, sCurrHierName, sElement ) > 0 );\n                                    If( pLogOutput\
    \ = 1 );\n                                        LogOutput( 'INFO', Expand( 'Process called\
    \ recursively for '%sElement%' in hierarchy '%sDim%:%sCurrHierName%'.' ) );\n          \
    \                          EndIf;\n                                    ExecuteProcess( cThisProcName,\
    \ 'pLogOutput', pLogOutput,\n                                        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n                                        'pDim', sDim, 'pHier',\
    \ sCurrHierName,\n                                        'pConsol', sElement, 'pRecursive',\
    \ pRecursive,\n                                        'pDelim', pDelim\n              \
    \                      );\n                                EndIf;\n                    \
    \            \n                                nCountElems = nCountElems - 1;\n        \
    \                    End;\n                        End;\n                    EndIf;\n  \
    \              Endif;\n            \n                nCountHier = nCountHier - 1;\n    \
    \        End;\n              \n        EndIf;\n      \n        nCountDim = nCountDim - 1;\n\
    \    End;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Check for errors in prolog ###\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### If Leaf or already unwound then skip\nIf( ElementComponentCount(\
    \ pDim, pHier, vElement ) = 0 );\n    ItemSkip;\nEndIf;\n    \n### Break all parent/child\
    \ links below target consol ###\nIf( pConsol @= '*' );\n    sAttrVal = cAttrVal;\nElse;\n\
    \    sAttrVal = ElementAttrS( pDim, pHier, vElement, cHierAttr );\nEndIf;\n\nIf( sAttrVal\
    \ @= cAttrVal );\n    bFastUnwind = 1;\n\n    # Cannot check nPars > 1 as due to ordering\
    \ of elements processes some parents may have already been removed\n    nPars = ElementParentCount(\
    \ pDim, pHier, vElement );\n    nPar = 1;\n    While( nPar <= nPars );\n        sPar = ElementParent(\
    \ pDim, pHier, vElement, nPar );\n        If( ElementAttrS( pDim, pHier, sPar, cHierAttr\
    \ ) @<> cAttrVal );\n            # Parent does not belong to unwinding intersection. Cannot\
    \ delete C children, must unwind.\n            bFastUnwind = 0;\n        EndIf;\n      \
    \  nPar = nPar + 1;\n    End;\n        \n    If( bFastUnwind = 1 );\n        # delete and\
    \ recreate C element (Fast)\n        sEleNext = ElementName( pDim, pHier, ElementIndex(\
    \ pDim, pHier, vElement ) + 1 );\n        HierarchyElementDelete( pDim, pHier, vElement\
    \ );\n        HierarchyElementInsert( pDim, pHier, sEleNext, vElement, 'C' );\n    Else;\n\
    \        # unwind C element without deletion (Slow for consols with many children)\n   \
    \     nComp = ElementComponentCount( pDim, pHier, vElement );\n        While( nComp > 0\
    \ );\n            sComp = ElementComponent( pDim, pHier, vElement, nComp );\n          \
    \  HierarchyElementComponentDelete( pDim, pHier, vElement, sComp );\n            nComp =\
    \ nComp - 1;\n        End;\n    EndIf;\n    \nEndIf;\n\n### End Metadata ###\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\nElse;\n\n    ### Remove Descendent attribute\n    IF( Scan( '*', pDim\
    \ ) = 0 &  Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier ) = 0 & Scan(\
    \ '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan( '?', pConsol\
    \ ) = 0 & Scan( pDelim, pConsol ) = 0 );\n      AttrDelete( pDim, cHierAttr );\n    EndIf;\n\
    EndIf;\n\n### Reset Logging in the Attribute cube\nIF( Scan( '*', pDim ) = 0 & Scan( '?',\
    \ pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier ) = 0 & Scan( '?', pHier ) =\
    \ 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 &\
    \ Scan( pDelim, pConsol ) = 0 );\n    If( CubeExists( sAttrCube ) = 1 );\n        If( nLogging\
    \ = 1 );\n            CubeSetLogChanges( sAttrCube, 1 );\n        EndIf;\n    EndIf;\nEndIf;\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully unwound the appropriate consolidated items the %pDim%:%pHier% dimension:hierarchy.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that removes all children from a specific
    target consolidation (pConsol) in a hierarchy within the target dimension. If recursive
    (pRecursive=1) is specified, the process will also unwind all consolidations that are descendants
    of the target regardless of depth. Otherwise, only immediate children of the target consolidation
    will be removed. This is intended for both production and development prototyping scenarios.
    In production, the process is called prior to the main dimension build process to account
    for changed mapping relationships and avoid double-counting. Combined with }ti.hier.emptyconsols.delete,
    it can also remove orphaned rollups. In development, it provides manual cleanup of dimensions
    before deployment. A valid source dimension name (pDim) is mandatory; otherwise, the process
    will abort. A blank pHier parameter processes only the same named hierarchy for each dimension
    processed. A ''*'' in the pConsol parameter processes all C-level items in the given hierarchy.
    A delimited list or wildcard for pDim or pHier or a delimited list of consolidations for
    pConsol results in recursive calls of the process. Caution: If consolidations are also used
    in unrelated consolidations and recursive is selected, this will result in orphan consolidations
    in other rollups.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will remove all children from a specific\
    \ target consolidation (pConsol) in a Hierarchy\n# in target Dimension. If recursive (pRecursive=1),\
    \ it will also unwind all consolidations that are \n# descendants of the target regardless\
    \ of depth. If not recursive (pRecursive=0) then only immediate children\n# of the target\
    \ consolidation will be removed.\n#\n# Use case: Intended for both production and development/prototyping\
    \ scenarios.\n# 1. **Production** call prior to main dimension build process in case mapping\
    \ relationships have changed to ensure no double-counting steming from leaf elements \n\
    #    rolling into multiple parents within the same rollup or hierarhcy\n# 2. **Production**\
    \ combine with }bedrock.hier.emptyconsols.delete to remove orphaned rollups\n# 3. **Development**\
    \ manual cleanup of dimensions during prototyping or prior to going to production\n#\n#\
    \ Note:\n# * A valid source dimension name (pDim) is mandatory otherwise the process will\
    \ abort.\n# * A blank pHier parameter will process _only the same named hierarchy_ for each\
    \ of the dimensions processed.\n# * A \\* pConsol parameter will process ALL C level items\
    \ in the given hierarchy (pHier).\n# * A delimited list or wildcard for pDim or pHier or\
    \ a delimited list of consolidations for pConsol will result in recursive calls of the process.\n\
    #\n# Caution: \n# If consolidations are also used in unrelated consolidations and recursive\
    \ is selected this\n# will result in orphan consolidations in the other rollups.\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName\
    \       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncTempSubOuter   = '}OuterLoop_' | cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncTempSubInner   = '}InnerLoop_' | cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo\
    \        = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pConsol:%pConsol%,\
    \ pRecursive:%pRecursive%, pDelim:%pDelim%.' ;\ncHierAttr       = 'Bedrock.Descendant';\n\
    cAttrVal        = 'Descendant';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan(\
    \ '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim )\
    \ > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim,\
    \ Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\n## Validate Source dimension\nIF( Trim( pDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElseIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim,\
    \ pDim ) = 0 & DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \ dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate hierarchy (can only validate hierarchy up front if dimension is fixed and doesn't\
    \ contain wildcards)\nIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim,\
    \ pDim ) = 0 & pHier @= '');\n    pHier = pDim;\nElseIf( Scan( '*', pHier ) = 0 & Scan(\
    \ '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & pHier @<> '' & DimensionExists( pDim )\
    \ = 1 & HierarchyExists( pDim, pHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \ dimension hierarchy: ' | pHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n\nIf( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards\
    \ are allowed, this is managed inside the code below\nEndIf;\n\n# Validate consol\nIf( pConsol\
    \ @<> '');\n    If( Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 & Scan( pDelim,\
    \ pConsol ) = 0 & ElementIndex( pDim, pHier, pConsol ) = 0 );\n        nErrors = 1;\n  \
    \      sMessage = 'Item ' | pConsol | ' does NOT exist. Please enter a valid consolidation\
    \ element in the ' |pDim| ':' |pHier| ' dimension:hierarchy.';  \n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    ElseIf( Scan( '*', pConsol ) = 0 & Scan( '?', pConsol\
    \ ) = 0 & Scan( pDelim, pConsol ) = 0 & ElementType( pDim, pHier, pConsol ) @<> 'C' );\n\
    \        nErrors = 1;\n        sMessage = 'Item ' | pConsol | ' is NOT a consolidated item.\
    \ Please enter a valid consolidation element in the ' |pDim| ':' |pHier| ' dimension:hierarchy.';\
    \  \n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ElseIf( Scan(\
    \ '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 & Scan( pDelim, pConsol ) = 0 & ElementComponentCount(\
    \ pDim, pHier, pConsol ) = 0 );\n        nErrors = 1;\n        sMessage = 'Invalid consolidation:\
    \ ' | pConsol | ' has no children.';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Endif;\nElseIf( Trim( pConsol ) @= '' );\n    nErrors = 1;\n    sMessage = 'No\
    \ consolidated element specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @=\
    \ '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nElse;\n  # If subset required will be set later\n  DataSourceType = 'NULL';\n\
    EndIf;\n\n### If there is no separator and wildcard in the parameters, execute the unwind\
    \ of the specific consolidated element\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) =\
    \ 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan(\
    \ pDelim, pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 & Scan( pDelim,\
    \ pConsol ) = 0 );\n\n    ### In case alias used for pConsol convert to principal name \n\
    \    If( ElementIndex( pDim, pHier, pConsol ) > 0 );\n        pConsol = HierarchyElementPrincipalName(\
    \ pDim, pHier, pConsol );\n    EndIf;\n\n    ### Turn-off Logging in the Attribute cube\n\
    \    sAttrCube = '}ElementAttributes_' | pDim;\n    If( CubeExists( sAttrCube ) = 1 );\n\
    \        nLogging = CubeGetLogChanges( sAttrCube );\n        CubeSetLogChanges( sAttrCube,\
    \ 0 );\n    EndIf;\n    \n    ### Create Temp Descendent Attribute\n    AttrDelete( pDim,\
    \ cHierAttr );\n    AttrInsert( pDim, '', cHierAttr, 'S' );\n    \n    ### Assign data source\
    \ ###\n    If( pRecursive      = 1);\n        # Set Descendent attribute value\n       \
    \ nElementIndex   = 1;\n        nElementCount   = ElementCount( pDim , pHier );\n      \
    \  While( nElementIndex <= nElementCount );\n            sElement = ElementName( pDim, pHier,\
    \ nElementIndex );\n            If( ElementIsAncestor( pDim, pHier, pConsol, sElement )\
    \ = 1 % pConsol @= sElement );\n                ElementAttrPutS( cAttrVal, pDim, pHier,\
    \ sElement, cHierAttr );\n            EndIf;\n            nElementIndex = nElementIndex\
    \ + 1;\n        End;\n        # Assign Data Source\n        DataSourceType            =\
    \ 'SUBSET';\n        DatasourceNameForServer   = pDim|':'|pHier;\n        DatasourceNameForClient\
    \   = pDim|':'|pHier;\n        DatasourceDimensionSubset = 'ALL';\n    Else;\n        ###\
    \ Remove direct children from the target consol ###\n        If( ElementComponentCount(\
    \ pDim, pHier, pConsol ) > 0 );\n            If( pLogOutput = 1 );\n                LogOutput(\
    \ 'INFO', Expand( 'Deleting all components from consolidation %pConsol% in hierarchy '%pHier%'\
    \ of '%pDim%' dimension.' ) );\n            EndIf;\n            nComp = ElementComponentCount(\
    \ pDim, pHier, pConsol );\n            While( nComp > 0 );\n                sComp = ElementComponent(\
    \ pDim, pHier, pConsol, nComp );\n                HierarchyElementComponentDelete( pDim,\
    \ pHier, pConsol, sComp );\n                nComp = nComp - 1;\n            End;\n     \
    \   EndIf;\n        # No data source, straight to Epilog\n        DataSourceType = 'NULL';\n\
    \    EndIf;\n\n### If pConsol is '*' and there is no separator and wildcard in the pDim\
    \ & pHier parameters then unwind the whole hierarchy\nElseIf( Scan( '*', pDim ) = 0 & Scan(\
    \ '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier ) = 0 & Scan( '?', pHier\
    \ ) = 0 & Scan( pDelim, pHier ) = 0 & Trim( pConsol ) @= '*' );\n\n    # as pConsol is *\
    \ wildcard it doesn't matter if recursive or not. We unwind everything. As speed enhancement\
    \ rather than removing children delete and add back C elements to empty children in one\
    \ step (not steps = count of children)\n    nMaxEle = ElementCount( pDim, pHier );\n   \
    \ nCtrEle = 1;\n    While( nCtrEle <= nMaxEle );\n        sEle = ElementName( pDim, pHier,\
    \ nCtrEle);\n        If( ElementComponentCount( pDim, pHier, sEle ) > 0 );\n           \
    \ If( nCtrEle < nMaxEle );\n                sEleNext = ElementName( pDim, pHier, nCtrEle\
    \ + 1 );\n            Else;\n                sEleNext = '';\n            EndIf;\n      \
    \      HierarchyElementDelete( pDim, pHier, sEle );\n            HierarchyElementInsert(\
    \ pDim, pHier, sEleNext, sEle, 'C' );\n        EndIf;\n        nCtrEle = nCtrEle + 1;\n\
    \    End;\n\n    # since hierarchy already fully unwound no subset; datasource = NULL\n\
    \    DataSourceType = 'NULL';\n\n## Otherwise, if there is a separator or wildcard in the\
    \ parameters, tokenize the string and self-call the process recursively.\nElse;\n    # No\
    \ data source, straight to Epilog\n    DataSourceType = 'NULL';\n    \n    # Loop through\
    \ dimensions in pDim\n    sDims = pDim;\n    nDimDelimiterIndex = 1;\n    sMdx = '';\n \
    \   # Get 1st dimension\n    While( nDimDelimiterIndex <> 0 );\n        # Extract 1st dimension\
    \ > sDim\n        nDimDelimiterIndex = Scan( pDelim, sDims );\n        If( nDimDelimiterIndex\
    \ = 0 );\n            sDim = sDims;\n        Else;\n            sDim = Trim( SubSt( sDims,\
    \ 1, nDimDelimiterIndex - 1 ) );\n            sDims = Trim( Subst( sDims, nDimDelimiterIndex\
    \ + Long(pDelim), Long( sDims ) ) );\n        EndIf;\n        \n        # Create subset\
    \ of dimensions using Wildcard to loop through dimensions in pDim with wildcard\n      \
    \  sDimExp = '''|sDim|''';\n        sMdxPart = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL(\
    \ [}Dimensions].[}Dimensions] ), TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions].[}Dimensions]\
    \ ) , '*:*') ) , %sDimExp% )}');\n        If( sMdx @= ''); \n            sMdx = sMdxPart;\
    \ \n        Else;\n            sMdx = sMdx | ' + ' | sMdxPart;\n        EndIf;\n    End;\n\
    \  \n    If( SubsetExists( '}Dimensions' , cTempSubOuter ) = 1 );\n        # If a delimited\
    \ list of dim names includes wildcards then we may have to re-use the subset multiple times\n\
    \        SubsetMDXSet( '}Dimensions' , cTempSubOuter, sMDX );\n    Else;\n        # temp\
    \ subset, therefore no need to destroy in epilog\n        SubsetCreatebyMDX( cTempSubOuter,\
    \ sMDX, '}Dimensions' , 1 );\n    EndIf;\n  \n    # Loop through dimensions in subset created\
    \ based on wildcard\n    nCountDim = SubsetGetSize( '}Dimensions' , cTempSubOuter );\n \
    \   While( nCountDim >= 1 );\n        sDim = SubsetGetElementName( '}Dimensions' , cTempSubOuter,\
    \ nCountDim );\n        # Validate dimension name\n        If( DimensionExists(sDim) = 0\
    \ );\n            nErrors = 1;\n            sMessage = Expand( 'Dimension '%sDim%' does\
    \ not exist.' );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n      \
    \  Else;\n            If( pLogOutput = 1 );\n                sMessage = Expand( 'Dimension\
    \ '%sDim%' being processed....' );\n                LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n            EndIf;\n            # Loop through hierarchies in pHier\n          \
    \  If( Trim( pHier ) @= '' );\n                ### Use main hierarchy for each dimension\
    \ if pHier is empty\n                sHierarchies  = sDim;\n            Else;\n        \
    \        sHierarchies  = pHier;\n            EndIf;\n            nDelimiterIndexA  = 1;\n\
    \            sHierDim          = '}Dimensions' ;\n            sMdxHier          = '';\n\
    \            While( nDelimiterIndexA <> 0 );\n                nDelimiterIndexA = Scan( pDelim,\
    \ sHierarchies );\n                If( nDelimiterIndexA = 0 );\n                    sHierarchy\
    \   = sHierarchies;\n                Else;\n                    sHierarchy   = Trim( SubSt(\
    \ sHierarchies, 1, nDelimiterIndexA - 1 ) );\n                    sHierarchies  = Trim(\
    \ Subst( sHierarchies, nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n    \
    \            EndIf;\n      \n                # Create subset of Hierarchies using Wildcard\n\
    \                If( sDim @= sHierarchy );\n                    sHierExp = '''| sDim |''';\n\
    \                Else;\n                    sHierExp = '''| sDim | ':' | sHierarchy|''';\n\
    \                EndIf;\n                    sMdxHierPart = Expand('{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([%sHierDim%].[%sHierDim%])}, %sHierExp% )}');\n                If( sMdxHier\
    \ @= ''); \n                    sMdxHier = sMdxHierPart; \n                Else;\n     \
    \               sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n                EndIf;\n  \
    \          End;\n          \n            # include the named hierarchy in case ALL hierachies\n\
    \            If( Trim(pHier) @= '*' );\n                sMdxHier = Expand('{[%sHierDim%].[%sHierDim%].[%sDim%]}\
    \ + %sMdxHier%');\n            EndIf;\n  \n            If( SubsetExists( sHierDim, cTempSubInner\
    \ ) = 1 );\n                # If a delimited list of hierarchy names includes wildcards\
    \ then we may have to re-use the subset multiple times\n                SubsetMDXSet( sHierDim,\
    \ cTempSubInner, sMdxHier );\n            Else;\n                # temp subset, therefore\
    \ no need to destroy in epilog\n                SubsetCreatebyMDX( cTempSubInner, sMdxHier,\
    \ sHierDim, 1 );\n            EndIf;\n\n            # Loop through subset of hierarchies\
    \ created based on wildcard\n            nCountHier = SubsetGetSize( sHierDim, cTempSubInner\
    \ );\n            While( nCountHier >= 1 );\n                sCurrHier = SubsetGetElementName(\
    \ sHierDim, cTempSubInner, nCountHier );\n                sCurrHierName = Subst( sCurrHier,\
    \ Scan(':', sCurrHier)+1, Long(sCurrHier) );\n                # Validate hierarchy name\
    \ in sHierDim\n                If( Dimix( sHierDim , sCurrHier ) = 0 );\n              \
    \      sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n\
    \                    LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n                ElseIf(\
    \ sCurrHierName @= 'Leaves' );\n                    sMessage = Expand('Skipping %sCurrHier%\
    \ hierarchy. No need to unwind!');\n                    If( pLogOutput = 1 );\n        \
    \                LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n                    EndIf;\n\
    \                Else;\n                    If( pLogOutput = 1 );\n                    \
    \    sMessage = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%' being processed....'\
    \ );\n                        LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n        \
    \            EndIf;\n                    # Loop through consolidated elements in pConsol\n\
    \                    sEles = Trim( pConsol );\n                    If( sEles @= '*' );\n\
    \                        # no need for recursive call for ALL wildcard. We can just unwind\
    \ whole hierarchy\n                        nMaxEle = ElementCount( sDim, sCurrHierName );\n\
    \                        nCtrEle = 1;\n                        While( nCtrEle <= nMaxEle\
    \ );\n                            sEle = ElementName( sDim, sCurrHierName, nCtrEle);\n \
    \                           If( ElementComponentCount( sDim, sCurrHierName, sEle ) > 0 );\n\
    \                                If( nCtrEle < nMaxEle );\n                            \
    \        sEleNext = ElementName( sDim, sCurrHierName, nCtrEle + 1 );\n                 \
    \               Else;\n                                    sEleNext = '';\n            \
    \                    EndIf;\n                                HierarchyElementDelete( sDim,\
    \ sCurrHierName, sEle );\n                                HierarchyElementInsert( sDim,\
    \ sCurrHierName, sEleNext, sEle, 'C' );\n                            EndIf;\n          \
    \                  nCtrEle = nCtrEle + 1;\n                        End;\n              \
    \      Else;\n                        # a delimited list of consolidations is given. Handle\
    \ with recursive call and temp descendents attribute\n                        nDelimiterIndexB\
    \ = 1;\n                        While( nDelimiterIndexB <> 0 );\n                      \
    \      nDelimiterIndexB = Scan( pDelim, sEles );\n                            If( nDelimiterIndexB\
    \ = 0 );\n                                sEle = sEles;\n                            Else;\n\
    \                                sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB - 1 ) );\n\
    \                                sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim),\
    \ Long( sEles ) ) );\n                            EndIf;\n                        \n   \
    \                         # Wildcard search string\n                            sEle = '''|sEle|''';\n\
    \                            sMdxEle = Expand('{TM1FILTERBYPATTERN( {TM1SUBSETALL([%sCurrHier%])},\
    \ %sEle% )}');\n      \n                            If( HierarchySubsetExists( sDim, sCurrHierName,\
    \ cTempSub ) = 1 );\n                                # If a delimited list of dim names\
    \ includes wildcards then we may have to re-use the subset multiple times\n            \
    \                    HierarchySubsetMDXSet( sDim, sCurrHierName, cTempSub, sMDXEle );\n\
    \                            Else;\n                                # temp subset, therefore\
    \ no need to destroy in epilog\n                                SubsetCreatebyMDX( cTempSub,\
    \ sMDXEle, sCurrHier, 1 );\n                            EndIf;\n      \n               \
    \             # Loop through subset of Consolidated elements created based on wildcard\n\
    \                            nCountElems = HierarchySubsetGetSize(sDim, sCurrHierName, cTempSub);\n\
    \                            While( nCountElems >= 1 );\n                              \
    \  sElement = HierarchySubsetGetElementName(sDim, sCurrHierName, cTempSub, nCountElems);\n\
    \                                ## Check that the element is consolidated and has children\n\
    \                                If( DType( sCurrHier, sElement ) @= 'C' & ElementComponentCount(\
    \ sDim, sCurrHierName, sElement ) > 0 );\n                                    If( pLogOutput\
    \ = 1 );\n                                        LogOutput( 'INFO', Expand( 'Process called\
    \ recursively for '%sElement%' in hierarchy '%sDim%:%sCurrHierName%'.' ) );\n          \
    \                          EndIf;\n                                    ExecuteProcess( cThisProcName,\
    \ 'pLogOutput', pLogOutput,\n                                        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n                                        'pDim', sDim, 'pHier',\
    \ sCurrHierName,\n                                        'pConsol', sElement, 'pRecursive',\
    \ pRecursive,\n                                        'pDelim', pDelim\n              \
    \                      );\n                                EndIf;\n                    \
    \            \n                                nCountElems = nCountElems - 1;\n        \
    \                    End;\n                        End;\n                    EndIf;\n  \
    \              Endif;\n            \n                nCountHier = nCountHier - 1;\n    \
    \        End;\n              \n        EndIf;\n      \n        nCountDim = nCountDim - 1;\n\
    \    End;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Check for errors in prolog ###\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### If Leaf or already unwound then skip\nIf( ElementComponentCount(\
    \ pDim, pHier, vElement ) = 0 );\n    ItemSkip;\nEndIf;\n    \n### Break all parent/child\
    \ links below target consol ###\nIf( pConsol @= '*' );\n    sAttrVal = cAttrVal;\nElse;\n\
    \    sAttrVal = ElementAttrS( pDim, pHier, vElement, cHierAttr );\nEndIf;\n\nIf( sAttrVal\
    \ @= cAttrVal );\n    bFastUnwind = 1;\n\n    # Cannot check nPars > 1 as due to ordering\
    \ of elements processes some parents may have already been removed\n    nPars = ElementParentCount(\
    \ pDim, pHier, vElement );\n    nPar = 1;\n    While( nPar <= nPars );\n        sPar = ElementParent(\
    \ pDim, pHier, vElement, nPar );\n        If( ElementAttrS( pDim, pHier, sPar, cHierAttr\
    \ ) @<> cAttrVal );\n            # Parent does not belong to unwinding intersection. Cannot\
    \ delete C children, must unwind.\n            bFastUnwind = 0;\n        EndIf;\n      \
    \  nPar = nPar + 1;\n    End;\n        \n    If( bFastUnwind = 1 );\n        # delete and\
    \ recreate C element (Fast)\n        sEleNext = ElementName( pDim, pHier, ElementIndex(\
    \ pDim, pHier, vElement ) + 1 );\n        HierarchyElementDelete( pDim, pHier, vElement\
    \ );\n        HierarchyElementInsert( pDim, pHier, sEleNext, vElement, 'C' );\n    Else;\n\
    \        # unwind C element without deletion (Slow for consols with many children)\n   \
    \     nComp = ElementComponentCount( pDim, pHier, vElement );\n        While( nComp > 0\
    \ );\n            sComp = ElementComponent( pDim, pHier, vElement, nComp );\n          \
    \  HierarchyElementComponentDelete( pDim, pHier, vElement, sComp );\n            nComp =\
    \ nComp - 1;\n        End;\n    EndIf;\n    \nEndIf;\n\n### End Metadata ###\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\nElse;\n\n    ### Remove Descendent attribute\n    IF( Scan( '*', pDim\
    \ ) = 0 &  Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier ) = 0 & Scan(\
    \ '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan( '?', pConsol\
    \ ) = 0 & Scan( pDelim, pConsol ) = 0 );\n      AttrDelete( pDim, cHierAttr );\n    EndIf;\n\
    EndIf;\n\n### Reset Logging in the Attribute cube\nIF( Scan( '*', pDim ) = 0 & Scan( '?',\
    \ pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier ) = 0 & Scan( '?', pHier ) =\
    \ 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 &\
    \ Scan( pDelim, pConsol ) = 0 );\n    If( CubeExists( sAttrCube ) = 1 );\n        If( nLogging\
    \ = 1 );\n            CubeSetLogChanges( sAttrCube, 1 );\n        EndIf;\n    EndIf;\nEndIf;\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully unwound the appropriate consolidated items the %pDim%:%pHier% dimension:hierarchy.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Erstelle eine Beschreibung für einen IBM Turbo Integrator Prozess. Die Beschreibung
    sollte klar und präzise darstellen, was der Prozess tut, sowie den Anwendungsfall erläutern.
    Außerdem sollten wichtige Hinweise für die Benutzer angegeben werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# A description of what this process does here.\n# Use case:\n\
    # A description of the use cast for this process does here.\n# Note:\n# * List any notes\
    \ for users to be aware of here.\n#EndRegion @DOC\n\n#Region Process Declarations\n### Process\
    \ Parameters\n# a short description of what the process does goes here in cAction variable,\
    \ e.g. 'copied data from cube A to cube B'. This will be written to the message log if pLogOutput=1\n\
    cAction             = 'ran with no action';\ncParamArray         = '';\n# to use the parameter\
    \ array remove the line above and uncomment the line below, adding the needed parameters\
    \ in the provided format\n#cParamArray         = 'pLogOutput:%pLogOutput%, pTemp:%pTemp%';\n\
    \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    \n### Standard Constants\ncThisProcName       = GetProcessName();\ncUserName           =\
    \ TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempObjName        = Expand('%cThisProcName%_%cTimeStamp%_%cRandomInt%');\n\
    cViewClr            = '}bedrock_clear_' | cTempObjName;\ncViewSrc            = '}bedrock_source_'\
    \ | cTempObjName;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ %cParamArray%';\nsDelimEleStart      = '¦';\nsDelimDim           = '&';\nsDelimEle   \
    \        = '+';\nnProcessReturnCode  = 0;\nnErrors             = 0;\nnMetadataRecordCount=\
    \ 0;\nnDataRecordCount    = 0;\n\n### Process Specific Constants\ncCubeSrc            =\
    \ 'Source Cube';\ncCubeTgt            = 'Target Cube';\n\n#EndRegion Process Declarations\n\
    \n### LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n#Region Validate Parameters\n\n# pLogOutput\nIf( pLogOutput >= 1 );\n\
    \    pLogOutput = 1;\nElse;\n    pLogOutput = 0;\nEndIf;\n    \n# pTemp\nIf( pTemp >= 1\
    \ );\n    pTemp = 1;\nElse;\n    pTemp = 0;\nEndIf;\n\n# Validate source cube\nIf( Trim(\
    \ cCubeSrc ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No source cube specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( cCubeSrc\
    \ ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid source cube specified:\
    \ %cCubeSrc%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate target cube\nIf( Trim( cCubeTgt ) @= '' );\n    nErrors = nErrors + 1;\n  \
    \  sMessage = 'No target cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( cCubeTgt ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'Invalid target cube specified: %cCubeTgt%.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# If any parameters fail validation then set\
    \ data source of process to null and go directly to epilog\nIf( nErrors > 0 );\n    DataSourceType\
    \ = 'NULL';\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n  \
    \      ProcessBreak;\n    EndIf;\nEndIf;\n\n#EndRegion Validate Parameters\n\n### If required\
    \ switch transaction logging off (this should be done AFTER the escape/reject if parameters\
    \ fail validation and BEFORE the zero out commences)\nnCubeLogChanges = CubeGetLogChanges(\
    \ cCubeTgt );\nCubeSetLogChanges( cCubeTgt, 0 );\n\n#Region - ZeroOut\n\nsProc       = '}bedrock.cube.data.clear';\n\
    # Set filter as per logic requirement of the ZeroOut\nsFilter     = 'Dim1' | sDelimEleStart\
    \ | 'El1' | sDelimDim | 'Dim2' | sDelimEleStart | 'El2';\nnRet        = ExecuteProcess(\
    \ sProc, 'pLogOutput', pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t\
    'pCube', cCubeTgt, 'pView', cViewClr, 'pFilter', sFilter,\n\t'pDimDelim', sDelimDim, 'pEleStartDelim',\
    \ sDelimEleStart, 'pEleDelim', sDelimEle,\n\t'pTemp', pTemp \n);\nIf( nRet <> ProcessExitNormal()\
    \ );\n    nErrors = nErrors + 1;\n    sMessage= 'Error in ZeroOut.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n#EndRegion\
    \ - ZeroOut\n\n#Region - DataSource\n\nsProc   = '}bedrock.cube.view.create';\n# Set filter\
    \ as per logic requirement of the data source processing\nsFilter = Expand('Dim1%sDelimEleStart%El1%%sDelimDim%Dim2%sDelimEleStart%El2%');\n\
    # Adjust parameters for skipping of blanks / consols / rule calcs as required\nbSuppressNull\
    \   = 1;\nbSuppressC      = 1;\nbSuppressRule   = 1;\nnRet = ExecuteProcess( sProc, 'pLogOutput',\
    \ pLogOutput, \n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pCube', cCubeSrc, 'pView',\
    \ cViewSrc, 'pFilter', sFilter,\n\t'pSuppressZero', bSuppressNull, 'pSuppressConsol', bSuppressC,\
    \ 'pSuppressRules', bSuppressRule,\n\t'pDimDelim', sDelimDim, 'pEleStartDelim', sDelimEleStart,\
    \ 'pEleDelim', sDelimEle,\n\t'pTemp', pTemp\n);\nIf( nRet <> ProcessExitNormal() );\n  \
    \  nErrors = nErrors + 1;\n    sMessage= 'Error in source view creation.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n###\
    \ Assign data source\nIf( nErrors = 0 );\n    DatasourceType          = 'VIEW';\n    DatasourceNameForServer\
    \ = cCubeSrc;\n    DatasourceCubeView      = cViewSrc;\nEndIf;\n\n#EndRegion - DataSource\n\
    \n### End Prolog ###\n#Section Metadaten\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\nIf( pLogOutput >= 1 );\n   nMetadataRecordCount = nMetadataRecordCount\
    \ + 1;\nEndIf;\n\n#Section Daten\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\nIf( pLogOutput >= 1 );\n   nDataRecordCount = nDataRecordCount + 1;\n\
    EndIf;\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### If required switch transaction logging back on \nCubeSetLogChanges( cCubeTgt, nCubeLogChanges\
    \ );\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully %cAction%. %nDataRecordCount% records processed.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Create a description for an IBM Turbo Integrator process. The description should
    clearly and precisely explain what the process does, detail the use case, and include any
    important notes for users.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# A description of what this process does here.\n# Use case:\n\
    # A description of the use cast for this process does here.\n# Note:\n# * List any notes\
    \ for users to be aware of here.\n#EndRegion @DOC\n\n#Region Process Declarations\n### Process\
    \ Parameters\n# a short description of what the process does goes here in cAction variable,\
    \ e.g. 'copied data from cube A to cube B'. This will be written to the message log if pLogOutput=1\n\
    cAction             = 'ran with no action';\ncParamArray         = '';\n# to use the parameter\
    \ array remove the line above and uncomment the line below, adding the needed parameters\
    \ in the provided format\n#cParamArray         = 'pLogOutput:%pLogOutput%, pTemp:%pTemp%';\n\
    \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    \n### Standard Constants\ncThisProcName       = GetProcessName();\ncUserName           =\
    \ TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempObjName        = Expand('%cThisProcName%_%cTimeStamp%_%cRandomInt%');\n\
    cViewClr            = '}bedrock_clear_' | cTempObjName;\ncViewSrc            = '}bedrock_source_'\
    \ | cTempObjName;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ %cParamArray%';\nsDelimEleStart      = '¦';\nsDelimDim           = '&';\nsDelimEle   \
    \        = '+';\nnProcessReturnCode  = 0;\nnErrors             = 0;\nnMetadataRecordCount=\
    \ 0;\nnDataRecordCount    = 0;\n\n### Process Specific Constants\ncCubeSrc            =\
    \ 'Source Cube';\ncCubeTgt            = 'Target Cube';\n\n#EndRegion Process Declarations\n\
    \n### LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n#Region Validate Parameters\n\n# pLogOutput\nIf( pLogOutput >= 1 );\n\
    \    pLogOutput = 1;\nElse;\n    pLogOutput = 0;\nEndIf;\n    \n# pTemp\nIf( pTemp >= 1\
    \ );\n    pTemp = 1;\nElse;\n    pTemp = 0;\nEndIf;\n\n# Validate source cube\nIf( Trim(\
    \ cCubeSrc ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No source cube specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( cCubeSrc\
    \ ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid source cube specified:\
    \ %cCubeSrc%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate target cube\nIf( Trim( cCubeTgt ) @= '' );\n    nErrors = nErrors + 1;\n  \
    \  sMessage = 'No target cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( cCubeTgt ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'Invalid target cube specified: %cCubeTgt%.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# If any parameters fail validation then set\
    \ data source of process to null and go directly to epilog\nIf( nErrors > 0 );\n    DataSourceType\
    \ = 'NULL';\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n  \
    \      ProcessBreak;\n    EndIf;\nEndIf;\n\n#EndRegion Validate Parameters\n\n### If required\
    \ switch transaction logging off (this should be done AFTER the escape/reject if parameters\
    \ fail validation and BEFORE the zero out commences)\nnCubeLogChanges = CubeGetLogChanges(\
    \ cCubeTgt );\nCubeSetLogChanges( cCubeTgt, 0 );\n\n#Region - ZeroOut\n\nsProc       = '}bedrock.cube.data.clear';\n\
    # Set filter as per logic requirement of the ZeroOut\nsFilter     = 'Dim1' | sDelimEleStart\
    \ | 'El1' | sDelimDim | 'Dim2' | sDelimEleStart | 'El2';\nnRet        = ExecuteProcess(\
    \ sProc, 'pLogOutput', pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t\
    'pCube', cCubeTgt, 'pView', cViewClr, 'pFilter', sFilter,\n\t'pDimDelim', sDelimDim, 'pEleStartDelim',\
    \ sDelimEleStart, 'pEleDelim', sDelimEle,\n\t'pTemp', pTemp \n);\nIf( nRet <> ProcessExitNormal()\
    \ );\n    nErrors = nErrors + 1;\n    sMessage= 'Error in ZeroOut.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n#EndRegion\
    \ - ZeroOut\n\n#Region - DataSource\n\nsProc   = '}bedrock.cube.view.create';\n# Set filter\
    \ as per logic requirement of the data source processing\nsFilter = Expand('Dim1%sDelimEleStart%El1%%sDelimDim%Dim2%sDelimEleStart%El2%');\n\
    # Adjust parameters for skipping of blanks / consols / rule calcs as required\nbSuppressNull\
    \   = 1;\nbSuppressC      = 1;\nbSuppressRule   = 1;\nnRet = ExecuteProcess( sProc, 'pLogOutput',\
    \ pLogOutput, \n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pCube', cCubeSrc, 'pView',\
    \ cViewSrc, 'pFilter', sFilter,\n\t'pSuppressZero', bSuppressNull, 'pSuppressConsol', bSuppressC,\
    \ 'pSuppressRules', bSuppressRule,\n\t'pDimDelim', sDelimDim, 'pEleStartDelim', sDelimEleStart,\
    \ 'pEleDelim', sDelimEle,\n\t'pTemp', pTemp\n);\nIf( nRet <> ProcessExitNormal() );\n  \
    \  nErrors = nErrors + 1;\n    sMessage= 'Error in source view creation.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n###\
    \ Assign data source\nIf( nErrors = 0 );\n    DatasourceType          = 'VIEW';\n    DatasourceNameForServer\
    \ = cCubeSrc;\n    DatasourceCubeView      = cViewSrc;\nEndIf;\n\n#EndRegion - DataSource\n\
    \n### End Prolog ###\n#Section Metadaten\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\nIf( pLogOutput >= 1 );\n   nMetadataRecordCount = nMetadataRecordCount\
    \ + 1;\nEndIf;\n\n#Section Daten\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\nIf( pLogOutput >= 1 );\n   nDataRecordCount = nDataRecordCount + 1;\n\
    EndIf;\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### If required switch transaction logging back on \nCubeSetLogChanges( cCubeTgt, nCubeLogChanges\
    \ );\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully %cAction%. %nDataRecordCount% records processed.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der die Sicherheit von einem Benutzer
    auf einen anderen kopiert. Wenn der Zielbenutzer oder die Zielbenutzer noch nicht existieren,
    sollen sie automatisch erstellt werden. Dieser Prozess soll für den produktiven Einsatz
    vorgesehen sein. Er ermöglicht es, das Profil neuer Mitarbeiter durch Klonen eines bestehenden
    Mitarbeiters zu erstellen. Hinweis: Ein gültiger Quellbenutzer (pSrcClient) ist obligatorisch,
    andernfalls wird der Prozess abgebrochen. Ebenso muss ein gültiger Zielbenutzer oder müssen
    gültige Zielbenutzer (pTgtClient) angegeben werden, andernfalls wird der Prozess abgebrochen.
    Mehrere Zielbenutzer können mit einem Trennzeichen angegeben werden. Wenn der Zielbenutzer
    noch nicht existiert, soll die Funktion Bedrock.Security.Client.Create aufgerufen werden.
    Der Prozess hat zwei Modi: Im REPLACE-Modus (Standard) werden alle bestehenden Gruppenmitgliedschaften
    gelöscht; im ADD-Modus werden nur neue Mitgliedschaften hinzugefügt.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will copy security from one user to another.\
    \ Target client(s) will be created if it doesn't exist.\n\n# Use case: Intended for production.\n\
    # 1/ When a company hires new employees their profile can be set up by cloning an existing\
    \ employee.\n\n# Note:\n# Naturally, a valid source client (pSrcClient) is mandatory otherwise\
    \ the process will abort.\n# Also, a valid target client(s) (pTgtClient) must be specified,\
    \ otherwise the process will abort:\n# - Multiple target clients can be specified separated\
    \ by a delimiter.\n# - If target client doesn't already exist then Bedrock.Security.Client.Create\
    \ will be called.\n# - The process has 2 modes REPLACE (default) clears any existing group\
    \ memberships. ADD only adds new ones. \n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n\n### Constants\
    \ ###\ncThisProcName       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\\
    m\\d\\h\\i\\s' );\nsRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName\
    \           = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pSrcClient:%pSrcClient%, pTgtClient:%pTgtClient%, pMode:%pMode%, pDelim:%pDelim%.'\
    \ ;  \n  \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n\n\
    # If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim\
    \          = '&';\nEndIf;\n\n# If blank mode specified then convert to default\nIf( pMode\
    \ @= '' );\n    pMode           = 'REPLACE';\nEndIf;\n\n# If unsupported mode specified\
    \ then abort\nIf( pMode @= 'ADD' % pMode @= 'REPLACE' );\n    # all is OK\nElse; \n    nErrors\
    \         = 1;\n    sMessage        = 'Invalid mode specified. Must be ADD or REPLACE';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If no source\
    \ client has been specified then terminate process\nIf( Trim( pSrcClient ) @= '' );\n  \
    \  nErrors         = 1;\n    sMessage        = 'No source client specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimIx( '}Clients', pSrcClient )\
    \ = 0 );\n    nErrors         = 1;\n    sMessage        = 'Source client does not exist';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElse;\n    pSrcClient   \
    \   = DimensionElementPrincipalName( '}Clients', pSrcClient );\nEndIf;\n\n# If no target\
    \ clients have been specified then terminate process\nIf( Trim( pTgtClient ) @= '' );\n\
    \    nErrors         = 1;\n    sMessage        = 'No target client(s) specified.';\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimIx( '}Clients', pTgtClient\
    \ ) > 0 );\n    pTgtClient      = DimensionElementPrincipalName( '}Clients', pTgtClient\
    \ );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Split\
    \ pClients into individual Clients and add only if they don't exist ###\n\nsClients    \
    \        = Trim( pTgtClient );\nnDelimiterIndex     = 1;\n\n# loop delimited string of target\
    \ clients\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex = Scan( pDelim, sClients\
    \ );\n    If( nDelimiterIndex = 0 );\n        sClient     = sClients;\n    Else;\n     \
    \   sClient     = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n        sClients \
    \   = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n   \
    \ EndIf;\n    # Don't attempt to add a blank client\n    If( sClient @<> '' );\n       \
    \ If( DimIx( '}Clients', sClient ) = 0 );\n            ExecuteProcess( '}bedrock.security.client.create',\
    \ 'pStrictErrorHandling', pStrictErrorHandling, 'pClient', sClient);\n        EndIf;\n \
    \   EndIf;\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Update group memberships ###\nsClients       \
    \     = Trim( pTgtClient );\nnDelimiterIndex     = 1;\n\n# loop delimited string of target\
    \ clients\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex = Scan( pDelim, sClients\
    \ );\n    If( nDelimiterIndex = 0 );\n        sClient     = sClients;\n    Else;\n     \
    \   sClient     = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n        sClients \
    \   = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n   \
    \ EndIf;\n    If( DimIx( '}Clients', sClient ) >= 1 );\n        IF (pPassword @<>'');\n\
    \          sPassExists = CellGetS('}ClientProperties', sClient, 'PASSWORD');\n         \
    \ IF (sPassExists @='');\n            AssignClientPassword( sClient, pPassword );\n    \
    \      EndIf;  \n        EndIf;\n        sClient     = DimensionElementPrincipalName( '}Clients',\
    \ sClient );\n        # loop all security groups\n        nGroupIndex = 1;\n        nMaxGroups\
    \  = DimSiz( '}Groups' );\n        While( nGroupIndex <= nMaxGroups );\n            sGroup\
    \  = DimNm( '}Groups', nGroupIndex );\n            If( sGroup @= CellGetS( '}ClientGroups',\
    \ pSrcClient, sGroup ) );\n                AssignClientToGroup( sClient, sGroup );\n   \
    \         Else;\n                If( pMode @= 'REPLACE' );\n                    # don't\
    \ need to check if user in group. If user not in group then no error with RemoveClientFromGroup\
    \ function\n                    RemoveClientFromGroup( sClient, sGroup );\n            \
    \    EndIf;\n            EndIf;\n            nGroupIndex = nGroupIndex + 1;\n          \
    \  # exit loop of }Groups \n        End;\n    EndIf;\n    # exit loop of target clients\
    \ \nEnd;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully cloned %pSrcClient% to %pTgtClient% by %pMode%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that copies security from one user to another.
    If the target user(s) do not exist, they should be automatically created. This process is
    intended for production use. It allows the setup of new employee profiles by cloning an
    existing employee. Note: A valid source client (pSrcClient) is mandatory; otherwise, the
    process will abort. Similarly, a valid target client(s) (pTgtClient) must be specified;
    otherwise, the process will abort. Multiple target clients can be specified, separated by
    a delimiter. If the target client does not already exist, the Bedrock.Security.Client.Create
    function should be called. The process has two modes: In REPLACE mode (default), all existing
    group memberships are cleared; in ADD mode, only new memberships are added.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will copy security from one user to another.\
    \ Target client(s) will be created if it doesn't exist.\n\n# Use case: Intended for production.\n\
    # 1/ When a company hires new employees their profile can be set up by cloning an existing\
    \ employee.\n\n# Note:\n# Naturally, a valid source client (pSrcClient) is mandatory otherwise\
    \ the process will abort.\n# Also, a valid target client(s) (pTgtClient) must be specified,\
    \ otherwise the process will abort:\n# - Multiple target clients can be specified separated\
    \ by a delimiter.\n# - If target client doesn't already exist then Bedrock.Security.Client.Create\
    \ will be called.\n# - The process has 2 modes REPLACE (default) clears any existing group\
    \ memberships. ADD only adds new ones. \n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n\n### Constants\
    \ ###\ncThisProcName       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\\
    m\\d\\h\\i\\s' );\nsRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName\
    \           = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pSrcClient:%pSrcClient%, pTgtClient:%pTgtClient%, pMode:%pMode%, pDelim:%pDelim%.'\
    \ ;  \n  \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n\n\
    # If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim\
    \          = '&';\nEndIf;\n\n# If blank mode specified then convert to default\nIf( pMode\
    \ @= '' );\n    pMode           = 'REPLACE';\nEndIf;\n\n# If unsupported mode specified\
    \ then abort\nIf( pMode @= 'ADD' % pMode @= 'REPLACE' );\n    # all is OK\nElse; \n    nErrors\
    \         = 1;\n    sMessage        = 'Invalid mode specified. Must be ADD or REPLACE';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If no source\
    \ client has been specified then terminate process\nIf( Trim( pSrcClient ) @= '' );\n  \
    \  nErrors         = 1;\n    sMessage        = 'No source client specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimIx( '}Clients', pSrcClient )\
    \ = 0 );\n    nErrors         = 1;\n    sMessage        = 'Source client does not exist';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElse;\n    pSrcClient   \
    \   = DimensionElementPrincipalName( '}Clients', pSrcClient );\nEndIf;\n\n# If no target\
    \ clients have been specified then terminate process\nIf( Trim( pTgtClient ) @= '' );\n\
    \    nErrors         = 1;\n    sMessage        = 'No target client(s) specified.';\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimIx( '}Clients', pTgtClient\
    \ ) > 0 );\n    pTgtClient      = DimensionElementPrincipalName( '}Clients', pTgtClient\
    \ );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Split\
    \ pClients into individual Clients and add only if they don't exist ###\n\nsClients    \
    \        = Trim( pTgtClient );\nnDelimiterIndex     = 1;\n\n# loop delimited string of target\
    \ clients\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex = Scan( pDelim, sClients\
    \ );\n    If( nDelimiterIndex = 0 );\n        sClient     = sClients;\n    Else;\n     \
    \   sClient     = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n        sClients \
    \   = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n   \
    \ EndIf;\n    # Don't attempt to add a blank client\n    If( sClient @<> '' );\n       \
    \ If( DimIx( '}Clients', sClient ) = 0 );\n            ExecuteProcess( '}bedrock.security.client.create',\
    \ 'pStrictErrorHandling', pStrictErrorHandling, 'pClient', sClient);\n        EndIf;\n \
    \   EndIf;\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Update group memberships ###\nsClients       \
    \     = Trim( pTgtClient );\nnDelimiterIndex     = 1;\n\n# loop delimited string of target\
    \ clients\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex = Scan( pDelim, sClients\
    \ );\n    If( nDelimiterIndex = 0 );\n        sClient     = sClients;\n    Else;\n     \
    \   sClient     = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n        sClients \
    \   = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n   \
    \ EndIf;\n    If( DimIx( '}Clients', sClient ) >= 1 );\n        IF (pPassword @<>'');\n\
    \          sPassExists = CellGetS('}ClientProperties', sClient, 'PASSWORD');\n         \
    \ IF (sPassExists @='');\n            AssignClientPassword( sClient, pPassword );\n    \
    \      EndIf;  \n        EndIf;\n        sClient     = DimensionElementPrincipalName( '}Clients',\
    \ sClient );\n        # loop all security groups\n        nGroupIndex = 1;\n        nMaxGroups\
    \  = DimSiz( '}Groups' );\n        While( nGroupIndex <= nMaxGroups );\n            sGroup\
    \  = DimNm( '}Groups', nGroupIndex );\n            If( sGroup @= CellGetS( '}ClientGroups',\
    \ pSrcClient, sGroup ) );\n                AssignClientToGroup( sClient, sGroup );\n   \
    \         Else;\n                If( pMode @= 'REPLACE' );\n                    # don't\
    \ need to check if user in group. If user not in group then no error with RemoveClientFromGroup\
    \ function\n                    RemoveClientFromGroup( sClient, sGroup );\n            \
    \    EndIf;\n            EndIf;\n            nGroupIndex = nGroupIndex + 1;\n          \
    \  # exit loop of }Groups \n        End;\n    EndIf;\n    # exit loop of target clients\
    \ \nEnd;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully cloned %pSrcClient% to %pTgtClient% by %pMode%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der zur Erstellung von Clients für
    mehrere neue Mitarbeiter gleichzeitig dient. Der Prozess weist jedem erstellten Client ein
    Passwort und eine maximale Anzahl von Ports zu. Beachte, dass die Angabe eines Clients (pClient)
    zwingend erforderlich ist, da der Prozess sonst abbricht. Mehrere Clients können durch ein
    Trennzeichen getrennt angegeben werden. Wenn ein Client bereits existiert, wird der Prozess
    ihn nicht erneut erstellen, sondern stattdessen das Passwort und die maximale Anzahl von
    Ports zurücksetzen. Beachte, dass jedem Client anschließend eine Gruppe zugewiesen werden
    muss. Dieser Prozess ist für die Produktion gedacht.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create clients, assign a password and\
    \ max ports.\n\n# Use case: Intended for production.\n# 1/ Create clients for multiple new\
    \ hires simultaneously.\n\n# Note:\n# Naturally, a client (pClient) is mandatory otherwise\
    \ the process will abort.\n# - Multiple clients can be specified separated by a delimiter.\n\
    # - If client already exists then the process will not attempt to re-create it but will\
    \ reset password and max ports.\n# - Each client will have to be assigned to a group afterwards.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pPassword:******,\
    \ pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             =\
    \ 0;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n  pDelim\
    \            = '&';\nEndIf;\n\n# If no clients have been specified then terminate process\n\
    If( Trim( pClient ) @= '' );\n  nErrors           = 1;\n  sMessage          = 'No clients\
    \ specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n###\
    \ Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling =\
    \ 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Alias\n\
    If( pAlias @<> '' );\n    If( DimensionExists( '}ElementAttributes_}Clients' ) = 0 );\n\
    \        AttrInsert( '}Clients', '', '}TM1_DefaultDisplayValue', 'A' );\n    ElseIf( DimIx(\
    \ '}ElementAttributes_}Clients', '}TM1_DefaultDisplayValue' ) = 0 );\n        AttrInsert(\
    \ '}Clients', '', '}TM1_DefaultDisplayValue', 'A' );\n    EndIf;\nEndIf;\n\n### Split pClient\
    \ into individual Clients and add ###\nsClients            = pClient;\nnDelimiterIndex \
    \    = 1;\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex   = Scan( pDelim, sClients\
    \ );\n    If( nDelimiterIndex = 0 );\n        sClient         = sClients;\n    Else;\n \
    \       sClient         = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n        sClients\
    \        = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n\
    \    EndIf;\n    # Don't attempt to add a blank client\n    If( sClient @<> '' );\n    \
    \    If( DimIx( '}Clients', sClient ) = 0 );\n            If( nErrors = 0 );\n         \
    \       AddClient( sClient );\n            EndIf;\n        EndIf;\n    EndIf;\nEnd;\n\n\
    If( nErrors = 0 );\n    DimensionSortOrder( '}Clients', 'ByName', 'Ascending', 'ByName'\
    \ , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Update password & Alias\n\nIf(\
    \ nErrors = 0 );\n\n  sAliases  = pAlias;\n  sClients  = pClient;\n  nDelimiterIndex = 1;\n\
    \n  While( nDelimiterIndex > 0 );\n    nDelimiterIndex = Scan( pDelim, sAliases );\n   \
    \ If( nDelimiterIndex = 0 );\n      sAlias    = sAliases;\n    Else;\n      sAlias    =\
    \ Trim( SubSt( sAliases, 1, nDelimiterIndex - 1 ) );\n      sAliases  = Trim( Subst( sAliases,\
    \ nDelimiterIndex + Long(pDelim), Long( sAliases ) ) );\n    EndIf;\n    nDelimiterIndex\
    \ = Scan( pDelim, sClients );\n    If( nDelimiterIndex = 0 );\n      sClient   = sClients;\n\
    \    Else;\n      sClient   = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n     \
    \ sClients  = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) )\
    \ );\n    EndIf;\n    \n    If( DimIx( '}Clients', sClient ) > 0 );\n      AssignClientPassword(\
    \ sClient, pPassword );\n      If( sAlias @<> '' );\n        AttrPutS( sAlias, '}Clients',\
    \ sClient, '}TM1_DefaultDisplayValue', 1 );\n      EndIf;\n    EndIf;\n  End;\n\nEndIf;\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully added user(s) %pClient% to }Clients Dimension.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process to create clients for multiple new hires
    simultaneously. The process assigns a password and a maximum number of ports to each created
    client. Note that specifying a client (pClient) is mandatory; otherwise, the process will
    abort. Multiple clients can be specified, separated by a delimiter. If a client already
    exists, the process will not attempt to recreate it but will reset the password and the
    maximum number of ports. Note that each client must be assigned to a group afterwards. This
    process is intended for production.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create clients, assign a password and\
    \ max ports.\n\n# Use case: Intended for production.\n# 1/ Create clients for multiple new\
    \ hires simultaneously.\n\n# Note:\n# Naturally, a client (pClient) is mandatory otherwise\
    \ the process will abort.\n# - Multiple clients can be specified separated by a delimiter.\n\
    # - If client already exists then the process will not attempt to re-create it but will\
    \ reset password and max ports.\n# - Each client will have to be assigned to a group afterwards.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pPassword:******,\
    \ pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             =\
    \ 0;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n  pDelim\
    \            = '&';\nEndIf;\n\n# If no clients have been specified then terminate process\n\
    If( Trim( pClient ) @= '' );\n  nErrors           = 1;\n  sMessage          = 'No clients\
    \ specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n###\
    \ Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling =\
    \ 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Alias\n\
    If( pAlias @<> '' );\n    If( DimensionExists( '}ElementAttributes_}Clients' ) = 0 );\n\
    \        AttrInsert( '}Clients', '', '}TM1_DefaultDisplayValue', 'A' );\n    ElseIf( DimIx(\
    \ '}ElementAttributes_}Clients', '}TM1_DefaultDisplayValue' ) = 0 );\n        AttrInsert(\
    \ '}Clients', '', '}TM1_DefaultDisplayValue', 'A' );\n    EndIf;\nEndIf;\n\n### Split pClient\
    \ into individual Clients and add ###\nsClients            = pClient;\nnDelimiterIndex \
    \    = 1;\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex   = Scan( pDelim, sClients\
    \ );\n    If( nDelimiterIndex = 0 );\n        sClient         = sClients;\n    Else;\n \
    \       sClient         = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n        sClients\
    \        = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n\
    \    EndIf;\n    # Don't attempt to add a blank client\n    If( sClient @<> '' );\n    \
    \    If( DimIx( '}Clients', sClient ) = 0 );\n            If( nErrors = 0 );\n         \
    \       AddClient( sClient );\n            EndIf;\n        EndIf;\n    EndIf;\nEnd;\n\n\
    If( nErrors = 0 );\n    DimensionSortOrder( '}Clients', 'ByName', 'Ascending', 'ByName'\
    \ , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Update password & Alias\n\nIf(\
    \ nErrors = 0 );\n\n  sAliases  = pAlias;\n  sClients  = pClient;\n  nDelimiterIndex = 1;\n\
    \n  While( nDelimiterIndex > 0 );\n    nDelimiterIndex = Scan( pDelim, sAliases );\n   \
    \ If( nDelimiterIndex = 0 );\n      sAlias    = sAliases;\n    Else;\n      sAlias    =\
    \ Trim( SubSt( sAliases, 1, nDelimiterIndex - 1 ) );\n      sAliases  = Trim( Subst( sAliases,\
    \ nDelimiterIndex + Long(pDelim), Long( sAliases ) ) );\n    EndIf;\n    nDelimiterIndex\
    \ = Scan( pDelim, sClients );\n    If( nDelimiterIndex = 0 );\n      sClient   = sClients;\n\
    \    Else;\n      sClient   = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n     \
    \ sClients  = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) )\
    \ );\n    EndIf;\n    \n    If( DimIx( '}Clients', sClient ) > 0 );\n      AssignClientPassword(\
    \ sClient, pPassword );\n      If( sAlias @<> '' );\n        AttrPutS( sAlias, '}Clients',\
    \ sClient, '}TM1_DefaultDisplayValue', 1 );\n      EndIf;\n    EndIf;\n  End;\n\nEndIf;\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully added user(s) %pClient% to }Clients Dimension.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der zur Löschung von Klienten bestimmt
    ist. Der Anwendungsfall umfasst die Bereinigung der Benutzer nach der Umstellung in der
    Entwicklungs- und Produktionsumgebung sowie die Entfernung ehemaliger Mitarbeiter bei deren
    Kündigung. Bitte beachte, dass ein gültiger Klient oder mehrere Klienten erforderlich sind,
    ansonsten wird der Prozess abgebrochen. Mehrere Klienten können durch ein Trennzeichen angegeben
    werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete clients.\n\n# Use case: Intended\
    \ for development and production.\n# 1/ Clean up users after go live.\n# 2/ Remove old employees\
    \ from the system on termination.\n\n# Note:\n# Naturally, a valid client(s) (pClient) is\
    \ mandatory otherwise the process will abort:\n# - Multiple clients can be specified separated\
    \ by a delimiter. \n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName = GetProcessName();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \ = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub = cThisProcName | '_' | cTimeStamp\
    \ | '_' | cRandomInt;\ncTempFile = GetProcessErrorFileDirectory | cTempSub | '.csv';\ncClientDim\
    \ = '}Clients';\ncClientHier = cClientDim;\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pDelim:%pDelim%.'\
    \ ; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# If no clients\
    \ have been specified then terminate process\nIf( Trim( pClient ) @= '' );\n  nErrors =\
    \ 1;\n  sMessage = 'No clients specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Check alias exists\nIf( DimensionExists('}ElementAttributes_'|cClientDim)\
    \ = 0 % DimIx('}ElementAttributes_'|cClientDim, '}TM1_DefaultDisplayValue') = 0 );\n   \
    \ AttrInsert( cClientDim, '', '}TM1_DefaultDisplayValue', 'A' );\nEndIf;\n\n### Split pClient\
    \ into individual clients and delete ###\nsClients            = pClient;\nnDelimiterIndex\
    \     = 1;\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex = Scan( pDelim, sClients );\n\
    \  If( nDelimiterIndex = 0 );\n    sClient = sClients;\n  Else;\n    sClient = Trim( SubSt(\
    \ sClients, 1, nDelimiterIndex - 1 ) );\n    sClients = Trim( Subst( sClients, nDelimiterIndex\
    \ + Long(pDelim), Long( sClients ) ) );\n  EndIf;\n  \n  If( Scan( '*', sClient ) = 0);\n\
    \    If( sClient @<> '' );\n      If( DimIx( cClientDim, sClient ) <> 0 );\n        sClient\
    \ = DimensionElementPrincipalName(cClientDim,sClient);\n        If( sClient @<> 'Admin'\
    \ & sClient @<> TM1User() );\n            DeleteClient(sClient);\n        ElseIf( sClient\
    \ @= 'Admin' );\n            nErrors = 1;\n            sMessage = 'Skipping attempt to delete\
    \ Admin user.';\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \        ElseIf( sClient @= TM1User() );\n            nErrors = 1;\n            sMessage\
    \ = 'Skipping attempt to delete self.';\n            LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n        EndIf;\n      Else;\n        nErrors = 1;\n        sMessage\
    \ = 'Client: ' | sClient | ' does not exist.';\n        LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n      Endif;\n      If( nErrors > 0 );\n          ItemReject( Expand(\
    \ cMsgErrorContent ) );\n      EndIf;\n    Endif;  \n  Else;\n  # Wildcard search string\n\
    \    iCount = 0;\n    iCheck = 1;\n    sChar = sClient;\n    While (iCheck > 0);\n     \
    \ iCheck = Scan('*',sChar);\n      If( iCheck > 0 );\n        iCount = iCount + 1;\n   \
    \     sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n      Endif;\n    End;\n    If(iCount\
    \ = 1);\n      ##If the wilcardsearch is *String, below code will get executed\n      if(Subst(sClient,iCount,1)\
    \ @= '*');\n        sClient1 = '''| Subst(sClient,iCount+1,(Long(sClient)- iCount))|''';\n\
    \        sTempCount = NumbertoString(Long(sClient)-iCount);\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (Right( ['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'|\
    \ sTempCount|') ='|sClient1|'))}+\n                {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (Right( ['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'| sTempCount|')\
    \ ='|sClient1|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n        \
    \    # If a delimited list of Client names includes wildcards then we may have to re-use\
    \ the subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n \
    \       Else;\n            # temp subset, therefore no need to destroy in epilog\n     \
    \       SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n        EndIf;\n        \n\
    \        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n \
    \       nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n          sTemp = HierarchySubsetElementGetIndex(cClientDim,\
    \ cClientHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cClientDim,\
    \ cClientHier, cTempSub, nCount);\n          If( sElement @<> 'Admin' & sElement @<> TM1User()\
    \ );\n              DeleteClient(sElement);\n          ElseIf( sElement @= 'Admin' );\n\
    \              LogOutput( 'WARN', 'Skipping attempt to delete Admin user.' );\n        \
    \  ElseIf( sElement @= TM1User() );\n              LogOutput( 'WARN', 'Skipping attempt\
    \ to delete self.' );\n          EndIf;\n          nCount = nCount -1;\n        End;\n \
    \       ##If the wilcardsearch is String*, below code will get executed\n        ElseIf(Subst(sClient,Long(sClient),1)\
    \ @= '*');\n\n        sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n\
    \        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n         \
    \       (INSTR('| NumbertoString(iCount)|', ['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}+\n                {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) =\
    \ 1 );\n            # If a delimited list of Client names includes wildcards then we may\
    \ have to re-use the subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub,\
    \ sMDX );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n        EndIf;\n\n   \
    \     nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n    \
    \    nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n          sTemp = HierarchySubsetElementGetIndex\
    \ (cClientDim, cClientHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cClientDim,\
    \ cClientHier, cTempSub, nCount);\n          If( sElement @<> 'Admin' & sElement @<> TM1User()\
    \ );\n              DeleteClient(sElement);\n          ElseIf( sElement @= 'Admin' );\n\
    \              LogOutput( 'WARN', 'Skipping attempt to delete Admin user.' );\n        \
    \  ElseIf( sElement @= TM1User() );\n              LogOutput( 'WARN', 'Skipping attempt\
    \ to delete self.' );\n          EndIf;\n          nCount = nCount -1;\n        End;\n \
    \     Endif;\n    Else;\n      ##If the wilcardsearch is *String*, below code will get executed\n\
    \      sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n      sMdx =\
    \ '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n              (INSTR(1,['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ <> 0))}+\n              {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \              (INSTR(1,['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'|sClient1|')\
    \ <> 0))}';\n      If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a delimited\
    \ list of Client names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n      Else;\n        \
    \    # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cClientDim, 1 );\n      EndIf;\n\n      nHier_Sub_Size = HierarchySubsetGetSize(cClientDim,\
    \ cClientHier, cTempSub);\n      nCount = nHier_Sub_Size;\n      While (nCount >= 1);\n\
    \        sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '',\
    \ 1);\n        sElement = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub,\
    \ nCount);\n          If( sElement @<> 'Admin' & sElement @<> TM1User() );\n           \
    \   DeleteClient(sElement);\n          ElseIf( sElement @= 'Admin' );\n              LogOutput(\
    \ 'WARN', 'Skipping attempt to delete Admin user.' );\n          ElseIf( sElement @= TM1User()\
    \ );\n              LogOutput( 'WARN', 'Skipping attempt to delete self.' );\n         \
    \ EndIf;\n        nCount = nCount -1;\n      End;\n    Endif;\n  EndIf;\nEnd;\n\nIf( nErrors\
    \ = 0 );\n  DimensionSortOrder( cClientDim, 'ByName', 'Ascending', 'ByName' , 'Ascending'\
    \ );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted Client %pClient% from dimension\
    \ %cClientDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process designed to delete clients. The use case
    includes cleaning up users after go-live in development and production environments and
    removing former employees upon termination. Note that a valid client or clients (pClient)
    are mandatory; otherwise, the process will abort. Multiple clients can be specified separated
    by a delimiter.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete clients.\n\n# Use case: Intended\
    \ for development and production.\n# 1/ Clean up users after go live.\n# 2/ Remove old employees\
    \ from the system on termination.\n\n# Note:\n# Naturally, a valid client(s) (pClient) is\
    \ mandatory otherwise the process will abort:\n# - Multiple clients can be specified separated\
    \ by a delimiter. \n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName = GetProcessName();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \ = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub = cThisProcName | '_' | cTimeStamp\
    \ | '_' | cRandomInt;\ncTempFile = GetProcessErrorFileDirectory | cTempSub | '.csv';\ncClientDim\
    \ = '}Clients';\ncClientHier = cClientDim;\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pDelim:%pDelim%.'\
    \ ; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# If no clients\
    \ have been specified then terminate process\nIf( Trim( pClient ) @= '' );\n  nErrors =\
    \ 1;\n  sMessage = 'No clients specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Check alias exists\nIf( DimensionExists('}ElementAttributes_'|cClientDim)\
    \ = 0 % DimIx('}ElementAttributes_'|cClientDim, '}TM1_DefaultDisplayValue') = 0 );\n   \
    \ AttrInsert( cClientDim, '', '}TM1_DefaultDisplayValue', 'A' );\nEndIf;\n\n### Split pClient\
    \ into individual clients and delete ###\nsClients            = pClient;\nnDelimiterIndex\
    \     = 1;\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex = Scan( pDelim, sClients );\n\
    \  If( nDelimiterIndex = 0 );\n    sClient = sClients;\n  Else;\n    sClient = Trim( SubSt(\
    \ sClients, 1, nDelimiterIndex - 1 ) );\n    sClients = Trim( Subst( sClients, nDelimiterIndex\
    \ + Long(pDelim), Long( sClients ) ) );\n  EndIf;\n  \n  If( Scan( '*', sClient ) = 0);\n\
    \    If( sClient @<> '' );\n      If( DimIx( cClientDim, sClient ) <> 0 );\n        sClient\
    \ = DimensionElementPrincipalName(cClientDim,sClient);\n        If( sClient @<> 'Admin'\
    \ & sClient @<> TM1User() );\n            DeleteClient(sClient);\n        ElseIf( sClient\
    \ @= 'Admin' );\n            nErrors = 1;\n            sMessage = 'Skipping attempt to delete\
    \ Admin user.';\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \        ElseIf( sClient @= TM1User() );\n            nErrors = 1;\n            sMessage\
    \ = 'Skipping attempt to delete self.';\n            LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n        EndIf;\n      Else;\n        nErrors = 1;\n        sMessage\
    \ = 'Client: ' | sClient | ' does not exist.';\n        LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n      Endif;\n      If( nErrors > 0 );\n          ItemReject( Expand(\
    \ cMsgErrorContent ) );\n      EndIf;\n    Endif;  \n  Else;\n  # Wildcard search string\n\
    \    iCount = 0;\n    iCheck = 1;\n    sChar = sClient;\n    While (iCheck > 0);\n     \
    \ iCheck = Scan('*',sChar);\n      If( iCheck > 0 );\n        iCount = iCount + 1;\n   \
    \     sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n      Endif;\n    End;\n    If(iCount\
    \ = 1);\n      ##If the wilcardsearch is *String, below code will get executed\n      if(Subst(sClient,iCount,1)\
    \ @= '*');\n        sClient1 = '''| Subst(sClient,iCount+1,(Long(sClient)- iCount))|''';\n\
    \        sTempCount = NumbertoString(Long(sClient)-iCount);\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (Right( ['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'|\
    \ sTempCount|') ='|sClient1|'))}+\n                {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (Right( ['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'| sTempCount|')\
    \ ='|sClient1|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n        \
    \    # If a delimited list of Client names includes wildcards then we may have to re-use\
    \ the subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n \
    \       Else;\n            # temp subset, therefore no need to destroy in epilog\n     \
    \       SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n        EndIf;\n        \n\
    \        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n \
    \       nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n          sTemp = HierarchySubsetElementGetIndex(cClientDim,\
    \ cClientHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cClientDim,\
    \ cClientHier, cTempSub, nCount);\n          If( sElement @<> 'Admin' & sElement @<> TM1User()\
    \ );\n              DeleteClient(sElement);\n          ElseIf( sElement @= 'Admin' );\n\
    \              LogOutput( 'WARN', 'Skipping attempt to delete Admin user.' );\n        \
    \  ElseIf( sElement @= TM1User() );\n              LogOutput( 'WARN', 'Skipping attempt\
    \ to delete self.' );\n          EndIf;\n          nCount = nCount -1;\n        End;\n \
    \       ##If the wilcardsearch is String*, below code will get executed\n        ElseIf(Subst(sClient,Long(sClient),1)\
    \ @= '*');\n\n        sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n\
    \        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n         \
    \       (INSTR('| NumbertoString(iCount)|', ['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}+\n                {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) =\
    \ 1 );\n            # If a delimited list of Client names includes wildcards then we may\
    \ have to re-use the subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub,\
    \ sMDX );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n        EndIf;\n\n   \
    \     nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n    \
    \    nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n          sTemp = HierarchySubsetElementGetIndex\
    \ (cClientDim, cClientHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cClientDim,\
    \ cClientHier, cTempSub, nCount);\n          If( sElement @<> 'Admin' & sElement @<> TM1User()\
    \ );\n              DeleteClient(sElement);\n          ElseIf( sElement @= 'Admin' );\n\
    \              LogOutput( 'WARN', 'Skipping attempt to delete Admin user.' );\n        \
    \  ElseIf( sElement @= TM1User() );\n              LogOutput( 'WARN', 'Skipping attempt\
    \ to delete self.' );\n          EndIf;\n          nCount = nCount -1;\n        End;\n \
    \     Endif;\n    Else;\n      ##If the wilcardsearch is *String*, below code will get executed\n\
    \      sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n      sMdx =\
    \ '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n              (INSTR(1,['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ <> 0))}+\n              {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \              (INSTR(1,['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'|sClient1|')\
    \ <> 0))}';\n      If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a delimited\
    \ list of Client names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n      Else;\n        \
    \    # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cClientDim, 1 );\n      EndIf;\n\n      nHier_Sub_Size = HierarchySubsetGetSize(cClientDim,\
    \ cClientHier, cTempSub);\n      nCount = nHier_Sub_Size;\n      While (nCount >= 1);\n\
    \        sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '',\
    \ 1);\n        sElement = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub,\
    \ nCount);\n          If( sElement @<> 'Admin' & sElement @<> TM1User() );\n           \
    \   DeleteClient(sElement);\n          ElseIf( sElement @= 'Admin' );\n              LogOutput(\
    \ 'WARN', 'Skipping attempt to delete Admin user.' );\n          ElseIf( sElement @= TM1User()\
    \ );\n              LogOutput( 'WARN', 'Skipping attempt to delete self.' );\n         \
    \ EndIf;\n        nCount = nCount -1;\n      End;\n    Endif;\n  EndIf;\nEnd;\n\nIf( nErrors\
    \ = 0 );\n  DimensionSortOrder( cClientDim, 'ByName', 'Ascending', 'ByName' , 'Ascending'\
    \ );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above\
    \ lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted Client %pClient% from dimension\
    \ %cClientDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der die Sicherheitszuweisung von
    Kunden und Gruppen verwaltet. Dieser Prozess ist für die Produktionsumgebung gedacht und
    wird verwendet, nachdem neue Benutzer über ''}ti.security.client.create'' hinzugefügt wurden,
    da diesen Benutzern Gruppen zugewiesen werden müssen. Beachte, dass ein gültiger Kunde (pClient)
    erforderlich ist, um Zuweisungen vornehmen zu können. Der Prozess kann Kunden je nach pAddOrRemove
    zu Gruppen hinzufügen oder aus diesen entfernen. Er unterstützt die Verarbeitung eines einzelnen
    oder mehrerer Kunden, die durch ein Trennzeichen getrennt sind, sowie eines einzelnen oder
    mehrerer Gruppen, die ebenfalls durch ein Trennzeichen getrennt sind. Daher kann er verwendet
    werden, um: einen einzelnen Kunden zu einer einzelnen Gruppe hinzuzufügen oder daraus zu
    entfernen, viele Kunden zu einer einzelnen Gruppe hinzuzufügen oder daraus zu entfernen,
    einen einzelnen Kunden zu mehreren Gruppen hinzuzufügen oder daraus zu entfernen, oder viele
    Kunden zu mehreren Gruppen hinzuzufügen oder daraus zu entfernen. Der Prozess erlaubt es
    dem Anwender, zu entscheiden, ob die Sicherheit am Ende aktualisiert werden soll, wobei
    die Standardeinstellung auf ''ja'' gesetzt ist.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will assign Client and Group Security.\n\n\
    # Use case: Intended for production.\n# 1/ After adding new user(s) using '}bedrock.security.client.create'\
    \ they must be assigned to groups.\n\n# Note:\n# Naturally, valid  client (pClient) is mandatory\
    \ otherwise the process can't make assignments:\n# - This process can either add or remove\
    \ clients to groups based on pAddOrRemove.\n# - This process can work on a single client\
    \ or multiple clients separated by a delimiter.\n# - This process can work on a single group\
    \ or multiple groups separated by a delimiter.\n# - Therefore, it can be used to:\n#   -\
    \ Add/remove a single client to/from a single group.\n#   - Add/remove many clients to/from\
    \ a single group.\n#   - Add/remove a single client to/from many groups.\n#   - Add/remove\
    \ many clients to/from many groups.\n# - The caller can choose whether or not to refresh\
    \ security at the end. Default is yes.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName = GetProcessName();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \ = NumberToString( INT( RAND( ) * 1000 ));\ncUserName         = TM1User();\ncTempSub  \
    \        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pGroup:%pGroup%,\
    \ pDelim:%pDelim%, pAddOrRemove:%pAddOrRemove%, pSecurityRefresh:%pSecurityRefresh%.' ;\
    \  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# If no clients have been\
    \ specified then terminate process\nIf( Trim( pClient ) @= '' );\n    nErrors = 1;\n   \
    \ sMessage = 'No clients specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If no groups have been specified then terminate process\nIf( Trim( pGroup\
    \ ) @= '' );\n    nErrors = 1;\n    sMessage = 'No groups specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# If pSecurityRefresh is blank then default to\
    \ yes\nIf( Trim( pSecurityRefresh ) @= '' );\n    pSecurityRefresh = 'Yes';\nEndIf;\n\n\
    # If pAddOrDelete has not been specified correctly then terminate process\nIf( Upper( pAddOrRemove\
    \ ) @<> 'ADD' & Upper( pAddOrRemove ) @<> 'REMOVE' );\n    nErrors = 1;\n    sMessage =\
    \ 'Incorrect value for pAddOrRemove: ' | pAddOrRemove | '. Valid values are Add or Remove';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If pSecurityRefresh\
    \ has not been specified correctly then terminate process\nIf( Upper( pSecurityRefresh )\
    \ @<> 'YES' & Upper( pSecurityRefresh ) @<> 'NO' );\n    nErrors = 1;\n    sMessage = 'Incorrect\
    \ value for pSecurityRefresh: ' | pSecurityRefresh | '. Valid values are Yes or No';\n \
    \   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n###\
    \ Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling =\
    \ 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Add/remove\
    \ clients to/from groups ###\n\n# Loop through list of clients\nsClients            = pClient;\n\
    nClientDelimIndex   = 1;\nWhile( nClientDelimIndex <> 0 );\n  nClientDelimIndex = Scan(\
    \ pDelim, sClients );\n  If( nClientDelimIndex = 0 );\n    sClient         = sClients;\n\
    \  Else;\n    sClient         = Trim( SubSt( sClients, 1, nClientDelimIndex - 1 ) );\n \
    \   sClients        = Trim( Subst( sClients, nClientDelimIndex + Long(pDelim), Long( sClients\
    \ ) ) );\n  EndIf;\n  \n  If(Scan('*', sClient) = 0 & Scan('?', sClient) = 0);\n  # Don't\
    \ attempt to process a blank client\n   If( sClient @<> '' );\n     # Check that client\
    \ exists\n     If( DimIx( '}Clients', sClient ) = 0 );\n        nErrors     = 1;\n     \
    \   sMessage    = 'Client: ' | sClient | ' does not exists';\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n     ELSE;\n        # Loop through list of Groups\n   \
    \     sGroups                 = pGroup;\n        nGroupDelimIndex        = 1;\n        While(\
    \ nGroupDelimIndex <> 0 );\n            nGroupDelimIndex    = Scan( pDelim, sGroups );\n\
    \            If( nGroupDelimIndex = 0 );\n                sGroup          = sGroups;\n \
    \           Else;\n                sGroup          = Trim( SubSt( sGroups, 1, nGroupDelimIndex\
    \ - 1 ) );\n                sGroups         = Trim( Subst( sGroups, nGroupDelimIndex + Long(pDelim),\
    \ Long( sGroups ) ) );\n            EndIf;\n            If( Scan( '*', sGroup ) = 0 & Scan('?',\
    \ sGroup ) = 0 );\n                # Don't attempt to process a blank Group\n          \
    \      If( sGroup @<> '' );\n                    # Check that group exists\n           \
    \         If( DimIx( '}Groups', sGroup ) = 0 );\n                        nErrors = 1;\n\
    \                        sMessage = 'Group: ' | sGroup | ' does not exists';\n         \
    \               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n             \
    \       ELSE;\n                        # Add/Remove Client\n                        If(\
    \ Upper( pAddOrRemove ) @= 'ADD' );\n                            AssignClientToGroup( sClient,\
    \ sGroup );\n                        ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n    \
    \                        RemoveClientFromGroup( sClient, sGroup );\n                   \
    \     EndIf;\n                    EndIf;\n                EndIf;\n            ELSE;\n  \
    \              # Wildcard search string\n                sGroup = '''|sGroup|''';\n    \
    \            sGroupDim = '}Groups';\n                sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([\
    \ ' |sGroupDim| '])},'| sGroup| ')}';\n                If( SubsetExists( sGroupDim, cTempSub\
    \ ) = 1 );\n                    # If a delimited list of Groups includes wildcards then\
    \ we may have to re-use the subset multiple times\n                    SubsetMDXSet( sGroupDim,\
    \ cTempSub, sMDX );\n                Else;\n                    # temp subset, therefore\
    \ no need to destroy in epilog\n                    SubsetCreatebyMDX( cTempSub, sMDX, sGroupDim,\
    \ 1 );\n                EndIf;\n                nCountGrp = SubsetGetSize( sGroupDim, cTempSub\
    \ );\n                While( nCountGrp >= 1 );\n                    sGroup = SubsetGetElementName(\
    \ sGroupDim, cTempSub, nCountGrp );\n                    # Add/Remove Client\n         \
    \           If( Upper( pAddOrRemove ) @= 'ADD' );\n                        AssignClientToGroup(\
    \ sClient, sGroup );\n                    ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n\
    \                        RemoveClientFromGroup( sClient, sGroup );\n                   \
    \ EndIf;\n                    nCountGrp = nCountGrp - 1;\n                End;\n       \
    \     Endif;    \n        End;\n     EndIf;\n   EndIf;\n  ELSE;\n  # Wildcard search string\n\
    \        sClientDim = '}Clients';\n        sClient = '''|sClient|''';\n        sMdx = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |sClientDim| '])},'| sClient| ')}';\n        If( SubsetExists( sClientDim,\
    \ cTempSub ) = 1 );\n            # If a delimited list of Clients includes wildcards then\
    \ we may have to re-use the subset multiple times\n            SubsetMDXSet( sClientDim,\
    \ cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, sClientDim, 1 );\n        EndIf;\n\
    \        # Loop through dimensions in clients with wildcard\n        nCountClient = SubsetGetSize(\
    \ '}Clients' , cTempSub );\n        While( nCountClient >= 1 );\n            \n        \
    \    sClient = SubsetGetElementName( '}Clients' , cTempSub, nCountClient );\n          \
    \  # Validate client name\n            If( Dimix('}Clients', sClient) = 0 );\n         \
    \       nErrors = 1;\n                sMessage = Expand( 'Client '%sClient%' does not exist.'\
    \ );\n                LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n            Else;\n\
    \              # Loop through list of Groups\n              sGroups = pGroup;\n        \
    \      nGroupDelimIndex = 1;\n              While( nGroupDelimIndex <> 0 );\n          \
    \      nGroupDelimIndex = Scan( pDelim, sGroups );\n                If( nGroupDelimIndex\
    \ = 0 );\n                   sGroup = sGroups;\n                Else;\n                \
    \   sGroup = Trim( SubSt( sGroups, 1, nGroupDelimIndex - 1 ) );\n                   sGroups\
    \ = Trim( Subst( sGroups, nGroupDelimIndex + Long(pDelim), Long( sGroups ) ) );\n      \
    \          EndIf;\n                If( Scan( '*', sGroup ) = 0 & Scan('?',sGroup ) = 0);\n\
    \                  # Don't attempt to process a blank Group\n                  If( sGroup\
    \ @<> '' );\n                    # Check that group exists\n                    If( DimIx(\
    \ '}Groups', sGroup ) = 0 );\n                        nErrors = 1;\n                   \
    \     sMessage = 'Group: ' | sGroup | ' does not exists';\n                        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                    ELSE;\n           \
    \           # Add/Remove Client\n                      If( Upper( pAddOrRemove ) @= 'ADD'\
    \ );\n                        AssignClientToGroup( sClient, sGroup );\n                \
    \      ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n                        RemoveClientFromGroup(\
    \ sClient, sGroup );\n                      EndIf;\n                    EndIf;\n       \
    \           EndIf;\n                ELSE;\n                # Wildcard search string\n  \
    \              sGroup = '''|sGroup|''';\n                sGroupDim = '}Groups';\n      \
    \          sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sGroupDim| '])},'| sGroup| ')}';\n\
    \                If( SubsetExists( sGroupDim, cTempSub ) = 1 );\n                   # If\
    \ a delimited list of objects includes wildcards then we may have to re-use the subset multiple\
    \ times\n                   SubsetMDXSet( sGroupDim, cTempSub, sMDX );\n               \
    \ Else;\n                   # temp subset, therefore no need to destroy in epilog\n    \
    \               SubsetCreatebyMDX( cTempSub, sMDX, sGroupDim, 1 );\n                EndIf;\n\
    \                nCountGrp = SubsetGetSize( sGroupDim, cTempSub );\n                  While(\
    \ nCountGrp >= 1 );\n                      sGroup = SubsetGetElementName( sGroupDim, cTempSub,\
    \ nCountGrp );\n                      # Add/Remove Client\n                      If( Upper(\
    \ pAddOrRemove ) @= 'ADD' );\n                          AssignClientToGroup( sClient, sGroup\
    \ );\n                      ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n             \
    \             RemoveClientFromGroup( sClient, sGroup );\n                      EndIf;\n\
    \                      nCountGrp = nCountGrp - 1;\n                  End;\n            \
    \   EndIf;\n              End;\n            Endif;\n            nCountClient = nCountClient\
    \ - 1;\n        End;\n  Endif;  \nEnd;\n\n### Refresh Security ###\n\nIf( Upper( pSecurityRefresh\
    \ ) @= 'YES' );\n  SecurityRefresh;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully performed %pAddOrRemove%\
    \ for client %pClient% to group %pGroup%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n\n### End Epilog\
    \ ###"
- question: 'Develop an IBM Turbo Integrator process that manages the assignment of client and
    group security. This process is intended for the production environment and is used after
    adding new users via ''}ti.security.client.create'', as these users need to be assigned
    to groups. Note that a valid client (pClient) is mandatory for making assignments. The process
    can add or remove clients from groups based on pAddOrRemove. It supports processing a single
    client or multiple clients separated by a delimiter, as well as a single group or multiple
    groups separated by a delimiter. Therefore, it can be used to: add/remove a single client
    to/from a single group, add/remove many clients to/from a single group, add/remove a single
    client to/from many groups, or add/remove many clients to/from many groups. The process
    allows the user to choose whether to refresh security at the end, with the default setting
    being ''yes''.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will assign Client and Group Security.\n\n\
    # Use case: Intended for production.\n# 1/ After adding new user(s) using '}bedrock.security.client.create'\
    \ they must be assigned to groups.\n\n# Note:\n# Naturally, valid  client (pClient) is mandatory\
    \ otherwise the process can't make assignments:\n# - This process can either add or remove\
    \ clients to groups based on pAddOrRemove.\n# - This process can work on a single client\
    \ or multiple clients separated by a delimiter.\n# - This process can work on a single group\
    \ or multiple groups separated by a delimiter.\n# - Therefore, it can be used to:\n#   -\
    \ Add/remove a single client to/from a single group.\n#   - Add/remove many clients to/from\
    \ a single group.\n#   - Add/remove a single client to/from many groups.\n#   - Add/remove\
    \ many clients to/from many groups.\n# - The caller can choose whether or not to refresh\
    \ security at the end. Default is yes.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName = GetProcessName();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \ = NumberToString( INT( RAND( ) * 1000 ));\ncUserName         = TM1User();\ncTempSub  \
    \        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo\
    \          = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pGroup:%pGroup%,\
    \ pDelim:%pDelim%, pAddOrRemove:%pAddOrRemove%, pSecurityRefresh:%pSecurityRefresh%.' ;\
    \  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# If no clients have been\
    \ specified then terminate process\nIf( Trim( pClient ) @= '' );\n    nErrors = 1;\n   \
    \ sMessage = 'No clients specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If no groups have been specified then terminate process\nIf( Trim( pGroup\
    \ ) @= '' );\n    nErrors = 1;\n    sMessage = 'No groups specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# If pSecurityRefresh is blank then default to\
    \ yes\nIf( Trim( pSecurityRefresh ) @= '' );\n    pSecurityRefresh = 'Yes';\nEndIf;\n\n\
    # If pAddOrDelete has not been specified correctly then terminate process\nIf( Upper( pAddOrRemove\
    \ ) @<> 'ADD' & Upper( pAddOrRemove ) @<> 'REMOVE' );\n    nErrors = 1;\n    sMessage =\
    \ 'Incorrect value for pAddOrRemove: ' | pAddOrRemove | '. Valid values are Add or Remove';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If pSecurityRefresh\
    \ has not been specified correctly then terminate process\nIf( Upper( pSecurityRefresh )\
    \ @<> 'YES' & Upper( pSecurityRefresh ) @<> 'NO' );\n    nErrors = 1;\n    sMessage = 'Incorrect\
    \ value for pSecurityRefresh: ' | pSecurityRefresh | '. Valid values are Yes or No';\n \
    \   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n###\
    \ Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling =\
    \ 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Add/remove\
    \ clients to/from groups ###\n\n# Loop through list of clients\nsClients            = pClient;\n\
    nClientDelimIndex   = 1;\nWhile( nClientDelimIndex <> 0 );\n  nClientDelimIndex = Scan(\
    \ pDelim, sClients );\n  If( nClientDelimIndex = 0 );\n    sClient         = sClients;\n\
    \  Else;\n    sClient         = Trim( SubSt( sClients, 1, nClientDelimIndex - 1 ) );\n \
    \   sClients        = Trim( Subst( sClients, nClientDelimIndex + Long(pDelim), Long( sClients\
    \ ) ) );\n  EndIf;\n  \n  If(Scan('*', sClient) = 0 & Scan('?', sClient) = 0);\n  # Don't\
    \ attempt to process a blank client\n   If( sClient @<> '' );\n     # Check that client\
    \ exists\n     If( DimIx( '}Clients', sClient ) = 0 );\n        nErrors     = 1;\n     \
    \   sMessage    = 'Client: ' | sClient | ' does not exists';\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n     ELSE;\n        # Loop through list of Groups\n   \
    \     sGroups                 = pGroup;\n        nGroupDelimIndex        = 1;\n        While(\
    \ nGroupDelimIndex <> 0 );\n            nGroupDelimIndex    = Scan( pDelim, sGroups );\n\
    \            If( nGroupDelimIndex = 0 );\n                sGroup          = sGroups;\n \
    \           Else;\n                sGroup          = Trim( SubSt( sGroups, 1, nGroupDelimIndex\
    \ - 1 ) );\n                sGroups         = Trim( Subst( sGroups, nGroupDelimIndex + Long(pDelim),\
    \ Long( sGroups ) ) );\n            EndIf;\n            If( Scan( '*', sGroup ) = 0 & Scan('?',\
    \ sGroup ) = 0 );\n                # Don't attempt to process a blank Group\n          \
    \      If( sGroup @<> '' );\n                    # Check that group exists\n           \
    \         If( DimIx( '}Groups', sGroup ) = 0 );\n                        nErrors = 1;\n\
    \                        sMessage = 'Group: ' | sGroup | ' does not exists';\n         \
    \               LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n             \
    \       ELSE;\n                        # Add/Remove Client\n                        If(\
    \ Upper( pAddOrRemove ) @= 'ADD' );\n                            AssignClientToGroup( sClient,\
    \ sGroup );\n                        ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n    \
    \                        RemoveClientFromGroup( sClient, sGroup );\n                   \
    \     EndIf;\n                    EndIf;\n                EndIf;\n            ELSE;\n  \
    \              # Wildcard search string\n                sGroup = '''|sGroup|''';\n    \
    \            sGroupDim = '}Groups';\n                sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([\
    \ ' |sGroupDim| '])},'| sGroup| ')}';\n                If( SubsetExists( sGroupDim, cTempSub\
    \ ) = 1 );\n                    # If a delimited list of Groups includes wildcards then\
    \ we may have to re-use the subset multiple times\n                    SubsetMDXSet( sGroupDim,\
    \ cTempSub, sMDX );\n                Else;\n                    # temp subset, therefore\
    \ no need to destroy in epilog\n                    SubsetCreatebyMDX( cTempSub, sMDX, sGroupDim,\
    \ 1 );\n                EndIf;\n                nCountGrp = SubsetGetSize( sGroupDim, cTempSub\
    \ );\n                While( nCountGrp >= 1 );\n                    sGroup = SubsetGetElementName(\
    \ sGroupDim, cTempSub, nCountGrp );\n                    # Add/Remove Client\n         \
    \           If( Upper( pAddOrRemove ) @= 'ADD' );\n                        AssignClientToGroup(\
    \ sClient, sGroup );\n                    ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n\
    \                        RemoveClientFromGroup( sClient, sGroup );\n                   \
    \ EndIf;\n                    nCountGrp = nCountGrp - 1;\n                End;\n       \
    \     Endif;    \n        End;\n     EndIf;\n   EndIf;\n  ELSE;\n  # Wildcard search string\n\
    \        sClientDim = '}Clients';\n        sClient = '''|sClient|''';\n        sMdx = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |sClientDim| '])},'| sClient| ')}';\n        If( SubsetExists( sClientDim,\
    \ cTempSub ) = 1 );\n            # If a delimited list of Clients includes wildcards then\
    \ we may have to re-use the subset multiple times\n            SubsetMDXSet( sClientDim,\
    \ cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, sClientDim, 1 );\n        EndIf;\n\
    \        # Loop through dimensions in clients with wildcard\n        nCountClient = SubsetGetSize(\
    \ '}Clients' , cTempSub );\n        While( nCountClient >= 1 );\n            \n        \
    \    sClient = SubsetGetElementName( '}Clients' , cTempSub, nCountClient );\n          \
    \  # Validate client name\n            If( Dimix('}Clients', sClient) = 0 );\n         \
    \       nErrors = 1;\n                sMessage = Expand( 'Client '%sClient%' does not exist.'\
    \ );\n                LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n            Else;\n\
    \              # Loop through list of Groups\n              sGroups = pGroup;\n        \
    \      nGroupDelimIndex = 1;\n              While( nGroupDelimIndex <> 0 );\n          \
    \      nGroupDelimIndex = Scan( pDelim, sGroups );\n                If( nGroupDelimIndex\
    \ = 0 );\n                   sGroup = sGroups;\n                Else;\n                \
    \   sGroup = Trim( SubSt( sGroups, 1, nGroupDelimIndex - 1 ) );\n                   sGroups\
    \ = Trim( Subst( sGroups, nGroupDelimIndex + Long(pDelim), Long( sGroups ) ) );\n      \
    \          EndIf;\n                If( Scan( '*', sGroup ) = 0 & Scan('?',sGroup ) = 0);\n\
    \                  # Don't attempt to process a blank Group\n                  If( sGroup\
    \ @<> '' );\n                    # Check that group exists\n                    If( DimIx(\
    \ '}Groups', sGroup ) = 0 );\n                        nErrors = 1;\n                   \
    \     sMessage = 'Group: ' | sGroup | ' does not exists';\n                        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                    ELSE;\n           \
    \           # Add/Remove Client\n                      If( Upper( pAddOrRemove ) @= 'ADD'\
    \ );\n                        AssignClientToGroup( sClient, sGroup );\n                \
    \      ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n                        RemoveClientFromGroup(\
    \ sClient, sGroup );\n                      EndIf;\n                    EndIf;\n       \
    \           EndIf;\n                ELSE;\n                # Wildcard search string\n  \
    \              sGroup = '''|sGroup|''';\n                sGroupDim = '}Groups';\n      \
    \          sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sGroupDim| '])},'| sGroup| ')}';\n\
    \                If( SubsetExists( sGroupDim, cTempSub ) = 1 );\n                   # If\
    \ a delimited list of objects includes wildcards then we may have to re-use the subset multiple\
    \ times\n                   SubsetMDXSet( sGroupDim, cTempSub, sMDX );\n               \
    \ Else;\n                   # temp subset, therefore no need to destroy in epilog\n    \
    \               SubsetCreatebyMDX( cTempSub, sMDX, sGroupDim, 1 );\n                EndIf;\n\
    \                nCountGrp = SubsetGetSize( sGroupDim, cTempSub );\n                  While(\
    \ nCountGrp >= 1 );\n                      sGroup = SubsetGetElementName( sGroupDim, cTempSub,\
    \ nCountGrp );\n                      # Add/Remove Client\n                      If( Upper(\
    \ pAddOrRemove ) @= 'ADD' );\n                          AssignClientToGroup( sClient, sGroup\
    \ );\n                      ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n             \
    \             RemoveClientFromGroup( sClient, sGroup );\n                      EndIf;\n\
    \                      nCountGrp = nCountGrp - 1;\n                  End;\n            \
    \   EndIf;\n              End;\n            Endif;\n            nCountClient = nCountClient\
    \ - 1;\n        End;\n  Endif;  \nEnd;\n\n### Refresh Security ###\n\nIf( Upper( pSecurityRefresh\
    \ ) @= 'YES' );\n  SecurityRefresh;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully performed %pAddOrRemove%\
    \ for client %pClient% to group %pGroup%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n\n### End Epilog\
    \ ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der von Administratoren verwendet
    werden kann, um das Passwort eines Kunden zurückzusetzen. Dieser Prozess ist für den Einsatz
    in der Produktion gedacht. Wenn ein Benutzer sein Passwort vergessen hat, kann dieser TI-Prozess
    verwendet werden, um es zurückzusetzen. Beachten Sie, dass ein gültiger Kunde (oder gültige
    Kunden) als zwingend erforderlich angegeben werden muss, da der Prozess sonst abbricht.
    Mehrere Kunden können durch ein Trennzeichen angegeben werden. Der Prozess muss von einer
    administrativen Person durchgeführt werden, da er sonst abgebrochen wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can be used by admins to reset a client password.\n\
    \n# Use case: Intended for production.\n# 1/ When a user has forgotten his/her password\
    \ this TI can be used to reset it.\n\n# Note:\n# Naturally, a valid client(s) (pClient)\
    \ is mandatory otherwise the process will abort.\n# Multiple clients can be specified separated\
    \ by a delimiter.\n# It has to be run by an ADMIN person otherwsie it will abort.\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory\
    \ | cTempSub | '.csv';\ncClientDim          = '}Clients';\ncClientHier         = cClientDim;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pClient:%pClient%, pPassword:******, pDelim:%pDelim%.' ;  \n\n### Validate Parameters\
    \ ###\nnErrors             = 0;\n\n# If blank delimiter specified then convert to default\n\
    If( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n# If no clients have been specified then\
    \ terminate process\nIf( Trim( pClient ) @= '' );\n    nErrors = 1;\n    sMessage = 'No\
    \ clients specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Check if the person executing the process has admin rights\n\nIF( CELLGETS( '}ClientGroups',\
    \ cUserName, 'Admin' ) @<> 'ADMIN' & CELLGETS( '}ClientGroups', cUserName, 'DataAdmin' )\
    \ @<> 'DataAdmin' & cUserName @<> pClient );\n    nErrors = 1;\n    sMessage = 'No Admin\
    \ access to change other clients password.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nENDIF;\n\n### Check for errors before continuing\nIf( nErrors > 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Split\
    \ pClient into individual clients and reset password ###\n\nsClients = pClient;\nnDelimiterIndex\
    \ = 1;\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex = Scan( pDelim, sClients );\n\
    \  If( nDelimiterIndex = 0 );\n    sClient = sClients;\n  Else;\n    sClient = Trim( SubSt(\
    \ sClients, 1, nDelimiterIndex - 1 ) );\n    sClients = Trim( Subst( sClients, nDelimiterIndex\
    \ + Long(pDelim), Long( sClients ) ) );\n  EndIf;\n  \n  If(Scan('*',sClient) = 0);\n  #\
    \ Don't attempt to update a blank client\n    If( sClient @<> '' );\n      If( DimIx( '}Clients',\
    \ sClient ) <> 0 );\n        If( nErrors = 0 );\n          sClient = DimensionElementPrincipalName(\
    \ '}Clients', sClient );\n          AssignClientPassword( sClient, pPassword );\n      \
    \  EndIf;\n      EndIf;\n    EndIf;\n  Else;\n    # Wildcard search string\n    iCount =\
    \ 0;\n    iCheck = 1;\n    sChar = sClient;\n    While (iCheck > 0);\n      iCheck = Scan('*',sChar);\n\
    \      If( iCheck > 0 );\n        iCount = iCount + 1;\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n\
    \      Endif;\n    End;\n    If(iCount = 1);\n      ##If the wilcardsearch is *String, below\
    \ code will get executed\n      if(Subst(sClient,iCount,1) @= '*');\n        sClient1 =\
    \ '''| Subst(sClient,iCount+1,(Long(sClient)- iCount))|''';\n        sTempCount = NumbertoString(Long(sClient)-iCount);\n\
    \        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n           \
    \     (Right( ['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|')\
    \ ='|sClient1|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n        \
    \    # If a delimited list of client names includes wildcards then we may have to re-use\
    \ the subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n \
    \       Else;\n            # temp subset, therefore no need to destroy in epilog\n     \
    \       SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n        EndIf;        \n\n\
    \        nCount = 1;\n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier,\
    \ cTempSub);\n        While (nCount <= nHier_Sub_Size);\n          nSubsetIndex = 1;\n \
    \         sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '',\
    \ nSubsetIndex);\n          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier,\
    \ cTempSub, nCount);\n          AssignClientPassword(sElement,pPassword);\n          nCount\
    \ = nCount +1;\n        End;\n        ##If the wilcardsearch is String*, below code will\
    \ get executed\n        ElseIf(Subst(sClient,Long(sClient),1) @= '*');\n      \n       \
    \ sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) =\
    \ 1 );\n            # If a delimited list of client names includes wildcards then we may\
    \ have to re-use the subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub,\
    \ sMDX );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n        EndIf;       \
    \ \n\n        nCount = 1;\n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier,\
    \ cTempSub);\n        While (nCount <= nHier_Sub_Size);\n          nSubsetIndex = 1;\n \
    \         sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '',\
    \ nSubsetIndex);\n          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier,\
    \ cTempSub, nCount);\n          AssignClientPassword(sElement,pPassword);\n          nCount\
    \ = nCount +1;\n        End;\n      Endif;\n    Else;\n      ##If the wilcardsearch is *String*,\
    \ below code will get executed\n      sClient1 = '''| Subst(sClient,iCount,(Long(sClient)-\
    \ iCount))|''';\n      sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n\
    \              (INSTR(1,['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ <> 0))}';\n      If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a delimited\
    \ list of Client names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n      Else;\n        \
    \    # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cClientDim, 1 );\n      EndIf;\n\n      nCount = 1;\n      nHier_Sub_Size\
    \ = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n      While (nCount <= nHier_Sub_Size);\n\
    \        nSubsetIndex = 1;\n        sTemp = HierarchySubsetElementGetIndex (cClientDim,\
    \ cClientHier, cTempSub, '', nSubsetIndex);\n        sElement = HierarchySubsetGetElementName(cClientDim,\
    \ cClientHier, cTempSub, nCount);\n        AssignClientPassword(sElement,pPassword);\n \
    \       nCount = nCount +1;\n      End;\n    Endif;\n  EndIf;\nEnd;\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully reset password for client %pClient% .' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that can be used by administrators to reset
    a client's password. This process is intended for production use. When a user has forgotten
    his or her password, this TI process can be utilized to reset it. Note that specifying a
    valid client (or clients) is mandatory, or the process will abort. Multiple clients can
    be specified, separated by a delimiter. The process has to be executed by an administrative
    person; otherwise, it will abort.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can be used by admins to reset a client password.\n\
    \n# Use case: Intended for production.\n# 1/ When a user has forgotten his/her password\
    \ this TI can be used to reset it.\n\n# Note:\n# Naturally, a valid client(s) (pClient)\
    \ is mandatory otherwise the process will abort.\n# Multiple clients can be specified separated\
    \ by a delimiter.\n# It has to be run by an ADMIN person otherwsie it will abort.\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName\
    \ | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory\
    \ | cTempSub | '.csv';\ncClientDim          = '}Clients';\ncClientHier         = cClientDim;\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pClient:%pClient%, pPassword:******, pDelim:%pDelim%.' ;  \n\n### Validate Parameters\
    \ ###\nnErrors             = 0;\n\n# If blank delimiter specified then convert to default\n\
    If( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n# If no clients have been specified then\
    \ terminate process\nIf( Trim( pClient ) @= '' );\n    nErrors = 1;\n    sMessage = 'No\
    \ clients specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Check if the person executing the process has admin rights\n\nIF( CELLGETS( '}ClientGroups',\
    \ cUserName, 'Admin' ) @<> 'ADMIN' & CELLGETS( '}ClientGroups', cUserName, 'DataAdmin' )\
    \ @<> 'DataAdmin' & cUserName @<> pClient );\n    nErrors = 1;\n    sMessage = 'No Admin\
    \ access to change other clients password.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nENDIF;\n\n### Check for errors before continuing\nIf( nErrors > 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Split\
    \ pClient into individual clients and reset password ###\n\nsClients = pClient;\nnDelimiterIndex\
    \ = 1;\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex = Scan( pDelim, sClients );\n\
    \  If( nDelimiterIndex = 0 );\n    sClient = sClients;\n  Else;\n    sClient = Trim( SubSt(\
    \ sClients, 1, nDelimiterIndex - 1 ) );\n    sClients = Trim( Subst( sClients, nDelimiterIndex\
    \ + Long(pDelim), Long( sClients ) ) );\n  EndIf;\n  \n  If(Scan('*',sClient) = 0);\n  #\
    \ Don't attempt to update a blank client\n    If( sClient @<> '' );\n      If( DimIx( '}Clients',\
    \ sClient ) <> 0 );\n        If( nErrors = 0 );\n          sClient = DimensionElementPrincipalName(\
    \ '}Clients', sClient );\n          AssignClientPassword( sClient, pPassword );\n      \
    \  EndIf;\n      EndIf;\n    EndIf;\n  Else;\n    # Wildcard search string\n    iCount =\
    \ 0;\n    iCheck = 1;\n    sChar = sClient;\n    While (iCheck > 0);\n      iCheck = Scan('*',sChar);\n\
    \      If( iCheck > 0 );\n        iCount = iCount + 1;\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n\
    \      Endif;\n    End;\n    If(iCount = 1);\n      ##If the wilcardsearch is *String, below\
    \ code will get executed\n      if(Subst(sClient,iCount,1) @= '*');\n        sClient1 =\
    \ '''| Subst(sClient,iCount+1,(Long(sClient)- iCount))|''';\n        sTempCount = NumbertoString(Long(sClient)-iCount);\n\
    \        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n           \
    \     (Right( ['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|')\
    \ ='|sClient1|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n        \
    \    # If a delimited list of client names includes wildcards then we may have to re-use\
    \ the subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n \
    \       Else;\n            # temp subset, therefore no need to destroy in epilog\n     \
    \       SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n        EndIf;        \n\n\
    \        nCount = 1;\n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier,\
    \ cTempSub);\n        While (nCount <= nHier_Sub_Size);\n          nSubsetIndex = 1;\n \
    \         sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '',\
    \ nSubsetIndex);\n          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier,\
    \ cTempSub, nCount);\n          AssignClientPassword(sElement,pPassword);\n          nCount\
    \ = nCount +1;\n        End;\n        ##If the wilcardsearch is String*, below code will\
    \ get executed\n        ElseIf(Subst(sClient,Long(sClient),1) @= '*');\n      \n       \
    \ sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) =\
    \ 1 );\n            # If a delimited list of client names includes wildcards then we may\
    \ have to re-use the subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub,\
    \ sMDX );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n        EndIf;       \
    \ \n\n        nCount = 1;\n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier,\
    \ cTempSub);\n        While (nCount <= nHier_Sub_Size);\n          nSubsetIndex = 1;\n \
    \         sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '',\
    \ nSubsetIndex);\n          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier,\
    \ cTempSub, nCount);\n          AssignClientPassword(sElement,pPassword);\n          nCount\
    \ = nCount +1;\n        End;\n      Endif;\n    Else;\n      ##If the wilcardsearch is *String*,\
    \ below code will get executed\n      sClient1 = '''| Subst(sClient,iCount,(Long(sClient)-\
    \ iCount))|''';\n      sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n\
    \              (INSTR(1,['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ <> 0))}';\n      If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a delimited\
    \ list of Client names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n      Else;\n        \
    \    # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cClientDim, 1 );\n      EndIf;\n\n      nCount = 1;\n      nHier_Sub_Size\
    \ = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n      While (nCount <= nHier_Sub_Size);\n\
    \        nSubsetIndex = 1;\n        sTemp = HierarchySubsetElementGetIndex (cClientDim,\
    \ cClientHier, cTempSub, '', nSubsetIndex);\n        sElement = HierarchySubsetGetElementName(cClientDim,\
    \ cClientHier, cTempSub, nCount);\n        AssignClientPassword(sElement,pPassword);\n \
    \       nCount = nCount +1;\n      End;\n    Endif;\n  EndIf;\nEnd;\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully reset password for client %pClient% .' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der ein Zellsicherheitswürfel für
    einen angegebenen Würfel und eine bestimmte Liste von Dimensionen erstellt. Verwende die
    TI-Funktion _CellSecurityCubeCreate_, um dies zu ermöglichen. Dieser Prozess hat den Vorteil,
    dass man nicht jedes Mal einen benutzerdefinierten Prozess schreiben muss, um einen Zellsicherheitswürfel
    zu erstellen. Beachte, dass ein gültiger Würfel (pCube) zwingend erforderlich ist, da der
    Prozess sonst abbricht. Wenn die Zellsicherheit bereits eingerichtet wurde, wird der TI-Prozess
    ebenfalls abgebrochen. Der pDim-Parameter muss alle Dimensionen im Würfel in der Reihenfolge
    mit einer 0 oder 1 abbilden. Dieser Prozess ist für Entwicklungszwecke gedacht und dient
    zum Einrichten von Zellsicherheitswürfeln.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a cell security cube for the\
    \ specified cube for the specified list of dimensions \n# using the TI function _CellSecurityCubeCreate_.\
    \ The benefit of this process is not needing to write a custom\n# process each time in order\
    \ to create a cell security cube.\n\n# Use case: Intended for development.\n# 1/ Set up\
    \ cell security cubes\n\n# Note:\n# * Naturally, a valid cube (pCube) is mandatory otherwise\
    \ the process will abort.\n# * If cell security has already been set up the TI will abort.\n\
    # * The pDim parameter must map _ALL_ the dimensions in order in the cube with a 0 or 1.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo\
    \            = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDim:%pDim%.'\
    \ ;  \ncDelim              = ':';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n  \
    \  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors\
    \ = 0;\n\n# If no cube has been specified then terminate process\nIf( Trim( pCube ) @= ''\
    \ );\n    nErrors = 1;\n    sMessage = 'No cube specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) = 0 );\n    nErrors = 1;\n\
    \    sMessage = Expand('Cube %pCube% does not exist.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check if cell security cube already exists\n\
    If( CubeExists(  '}CellSecurity_' | pCube ) = 1 );\n    nErrors = 1;\n    sMessage = 'Cell\
    \ Security cube already exists.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Count\
    \ dimensions in cube ###\nnDims               = 0;\niDim                = 1;\nWhile( TabDim(\
    \ pCube, iDim ) @<> '' );\n   nDims            = iDim;\n   iDim             = iDim + 1;\n\
    End;\n\n### Count dimensions mapped in pDim ###\nsDimensions         = pDim;\nnDelimiterIndex\
    \     = 1;\nnMapDims            = 0;\niDim                = 1;\nWhile( nDelimiterIndex <>\
    \ 0 );\n    nMapDims        = iDim;\n    nDelimiterIndex = Scan( cDelim, sDimensions );\n\
    \    If( nDelimiterIndex = 0 );\n        sDimension  = sDimensions;\n    Else;\n       \
    \ sDimension  = Trim( SubSt( sDimensions, 1, nDelimiterIndex - 1 ) );\n        sDimensions\
    \ = Trim( Subst( sDimensions, nDelimiterIndex + Long(cDelim), Long( sDimensions ) ) );\n\
    \    EndIf;\n    # Redundant?\n    If( sDimension @= '1' );\n        sMessage    = ' INCLUDE\
    \ in cell security cube';\n    ElseIf( sDimension @= '0' );\n        sMessage    = ' EXCLUDE\
    \ from cell security cube';\n    Else;\n        sMessage    = ' INVALID map parameter: '\
    \ | sDimension;\n    EndIF;\n    iDim            = iDim + 1;\nEnd;\n\n### Check dimension\
    \ count of dimension map vs. dimensions in cube ###\nIf( nDims <> nMapDims );\n    nErrors\
    \         = 1;\n    sMessage        = 'Parameter count of dimension map does not match dimension\
    \ count of cube!';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElse;\n\
    \    nRet            = CellSecurityCubeCreate ( pCube, pDim );\n    If( nRet = 1 );\n  \
    \      sMessage    = '}CellSecurity_' | pCube | ' successfully created';\n        LogOutput(\
    \ 'INFO', Expand( cMsgErrorContent ) );\n    Else;\n        sMessage    = 'Error. Could\
    \ not create }CellSecurity_' | pCube;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created cell security for %pCube% and\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates a cell security cube for a
    specified cube and a specified list of dimensions. Use the TI function _CellSecurityCubeCreate_
    to achieve this. The advantage of this process is that it eliminates the need to write a
    custom process each time to create a cell security cube. Note that a valid cube (pCube)
    is mandatory, otherwise the process will abort. If cell security has already been set up,
    the TI process will also abort. The pDim parameter must map all dimensions in order in the
    cube with either a 0 or 1. This process is intended for development purposes and is used
    to set up cell security cubes.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a cell security cube for the\
    \ specified cube for the specified list of dimensions \n# using the TI function _CellSecurityCubeCreate_.\
    \ The benefit of this process is not needing to write a custom\n# process each time in order\
    \ to create a cell security cube.\n\n# Use case: Intended for development.\n# 1/ Set up\
    \ cell security cubes\n\n# Note:\n# * Naturally, a valid cube (pCube) is mandatory otherwise\
    \ the process will abort.\n# * If cell security has already been set up the TI will abort.\n\
    # * The pDim parameter must map _ALL_ the dimensions in order in the cube with a 0 or 1.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo\
    \            = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDim:%pDim%.'\
    \ ;  \ncDelim              = ':';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n  \
    \  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors\
    \ = 0;\n\n# If no cube has been specified then terminate process\nIf( Trim( pCube ) @= ''\
    \ );\n    nErrors = 1;\n    sMessage = 'No cube specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) = 0 );\n    nErrors = 1;\n\
    \    sMessage = Expand('Cube %pCube% does not exist.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check if cell security cube already exists\n\
    If( CubeExists(  '}CellSecurity_' | pCube ) = 1 );\n    nErrors = 1;\n    sMessage = 'Cell\
    \ Security cube already exists.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Count\
    \ dimensions in cube ###\nnDims               = 0;\niDim                = 1;\nWhile( TabDim(\
    \ pCube, iDim ) @<> '' );\n   nDims            = iDim;\n   iDim             = iDim + 1;\n\
    End;\n\n### Count dimensions mapped in pDim ###\nsDimensions         = pDim;\nnDelimiterIndex\
    \     = 1;\nnMapDims            = 0;\niDim                = 1;\nWhile( nDelimiterIndex <>\
    \ 0 );\n    nMapDims        = iDim;\n    nDelimiterIndex = Scan( cDelim, sDimensions );\n\
    \    If( nDelimiterIndex = 0 );\n        sDimension  = sDimensions;\n    Else;\n       \
    \ sDimension  = Trim( SubSt( sDimensions, 1, nDelimiterIndex - 1 ) );\n        sDimensions\
    \ = Trim( Subst( sDimensions, nDelimiterIndex + Long(cDelim), Long( sDimensions ) ) );\n\
    \    EndIf;\n    # Redundant?\n    If( sDimension @= '1' );\n        sMessage    = ' INCLUDE\
    \ in cell security cube';\n    ElseIf( sDimension @= '0' );\n        sMessage    = ' EXCLUDE\
    \ from cell security cube';\n    Else;\n        sMessage    = ' INVALID map parameter: '\
    \ | sDimension;\n    EndIF;\n    iDim            = iDim + 1;\nEnd;\n\n### Check dimension\
    \ count of dimension map vs. dimensions in cube ###\nIf( nDims <> nMapDims );\n    nErrors\
    \         = 1;\n    sMessage        = 'Parameter count of dimension map does not match dimension\
    \ count of cube!';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElse;\n\
    \    nRet            = CellSecurityCubeCreate ( pCube, pDim );\n    If( nRet = 1 );\n  \
    \      sMessage    = '}CellSecurity_' | pCube | ' successfully created';\n        LogOutput(\
    \ 'INFO', Expand( cMsgErrorContent ) );\n    Else;\n        sMessage    = 'Error. Could\
    \ not create }CellSecurity_' | pCube;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created cell security for %pCube% and\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der dazu bestimmt ist, das Zellen-Sicherheitswürfel(n)
    für die angegebenen Würfel zu löschen. Der Anwendungsfall ist für die Entwicklung gedacht
    und ermöglicht es, die Zellenebene-Sicherheit für einen oder mehrere Würfel zu entfernen.
    Beachte, dass ein gültiger Würfel (pCube) zwingend erforderlich ist, andernfalls wird der
    Prozess abgebrochen. Wenn für einen Würfel keine Zellen-Sicherheit eingerichtet ist, wird
    dieser Würfel übersprungen, jedoch ein Fehler protokolliert. Es können mehrere Würfel angegeben
    werden, die durch das Trennzeichen pDelim oder durch die Verwendung von Platzhaltern (*)
    voneinander getrennt sind.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will destroy the cell security cube(s) for\
    \ the specified cube(s).\n\n# Use case: Intended for development.\n# 1/ Remove cell level\
    \ security for one or more cubes.\n\n# Note:\n# Naturally, a valid cube (pCube) is mandatory\
    \ otherwise the process will abort.\n# If the cube does not have cell security set up, it\
    \ will skip that cube but log an error.\n# Multiple cubes can be specified separated by\
    \ the pDelim or by using wildcards (*).\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName = GetProcessName();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \ = NumberToString( INT( RAND( ) * 1000 ));\nDatasourceASCIIQuoteCharacter = '';\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% Message:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n## check\
    \ operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\n# If blank delimiter specified then convert to default\n\
    If( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n# If no cubes have been specified then\
    \ terminate process\nIf( Trim( pCube ) @= '' );\n    nErrors = 1;\n    sMessage = 'No cube(s)\
    \ specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\nEndIf;\n\
    \n### Split pCubes into individual Cubes  ###\nsCubes                  = pCube;\nnDelimiterIndex\
    \         = 1;\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex     = Scan( pDelim,\
    \ sCubes );\n    If( nDelimiterIndex = 0 );\n        sCube           = sCubes;\n    Else;\n\
    \        sCube           = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n        sCubes\
    \          = Trim( Subst( sCubes, nDelimiterIndex + Long(pDelim), Long( sCubes ) ) );\n\
    \    EndIf;\n  \n    # Check if a wildcard has been used to specify the Cube name.\n   \
    \ # If it hasn't then just delete the Cube if it exists\n    # If it has then search the\
    \ relevant Cube folder to find the matches\n    If( Scan( '*', sCube ) = 0 );\n        If(\
    \ CubeExists( sCube ) = 1 ); \n            If(CubeExists( '}CellSecurity_' | sCube ) = 1);\n\
    \                nRet = CellSecurityCubeDestroy( sCube );\n                If( nRet = 1\
    \ );\n                    sMessage = '}CellSecurity_' | sCube | ' successfully destroyed.';\n\
    \                    LogOutput( 'INFO', Expand( cMsgErrorContent ) );\n                Else;\n\
    \                    nErrors = 1;\n                    sMessage = 'Error. Could not destroy\
    \ }CellSecurity_' | sCube;\n                    LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n                EndIf;\n            Endif;\n        Endif;\n    Else;\n        #\
    \ Wildcard search string\n        sSearch                     = Expand('.%sOSDelim%%sCube%.cub');\n\
    \n        # Find all Cubes that match search string\n        sFilename                 \
    \  = WildcardFileSearch( sSearch, '' );\n        While( sFilename @<> '' );\n          \
    \  # Trim .cub off the filename\n            sCube                   = SubSt( sFilename,\
    \ 1, Long( sFilename ) - 4 );\n            # Destroy Cube\n            If( CubeExists( sCube\
    \ ) = 1 ); \n                If(CubeExists( '}CellSecurity_' | sCube ) = 1);\n         \
    \           nRet            = CellSecurityCubeDestroy( sCube );\n                    If(\
    \ nRet = 1 );\n                        sMessage    = '}CellSecurity_' | sCube | ' successfully\
    \ destroyed.';\n                        LogOutput( 'INFO', Expand( cMsgErrorContent ) );\n\
    \                    Else;\n                        nErrors     = 1;\n                 \
    \       sMessage    = 'Error. Could not destroy }CellSecurity_' | sCube;\n             \
    \           LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n                    EndIf;\n\
    \                Endif;\n            Endif;\n            sFilename               = WildcardFileSearch(\
    \ sSearch, sFilename );\n        End;\n    EndIf;\n\nEnd;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully detsroyed cell security for cube  %pCube%.' );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If(\
    \ pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\nsProcessReturnCode = pCube;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process intended to destroy the cell security cube(s)
    for the specified cube(s). This use case is intended for development and allows removing
    cell level security for one or more cubes. Note that a valid cube (pCube) is mandatory;
    otherwise, the process will abort. If a cube does not have cell security set up, it will
    skip that cube but log an error. Multiple cubes can be specified, separated by the delimiter
    pDelim or by using wildcards (*).
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will destroy the cell security cube(s) for\
    \ the specified cube(s).\n\n# Use case: Intended for development.\n# 1/ Remove cell level\
    \ security for one or more cubes.\n\n# Note:\n# Naturally, a valid cube (pCube) is mandatory\
    \ otherwise the process will abort.\n# If the cube does not have cell security set up, it\
    \ will skip that cube but log an error.\n# Multiple cubes can be specified separated by\
    \ the pDelim or by using wildcards (*).\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName = GetProcessName();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \ = NumberToString( INT( RAND( ) * 1000 ));\nDatasourceASCIIQuoteCharacter = '';\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% Message:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n## check\
    \ operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n### Validate\
    \ Parameters ###\nnErrors = 0;\n\n# If blank delimiter specified then convert to default\n\
    If( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n# If no cubes have been specified then\
    \ terminate process\nIf( Trim( pCube ) @= '' );\n    nErrors = 1;\n    sMessage = 'No cube(s)\
    \ specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\nEndIf;\n\
    \n### Split pCubes into individual Cubes  ###\nsCubes                  = pCube;\nnDelimiterIndex\
    \         = 1;\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex     = Scan( pDelim,\
    \ sCubes );\n    If( nDelimiterIndex = 0 );\n        sCube           = sCubes;\n    Else;\n\
    \        sCube           = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n        sCubes\
    \          = Trim( Subst( sCubes, nDelimiterIndex + Long(pDelim), Long( sCubes ) ) );\n\
    \    EndIf;\n  \n    # Check if a wildcard has been used to specify the Cube name.\n   \
    \ # If it hasn't then just delete the Cube if it exists\n    # If it has then search the\
    \ relevant Cube folder to find the matches\n    If( Scan( '*', sCube ) = 0 );\n        If(\
    \ CubeExists( sCube ) = 1 ); \n            If(CubeExists( '}CellSecurity_' | sCube ) = 1);\n\
    \                nRet = CellSecurityCubeDestroy( sCube );\n                If( nRet = 1\
    \ );\n                    sMessage = '}CellSecurity_' | sCube | ' successfully destroyed.';\n\
    \                    LogOutput( 'INFO', Expand( cMsgErrorContent ) );\n                Else;\n\
    \                    nErrors = 1;\n                    sMessage = 'Error. Could not destroy\
    \ }CellSecurity_' | sCube;\n                    LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n                EndIf;\n            Endif;\n        Endif;\n    Else;\n        #\
    \ Wildcard search string\n        sSearch                     = Expand('.%sOSDelim%%sCube%.cub');\n\
    \n        # Find all Cubes that match search string\n        sFilename                 \
    \  = WildcardFileSearch( sSearch, '' );\n        While( sFilename @<> '' );\n          \
    \  # Trim .cub off the filename\n            sCube                   = SubSt( sFilename,\
    \ 1, Long( sFilename ) - 4 );\n            # Destroy Cube\n            If( CubeExists( sCube\
    \ ) = 1 ); \n                If(CubeExists( '}CellSecurity_' | sCube ) = 1);\n         \
    \           nRet            = CellSecurityCubeDestroy( sCube );\n                    If(\
    \ nRet = 1 );\n                        sMessage    = '}CellSecurity_' | sCube | ' successfully\
    \ destroyed.';\n                        LogOutput( 'INFO', Expand( cMsgErrorContent ) );\n\
    \                    Else;\n                        nErrors     = 1;\n                 \
    \       sMessage    = 'Error. Could not destroy }CellSecurity_' | sCube;\n             \
    \           LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n                    EndIf;\n\
    \                Endif;\n            Endif;\n            sFilename               = WildcardFileSearch(\
    \ sSearch, sFilename );\n        End;\n    EndIf;\n\nEnd;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully detsroyed cell security for cube  %pCube%.' );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If(\
    \ pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\nsProcessReturnCode = pCube;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der identifiziert, welche Dimensionen
    über Sicherheit verfügen, insbesondere Elementesicherheit, und dynamische Teilmengen evaluiert,
    deren Ausdrücke von den neuesten MDX-Sicherheitsänderungen betroffen sind. Dieser Prozess
    ist sowohl für Entwicklungs- als auch für Produktivumgebungen gedacht.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will find out which dimensions have security\
    \ on them - element security - and evaluate dynamic subsets with expressions impacted by\
    \ the latest MDX security changes \n# Use case: Intended for development or production.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    StringGlobalVariable('sGlobPrivateSubsetsTotalString');\nsGlobPrivateSubsetsTotalString\
    \ = '';\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\n\
    cTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pNameSpace:%pNameSpace%,\
    \ pFilePath:%pFilePath%, pFileName:%pFileName%, pDelim:%pDelim%, pQuote:%pQuote%.' ;  \n\
    cMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\ncSecurityPrefix\
    \ = '}ElementSecurity_';\ncDimDim = '}Dimensions';\ncUserDim = '}Clients';\ncUserAttrDim=\
    \ '}ElementAttributes_}Clients';\ncUserAlias = '}TM1_DefaultDisplayValue';\ncSubsetPrefix\
    \ = '}Subsets_';\ncGroupDim = '}Groups';\ncSecCube = '}ClientGroups';\n\npFieldDelim   \
    \    = TRIM(pDelim);\nsCRChar           = Char( 13 );\nsLFChar           = Char( 10 );\n\
    sCRLF             = Char( 13 ) | Char( 10 );\ncLenASCIICode     = 3;\nnDataCount       \
    \ = 0;\nnErrors           = 0;\n\ncKeyWordList = 'DRILLDOWN&.Children&FirstChild&Ancestors&Ascendants&Cousin&DrillUp&FirstSibling&IsAncestor&FirstSibling&LastChild&LastSibling&Descendants';\n\
    cKeyWordList = UPPER ( cKeyWordList );\ncKeyWordDelimiter = '&';\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\n\n# Namespace\nIf( pNameSpace <> 0 & pNameSpace <> 1 );\n    nErrors \
    \        = 1;\n    sMessage        = 'NameSpace parameter not valid';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n# Validate file path\nIf(Trim( pFilePath ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf( SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\n    pFilePath = SubSt(\
    \ pFilePath, 1, Long( pFilePath ) -1 );\nEndIf;\nIf(  FileExists( pFilePath ) = 0 );\n \
    \   sMessage = Expand('Invalid export directory: %pFilePath%');\n    nErrors = nErrors +\
    \ 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npFilePath =\
    \ pFilePath | sOSDelim;\n\n# Validate file name\nIf( pFileName @= '' );\n    sBaseFileName\
    \ = Expand('%cThisProcName%_Export');\n    sExt = '.csv';\n    pFileName = sBaseFileName\
    \ | '.csv';\nElse;\n    # determine file extension. If no file extension entered then use\
    \ .csv as default\n    If( Scan( '.', pFileName ) = 0 );\n        sExt = '.csv';\n     \
    \   sBaseFileName = pFileName;\n    Else;\n        sExt = SubSt( pFileName, Scan( '.', pFileName\
    \ ), Long( pFileName ) );\n        sBaseFileName = SubSt( pFileName, 1, Scan( '.', pFileName\
    \ ) - 1 );\n    EndIf;\n    pFileName = sBaseFileName | sExt;\nEndIf;\ncExportFile = pFilePath\
    \ | pFileName;\n\n# Validate file delimiter & quote character\nIf( pFieldDelim @= '' );\n\
    \    pFieldDelim = ',';\nElse;\n    # If length of pFieldDelim is exactly 3 chars and each\
    \ of them is decimal digit, then the pFieldDelim is entered as ASCII code\n    nValid =\
    \ 0;\n    If ( LONG(pFieldDelim) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar\
    \ <= cLenASCIICode );\n        If( CODE( pFieldDelim, nChar ) >= CODE( '0', 1 ) & CODE(\
    \ pFieldDelim, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n    \
    \      nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n\
    \    If ( nValid<>0 );\n      pFieldDelim=CHAR(StringToNumber( pFieldDelim ));\n    Else;\n\
    \      pFieldDelim = SubSt( Trim( pFieldDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf( pQuote\
    \ @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is exactly\
    \ 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII code\n\
    \    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While\
    \ ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE(\
    \ pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n         \
    \ nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If\
    \ ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote\
    \ = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\nDatasourceAsciiDelimiter = pFieldDelim;\nDatasourceAsciiQuoteCharacter\
    \ = '';\nsTotalRowString = '';\n\nsTitleRow = '%pQuote%DIMENSION%pQuote%%pFieldDelim%%pQuote%HAS\
    \ SECURITY%pQuote%%pFieldDelim%%pQuote%SUBSET NAME%pQuote%';\nsTitleRow = sTitleRow|'%pFieldDelim%%pQuote%IS\
    \ PRIVATE%pQuote%%pFieldDelim%%pQuote%MDX EXPRESSION%pQuote%';\nsTitleRow = sTitleRow|'%pFieldDelim%%pQuote%KEYWORDS%pQuote%%pFieldDelim%%pQuote%ELEMENTS%pQuote%%pFieldDelim%%pQuote%USERS\
    \ WITH NO ACCESS%pQuote%';\nTextOutput( cExportFile, Expand(sTitleRow) );\nsTotalRowString\
    \ = Expand(sTitleRow);\n\niDim = 1;\nnMaxDim = DimSiz ( cDimDim );\n\nWhile ( iDim <= nMaxDim\
    \ );\n    sDim = DimNm ( cDimDim, iDim );\n    sSecurityCube = cSecurityPrefix | sDim;\n\
    \    If ( CubeExists ( sSecurityCube ) = 1 );\n        IF( pLogoutput = 1 );\n         \
    \   sMessage = 'The dimension ' | sDim | ' has element security assigned';\n           \
    \ LogOutput('INFO', Expand( cMsgInfoContent ) );\n        ENDIF;\n        # now we need\
    \ to go find subsets - two ways of doing this - data directory or }subset dimension\n  \
    \      # data directory is the only place to find private subs but need to know the username\
    \ to loop through  \n        iUser = 1;\n        nMaxUser = DimSiz ( cUserDim );\n     \
    \   While ( iUser <= nMaxUser );\n            sUser = DimNm ( cUserDim, iUser );\n     \
    \       # if CAMId is used folder structure is different\n            If ( DimIx ( cUserAttrDim,\
    \ cUserAlias ) > 0 );\n                sAlias = AttrS ( cUserDim, sUser, cUserAlias );\n\
    \                If ( sAlias @= '' );\n                    sAlias = sUser;\n           \
    \     EndIf;\n            EndIf; \n            sNamespacePrefix = '';\n            # if\
    \ CAMId is used folder structure is different\n            If ( pNamespace = 1 );\n    \
    \            # this \\ or / is hardcoded as it is the CAMID }TM1_DefaultDisplayValue alias\
    \ which sometimes uses back- and sometimes forward-slash. We aren't sanning for directory\
    \ separator.\n                nEnd = Scan( '/', sAlias);\n                If ( nEnd = 0\
    \ );\n                    nEnd = Scan ( '', sAlias );\n                EndIf;    \n    \
    \            sNamespace = SubSt ( sAlias, 1, nEnd - 1 );\n                sAlias = SubSt\
    \ ( sAlias, nEnd + 1, Long ( sAlias ) - nEnd );\n                sNamespacePrefix = sNameSpace\
    \ | sOSDelim;\n            EndIf;    \n            sSubset = WildcardFileSearch( Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%*.sub')\
    \ , '');\n            # loop through all subsets\n            While ( sSubset @<> '' );\n\
    \                sSubsetName = Subst ( sSubset, 1, LONG ( sSubset ) - 4 );\n           \
    \     sFile = Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%%sSubset%')\
    \ ;\n                IF( pLogoutput = 1 );\n                    sMessage = Expand('Private\
    \ subset called %sSubsetName% found for user %sAlias% in dimension %sDim%. File = %sFile%');\n\
    \                    LogOutput('INFO', Expand( cMsgInfoContent ) );\n                ENDIF;\n\
    \                # run the sub process to evaluate the MDX\n                If ( sSubset\
    \ @<> '' );\n                    nRet = ExecuteProcess('}bedrock.security.evaluate.mdx.private',\n\
    \                               'pLogOutput', pLogOutput,\n                            \
    \   'pStrictErrorHandling', pStrictErrorHandling,\n                               'pUser',\
    \ sUser,\n                               'pDimension', sDim,\n                         \
    \      'pSubset', sSubsetName,\n                               'pSubsetFile', sFile,\n \
    \                              'pFilePath', pFilePath,\n                               'pFileName',\
    \ '',\n                               'pDelim', pDelim,\n                              \
    \ 'pQuote', pQuote,\n                               'pWriteOutput', 0\n                \
    \      );\n                    If( nRet <> ProcessExitNormal() );\n                    \
    \    nErrors = nErrors + 1;\n                        sMessage= 'Error in evaluating private\
    \ subsets.';\n                        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n                    EndIf;\n\n                EndIf;  \n                sSubset\
    \ = WildcardFileSearch( Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%*.sub')\
    \ , sSubset);                \n            End;    \n            iUser = iUser + 1;\n  \
    \      End; \n        \n        sSubsetDim = cSubsetPrefix | sDim;\n        iSub = 1;\n\
    \        nSubsetMax = DimSiz ( sSubsetDim );\n        # loop through all subsets\n     \
    \   While ( iSub <= nSubsetMax );\n            sSubsetName = DimNm ( sSubsetDim, iSub );\n\
    \            sMDX = '';\n            sMDX = SubsetMDXGet ( sDim, sSubsetName );\n      \
    \      sMDX = UPPER ( sMDX );\n            If ( sMDX @<> '' );\n                ## Remove\
    \ line breaks from MDX string\n                nMDXLen = Long( sMDX );\n               \
    \ nMDXCount = 1;\n                While( nMDXCount <= nMDXLen );\n                  sCharPoint\
    \ = Subst( sMDX, nMDXCount, 1 );\n                  IF( sCharPoint @= sCRChar % sCharPoint\
    \ @= sLFChar );\n                      Delet( sMDX, nMDXCount, 1 );\n                  \
    \    nMDXLen = Long( sMDX );\n                  ENDIF;\n                  \n           \
    \       nMDXCount = nMDXCount + 1;\n                End;\n                nMDXLen = Long(\
    \ sMDX );\n                sMDXLastChar = Subst( sMDX, nMDXLen, 1 );\n                While(\
    \ sMDXLastChar @<> '}' );\n                  sMDX = Subst( sMDX, 1, nMDXLen - 1 );\n   \
    \               nMDXLen = Long( sMDX );\n                  sMDXLastChar = Subst( sMDX, nMDXLen,\
    \ 1 );\n                End;\n                sRow = '%pQuote%%sDim%%pQuote%%pFieldDelim%%pQuote%Y%pQuote%%pFieldDelim%%pQuote%%sSubsetName%%pQuote%%pFieldDelim%%pQuote%NO%pQuote%%pFieldDelim%%pQuote%%sMDX%%pQuote%';\n\
    \                IF( pLogoutput = 1 );\n                    sMessage = Expand('Public subset\
    \ called %sSubsetName% found in dimension %sDim% with MDX %sMDX%');\n                  \
    \  LogOutput('INFO', Expand( cMsgInfoContent ) );\n                ENDIF;\n            \
    \    # now parse the MDX \n                nKeywordFlag = 0;\n                sKeyWordString\
    \ = '';\n                sKeywordList = cKeywordList;\n                nKeywordLength =\
    \ Long ( sKeywordList );\n                While ( nKeywordLength > 0 );\n              \
    \      nDelimiter = Scan ( cKeywordDelimiter, sKeyWordList );\n                    If (\
    \ nDelimiter = 0 );\n                        sKeyword = sKeyWordList;\n                \
    \        sKeyWordList = '';\n                    Else;\n                        nEnd = nDelimiter\
    \ - 1;\n                        sKeyWord = SubSt ( sKeywordList, 1, nEnd );\n          \
    \              sKeyWordList = Subst ( sKeywordList, nEnd + 2, nKeywordLength - nEnd);\n\
    \                    EndIf;    \n                    If ( Scan( sKeyWord, sMDX ) > 0 );\n\
    \                        nKeyWordFlag = nKeyWordFlag + 1;\n                        IF( Long(\
    \ sKeyWordString ) = 0 );\n                          sKeyWordString = sKeyWordString | sKeyWord;\n\
    \                        ELSE;\n                          sKeyWordString = sKeyWordString\
    \ | pDelim | ' ' | sKeyWord;\n                        ENDIF;\n                        IF(\
    \ pLogoutput = 1 );\n                            sMessage = 'Keyword ' | sKeyWord | ' found\
    \ in ' | sMDX;\n                            LogOutput('INFO', Expand( cMsgInfoContent )\
    \ );\n                        ENDIF;\n                    EndIf;   \n                  \
    \  nKeywordLength = Long ( sKeywordList );\n                End;    \n                #\
    \ if keywords found then see if we can match an element in the MDX with one in the dimension\n\
    \                # element will be included within [] but there will be [dimension][hierarchy][subset][attribute]\
    \ so could be a false positive\n                If ( nKeyWordFlag > 0 );\n             \
    \       sRow = sRow|'%pFieldDelim%%pQuote%%sKeyWordString%%pQuote%';\n                 \
    \   sUsersString = '';\n                    sElementString = '';\n                    sMDXTemp\
    \ = sMDX;\n                    sStarter = '[';\n                    sEnder = ']';\n    \
    \                nMDXLength = Long ( sMDXTemp );\n                    While ( nMDXLength\
    \ > 0 );\n                        nStarter = SCAN ( sStarter, sMDXTemp );\n            \
    \            If ( nStarter > 0 );\n                            nEnder = SCAN ( sEnder, sMDXTemp\
    \ );\n                            sElement = SubSt ( sMDXTemp, nStarter + 1, nEnder - nStarter\
    \ -1);\n                            nToGo = nMDXLength - nEnder + 1;\n                 \
    \           sMDXTemp = Subst ( sMDXTemp, nEnder + 1, nToGo );\n                        \
    \    # check if that is actually an element\n                            If ( DimIx ( sDim,\
    \ sElement ) > 0 );\n                                IF( Scan( sElement, sElementString\
    \ ) = 0 );\n                                    IF( sElementString @= '' );\n          \
    \                              sElementString = sElementString | sElement;\n           \
    \                         ELSE;\n                                        sElementString\
    \ = sElementString | pDelim | ' ' | sElement;\n                                    ENDIF;\n\
    \                                ENDIF;\n                                IF( pLogoutput\
    \ = 1 );\n                                    sMessage = sElement | ' is referenced in the\
    \ MDX and exists in the dimension';\n                                    LogOutput('INFO',\
    \ Expand( cMsgInfoContent ) );\n                                ENDIF;\n               \
    \                 #loop thropugh all users\n                                iUser = 1;\n\
    \                                nMaxUser = DimSiz ( cUserDim );\n                     \
    \           While ( iUser <= nMaxUser );\n                                    sUser = DimNm\
    \ ( cUserDim, iUser );\n                                    # now need to loop through relevant\
    \ groups to see access\n                                    # loop through all groups to\
    \ check access to this element\n                                    nUserCheck = 0;\n  \
    \                                  iGroup = 1;\n                                    nGroupMax\
    \ = DimSiz ( cGroupDim );\n                                    While ( iGroup <= nGroupMax\
    \ );\n                                        sGroup = DimNm ( cGroupDim, iGroup );\n  \
    \                                      #skip the admin groups!\n                       \
    \                 If ( sGroup @<> 'ADMIN' & sGroup @<> 'SecurityAdmin' & sGroup @<> 'DataAdmin'\
    \ & sGroup @<> 'OperationsAdmin' );\n                                            nCheck\
    \ = 1;\n                                            # if we have a user check membership\
    \ and we don;t need to continue if not in that group\n                                 \
    \           If ( CellGetS ( cSecCube, sUser, sGroup ) @= '' );\n                       \
    \                         nCheck = 0;\n                                            EndIf;\
    \    \n                                            If ( nCheck = 1 );\n                \
    \                                # get the groups security assignment\n                \
    \                                sAccess = CellGetS ( sSecurityCube, sElement, sGroup );\n\
    \                                                # if the user has rights to that element\
    \ then all is good and we can quit the loops\n                                         \
    \       If ( sAccess @<> '' & sAccess @<> 'NONE' );\n                                  \
    \                  nUserCheck = 1;\n                                                   \
    \ iGroup = nGroupMax + 1;\n                                                EndIf;\n    \
    \                                        EndIf;\n                                      \
    \  Else;\n                                            # if the user is in an admin group\
    \ them they will have access\n                                            \n           \
    \                                 If ( CellGetS ( cSecCube, sUser, sGroup ) @<> '' );\n\
    \                                                nUserCheck = 1;\n                     \
    \                           iGroup = nGroupMax + 1;\n                                  \
    \          EndIf;   \n                                        EndIf;    \n             \
    \                           iGroup = iGroup + 1;\n                                    End;\
    \    \n                                    If ( nUserCheck = 0 );\n                    \
    \                    IF( Scan( sUser, sUsersString ) = 0 );\n                          \
    \                  IF( sUsersString @= '' );\n                                         \
    \     sUsersString = sUsersString | sUser;\n                                           \
    \ ELSE;\n                                              sUsersString = sUsersString | pDelim\
    \ | ' ' | sUser;\n                                            ENDIF;\n                 \
    \                       ENDIF;\n                                        IF( pLogoutput =\
    \ 1 );\n                                            sMessage = Expand('Public subset %sSubsetName%\
    \ contains a keyword and a specific element %sElement% that the user %sUser% do not have\
    \ access to');\n                                            LogOutput('INFO', Expand( cMsgInfoContent\
    \ ) );\n                                        ENDIF;\n                               \
    \     EndIf;\n                                    iUser = iUser + 1;\n                 \
    \               End;\n                            EndIf;\n                            nMDXLength\
    \ = Long ( sMDXTemp );\n                        Else;\n                            nMDXLength\
    \ = 0;\n                        EndIf;  \n                    End;                     \
    \ \n                    \n                sRow = sRow|'%pFieldDelim%%pQuote%%sElementString%%pQuote%%pFieldDelim%%pQuote%%sUsersString%%pQuote%';\n\
    \                sTotalRowString = sTotalRowString | sCRLF | Expand(sRow);\n           \
    \     # Output data\n                #TextOutput( cExportFile, Expand(sRow) );\n       \
    \         EndIf;    \n            EndIf;    \n            iSub = iSub + 1;\n        End;\
    \      \n    EndIf;    \n    iDim = iDim + 1;\nEnd;\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Write Output data\nIf( nErrors\
    \ = 0 );\n  TextOutput( cExportFile, sTotalRowString );\n  TextOutput( cExportFile, sGlobPrivateSubsetsTotalString\
    \ );\nENDIF;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n   \
    \ sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created report file.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Develop an IBM Turbo Integrator process that identifies which dimensions have security,
    particularly element security, and evaluates dynamic subsets with expressions impacted by
    the latest MDX security changes. This process is intended for both development and production
    environments.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will find out which dimensions have security\
    \ on them - element security - and evaluate dynamic subsets with expressions impacted by\
    \ the latest MDX security changes \n# Use case: Intended for development or production.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    StringGlobalVariable('sGlobPrivateSubsetsTotalString');\nsGlobPrivateSubsetsTotalString\
    \ = '';\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\n\
    cTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pNameSpace:%pNameSpace%,\
    \ pFilePath:%pFilePath%, pFileName:%pFileName%, pDelim:%pDelim%, pQuote:%pQuote%.' ;  \n\
    cMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\ncSecurityPrefix\
    \ = '}ElementSecurity_';\ncDimDim = '}Dimensions';\ncUserDim = '}Clients';\ncUserAttrDim=\
    \ '}ElementAttributes_}Clients';\ncUserAlias = '}TM1_DefaultDisplayValue';\ncSubsetPrefix\
    \ = '}Subsets_';\ncGroupDim = '}Groups';\ncSecCube = '}ClientGroups';\n\npFieldDelim   \
    \    = TRIM(pDelim);\nsCRChar           = Char( 13 );\nsLFChar           = Char( 10 );\n\
    sCRLF             = Char( 13 ) | Char( 10 );\ncLenASCIICode     = 3;\nnDataCount       \
    \ = 0;\nnErrors           = 0;\n\ncKeyWordList = 'DRILLDOWN&.Children&FirstChild&Ancestors&Ascendants&Cousin&DrillUp&FirstSibling&IsAncestor&FirstSibling&LastChild&LastSibling&Descendants';\n\
    cKeyWordList = UPPER ( cKeyWordList );\ncKeyWordDelimiter = '&';\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\n\n# Namespace\nIf( pNameSpace <> 0 & pNameSpace <> 1 );\n    nErrors \
    \        = 1;\n    sMessage        = 'NameSpace parameter not valid';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n# Validate file path\nIf(Trim( pFilePath ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf( SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\n    pFilePath = SubSt(\
    \ pFilePath, 1, Long( pFilePath ) -1 );\nEndIf;\nIf(  FileExists( pFilePath ) = 0 );\n \
    \   sMessage = Expand('Invalid export directory: %pFilePath%');\n    nErrors = nErrors +\
    \ 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npFilePath =\
    \ pFilePath | sOSDelim;\n\n# Validate file name\nIf( pFileName @= '' );\n    sBaseFileName\
    \ = Expand('%cThisProcName%_Export');\n    sExt = '.csv';\n    pFileName = sBaseFileName\
    \ | '.csv';\nElse;\n    # determine file extension. If no file extension entered then use\
    \ .csv as default\n    If( Scan( '.', pFileName ) = 0 );\n        sExt = '.csv';\n     \
    \   sBaseFileName = pFileName;\n    Else;\n        sExt = SubSt( pFileName, Scan( '.', pFileName\
    \ ), Long( pFileName ) );\n        sBaseFileName = SubSt( pFileName, 1, Scan( '.', pFileName\
    \ ) - 1 );\n    EndIf;\n    pFileName = sBaseFileName | sExt;\nEndIf;\ncExportFile = pFilePath\
    \ | pFileName;\n\n# Validate file delimiter & quote character\nIf( pFieldDelim @= '' );\n\
    \    pFieldDelim = ',';\nElse;\n    # If length of pFieldDelim is exactly 3 chars and each\
    \ of them is decimal digit, then the pFieldDelim is entered as ASCII code\n    nValid =\
    \ 0;\n    If ( LONG(pFieldDelim) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar\
    \ <= cLenASCIICode );\n        If( CODE( pFieldDelim, nChar ) >= CODE( '0', 1 ) & CODE(\
    \ pFieldDelim, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n    \
    \      nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n\
    \    If ( nValid<>0 );\n      pFieldDelim=CHAR(StringToNumber( pFieldDelim ));\n    Else;\n\
    \      pFieldDelim = SubSt( Trim( pFieldDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf( pQuote\
    \ @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is exactly\
    \ 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII code\n\
    \    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While\
    \ ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE(\
    \ pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n         \
    \ nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If\
    \ ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote\
    \ = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\nDatasourceAsciiDelimiter = pFieldDelim;\nDatasourceAsciiQuoteCharacter\
    \ = '';\nsTotalRowString = '';\n\nsTitleRow = '%pQuote%DIMENSION%pQuote%%pFieldDelim%%pQuote%HAS\
    \ SECURITY%pQuote%%pFieldDelim%%pQuote%SUBSET NAME%pQuote%';\nsTitleRow = sTitleRow|'%pFieldDelim%%pQuote%IS\
    \ PRIVATE%pQuote%%pFieldDelim%%pQuote%MDX EXPRESSION%pQuote%';\nsTitleRow = sTitleRow|'%pFieldDelim%%pQuote%KEYWORDS%pQuote%%pFieldDelim%%pQuote%ELEMENTS%pQuote%%pFieldDelim%%pQuote%USERS\
    \ WITH NO ACCESS%pQuote%';\nTextOutput( cExportFile, Expand(sTitleRow) );\nsTotalRowString\
    \ = Expand(sTitleRow);\n\niDim = 1;\nnMaxDim = DimSiz ( cDimDim );\n\nWhile ( iDim <= nMaxDim\
    \ );\n    sDim = DimNm ( cDimDim, iDim );\n    sSecurityCube = cSecurityPrefix | sDim;\n\
    \    If ( CubeExists ( sSecurityCube ) = 1 );\n        IF( pLogoutput = 1 );\n         \
    \   sMessage = 'The dimension ' | sDim | ' has element security assigned';\n           \
    \ LogOutput('INFO', Expand( cMsgInfoContent ) );\n        ENDIF;\n        # now we need\
    \ to go find subsets - two ways of doing this - data directory or }subset dimension\n  \
    \      # data directory is the only place to find private subs but need to know the username\
    \ to loop through  \n        iUser = 1;\n        nMaxUser = DimSiz ( cUserDim );\n     \
    \   While ( iUser <= nMaxUser );\n            sUser = DimNm ( cUserDim, iUser );\n     \
    \       # if CAMId is used folder structure is different\n            If ( DimIx ( cUserAttrDim,\
    \ cUserAlias ) > 0 );\n                sAlias = AttrS ( cUserDim, sUser, cUserAlias );\n\
    \                If ( sAlias @= '' );\n                    sAlias = sUser;\n           \
    \     EndIf;\n            EndIf; \n            sNamespacePrefix = '';\n            # if\
    \ CAMId is used folder structure is different\n            If ( pNamespace = 1 );\n    \
    \            # this \\ or / is hardcoded as it is the CAMID }TM1_DefaultDisplayValue alias\
    \ which sometimes uses back- and sometimes forward-slash. We aren't sanning for directory\
    \ separator.\n                nEnd = Scan( '/', sAlias);\n                If ( nEnd = 0\
    \ );\n                    nEnd = Scan ( '', sAlias );\n                EndIf;    \n    \
    \            sNamespace = SubSt ( sAlias, 1, nEnd - 1 );\n                sAlias = SubSt\
    \ ( sAlias, nEnd + 1, Long ( sAlias ) - nEnd );\n                sNamespacePrefix = sNameSpace\
    \ | sOSDelim;\n            EndIf;    \n            sSubset = WildcardFileSearch( Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%*.sub')\
    \ , '');\n            # loop through all subsets\n            While ( sSubset @<> '' );\n\
    \                sSubsetName = Subst ( sSubset, 1, LONG ( sSubset ) - 4 );\n           \
    \     sFile = Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%%sSubset%')\
    \ ;\n                IF( pLogoutput = 1 );\n                    sMessage = Expand('Private\
    \ subset called %sSubsetName% found for user %sAlias% in dimension %sDim%. File = %sFile%');\n\
    \                    LogOutput('INFO', Expand( cMsgInfoContent ) );\n                ENDIF;\n\
    \                # run the sub process to evaluate the MDX\n                If ( sSubset\
    \ @<> '' );\n                    nRet = ExecuteProcess('}bedrock.security.evaluate.mdx.private',\n\
    \                               'pLogOutput', pLogOutput,\n                            \
    \   'pStrictErrorHandling', pStrictErrorHandling,\n                               'pUser',\
    \ sUser,\n                               'pDimension', sDim,\n                         \
    \      'pSubset', sSubsetName,\n                               'pSubsetFile', sFile,\n \
    \                              'pFilePath', pFilePath,\n                               'pFileName',\
    \ '',\n                               'pDelim', pDelim,\n                              \
    \ 'pQuote', pQuote,\n                               'pWriteOutput', 0\n                \
    \      );\n                    If( nRet <> ProcessExitNormal() );\n                    \
    \    nErrors = nErrors + 1;\n                        sMessage= 'Error in evaluating private\
    \ subsets.';\n                        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n                    EndIf;\n\n                EndIf;  \n                sSubset\
    \ = WildcardFileSearch( Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%*.sub')\
    \ , sSubset);                \n            End;    \n            iUser = iUser + 1;\n  \
    \      End; \n        \n        sSubsetDim = cSubsetPrefix | sDim;\n        iSub = 1;\n\
    \        nSubsetMax = DimSiz ( sSubsetDim );\n        # loop through all subsets\n     \
    \   While ( iSub <= nSubsetMax );\n            sSubsetName = DimNm ( sSubsetDim, iSub );\n\
    \            sMDX = '';\n            sMDX = SubsetMDXGet ( sDim, sSubsetName );\n      \
    \      sMDX = UPPER ( sMDX );\n            If ( sMDX @<> '' );\n                ## Remove\
    \ line breaks from MDX string\n                nMDXLen = Long( sMDX );\n               \
    \ nMDXCount = 1;\n                While( nMDXCount <= nMDXLen );\n                  sCharPoint\
    \ = Subst( sMDX, nMDXCount, 1 );\n                  IF( sCharPoint @= sCRChar % sCharPoint\
    \ @= sLFChar );\n                      Delet( sMDX, nMDXCount, 1 );\n                  \
    \    nMDXLen = Long( sMDX );\n                  ENDIF;\n                  \n           \
    \       nMDXCount = nMDXCount + 1;\n                End;\n                nMDXLen = Long(\
    \ sMDX );\n                sMDXLastChar = Subst( sMDX, nMDXLen, 1 );\n                While(\
    \ sMDXLastChar @<> '}' );\n                  sMDX = Subst( sMDX, 1, nMDXLen - 1 );\n   \
    \               nMDXLen = Long( sMDX );\n                  sMDXLastChar = Subst( sMDX, nMDXLen,\
    \ 1 );\n                End;\n                sRow = '%pQuote%%sDim%%pQuote%%pFieldDelim%%pQuote%Y%pQuote%%pFieldDelim%%pQuote%%sSubsetName%%pQuote%%pFieldDelim%%pQuote%NO%pQuote%%pFieldDelim%%pQuote%%sMDX%%pQuote%';\n\
    \                IF( pLogoutput = 1 );\n                    sMessage = Expand('Public subset\
    \ called %sSubsetName% found in dimension %sDim% with MDX %sMDX%');\n                  \
    \  LogOutput('INFO', Expand( cMsgInfoContent ) );\n                ENDIF;\n            \
    \    # now parse the MDX \n                nKeywordFlag = 0;\n                sKeyWordString\
    \ = '';\n                sKeywordList = cKeywordList;\n                nKeywordLength =\
    \ Long ( sKeywordList );\n                While ( nKeywordLength > 0 );\n              \
    \      nDelimiter = Scan ( cKeywordDelimiter, sKeyWordList );\n                    If (\
    \ nDelimiter = 0 );\n                        sKeyword = sKeyWordList;\n                \
    \        sKeyWordList = '';\n                    Else;\n                        nEnd = nDelimiter\
    \ - 1;\n                        sKeyWord = SubSt ( sKeywordList, 1, nEnd );\n          \
    \              sKeyWordList = Subst ( sKeywordList, nEnd + 2, nKeywordLength - nEnd);\n\
    \                    EndIf;    \n                    If ( Scan( sKeyWord, sMDX ) > 0 );\n\
    \                        nKeyWordFlag = nKeyWordFlag + 1;\n                        IF( Long(\
    \ sKeyWordString ) = 0 );\n                          sKeyWordString = sKeyWordString | sKeyWord;\n\
    \                        ELSE;\n                          sKeyWordString = sKeyWordString\
    \ | pDelim | ' ' | sKeyWord;\n                        ENDIF;\n                        IF(\
    \ pLogoutput = 1 );\n                            sMessage = 'Keyword ' | sKeyWord | ' found\
    \ in ' | sMDX;\n                            LogOutput('INFO', Expand( cMsgInfoContent )\
    \ );\n                        ENDIF;\n                    EndIf;   \n                  \
    \  nKeywordLength = Long ( sKeywordList );\n                End;    \n                #\
    \ if keywords found then see if we can match an element in the MDX with one in the dimension\n\
    \                # element will be included within [] but there will be [dimension][hierarchy][subset][attribute]\
    \ so could be a false positive\n                If ( nKeyWordFlag > 0 );\n             \
    \       sRow = sRow|'%pFieldDelim%%pQuote%%sKeyWordString%%pQuote%';\n                 \
    \   sUsersString = '';\n                    sElementString = '';\n                    sMDXTemp\
    \ = sMDX;\n                    sStarter = '[';\n                    sEnder = ']';\n    \
    \                nMDXLength = Long ( sMDXTemp );\n                    While ( nMDXLength\
    \ > 0 );\n                        nStarter = SCAN ( sStarter, sMDXTemp );\n            \
    \            If ( nStarter > 0 );\n                            nEnder = SCAN ( sEnder, sMDXTemp\
    \ );\n                            sElement = SubSt ( sMDXTemp, nStarter + 1, nEnder - nStarter\
    \ -1);\n                            nToGo = nMDXLength - nEnder + 1;\n                 \
    \           sMDXTemp = Subst ( sMDXTemp, nEnder + 1, nToGo );\n                        \
    \    # check if that is actually an element\n                            If ( DimIx ( sDim,\
    \ sElement ) > 0 );\n                                IF( Scan( sElement, sElementString\
    \ ) = 0 );\n                                    IF( sElementString @= '' );\n          \
    \                              sElementString = sElementString | sElement;\n           \
    \                         ELSE;\n                                        sElementString\
    \ = sElementString | pDelim | ' ' | sElement;\n                                    ENDIF;\n\
    \                                ENDIF;\n                                IF( pLogoutput\
    \ = 1 );\n                                    sMessage = sElement | ' is referenced in the\
    \ MDX and exists in the dimension';\n                                    LogOutput('INFO',\
    \ Expand( cMsgInfoContent ) );\n                                ENDIF;\n               \
    \                 #loop thropugh all users\n                                iUser = 1;\n\
    \                                nMaxUser = DimSiz ( cUserDim );\n                     \
    \           While ( iUser <= nMaxUser );\n                                    sUser = DimNm\
    \ ( cUserDim, iUser );\n                                    # now need to loop through relevant\
    \ groups to see access\n                                    # loop through all groups to\
    \ check access to this element\n                                    nUserCheck = 0;\n  \
    \                                  iGroup = 1;\n                                    nGroupMax\
    \ = DimSiz ( cGroupDim );\n                                    While ( iGroup <= nGroupMax\
    \ );\n                                        sGroup = DimNm ( cGroupDim, iGroup );\n  \
    \                                      #skip the admin groups!\n                       \
    \                 If ( sGroup @<> 'ADMIN' & sGroup @<> 'SecurityAdmin' & sGroup @<> 'DataAdmin'\
    \ & sGroup @<> 'OperationsAdmin' );\n                                            nCheck\
    \ = 1;\n                                            # if we have a user check membership\
    \ and we don;t need to continue if not in that group\n                                 \
    \           If ( CellGetS ( cSecCube, sUser, sGroup ) @= '' );\n                       \
    \                         nCheck = 0;\n                                            EndIf;\
    \    \n                                            If ( nCheck = 1 );\n                \
    \                                # get the groups security assignment\n                \
    \                                sAccess = CellGetS ( sSecurityCube, sElement, sGroup );\n\
    \                                                # if the user has rights to that element\
    \ then all is good and we can quit the loops\n                                         \
    \       If ( sAccess @<> '' & sAccess @<> 'NONE' );\n                                  \
    \                  nUserCheck = 1;\n                                                   \
    \ iGroup = nGroupMax + 1;\n                                                EndIf;\n    \
    \                                        EndIf;\n                                      \
    \  Else;\n                                            # if the user is in an admin group\
    \ them they will have access\n                                            \n           \
    \                                 If ( CellGetS ( cSecCube, sUser, sGroup ) @<> '' );\n\
    \                                                nUserCheck = 1;\n                     \
    \                           iGroup = nGroupMax + 1;\n                                  \
    \          EndIf;   \n                                        EndIf;    \n             \
    \                           iGroup = iGroup + 1;\n                                    End;\
    \    \n                                    If ( nUserCheck = 0 );\n                    \
    \                    IF( Scan( sUser, sUsersString ) = 0 );\n                          \
    \                  IF( sUsersString @= '' );\n                                         \
    \     sUsersString = sUsersString | sUser;\n                                           \
    \ ELSE;\n                                              sUsersString = sUsersString | pDelim\
    \ | ' ' | sUser;\n                                            ENDIF;\n                 \
    \                       ENDIF;\n                                        IF( pLogoutput =\
    \ 1 );\n                                            sMessage = Expand('Public subset %sSubsetName%\
    \ contains a keyword and a specific element %sElement% that the user %sUser% do not have\
    \ access to');\n                                            LogOutput('INFO', Expand( cMsgInfoContent\
    \ ) );\n                                        ENDIF;\n                               \
    \     EndIf;\n                                    iUser = iUser + 1;\n                 \
    \               End;\n                            EndIf;\n                            nMDXLength\
    \ = Long ( sMDXTemp );\n                        Else;\n                            nMDXLength\
    \ = 0;\n                        EndIf;  \n                    End;                     \
    \ \n                    \n                sRow = sRow|'%pFieldDelim%%pQuote%%sElementString%%pQuote%%pFieldDelim%%pQuote%%sUsersString%%pQuote%';\n\
    \                sTotalRowString = sTotalRowString | sCRLF | Expand(sRow);\n           \
    \     # Output data\n                #TextOutput( cExportFile, Expand(sRow) );\n       \
    \         EndIf;    \n            EndIf;    \n            iSub = iSub + 1;\n        End;\
    \      \n    EndIf;    \n    iDim = iDim + 1;\nEnd;\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Write Output data\nIf( nErrors\
    \ = 0 );\n  TextOutput( cExportFile, sTotalRowString );\n  TextOutput( cExportFile, sGlobPrivateSubsetsTotalString\
    \ );\nENDIF;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n   \
    \ sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created report file.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der darauf abzielt, die privaten dynamischen
    Teilmengen von Dimensionen zu identifizieren, die mit Element-Sicherheitsvorkehrungen versehen
    sind. Der Prozess sollte die durch die neuesten MDX-Sicherheitsänderungen betroffenen Ausdrücke
    bewerten und sowohl für Entwicklungs- als auch Produktionsumgebungen geeignet sein.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will find out PRIVATE dynamic subsets of\
    \ dimensions having security on them - element security - and evaluate expressions impacted\
    \ by the latest MDX security changes \n# Use case: Intended for development or production.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    StringGlobalVariable('sGlobPrivateSubsetsTotalString');\nnProcessReturnCode= 0;\n\n### Constants\
    \ ###\ncThisProcName       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\\
    m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName\
    \           = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pUser:%pUser%, pDimension:%pDimension%, pSubset:%pSubset%, pSubsetFile:%pSubsetFile%,\
    \ pFilePath:%pFilePath%, pFileName:%pFileName%, pDelim:%pDelim%, pQuote:%pQuote%.' ;  \n\
    cMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\ncSecurityPrefix\
    \ = '}ElementSecurity_';\ncDimDim = '}Dimensions';\ncUserDim = '}Clients';\ncUserAttrDim=\
    \ '}ElementAttributes_}Clients';\ncUserAlias = '}TM1_DefaultDisplayValue';\ncSubsetPrefix\
    \ = '}Subsets_';\ncGroupDim = '}Groups';\ncSecCube = '}ClientGroups';\nnGroupMax = DimSiz\
    \ ( cGroupDim );\nnUserMax = DimSiz ( cUserDim );\ncEleSecCube = cSecurityPrefix | pDimension;\n\
    \npFieldDelim       = TRIM(pDelim);\nsCRLF             = Char( 13 ) | Char( 10 );\ncLenASCIICode\
    \     = 3;\nnDataCount        = 0;\nnErrors           = 0;\n\n#reset flag and string\nnMDXFlag\
    \ = 0;\nsMDX = '';\nsTotalRowString = '';\n\n#keywords to look out for in an MDX expression\n\
    cKeyWordList = 'DRILLDOWN&.Children&FirstChild&Ancestors&Ascendants&Cousin&DrillUp&FirstSibling&IsAncestor&FirstSibling&LastChild&LastSibling&Descendants';\n\
    cKeyWordList = UPPER ( cKeyWordList );\ncKeyWordDelimiter = '&';\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\n\n# Validate user\nIF( DimIx( cUserDim,  pUser) = 0 );\n    sMessage =\
    \ Expand('Invalid user: %pUser%');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nENDIF;\n\n# Validate dimension\nIF( DimIx( cDimDim,  pDimension)\
    \ = 0 );\n    sMessage = Expand('Invalid dimension: %pDimension%');\n    nErrors = nErrors\
    \ + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nENDIF;\n\n# Validate\
    \ subset name\nIF( pSubset @= '' % Scan( pSubset, pSubsetFile ) = 0  );\n    sMessage =\
    \ Expand('Invalid subset name: %pSubset%');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nENDIF;\n\n## check operating system\nIf(\
    \ SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim\
    \ = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate file path\n\
    If(Trim( pFilePath ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\nEndIf;\nIf(\
    \ SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\n    pFilePath = SubSt( pFilePath,\
    \ 1, Long( pFilePath ) -1 );\nEndIf;\nIf(  FileExists( pFilePath ) = 0 );\n    sMessage\
    \ = Expand('Invalid export directory: %pFilePath%');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npFilePath = pFilePath | sOSDelim;\n\
    \n# Validate file name\nIf( pFileName @= '' );\n    sBaseFileName = Expand('%cThisProcName%_%pUser%_%pDimension%_%pSubset%_Export');\n\
    \    sExt = '.csv';\n    pFileName = sBaseFileName | '.csv';\nElse;\n    # determine file\
    \ extension. If no file extension entered then use .csv as default\n    If( Scan( '.', pFileName\
    \ ) = 0 );\n        sExt = '.csv';\n        sBaseFileName = pFileName;\n    Else;\n    \
    \    sExt = SubSt( pFileName, Scan( '.', pFileName ), Long( pFileName ) );\n        sBaseFileName\
    \ = SubSt( pFileName, 1, Scan( '.', pFileName ) - 1 );\n    EndIf;\n    pFileName = sBaseFileName\
    \ | sExt;\nEndIf;\ncExportFile = pFilePath | pFileName;\n\n# Validate file delimiter & quote\
    \ character\nIf( pFieldDelim @= '' );\n    pFieldDelim = ',';\nElse;\n    # If length of\
    \ pFieldDelim is exactly 3 chars and each of them is decimal digit, then the pFieldDelim\
    \ is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pFieldDelim) = cLenASCIICode\
    \ );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pFieldDelim,\
    \ nChar ) >= CODE( '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE( '9', 1 ) );\n        \
    \  nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pFieldDelim=CHAR(StringToNumber(\
    \ pFieldDelim ));\n    Else;\n      pFieldDelim = SubSt( Trim( pFieldDelim ), 1, 1 );\n\
    \    EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If\
    \ length of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote\
    \ is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n\
    \      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar\
    \ ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n\
    \        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n    \
    \  End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n\
    \    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate\
    \ subset file\n\nIf ( FileExists( pSubsetFile ) = 0 );\n    sMessage = Expand('Invalid subset\
    \ file: %pSubsetFile%');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Initialize output\n\nsTotalOutputRowString = '';\nIF( pWriteOutput\
    \ <> 0 );\n  sTitleRow = '%pQuote%DIMENSION%pQuote%%pFieldDelim%%pQuote%HAS SECURITY%pQuote%%pFieldDelim%%pQuote%SUBSET\
    \ NAME%pQuote%';\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%IS PRIVATE%pQuote%%pFieldDelim%%pQuote%MDX\
    \ EXPRESSION%pQuote%';\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%KEYWORDS%pQuote%%pFieldDelim%%pQuote%ELEMENTS%pQuote%%pFieldDelim%%pQuote%USERS\
    \ WITH NO ACCESS%pQuote%';\n  sTotalOutputRowString = Expand(sTitleRow);\nENDIF;\nsRow =\
    \ '';\n\n### Assign data source\nIf( nErrors = 0 );\n    DataSourceType ='CHARACTERDELIMITED';\n\
    \    DatasourceNameForServer = pSubsetFile;\n    DatasourceASCIIDelimiter='@@';\nEndIF;\n\
    \n#Section Metadaten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n# MDX statement flag ends on 278\n\nIf ( Subst ( vLine, 1, 3 ) @= '278' );\n    # parse\
    \ this MDX for keywords\n    sKeyWordString = '';\n    nKeywordFlag = 0;\n    sKeywordList\
    \ = cKeywordList;\n    nKeywordLength = Long ( sKeywordList );\n    While ( nKeywordLength\
    \ > 0 );\n        nDelimiter = Scan ( cKeywordDelimiter, sKeyWordList );\n        If ( nDelimiter\
    \ = 0 );\n            sKeyword = sKeyWordList;\n            sKeyWordList = '';\n       \
    \ Else;\n            nEnd = nDelimiter - 1;\n            sKeyWord = SubSt ( sKeywordList,\
    \ 1, nEnd );\n            sKeyWordList = Subst ( sKeywordList, nEnd + 2, nKeywordLength\
    \ - nEnd);\n        EndIf;    \n\n        If ( Scan( sKeyWord, sMDX ) > 0 );\n         \
    \   nKeyWordFlag = nKeyWordFlag + 1;\n            IF( Long( sKeyWordString ) = 0 );\n  \
    \            sKeyWordString = sKeyWordString | sKeyWord;\n            ELSE;\n          \
    \    sKeyWordString = sKeyWordString | pDelim | ' ' | sKeyWord;\n            ENDIF;\n  \
    \          IF( pLogoutput = 1 );\n                sMessage = 'Keyword ' | sKeyWord | ' found\
    \ in ' |sMDX;\n                LogOutput('INFO', Expand( cMsgInfoContent ) );\n        \
    \    ENDIF;\n        EndIf;   \n        nKeywordLength = Long ( sKeywordList );\n    End;\n\
    \    IF( sKeyWordString @<> '' );\n        sRow = '%pQuote%%pDimension%%pQuote%%pFieldDelim%%pQuote%Y%pQuote%%pFieldDelim%%pQuote%%pSubset%%pQuote%%pFieldDelim%%pQuote%%pUser%%pQuote%';\n\
    \        sRow = sRow|'%pFieldDelim%%pQuote%%sMDX%%pQuote%';\n        sRow = sRow|'%pFieldDelim%%pQuote%%sKeyWordString%%pQuote%';\n\
    \    ENDIF;\n    # end parsing for keywords\n    # if keywords found then see if we can\
    \ match an element in the MDX with one in the dimension\n    # element will be included\
    \ within [] but there will be [dimension][hierarchy][subset][attribute] so could be a false\
    \ positive\n    sElementString = '';\n    sUsersString = '';\n    If ( nKeyWordFlag > 0\
    \ );\n        sMDXTemp = sMDX;\n        sStarter = '[';\n        sEnder = ']';\n       \
    \ nMDXLength = Long ( sMDXTemp );\n        While ( nMDXLength > 0 );\n            nStarter\
    \ = SCAN ( sStarter, sMDXTemp );\n            If ( nStarter > 0 );\n                nEnder\
    \ = SCAN ( sEnder, sMDXTemp );\n                sElement = SubSt ( sMDXTemp, nStarter +\
    \ 1, nEnder - nStarter -1);\n                nToGo = nMDXLength - nEnder + 1;\n        \
    \        sMDXTemp = Subst ( sMDXTemp, nEnder + 1, nToGo );\n                # check if that\
    \ is actually an element\n                If ( DimIx ( pDimension, sElement ) > 0 );\n \
    \                   IF( Scan( sElement, sElementString ) = 0 );\n                      \
    \  IF( sElementString @= '' );\n                            sElementString = sElementString\
    \ | sElement;\n                        ELSE;\n                            sElementString\
    \ = sElementString | pDelim | ' ' | sElement;\n                        ENDIF;\n        \
    \            ENDIF;\n                    IF( pLogoutput = 1 );\n                       \
    \ sMessage = sElement | ' is referenced in the MDX and exists in the dimension';\n     \
    \                   LogOutput('INFO', Expand( cMsgInfoContent ) );\n                   \
    \ ENDIF;\n                    # now need to loop through relevant groups to see access\n\
    \                    # loop through all groups to check access to this element\n       \
    \             nUserCheck = 0;\n                    iGroup = 1;\n                    While\
    \ ( iGroup <= nGroupMax );\n                        sGroup = DimNm ( cGroupDim, iGroup );\n\
    \                        #skip the admin groups!\n                        If ( sGroup @<>\
    \ 'ADMIN' & sGroup @<> 'SecurityAdmin' & sGroup @<> 'DataAdmin' & sGroup @<> 'OperationsAdmin'\
    \ );\n                            nCheck = 1;\n                            # if we have\
    \ a user check membership and we don;t need to continue if not in that group\n         \
    \                   If ( CellGetS ( cSecCube, pUser, sGroup ) @= '' );\n               \
    \                 nCheck = 0;\n                            EndIf;    \n                \
    \            If ( nCheck = 1 );\n                                # get the groups security\
    \ assignment\n                                sAccess = CellGetS ( cEleSecCube, sElement,\
    \ sGroup );\n                                # if the user has rights to that element then\
    \ all is good and we can quit the loops\n                                If ( sAccess @<>\
    \ '' & sAccess @<> 'NONE' );\n                                    nUserCheck = 1;\n    \
    \                                iGroup = nGroupMax + 1;\n                             \
    \   EndIf;\n                            EndIf;\n                        Else;\n        \
    \                    # if the user is in an admin group them they will have access\n   \
    \                         If ( CellGetS ( cSecCube, pUser, sGroup ) @<> '' );\n        \
    \                        nUserCheck = 1;\n                            EndIf;       \n  \
    \                      EndIf;    \n                        iGroup = iGroup + 1;\n      \
    \              End;    \n                    If ( nUserCheck = 0 );\n                  \
    \      sAlias = AttrS ( cUserDim, pUser, cUserAlias );\n                        If ( sAlias\
    \ @= '' );\n                            sAlias = pUser;\n                        EndIf;\n\
    \                        IF( Scan( sAlias, sUsersString ) = 0 );\n                     \
    \       IF( sUsersString @= '' );\n                              sUsersString = sUsersString\
    \ | sAlias;\n                            ELSE;\n                              sUsersString\
    \ = sUsersString | pDelim | ' ' | sAlias;\n                            ENDIF;\n        \
    \                ENDIF;\n                        IF( pLogoutput = 1 );\n               \
    \             sMessage = Expand('Private subset %pSubset% contains a keyword and a specific\
    \ element %sElement% that the user %sAlias% do not have access to');\n                 \
    \           LogOutput('INFO', Expand( cMsgInfoContent ) );\n                        ENDIF;\n\
    \                    EndIf;\n                EndIf;\n                nMDXLength = Long (\
    \ sMDXTemp );\n            Else;\n                nMDXLength = 0;\n            EndIf;  \
    \  \n        End;  \n    sRow = sRow|'%pFieldDelim%%pQuote%%sElementString%%pQuote%%pFieldDelim%%pQuote%%sUsersString%%pQuote%';\n\
    \    EndIf;\n    nMDXFlag = 0;\n    IF( sTotalOutputRowString @= '' );\n        sTotalOutputRowString\
    \ = Expand(sRow);\n    ELSE;\n        sTotalOutputRowString = sTotalOutputRowString | sCRLF\
    \ | Expand(sRow);\n    ENDIF;\nEndIf;\n\nIf ( nMDXFlag = 1 );\n    sMDX = UPPER ( sMDX |\
    \ vLine ); \nEndIf;    \n\n# MDX statement flag starts on 275\n\nIf ( Subst ( vLine, 1,\
    \ 3 ) @= '275' );\n    nMDXFlag = 1;\nEndIf;\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Write Output data\nIf( nErrors = 0 );\n  IF( pWriteOutput\
    \ <> 0 );\n      DatasourceAsciiQuoteCharacter = '';\n      TextOutput( cExportFile, Expand(sTotalOutputRowString)\
    \ );\n  ELSE;\n      IF( sGlobPrivateSubsetsTotalString @= '' );\n          sGlobPrivateSubsetsTotalString\
    \ = sTotalOutputRowString;\n      ELSE;\n          IF( sTotalOutputRowString @<> '' );\n\
    \              sGlobPrivateSubsetsTotalString = sGlobPrivateSubsetsTotalString | sCRLF |\
    \ sTotalOutputRowString;\n          ENDIF;\n      ENDIF;\n  ENDIF;\nENDIF;\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully executed.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that aims to identify private dynamic subsets
    of dimensions with element security restrictions. The process should evaluate expressions
    affected by the latest MDX security changes and be suitable for both development and production
    environments.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will find out PRIVATE dynamic subsets of\
    \ dimensions having security on them - element security - and evaluate expressions impacted\
    \ by the latest MDX security changes \n# Use case: Intended for development or production.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    StringGlobalVariable('sGlobPrivateSubsetsTotalString');\nnProcessReturnCode= 0;\n\n### Constants\
    \ ###\ncThisProcName       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\\
    m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName\
    \           = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pUser:%pUser%, pDimension:%pDimension%, pSubset:%pSubset%, pSubsetFile:%pSubsetFile%,\
    \ pFilePath:%pFilePath%, pFileName:%pFileName%, pDelim:%pDelim%, pQuote:%pQuote%.' ;  \n\
    cMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\ncSecurityPrefix\
    \ = '}ElementSecurity_';\ncDimDim = '}Dimensions';\ncUserDim = '}Clients';\ncUserAttrDim=\
    \ '}ElementAttributes_}Clients';\ncUserAlias = '}TM1_DefaultDisplayValue';\ncSubsetPrefix\
    \ = '}Subsets_';\ncGroupDim = '}Groups';\ncSecCube = '}ClientGroups';\nnGroupMax = DimSiz\
    \ ( cGroupDim );\nnUserMax = DimSiz ( cUserDim );\ncEleSecCube = cSecurityPrefix | pDimension;\n\
    \npFieldDelim       = TRIM(pDelim);\nsCRLF             = Char( 13 ) | Char( 10 );\ncLenASCIICode\
    \     = 3;\nnDataCount        = 0;\nnErrors           = 0;\n\n#reset flag and string\nnMDXFlag\
    \ = 0;\nsMDX = '';\nsTotalRowString = '';\n\n#keywords to look out for in an MDX expression\n\
    cKeyWordList = 'DRILLDOWN&.Children&FirstChild&Ancestors&Ascendants&Cousin&DrillUp&FirstSibling&IsAncestor&FirstSibling&LastChild&LastSibling&Descendants';\n\
    cKeyWordList = UPPER ( cKeyWordList );\ncKeyWordDelimiter = '&';\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\n\n# Validate user\nIF( DimIx( cUserDim,  pUser) = 0 );\n    sMessage =\
    \ Expand('Invalid user: %pUser%');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nENDIF;\n\n# Validate dimension\nIF( DimIx( cDimDim,  pDimension)\
    \ = 0 );\n    sMessage = Expand('Invalid dimension: %pDimension%');\n    nErrors = nErrors\
    \ + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nENDIF;\n\n# Validate\
    \ subset name\nIF( pSubset @= '' % Scan( pSubset, pSubsetFile ) = 0  );\n    sMessage =\
    \ Expand('Invalid subset name: %pSubset%');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nENDIF;\n\n## check operating system\nIf(\
    \ SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim\
    \ = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate file path\n\
    If(Trim( pFilePath ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\nEndIf;\nIf(\
    \ SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\n    pFilePath = SubSt( pFilePath,\
    \ 1, Long( pFilePath ) -1 );\nEndIf;\nIf(  FileExists( pFilePath ) = 0 );\n    sMessage\
    \ = Expand('Invalid export directory: %pFilePath%');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npFilePath = pFilePath | sOSDelim;\n\
    \n# Validate file name\nIf( pFileName @= '' );\n    sBaseFileName = Expand('%cThisProcName%_%pUser%_%pDimension%_%pSubset%_Export');\n\
    \    sExt = '.csv';\n    pFileName = sBaseFileName | '.csv';\nElse;\n    # determine file\
    \ extension. If no file extension entered then use .csv as default\n    If( Scan( '.', pFileName\
    \ ) = 0 );\n        sExt = '.csv';\n        sBaseFileName = pFileName;\n    Else;\n    \
    \    sExt = SubSt( pFileName, Scan( '.', pFileName ), Long( pFileName ) );\n        sBaseFileName\
    \ = SubSt( pFileName, 1, Scan( '.', pFileName ) - 1 );\n    EndIf;\n    pFileName = sBaseFileName\
    \ | sExt;\nEndIf;\ncExportFile = pFilePath | pFileName;\n\n# Validate file delimiter & quote\
    \ character\nIf( pFieldDelim @= '' );\n    pFieldDelim = ',';\nElse;\n    # If length of\
    \ pFieldDelim is exactly 3 chars and each of them is decimal digit, then the pFieldDelim\
    \ is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pFieldDelim) = cLenASCIICode\
    \ );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pFieldDelim,\
    \ nChar ) >= CODE( '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE( '9', 1 ) );\n        \
    \  nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pFieldDelim=CHAR(StringToNumber(\
    \ pFieldDelim ));\n    Else;\n      pFieldDelim = SubSt( Trim( pFieldDelim ), 1, 1 );\n\
    \    EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If\
    \ length of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote\
    \ is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n\
    \      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar\
    \ ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n\
    \        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n    \
    \  End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n\
    \    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate\
    \ subset file\n\nIf ( FileExists( pSubsetFile ) = 0 );\n    sMessage = Expand('Invalid subset\
    \ file: %pSubsetFile%');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Initialize output\n\nsTotalOutputRowString = '';\nIF( pWriteOutput\
    \ <> 0 );\n  sTitleRow = '%pQuote%DIMENSION%pQuote%%pFieldDelim%%pQuote%HAS SECURITY%pQuote%%pFieldDelim%%pQuote%SUBSET\
    \ NAME%pQuote%';\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%IS PRIVATE%pQuote%%pFieldDelim%%pQuote%MDX\
    \ EXPRESSION%pQuote%';\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%KEYWORDS%pQuote%%pFieldDelim%%pQuote%ELEMENTS%pQuote%%pFieldDelim%%pQuote%USERS\
    \ WITH NO ACCESS%pQuote%';\n  sTotalOutputRowString = Expand(sTitleRow);\nENDIF;\nsRow =\
    \ '';\n\n### Assign data source\nIf( nErrors = 0 );\n    DataSourceType ='CHARACTERDELIMITED';\n\
    \    DatasourceNameForServer = pSubsetFile;\n    DatasourceASCIIDelimiter='@@';\nEndIF;\n\
    \n#Section Metadaten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n# MDX statement flag ends on 278\n\nIf ( Subst ( vLine, 1, 3 ) @= '278' );\n    # parse\
    \ this MDX for keywords\n    sKeyWordString = '';\n    nKeywordFlag = 0;\n    sKeywordList\
    \ = cKeywordList;\n    nKeywordLength = Long ( sKeywordList );\n    While ( nKeywordLength\
    \ > 0 );\n        nDelimiter = Scan ( cKeywordDelimiter, sKeyWordList );\n        If ( nDelimiter\
    \ = 0 );\n            sKeyword = sKeyWordList;\n            sKeyWordList = '';\n       \
    \ Else;\n            nEnd = nDelimiter - 1;\n            sKeyWord = SubSt ( sKeywordList,\
    \ 1, nEnd );\n            sKeyWordList = Subst ( sKeywordList, nEnd + 2, nKeywordLength\
    \ - nEnd);\n        EndIf;    \n\n        If ( Scan( sKeyWord, sMDX ) > 0 );\n         \
    \   nKeyWordFlag = nKeyWordFlag + 1;\n            IF( Long( sKeyWordString ) = 0 );\n  \
    \            sKeyWordString = sKeyWordString | sKeyWord;\n            ELSE;\n          \
    \    sKeyWordString = sKeyWordString | pDelim | ' ' | sKeyWord;\n            ENDIF;\n  \
    \          IF( pLogoutput = 1 );\n                sMessage = 'Keyword ' | sKeyWord | ' found\
    \ in ' |sMDX;\n                LogOutput('INFO', Expand( cMsgInfoContent ) );\n        \
    \    ENDIF;\n        EndIf;   \n        nKeywordLength = Long ( sKeywordList );\n    End;\n\
    \    IF( sKeyWordString @<> '' );\n        sRow = '%pQuote%%pDimension%%pQuote%%pFieldDelim%%pQuote%Y%pQuote%%pFieldDelim%%pQuote%%pSubset%%pQuote%%pFieldDelim%%pQuote%%pUser%%pQuote%';\n\
    \        sRow = sRow|'%pFieldDelim%%pQuote%%sMDX%%pQuote%';\n        sRow = sRow|'%pFieldDelim%%pQuote%%sKeyWordString%%pQuote%';\n\
    \    ENDIF;\n    # end parsing for keywords\n    # if keywords found then see if we can\
    \ match an element in the MDX with one in the dimension\n    # element will be included\
    \ within [] but there will be [dimension][hierarchy][subset][attribute] so could be a false\
    \ positive\n    sElementString = '';\n    sUsersString = '';\n    If ( nKeyWordFlag > 0\
    \ );\n        sMDXTemp = sMDX;\n        sStarter = '[';\n        sEnder = ']';\n       \
    \ nMDXLength = Long ( sMDXTemp );\n        While ( nMDXLength > 0 );\n            nStarter\
    \ = SCAN ( sStarter, sMDXTemp );\n            If ( nStarter > 0 );\n                nEnder\
    \ = SCAN ( sEnder, sMDXTemp );\n                sElement = SubSt ( sMDXTemp, nStarter +\
    \ 1, nEnder - nStarter -1);\n                nToGo = nMDXLength - nEnder + 1;\n        \
    \        sMDXTemp = Subst ( sMDXTemp, nEnder + 1, nToGo );\n                # check if that\
    \ is actually an element\n                If ( DimIx ( pDimension, sElement ) > 0 );\n \
    \                   IF( Scan( sElement, sElementString ) = 0 );\n                      \
    \  IF( sElementString @= '' );\n                            sElementString = sElementString\
    \ | sElement;\n                        ELSE;\n                            sElementString\
    \ = sElementString | pDelim | ' ' | sElement;\n                        ENDIF;\n        \
    \            ENDIF;\n                    IF( pLogoutput = 1 );\n                       \
    \ sMessage = sElement | ' is referenced in the MDX and exists in the dimension';\n     \
    \                   LogOutput('INFO', Expand( cMsgInfoContent ) );\n                   \
    \ ENDIF;\n                    # now need to loop through relevant groups to see access\n\
    \                    # loop through all groups to check access to this element\n       \
    \             nUserCheck = 0;\n                    iGroup = 1;\n                    While\
    \ ( iGroup <= nGroupMax );\n                        sGroup = DimNm ( cGroupDim, iGroup );\n\
    \                        #skip the admin groups!\n                        If ( sGroup @<>\
    \ 'ADMIN' & sGroup @<> 'SecurityAdmin' & sGroup @<> 'DataAdmin' & sGroup @<> 'OperationsAdmin'\
    \ );\n                            nCheck = 1;\n                            # if we have\
    \ a user check membership and we don;t need to continue if not in that group\n         \
    \                   If ( CellGetS ( cSecCube, pUser, sGroup ) @= '' );\n               \
    \                 nCheck = 0;\n                            EndIf;    \n                \
    \            If ( nCheck = 1 );\n                                # get the groups security\
    \ assignment\n                                sAccess = CellGetS ( cEleSecCube, sElement,\
    \ sGroup );\n                                # if the user has rights to that element then\
    \ all is good and we can quit the loops\n                                If ( sAccess @<>\
    \ '' & sAccess @<> 'NONE' );\n                                    nUserCheck = 1;\n    \
    \                                iGroup = nGroupMax + 1;\n                             \
    \   EndIf;\n                            EndIf;\n                        Else;\n        \
    \                    # if the user is in an admin group them they will have access\n   \
    \                         If ( CellGetS ( cSecCube, pUser, sGroup ) @<> '' );\n        \
    \                        nUserCheck = 1;\n                            EndIf;       \n  \
    \                      EndIf;    \n                        iGroup = iGroup + 1;\n      \
    \              End;    \n                    If ( nUserCheck = 0 );\n                  \
    \      sAlias = AttrS ( cUserDim, pUser, cUserAlias );\n                        If ( sAlias\
    \ @= '' );\n                            sAlias = pUser;\n                        EndIf;\n\
    \                        IF( Scan( sAlias, sUsersString ) = 0 );\n                     \
    \       IF( sUsersString @= '' );\n                              sUsersString = sUsersString\
    \ | sAlias;\n                            ELSE;\n                              sUsersString\
    \ = sUsersString | pDelim | ' ' | sAlias;\n                            ENDIF;\n        \
    \                ENDIF;\n                        IF( pLogoutput = 1 );\n               \
    \             sMessage = Expand('Private subset %pSubset% contains a keyword and a specific\
    \ element %sElement% that the user %sAlias% do not have access to');\n                 \
    \           LogOutput('INFO', Expand( cMsgInfoContent ) );\n                        ENDIF;\n\
    \                    EndIf;\n                EndIf;\n                nMDXLength = Long (\
    \ sMDXTemp );\n            Else;\n                nMDXLength = 0;\n            EndIf;  \
    \  \n        End;  \n    sRow = sRow|'%pFieldDelim%%pQuote%%sElementString%%pQuote%%pFieldDelim%%pQuote%%sUsersString%%pQuote%';\n\
    \    EndIf;\n    nMDXFlag = 0;\n    IF( sTotalOutputRowString @= '' );\n        sTotalOutputRowString\
    \ = Expand(sRow);\n    ELSE;\n        sTotalOutputRowString = sTotalOutputRowString | sCRLF\
    \ | Expand(sRow);\n    ENDIF;\nEndIf;\n\nIf ( nMDXFlag = 1 );\n    sMDX = UPPER ( sMDX |\
    \ vLine ); \nEndIf;    \n\n# MDX statement flag starts on 275\n\nIf ( Subst ( vLine, 1,\
    \ 3 ) @= '275' );\n    nMDXFlag = 1;\nEndIf;\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Write Output data\nIf( nErrors = 0 );\n  IF( pWriteOutput\
    \ <> 0 );\n      DatasourceAsciiQuoteCharacter = '';\n      TextOutput( cExportFile, Expand(sTotalOutputRowString)\
    \ );\n  ELSE;\n      IF( sGlobPrivateSubsetsTotalString @= '' );\n          sGlobPrivateSubsetsTotalString\
    \ = sTotalOutputRowString;\n      ELSE;\n          IF( sTotalOutputRowString @<> '' );\n\
    \              sGlobPrivateSubsetsTotalString = sGlobPrivateSubsetsTotalString | sCRLF |\
    \ sTotalOutputRowString;\n          ENDIF;\n      ENDIF;\n  ENDIF;\nENDIF;\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully executed.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der dafür sorgt, dass Klientengruppen
    erstellt werden. Beachte dabei, dass eine Gruppe (pGroup) obligatorisch ist, ansonsten wird
    der Prozess abgebrochen. Mehrere Gruppen können mit einem Trennzeichen angegeben werden.
    Wenn eine Gruppe bereits existiert, wird dieser Schritt übersprungen. Der Prozess sollte
    sowohl für Entwicklungs- als auch Produktionszwecke geeignet sein. In Schritt 1 werden anfängliche
    Sicherheitsgruppen erstellt, und in Schritt 2 kannst du weitere Sicherheitsgruppen hinzufügen,
    wenn sich die geschäftlichen Anforderungen ändern.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create client groups.\n\n# Use case:\
    \ Intended for development or production.\n# 1/ Create initial security groups.\n# 2/ Add\
    \ security groups as business needs change.\n\n# Note:\n# Naturally, a group (pGroup) is\
    \ mandatory otherwise the process will abort.\n# - Multiple groups can be specified separated\
    \ by a delimiter.\n# - If group already exists then the process will skip that group.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pGroup:%pGroup%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n    pDelim          = '&';\nEndIf;\n\
    \n# If no groups have been specified then terminate process\nIf( Trim( pGroup ) @= '' );\n\
    \    nErrors         = 1;\n    sMessage        = 'No groups specified';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Alias\nIf( pAlias @<> '' );\n    If( DimensionExists(\
    \ '}ElementAttributes_}Groups' ) = 0 );\n        AttrInsert( '}Groups', '', '}TM1_DefaultDisplayValue',\
    \ 'A' );\n    ElseIf( DimIx( '}ElementAttributes_}Groups', '}TM1_DefaultDisplayValue' )\
    \ = 0 );\n        AttrInsert( '}Groups', '', '}TM1_DefaultDisplayValue', 'A' );\n    EndIf;\n\
    EndIf;\n\n### Split pGroups into individual groups and add ###\nsGroups = pGroup;\nnDelimiterIndex\
    \ = 1;\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex = Scan( pDelim, sGroups );\n\
    \    If( nDelimiterIndex = 0 );\n        sGroup = sGroups;\n    Else;\n        sGroup =\
    \ Trim( SubSt( sGroups, 1, nDelimiterIndex - 1 ) );\n        sGroups = Trim( Subst( sGroups,\
    \ nDelimiterIndex + Long(pDelim), Long( sGroups ) ) );\n    EndIf;\n    # Don't attempt\
    \ to add a blank group\n    If( sGroup @<> '' );\n        If( DimIx( '}Groups', sGroup )\
    \ = 0 );\n            AddGroup( sGroup );\n        Else;\n            #Skip group\n    \
    \    EndIf;\n    EndIf;\nEnd;\n\nIf( nErrors = 0 );\n  DimensionSortOrder( '}Groups', 'ByName',\
    \ 'Ascending', 'ByName' , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Update\
    \ Alias\n\nIf( nErrors = 0 );\n\n  sAliases  = pAlias;\n  sGroups   = pGroup;\n  nDelimiterIndex\
    \ = 1;\n\n  While( nDelimiterIndex > 0 );\n    nDelimiterIndex = Scan( pDelim, sAliases\
    \ );\n    If( nDelimiterIndex = 0 );\n      sAlias    = sAliases;\n    Else;\n      sAlias\
    \    = Trim( SubSt( sAliases, 1, nDelimiterIndex - 1 ) );\n      sAliases  = Trim( Subst(\
    \ sAliases, nDelimiterIndex + Long(pDelim), Long( sAliases ) ) );\n    EndIf;\n    nDelimiterIndex\
    \ = Scan( pDelim, sGroups );\n    If( nDelimiterIndex = 0 );\n      sGroup   = sGroups;\n\
    \    Else;\n      sGroup   = Trim( SubSt( sGroups, 1, nDelimiterIndex - 1 ) );\n      sGroups\
    \  = Trim( Subst( sGroups, nDelimiterIndex + Long(pDelim), Long( sGroups ) ) );\n    EndIf;\n\
    \    \n    If( DimIx( '}Groups', sGroup ) > 0 );\n      If( sAlias @<> '' );\n        AttrPutS(\
    \ sAlias, '}Groups', sGroup, '}TM1_DefaultDisplayValue', 1 );\n      EndIf;\n    EndIf;\n\
    \  End;\n\nEndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created Group %pGroup% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Develop an IBM Turbo Integrator process that ensures client groups are created.
    Keep in mind that a group (pGroup) is mandatory, and the process will abort if it isn't
    specified. Multiple groups can be indicated by separating them with a delimiter. If a group
    already exists, the process will skip it. The process should be suitable for both development
    and production purposes. In step 1, create initial security groups, and in step 2, add additional
    security groups as business needs evolve.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create client groups.\n\n# Use case:\
    \ Intended for development or production.\n# 1/ Create initial security groups.\n# 2/ Add\
    \ security groups as business needs change.\n\n# Note:\n# Naturally, a group (pGroup) is\
    \ mandatory otherwise the process will abort.\n# - Multiple groups can be specified separated\
    \ by a delimiter.\n# - If group already exists then the process will skip that group.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pGroup:%pGroup%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n    pDelim          = '&';\nEndIf;\n\
    \n# If no groups have been specified then terminate process\nIf( Trim( pGroup ) @= '' );\n\
    \    nErrors         = 1;\n    sMessage        = 'No groups specified';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Alias\nIf( pAlias @<> '' );\n    If( DimensionExists(\
    \ '}ElementAttributes_}Groups' ) = 0 );\n        AttrInsert( '}Groups', '', '}TM1_DefaultDisplayValue',\
    \ 'A' );\n    ElseIf( DimIx( '}ElementAttributes_}Groups', '}TM1_DefaultDisplayValue' )\
    \ = 0 );\n        AttrInsert( '}Groups', '', '}TM1_DefaultDisplayValue', 'A' );\n    EndIf;\n\
    EndIf;\n\n### Split pGroups into individual groups and add ###\nsGroups = pGroup;\nnDelimiterIndex\
    \ = 1;\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex = Scan( pDelim, sGroups );\n\
    \    If( nDelimiterIndex = 0 );\n        sGroup = sGroups;\n    Else;\n        sGroup =\
    \ Trim( SubSt( sGroups, 1, nDelimiterIndex - 1 ) );\n        sGroups = Trim( Subst( sGroups,\
    \ nDelimiterIndex + Long(pDelim), Long( sGroups ) ) );\n    EndIf;\n    # Don't attempt\
    \ to add a blank group\n    If( sGroup @<> '' );\n        If( DimIx( '}Groups', sGroup )\
    \ = 0 );\n            AddGroup( sGroup );\n        Else;\n            #Skip group\n    \
    \    EndIf;\n    EndIf;\nEnd;\n\nIf( nErrors = 0 );\n  DimensionSortOrder( '}Groups', 'ByName',\
    \ 'Ascending', 'ByName' , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Update\
    \ Alias\n\nIf( nErrors = 0 );\n\n  sAliases  = pAlias;\n  sGroups   = pGroup;\n  nDelimiterIndex\
    \ = 1;\n\n  While( nDelimiterIndex > 0 );\n    nDelimiterIndex = Scan( pDelim, sAliases\
    \ );\n    If( nDelimiterIndex = 0 );\n      sAlias    = sAliases;\n    Else;\n      sAlias\
    \    = Trim( SubSt( sAliases, 1, nDelimiterIndex - 1 ) );\n      sAliases  = Trim( Subst(\
    \ sAliases, nDelimiterIndex + Long(pDelim), Long( sAliases ) ) );\n    EndIf;\n    nDelimiterIndex\
    \ = Scan( pDelim, sGroups );\n    If( nDelimiterIndex = 0 );\n      sGroup   = sGroups;\n\
    \    Else;\n      sGroup   = Trim( SubSt( sGroups, 1, nDelimiterIndex - 1 ) );\n      sGroups\
    \  = Trim( Subst( sGroups, nDelimiterIndex + Long(pDelim), Long( sGroups ) ) );\n    EndIf;\n\
    \    \n    If( DimIx( '}Groups', sGroup ) > 0 );\n      If( sAlias @<> '' );\n        AttrPutS(\
    \ sAlias, '}Groups', sGroup, '}TM1_DefaultDisplayValue', 1 );\n      EndIf;\n    EndIf;\n\
    \  End;\n\nEndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created Group %pGroup% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Erstelle einen IBM Turbo Integrator Prozess, der dazu dient, Client-Gruppen zu löschen.
    Dieser Prozess ist sowohl für Entwicklungs- als auch Produktionsumgebungen gedacht. Die
    Anwendungsfälle umfassen die Bereinigung von Sicherheitsgruppen nach dem Go-Live sowie das
    Löschen veralteter Sicherheitsgruppen, wenn sich die Geschäftsanforderungen ändern. Beachte,
    dass eine Gruppe (pGroup) zwingend erforderlich ist, da der Prozess andernfalls abbricht.
    Mehrere Gruppen können durch ein Trennzeichen angegeben werden. Falls eine Gruppe nicht
    existiert, wird sie übersprungen. Wenn mehrere Gruppen angegeben werden und einige nicht
    existieren, werden die Gruppen, die existieren, trotzdem gelöscht.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete client groups.\n\n# Use case:\
    \ Intended for development or production.\n# 1/ Clean up security groups after go live.\n\
    # 2/ Delete obsolete security groups as business needs change.\n\n# Note:\n# Naturally,\
    \ a group (pGroup) is mandatory otherwise the process will abort:\n# - Multiple groups can\
    \ be specified separated by a delimiter.\n# - If group does not exist then it will be skipped.\n\
    # - If multiple groups are specified and some don't exist and some do, then the ones that\
    \ do exist will still be deleted.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName           = GetProcessName();\ncTimeStamp              = TimSt( Now, '\\Y\\\
    m\\d\\h\\i\\s' );\ncRandomInt              = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub\
    \                = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile     \
    \          = GetProcessErrorFileDirectory | cTempSub | '.csv';\ncGroupDim              \
    \ = '}Groups';\ncGroupHier              = cGroupDim;\ncUserName               = TM1User();\n\
    cMsgErrorLevel          = 'ERROR';\ncMsgErrorContent        = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo                = 'Process:%cThisProcName% run with parameters\
    \ pGroup:%pGroup%, pDelim:%pDelim%.';\ncBuiltInGroups          = 'ADMIN&SecurityAdmin&DataAdmin&OperationsAdmin&';\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n    pDelim              = '&';\nEndIf;\n\
    \n# If no groups have been specified then terminate process\nIf( Trim( pGroup ) @= '' );\n\
    \    nErrors             = 1;\n    sMessage            = 'No groups specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Check alias exists\nIf( DimensionExists('}ElementAttributes_'|cGroupDim)\
    \ = 0 % DimIx('}ElementAttributes_'|cGroupDim, '}TM1_DefaultDisplayValue') = 0 );\n    AttrInsert(\
    \ cGroupDim, '', '}TM1_DefaultDisplayValue', 'A' );\nEndIf;\n\n### Split pGroups into individual\
    \ groups and delete ###\nsGroups                 = pGroup;\nnDelimiterIndex         = 1;\n\
    While( nDelimiterIndex <> 0 );\n  nDelimiterIndex = Scan( pDelim, sGroups );\n  If( nDelimiterIndex\
    \ = 0 );\n        sGroup          = sGroups;\n  Else;\n        sGroup          = Trim( SubSt(\
    \ sGroups, 1, nDelimiterIndex - 1 ) );\n        sGroups         = Trim( Subst( sGroups,\
    \ nDelimiterIndex + Long(pDelim), Long( sGroups ) ) );\n  EndIf;\n  \n  If( Scan( '*', sGroup\
    \ ) = 0);\n    # Don't attempt to delete a blank group\n    If( sGroup @<> '' );\n     \
    \   If( DimIx( '}Groups', sGroup ) > 0 );\n            If( nErrors = 0 );\n            \
    \    If( Scan( Upper( sGroup ) |'&', Upper( cBuiltInGroups ) ) = 0 );\n                \
    \    DeleteGroup( sGroup );\n                Else;\n                    nErrors = 1;\n \
    \                   sMessage= Expand('Attempt to delete built-in group %sGroup%.');\n  \
    \                  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n          \
    \      EndIf;\n            EndIf;\n            If( nErrors > 0 );\n                ItemReject(\
    \ Expand( cMsgErrorContent ) );\n            EndIf;\n        EndIf;\n    EndIf;\n  Else;\n\
    \    # Wildcard search string\n    iCount = 0;\n    iCheck = 1;\n    sChar = sGroup;\n \
    \   While (iCheck > 0);\n      iCheck = Scan('*',sChar);\n      If( iCheck > 0 );\n    \
    \    iCount = iCount + 1;\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n\
    \      Endif;\n    End;\n    If(iCount = 1);\n      ##If the wilcardsearch is *String, below\
    \ code will get executed\n      if(Subst(sGroup,iCount,1) @= '*');\n        sGroup1 = '''|\
    \ Subst(sGroup,iCount+1,(Long(sGroup)- iCount))|''';\n        sTempCount = NumbertoString(Long(sGroup)-iCount);\n\
    \        sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n           \
    \     (Right( ['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|')\
    \ ='|sGroup1|'))}+\n                {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \                (Right( ['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'| sTempCount|')\
    \ ='|sGroup1|'))}';\n        If( SubsetExists( cGroupDim, cTempSub ) = 1 );\n          \
    \  # If a delimited list of Groups includes wildcards then we may have to re-use the subset\
    \ multiple times\n            SubsetMDXSet( cGroupDim, cTempSub, sMDX );\n        Else;\n\
    \            # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cGroupDim, 1 );\n        EndIf;\n\n        nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim,\
    \ cGroupHier, cTempSub);\n        nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n\
    \          nSubsetIndex = 1;\n          sTemp = HierarchySubsetElementGetIndex (cGroupDim,\
    \ cGroupHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cGroupDim,\
    \ cGroupHier, cTempSub, nCount);\n          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups\
    \ ) ) = 0 );\n            DeleteGroup( sElement );\n          Else;\n            sMessage=\
    \ 'Attempt to delete built-in group %sGroup%.';\n            LogOutput( 'WARN', Expand(\
    \ cMsgErrorContent ) );\n          EndIF;\n          nCount = nCount -1;\n        End;\n\
    \        ##If the wilcardsearch is String*, below code will get executed\n        ElseIf(Subst(sGroup,Long(sGroup),1)\
    \ @= '*');\n        sGroup1 = '''| Subst(sGroup,iCount,(Long(sGroup)- iCount))|''';\n  \
    \      sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n             \
    \   (INSTR('| NumbertoString(iCount)|', ['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'|sGroup1|')\
    \ ='| NumbertoString(iCount)|'))}+\n                {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'|sGroup1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cGroupDim, cTempSub ) = 1\
    \ );\n            # If a delimited list of Groups includes wildcards then we may have to\
    \ re-use the subset multiple times\n            SubsetMDXSet( cGroupDim, cTempSub, sMDX\
    \ );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, cGroupDim, 1 );\n        EndIf;\n\n    \
    \    nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim, cGroupHier, cTempSub);\n       \
    \ nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n          sTemp = HierarchySubsetElementGetIndex\
    \ (cGroupDim, cGroupHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cGroupDim,\
    \ cGroupHier, cTempSub, nCount);\n          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups\
    \ ) ) = 0 );\n            DeleteGroup( sElement );\n          Else;\n            sMessage=\
    \ 'Attempt to delete built-in group %sGroup%.';\n            LogOutput( 'WARN', Expand(\
    \ cMsgErrorContent ) );\n          EndIF;\n          nCount = nCount -1;\n        End;\n\
    \      Endif;\n    Else;\n      ##If the wilcardsearch is *String*, below code will get\
    \ executed\n      sGroup1 = '''| Subst(sGroup,iCount,(Long(sGroup)- iCount))|''';\n    \
    \  sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n              (INSTR(1,['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'|sGroup1|')\
    \ <> 0))}+\n              {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n  \
    \            (INSTR(1,['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'|sGroup1|') <>\
    \ 0))}';\n      If( SubsetExists( cGroupDim, cTempSub ) = 1 );\n            # If a delimited\
    \ list of Groups includes wildcards then we may have to re-use the subset multiple times\n\
    \            SubsetMDXSet( cGroupDim, cTempSub, sMDX );\n        Else;\n            # temp\
    \ subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub,\
    \ sMDX, cGroupDim, 1 );\n        EndIf;\n\n      nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim,\
    \ cGroupHier, cTempSub);\n      nCount = nHier_Sub_Size;\n      While (nCount >= 1);\n \
    \       sTemp = HierarchySubsetElementGetIndex (cGroupDim, cGroupHier, cTempSub, '', 1);\n\
    \        sElement = HierarchySubsetGetElementName(cGroupDim, cGroupHier, cTempSub, nCount);\n\
    \          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups ) ) = 0 );\n        \
    \    DeleteGroup( sElement );\n          Else;\n            sMessage= 'Attempt to delete\
    \ built-in group %sGroup%.';\n            LogOutput( 'WARN', Expand( cMsgErrorContent )\
    \ );\n          EndIF;\n        nCount = nCount -1;\n      End;\n    Endif;\n  EndIf;\n\
    End;\n\nIf( nErrors = 0 );\n  DimensionSortOrder( '}Groups', 'ByName', 'Ascending', 'ByName'\
    \ , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted group %pGroup% from dimension\
    \ %cGroupDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process designed to delete client groups. This process
    is intended for both development and production environments. Use cases include cleaning
    up security groups after go-live and deleting obsolete security groups as business needs
    change. Note that a group (pGroup) is mandatory; otherwise, the process will abort. Multiple
    groups can be specified and separated by a delimiter. If a group does not exist, it will
    be skipped. If multiple groups are specified and some do not exist, the ones that do exist
    will still be deleted.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete client groups.\n\n# Use case:\
    \ Intended for development or production.\n# 1/ Clean up security groups after go live.\n\
    # 2/ Delete obsolete security groups as business needs change.\n\n# Note:\n# Naturally,\
    \ a group (pGroup) is mandatory otherwise the process will abort:\n# - Multiple groups can\
    \ be specified separated by a delimiter.\n# - If group does not exist then it will be skipped.\n\
    # - If multiple groups are specified and some don't exist and some do, then the ones that\
    \ do exist will still be deleted.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName           = GetProcessName();\ncTimeStamp              = TimSt( Now, '\\Y\\\
    m\\d\\h\\i\\s' );\ncRandomInt              = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub\
    \                = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile     \
    \          = GetProcessErrorFileDirectory | cTempSub | '.csv';\ncGroupDim              \
    \ = '}Groups';\ncGroupHier              = cGroupDim;\ncUserName               = TM1User();\n\
    cMsgErrorLevel          = 'ERROR';\ncMsgErrorContent        = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo                = 'Process:%cThisProcName% run with parameters\
    \ pGroup:%pGroup%, pDelim:%pDelim%.';\ncBuiltInGroups          = 'ADMIN&SecurityAdmin&DataAdmin&OperationsAdmin&';\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n    pDelim              = '&';\nEndIf;\n\
    \n# If no groups have been specified then terminate process\nIf( Trim( pGroup ) @= '' );\n\
    \    nErrors             = 1;\n    sMessage            = 'No groups specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Check alias exists\nIf( DimensionExists('}ElementAttributes_'|cGroupDim)\
    \ = 0 % DimIx('}ElementAttributes_'|cGroupDim, '}TM1_DefaultDisplayValue') = 0 );\n    AttrInsert(\
    \ cGroupDim, '', '}TM1_DefaultDisplayValue', 'A' );\nEndIf;\n\n### Split pGroups into individual\
    \ groups and delete ###\nsGroups                 = pGroup;\nnDelimiterIndex         = 1;\n\
    While( nDelimiterIndex <> 0 );\n  nDelimiterIndex = Scan( pDelim, sGroups );\n  If( nDelimiterIndex\
    \ = 0 );\n        sGroup          = sGroups;\n  Else;\n        sGroup          = Trim( SubSt(\
    \ sGroups, 1, nDelimiterIndex - 1 ) );\n        sGroups         = Trim( Subst( sGroups,\
    \ nDelimiterIndex + Long(pDelim), Long( sGroups ) ) );\n  EndIf;\n  \n  If( Scan( '*', sGroup\
    \ ) = 0);\n    # Don't attempt to delete a blank group\n    If( sGroup @<> '' );\n     \
    \   If( DimIx( '}Groups', sGroup ) > 0 );\n            If( nErrors = 0 );\n            \
    \    If( Scan( Upper( sGroup ) |'&', Upper( cBuiltInGroups ) ) = 0 );\n                \
    \    DeleteGroup( sGroup );\n                Else;\n                    nErrors = 1;\n \
    \                   sMessage= Expand('Attempt to delete built-in group %sGroup%.');\n  \
    \                  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n          \
    \      EndIf;\n            EndIf;\n            If( nErrors > 0 );\n                ItemReject(\
    \ Expand( cMsgErrorContent ) );\n            EndIf;\n        EndIf;\n    EndIf;\n  Else;\n\
    \    # Wildcard search string\n    iCount = 0;\n    iCheck = 1;\n    sChar = sGroup;\n \
    \   While (iCheck > 0);\n      iCheck = Scan('*',sChar);\n      If( iCheck > 0 );\n    \
    \    iCount = iCount + 1;\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n\
    \      Endif;\n    End;\n    If(iCount = 1);\n      ##If the wilcardsearch is *String, below\
    \ code will get executed\n      if(Subst(sGroup,iCount,1) @= '*');\n        sGroup1 = '''|\
    \ Subst(sGroup,iCount+1,(Long(sGroup)- iCount))|''';\n        sTempCount = NumbertoString(Long(sGroup)-iCount);\n\
    \        sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n           \
    \     (Right( ['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|')\
    \ ='|sGroup1|'))}+\n                {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \                (Right( ['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'| sTempCount|')\
    \ ='|sGroup1|'))}';\n        If( SubsetExists( cGroupDim, cTempSub ) = 1 );\n          \
    \  # If a delimited list of Groups includes wildcards then we may have to re-use the subset\
    \ multiple times\n            SubsetMDXSet( cGroupDim, cTempSub, sMDX );\n        Else;\n\
    \            # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cGroupDim, 1 );\n        EndIf;\n\n        nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim,\
    \ cGroupHier, cTempSub);\n        nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n\
    \          nSubsetIndex = 1;\n          sTemp = HierarchySubsetElementGetIndex (cGroupDim,\
    \ cGroupHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cGroupDim,\
    \ cGroupHier, cTempSub, nCount);\n          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups\
    \ ) ) = 0 );\n            DeleteGroup( sElement );\n          Else;\n            sMessage=\
    \ 'Attempt to delete built-in group %sGroup%.';\n            LogOutput( 'WARN', Expand(\
    \ cMsgErrorContent ) );\n          EndIF;\n          nCount = nCount -1;\n        End;\n\
    \        ##If the wilcardsearch is String*, below code will get executed\n        ElseIf(Subst(sGroup,Long(sGroup),1)\
    \ @= '*');\n        sGroup1 = '''| Subst(sGroup,iCount,(Long(sGroup)- iCount))|''';\n  \
    \      sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n             \
    \   (INSTR('| NumbertoString(iCount)|', ['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'|sGroup1|')\
    \ ='| NumbertoString(iCount)|'))}+\n                {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'|sGroup1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cGroupDim, cTempSub ) = 1\
    \ );\n            # If a delimited list of Groups includes wildcards then we may have to\
    \ re-use the subset multiple times\n            SubsetMDXSet( cGroupDim, cTempSub, sMDX\
    \ );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, cGroupDim, 1 );\n        EndIf;\n\n    \
    \    nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim, cGroupHier, cTempSub);\n       \
    \ nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n          sTemp = HierarchySubsetElementGetIndex\
    \ (cGroupDim, cGroupHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cGroupDim,\
    \ cGroupHier, cTempSub, nCount);\n          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups\
    \ ) ) = 0 );\n            DeleteGroup( sElement );\n          Else;\n            sMessage=\
    \ 'Attempt to delete built-in group %sGroup%.';\n            LogOutput( 'WARN', Expand(\
    \ cMsgErrorContent ) );\n          EndIF;\n          nCount = nCount -1;\n        End;\n\
    \      Endif;\n    Else;\n      ##If the wilcardsearch is *String*, below code will get\
    \ executed\n      sGroup1 = '''| Subst(sGroup,iCount,(Long(sGroup)- iCount))|''';\n    \
    \  sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n              (INSTR(1,['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'|sGroup1|')\
    \ <> 0))}+\n              {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n  \
    \            (INSTR(1,['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'|sGroup1|') <>\
    \ 0))}';\n      If( SubsetExists( cGroupDim, cTempSub ) = 1 );\n            # If a delimited\
    \ list of Groups includes wildcards then we may have to re-use the subset multiple times\n\
    \            SubsetMDXSet( cGroupDim, cTempSub, sMDX );\n        Else;\n            # temp\
    \ subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub,\
    \ sMDX, cGroupDim, 1 );\n        EndIf;\n\n      nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim,\
    \ cGroupHier, cTempSub);\n      nCount = nHier_Sub_Size;\n      While (nCount >= 1);\n \
    \       sTemp = HierarchySubsetElementGetIndex (cGroupDim, cGroupHier, cTempSub, '', 1);\n\
    \        sElement = HierarchySubsetGetElementName(cGroupDim, cGroupHier, cTempSub, nCount);\n\
    \          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups ) ) = 0 );\n        \
    \    DeleteGroup( sElement );\n          Else;\n            sMessage= 'Attempt to delete\
    \ built-in group %sGroup%.';\n            LogOutput( 'WARN', Expand( cMsgErrorContent )\
    \ );\n          EndIF;\n        nCount = nCount -1;\n      End;\n    Endif;\n  EndIf;\n\
    End;\n\nIf( nErrors = 0 );\n  DimensionSortOrder( '}Groups', 'ByName', 'Ascending', 'ByName'\
    \ , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted group %pGroup% from dimension\
    \ %cGroupDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der Sicherheitszuweisungen für angegebene
    Objekte an bestimmte Gruppen zuweist. Benutze zwei Parameter, pGroup und pObject, die durch
    Trennzeichen getrennte Listen und Wildcards unterstützen. Der Prozess ist für Entwicklungs-
    oder Produktionsumgebungen gedacht und zwei Hauptanwendungsfälle umfassen die erstmalige
    Sicherheitszuweisung und die Aktualisierung von Sicherheitszuweisungen bei Änderungen der
    Geschäftsanforderungen. Wichtige Hinweise: Die Parameter Gruppe (pGroup), Objekttyp (pObjectType)
    und Sicherheitsstufe (pSecurityLevel) sind obligatorisch, bei ihrer Abwesenheit wird der
    Prozess abgebrochen. Mehrere Gruppen und Objektnamen können mit Trennzeichen angegeben werden,
    müssen jedoch gültig sein. Vor der Nutzung des Prozesses muss die Objektsicherheit initialisiert
    werden und das Sicherheitsupdate muss im Server Explorer durchgeführt werden. Wenn nicht
    existierende Gruppen oder Objekte angegeben werden, werden diese übersprungen; gültige Gruppen
    und Objekte werden jedoch verarbeitet.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will assign security to specified object(s)\
    \ for specified group(s). Both pGroup \n# and pObject parameters support delimited lists\
    \ and wildcards.\n\n# Use case: Intended for develpment or production.\n# 1. Set up initial\
    \ security assignments.\n# 2. Update security assignments a business needs change.\n\n#\
    \ Note:\n# Naturally, group (pGroup), object type (pObjectType) and security level (pSecurityLevel)\
    \ are mandatory otherwise the process will abort:\n# - Multiple groups can be specified\
    \ separated by delimiter.\n# Object names (pObject) can be listed with delimiters but need\
    \ to be valid as well. \n# - Before using this process, you must first initialise object\
    \ security.\n# - For Applications, in Server Explorer go to Applications -> Security Assignments\
    \ and assign an access security for an Application. \n# - For other object types follow\
    \ a similar process but for that object type.\n# - Then from the Server Explorer go to your\
    \ ServerName -> Security -> Refresh Security.\n# - Multiple objects can be specified separated\
    \ by delimiter.\n# - If groups and/or objects that don't exist are specified, then they\
    \ will be skipped but valid groups and ojects will still be processed.\n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncSecurityCube       = '}' | pObjectType | 'Security';\ncTempSub\
    \            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncUserName           = TM1User();\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pGroup:%pGroup%, pObjectType:%pObjectType%, pObject:%pObject%, pSecurityLevel:%pSecurityLevel%,\
    \ pSecurityRefresh:%pSecurityRefresh%, pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors             = 0;\n# If no groups have been specified then terminate\
    \ process\nIf( Trim( pGroup ) @= '' );\n    nErrors         = 1;\n    sMessage        =\
    \ 'No groups specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate Object Type\nIf( pObjectType @<> 'Application' & pObjectType @<> 'Cube'\
    \ & pObjectType @<> 'Dimension' & pObjectType @<> 'Process' & pObjectType @<> 'Chore' );\n\
    \    nErrors         = 1;\n    sMessage        = 'Invalid object type specified: ' | pObjectType\
    \ | '. Valid object types are: Application, Cube, Dimension, Process and Chore';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If no objects have been specified\
    \ then terminate process\nIf( Trim( pObject ) @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'No objects specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate that object type has object security enabled\nIf( CubeExists(\
    \ cSecurityCube ) = 0 );\n    sObjectTypePlural = pObjectType;\n    If( pObjectType @= 'Process');\n\
    \        sObjectTypePlural = sObjectTypePlural | 'es';\n    Else;\n        sObjectTypePlural\
    \ = sObjectTypePlural | 's';\n    EndIf;\n    nErrors = 1;\n    sMessage = 'You must first\
    \ initialise ' | pObjectType | ' Security. In the Server Explorer go to ' |\n          \
    \     sObjectTypePlural | ' -> Security Assignments, and assign an access security to a\
    \ ' |\n               pObjectType | '. Then from the Server Explorer go to your ServerName\
    \ -> Security -> Refresh Security';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Set Object Type Dimension\nsObjectTypeDimension = '}' | pObjectType;\n\
    If( pObjectType @= 'Application' );\n    sObjectTypeDimension = sObjectTypeDimension | 'Entries';\n\
    ElseIf( pObjectType @= 'Process' );\n    sObjectTypeDimension = sObjectTypeDimension | 'es';\n\
    Else;\n    sObjectTypeDimension = sObjectTypeDimension | 's';\nEndIf;\n\n# Validate Security\
    \ Level\n# Allowable Security Levels by Object Type (excluding RESERVE and LOCK):\n#   Cube\
    \        : NONE, READ, ADMIN, WRITE\n#   Dimension   : NONE, READ, ADMIN, WRITE\n#   Application\
    \ : NONE, READ, ADMIN\n#   Process     : NONE, READ\n#   Chore       : NONE, READ\npSecurityLevel\
    \ = Upper( pSecurityLevel );\nIf( pSecurityLevel @= 'NONE' % pSecurityLevel @= 'READ' %\
    \ \n  ( pSecurityLevel @= 'ADMIN' & ( pObjectType @= 'Cube' % pObjectType @= 'Dimension'\
    \ % pObjectType @= 'Application' ) ) %\n  ( pSecurityLevel @= 'WRITE' & ( pObjectType @=\
    \ 'Cube' % pObjectType @= 'Dimension' ) ) );\n  # Valid Security Levels\nElse;\n    nErrors\
    \ = 1;\n    sMessage = 'Invalid security level parameter: ' | pSecurityLevel | ' for object\
    \ type: ' | pObjectType;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# If pSecurityRefresh is blank then default to yes\nIf( Trim( pSecurityRefresh\
    \ ) @= '' );\n    pSecurityRefresh = 'Yes';\nEndIf;\n\n# If pSecurityRefresh has not been\
    \ specified correctly then terminate process\nIf( Upper( pSecurityRefresh ) @<> 'YES' &\
    \ Upper( pSecurityRefresh ) @<> 'NO' );\n    nErrors = 1;\n    sMessage = 'Incorrect value\
    \ for pSecurityRefresh: ' | pSecurityRefresh | '. Valid values are Yes or No';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Application\
    \ Security ###\n# Loop through list of groups\nsGroups = pGroup;\nnGroupDelimIndex = 1;\n\
    \nWhile( nGroupDelimIndex <> 0 );\n  nGroupDelimIndex = Scan( pDelim, sGroups );\n  If(\
    \ nGroupDelimIndex = 0 );\n    sGroup = sGroups;\n  Else;\n    sGroup = Trim( SubSt( sGroups,\
    \ 1, nGroupDelimIndex - 1 ) );\n    sGroups = Trim( Subst( sGroups, nGroupDelimIndex + Long(pDelim),\
    \ Long( sGroups ) ) );\n  EndIf;\n  \n\n If(Scan('*',sGroup) = 0);\n   \n \n  # Don't attempt\
    \ to process a blank group or ADMIN\n  If( sGroup @<> '' & sGroup @<> 'ADMIN' );\n    #\
    \ Check that Group exists\n    If( DimIx( '}Groups', sGroup ) = 0 );\n        nErrors =\
    \ 1;\n        sMessage = 'Group: ' | sGroup | ' does not exists';\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n     ELSE;\n\n      # Loop through list of objects\n  \
    \    sObjects = pObject;\n      nObjectDelimIndex = 1;\n\n      While( nObjectDelimIndex\
    \ <> 0 );\n        nObjectDelimIndex = Scan( pDelim, sObjects );\n        If( nObjectDelimIndex\
    \ = 0 );\n          sObject = sObjects;\n        Else;\n          sObject = Trim( SubSt(\
    \ sObjects, 1, nObjectDelimIndex - 1 ) );\n          sObjects = Trim( Subst( sObjects, nObjectDelimIndex\
    \ + Long(pDelim), Long( sObjects ) ) );\n        EndIf;\n        If( Scan( '*', sObject\
    \ ) = 0);\n         # Don't attempt to process a blank object\n         If( sObject @<>\
    \ '' );\n           # Check that object exists\n           If( DimIx( sObjectTypeDimension,\
    \ sObject ) = 0 );\n                nErrors = 1;\n                sMessage = 'Object: '\
    \ | sObject | ' does not exists';\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n          ELSE;\n             # Assign Security\n             If( CellIsUpdateable(\
    \ cSecurityCube, sObject, sGroup ) = 1 );\n               If( nErrors = 0);\n          \
    \       CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\n               EndIf;\n\
    \             EndIf;\n           EndIf;\n         EndIf;\n        ELSE;\n          # Wildcard\
    \ search string\n         sObject = '''|sObject|''';\n         sMdx = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |sObjectTypeDimension| '])},'| sObject| ')}';\n         If( SubsetExists(\
    \ sObjectTypeDimension, cTempSub ) = 1 );\n            # If a delimited list of objects\
    \ includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ sObjectTypeDimension, cTempSub, sMDX );\n         Else;\n            # temp subset, therefore\
    \ no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, sObjectTypeDimension,\
    \ 1 );\n         EndIf;\n         nCountObj = SubsetGetSize( sObjectTypeDimension, cTempSub\
    \ );\n         While( nCountObj >= 1 );\n            sObject = SubsetGetElementName( sObjectTypeDimension,\
    \ cTempSub, nCountObj );\n            # Assign Security\n             If( CellIsUpdateable(\
    \ cSecurityCube, sObject, sGroup ) = 1 );\n               If( nErrors = 0);\n          \
    \       CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\n               EndIf;\n\
    \             EndIf;\n            nCountObj = nCountObj - 1;\n         End;\n        EndIf;\n\
    \      End;\n    EndIf;\n  EndIf;\n ELSE;\n# Wildcard search string\n        sGroupDim =\
    \ '}Groups';\n        sGroup = '''|sGroup|''';\n        sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([\
    \ ' |sGroupDim| '])},'| sGroup| ')}';\n        If( SubsetExists( sGroupDim, cTempSub ) =\
    \ 1 );\n            # If a delimited list of groups includes wildcards then we may have\
    \ to re-use the subset multiple times\n            SubsetMDXSet( sGroupDim, cTempSub, sMDX\
    \ );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, sGroupDim, 1 );\n        EndIf;\n      \
    \  # Loop through dimensions in groups with wildcard\n        nCountGroup = SubsetGetSize(\
    \ '}Groups' , cTempSub );\n        While( nCountGroup >= 1 );\n            \n          \
    \  sGroup = SubsetGetElementName( '}Groups' , cTempSub, nCountGroup );\n            # Validate\
    \ group name\n            If( Dimix('}Groups', sGroup) = 0 );\n                nErrors =\
    \ 1;\n                sMessage = Expand( 'Group '%sGroup%' does not exist.' );\n       \
    \         LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n            Else;\n       \
    \       # Loop through list of objects\n              sObjects = pObject;\n            \
    \  nObjectDelimIndex = 1;\n\n              While( nObjectDelimIndex <> 0 );\n          \
    \      nObjectDelimIndex = Scan( pDelim, sObjects );\n                If( nObjectDelimIndex\
    \ = 0 );\n                  sObject = sObjects;\n                Else;\n               \
    \   sObject = Trim( SubSt( sObjects, 1, nObjectDelimIndex - 1 ) );\n                  sObjects\
    \ = Trim( Subst( sObjects, nObjectDelimIndex + Long(pDelim), Long( sObjects ) ) );\n   \
    \             EndIf;\n                If( Scan( '*', sObject ) = 0);\n                #\
    \ Don't attempt to process a blank object\n                  If( sObject @<> '' );\n   \
    \                 # Check that object exists\n                    If( DimIx( sObjectTypeDimension,\
    \ sObject ) = 0 );\n                        nErrors = 1;\n                        sMessage\
    \ = 'Object: ' | sObject | ' does not exists';\n                        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n                    ELSE;\n                      # Assign\
    \ Security\n                      If( CellIsUpdateable( cSecurityCube, sObject, sGroup )\
    \ = 1 );\n                        If( nErrors = 0);\n                          CellPutS(\
    \ pSecurityLevel, cSecurityCube, sObject, sGroup );\n                        EndIf;\n  \
    \                    EndIf;\n                    EndIf;\n                  EndIf;\n    \
    \            ELSE;\n                # Wildcard search string\n                sObject =\
    \ '''|sObject|''';\n                sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sObjectTypeDimension|\
    \ '])},'| sObject| ')}';\n                If( SubsetExists( sObjectTypeDimension, cTempSub\
    \ ) = 1 );\n                    # If a delimited list of objects includes wildcards then\
    \ we may have to re-use the subset multiple times\n                    SubsetMDXSet( sObjectTypeDimension,\
    \ cTempSub, sMDX );\n                Else;\n                    # temp subset, therefore\
    \ no need to destroy in epilog\n                    SubsetCreatebyMDX( cTempSub, sMDX, sObjectTypeDimension,\
    \ 1 );\n                EndIf;\n                  nCountObj = SubsetGetSize( sObjectTypeDimension,\
    \ cTempSub );\n                  While( nCountObj >= 1 );\n                      sObject\
    \ = SubsetGetElementName( sObjectTypeDimension, cTempSub, nCountObj );\n               \
    \       # Assign Security\n                      If( CellIsUpdateable( cSecurityCube, sObject,\
    \ sGroup ) = 1 );\n                        If( nErrors = 0);\n                         \
    \ CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\n                        EndIf;\n\
    \                      EndIf;\n                      nCountObj = nCountObj - 1;\n      \
    \            End;\n                EndIf;\n              End;\n            Endif;\n    \
    \        nCountGroup = nCountGroup - 1;\n        End;\n  Endif;    \nEnd;\n\n### Refresh\
    \ Security ###\n\nIf( Upper( pSecurityRefresh ) @= 'YES' );\n  SecurityRefresh;\nEndIf;\n\
    \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully assigned object %pObject% of type %pObjectType%\
    \ security level %pSecurityLevel% for group %pGroup%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that assigns security to specified objects
    for particular groups. Use two parameters, pGroup and pObject, which support delimited lists
    and wildcards. This process is intended for development or production environments with
    two main use cases: setting up initial security assignments and updating security assignments
    as business needs change. Important notes: The parameters group (pGroup), object type (pObjectType),
    and security level (pSecurityLevel) are mandatory; the absence of these will cause the process
    to abort. Multiple groups and object names can be specified using delimiters, but they must
    be valid. Object security must be initialized before using the process, and a security update
    must be done through Server Explorer. If non-existing groups or objects are specified, they
    will be skipped, but valid groups and objects will still be processed.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will assign security to specified object(s)\
    \ for specified group(s). Both pGroup \n# and pObject parameters support delimited lists\
    \ and wildcards.\n\n# Use case: Intended for develpment or production.\n# 1. Set up initial\
    \ security assignments.\n# 2. Update security assignments a business needs change.\n\n#\
    \ Note:\n# Naturally, group (pGroup), object type (pObjectType) and security level (pSecurityLevel)\
    \ are mandatory otherwise the process will abort:\n# - Multiple groups can be specified\
    \ separated by delimiter.\n# Object names (pObject) can be listed with delimiters but need\
    \ to be valid as well. \n# - Before using this process, you must first initialise object\
    \ security.\n# - For Applications, in Server Explorer go to Applications -> Security Assignments\
    \ and assign an access security for an Application. \n# - For other object types follow\
    \ a similar process but for that object type.\n# - Then from the Server Explorer go to your\
    \ ServerName -> Security -> Refresh Security.\n# - Multiple objects can be specified separated\
    \ by delimiter.\n# - If groups and/or objects that don't exist are specified, then they\
    \ will be skipped but valid groups and ojects will still be processed.\n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncSecurityCube       = '}' | pObjectType | 'Security';\ncTempSub\
    \            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncUserName           = TM1User();\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters\
    \ pGroup:%pGroup%, pObjectType:%pObjectType%, pObject:%pObject%, pSecurityLevel:%pSecurityLevel%,\
    \ pSecurityRefresh:%pSecurityRefresh%, pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\nnErrors             = 0;\n# If no groups have been specified then terminate\
    \ process\nIf( Trim( pGroup ) @= '' );\n    nErrors         = 1;\n    sMessage        =\
    \ 'No groups specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate Object Type\nIf( pObjectType @<> 'Application' & pObjectType @<> 'Cube'\
    \ & pObjectType @<> 'Dimension' & pObjectType @<> 'Process' & pObjectType @<> 'Chore' );\n\
    \    nErrors         = 1;\n    sMessage        = 'Invalid object type specified: ' | pObjectType\
    \ | '. Valid object types are: Application, Cube, Dimension, Process and Chore';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If no objects have been specified\
    \ then terminate process\nIf( Trim( pObject ) @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'No objects specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate that object type has object security enabled\nIf( CubeExists(\
    \ cSecurityCube ) = 0 );\n    sObjectTypePlural = pObjectType;\n    If( pObjectType @= 'Process');\n\
    \        sObjectTypePlural = sObjectTypePlural | 'es';\n    Else;\n        sObjectTypePlural\
    \ = sObjectTypePlural | 's';\n    EndIf;\n    nErrors = 1;\n    sMessage = 'You must first\
    \ initialise ' | pObjectType | ' Security. In the Server Explorer go to ' |\n          \
    \     sObjectTypePlural | ' -> Security Assignments, and assign an access security to a\
    \ ' |\n               pObjectType | '. Then from the Server Explorer go to your ServerName\
    \ -> Security -> Refresh Security';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Set Object Type Dimension\nsObjectTypeDimension = '}' | pObjectType;\n\
    If( pObjectType @= 'Application' );\n    sObjectTypeDimension = sObjectTypeDimension | 'Entries';\n\
    ElseIf( pObjectType @= 'Process' );\n    sObjectTypeDimension = sObjectTypeDimension | 'es';\n\
    Else;\n    sObjectTypeDimension = sObjectTypeDimension | 's';\nEndIf;\n\n# Validate Security\
    \ Level\n# Allowable Security Levels by Object Type (excluding RESERVE and LOCK):\n#   Cube\
    \        : NONE, READ, ADMIN, WRITE\n#   Dimension   : NONE, READ, ADMIN, WRITE\n#   Application\
    \ : NONE, READ, ADMIN\n#   Process     : NONE, READ\n#   Chore       : NONE, READ\npSecurityLevel\
    \ = Upper( pSecurityLevel );\nIf( pSecurityLevel @= 'NONE' % pSecurityLevel @= 'READ' %\
    \ \n  ( pSecurityLevel @= 'ADMIN' & ( pObjectType @= 'Cube' % pObjectType @= 'Dimension'\
    \ % pObjectType @= 'Application' ) ) %\n  ( pSecurityLevel @= 'WRITE' & ( pObjectType @=\
    \ 'Cube' % pObjectType @= 'Dimension' ) ) );\n  # Valid Security Levels\nElse;\n    nErrors\
    \ = 1;\n    sMessage = 'Invalid security level parameter: ' | pSecurityLevel | ' for object\
    \ type: ' | pObjectType;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# If pSecurityRefresh is blank then default to yes\nIf( Trim( pSecurityRefresh\
    \ ) @= '' );\n    pSecurityRefresh = 'Yes';\nEndIf;\n\n# If pSecurityRefresh has not been\
    \ specified correctly then terminate process\nIf( Upper( pSecurityRefresh ) @<> 'YES' &\
    \ Upper( pSecurityRefresh ) @<> 'NO' );\n    nErrors = 1;\n    sMessage = 'Incorrect value\
    \ for pSecurityRefresh: ' | pSecurityRefresh | '. Valid values are Yes or No';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Application\
    \ Security ###\n# Loop through list of groups\nsGroups = pGroup;\nnGroupDelimIndex = 1;\n\
    \nWhile( nGroupDelimIndex <> 0 );\n  nGroupDelimIndex = Scan( pDelim, sGroups );\n  If(\
    \ nGroupDelimIndex = 0 );\n    sGroup = sGroups;\n  Else;\n    sGroup = Trim( SubSt( sGroups,\
    \ 1, nGroupDelimIndex - 1 ) );\n    sGroups = Trim( Subst( sGroups, nGroupDelimIndex + Long(pDelim),\
    \ Long( sGroups ) ) );\n  EndIf;\n  \n\n If(Scan('*',sGroup) = 0);\n   \n \n  # Don't attempt\
    \ to process a blank group or ADMIN\n  If( sGroup @<> '' & sGroup @<> 'ADMIN' );\n    #\
    \ Check that Group exists\n    If( DimIx( '}Groups', sGroup ) = 0 );\n        nErrors =\
    \ 1;\n        sMessage = 'Group: ' | sGroup | ' does not exists';\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n     ELSE;\n\n      # Loop through list of objects\n  \
    \    sObjects = pObject;\n      nObjectDelimIndex = 1;\n\n      While( nObjectDelimIndex\
    \ <> 0 );\n        nObjectDelimIndex = Scan( pDelim, sObjects );\n        If( nObjectDelimIndex\
    \ = 0 );\n          sObject = sObjects;\n        Else;\n          sObject = Trim( SubSt(\
    \ sObjects, 1, nObjectDelimIndex - 1 ) );\n          sObjects = Trim( Subst( sObjects, nObjectDelimIndex\
    \ + Long(pDelim), Long( sObjects ) ) );\n        EndIf;\n        If( Scan( '*', sObject\
    \ ) = 0);\n         # Don't attempt to process a blank object\n         If( sObject @<>\
    \ '' );\n           # Check that object exists\n           If( DimIx( sObjectTypeDimension,\
    \ sObject ) = 0 );\n                nErrors = 1;\n                sMessage = 'Object: '\
    \ | sObject | ' does not exists';\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n          ELSE;\n             # Assign Security\n             If( CellIsUpdateable(\
    \ cSecurityCube, sObject, sGroup ) = 1 );\n               If( nErrors = 0);\n          \
    \       CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\n               EndIf;\n\
    \             EndIf;\n           EndIf;\n         EndIf;\n        ELSE;\n          # Wildcard\
    \ search string\n         sObject = '''|sObject|''';\n         sMdx = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |sObjectTypeDimension| '])},'| sObject| ')}';\n         If( SubsetExists(\
    \ sObjectTypeDimension, cTempSub ) = 1 );\n            # If a delimited list of objects\
    \ includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ sObjectTypeDimension, cTempSub, sMDX );\n         Else;\n            # temp subset, therefore\
    \ no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, sObjectTypeDimension,\
    \ 1 );\n         EndIf;\n         nCountObj = SubsetGetSize( sObjectTypeDimension, cTempSub\
    \ );\n         While( nCountObj >= 1 );\n            sObject = SubsetGetElementName( sObjectTypeDimension,\
    \ cTempSub, nCountObj );\n            # Assign Security\n             If( CellIsUpdateable(\
    \ cSecurityCube, sObject, sGroup ) = 1 );\n               If( nErrors = 0);\n          \
    \       CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\n               EndIf;\n\
    \             EndIf;\n            nCountObj = nCountObj - 1;\n         End;\n        EndIf;\n\
    \      End;\n    EndIf;\n  EndIf;\n ELSE;\n# Wildcard search string\n        sGroupDim =\
    \ '}Groups';\n        sGroup = '''|sGroup|''';\n        sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([\
    \ ' |sGroupDim| '])},'| sGroup| ')}';\n        If( SubsetExists( sGroupDim, cTempSub ) =\
    \ 1 );\n            # If a delimited list of groups includes wildcards then we may have\
    \ to re-use the subset multiple times\n            SubsetMDXSet( sGroupDim, cTempSub, sMDX\
    \ );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, sGroupDim, 1 );\n        EndIf;\n      \
    \  # Loop through dimensions in groups with wildcard\n        nCountGroup = SubsetGetSize(\
    \ '}Groups' , cTempSub );\n        While( nCountGroup >= 1 );\n            \n          \
    \  sGroup = SubsetGetElementName( '}Groups' , cTempSub, nCountGroup );\n            # Validate\
    \ group name\n            If( Dimix('}Groups', sGroup) = 0 );\n                nErrors =\
    \ 1;\n                sMessage = Expand( 'Group '%sGroup%' does not exist.' );\n       \
    \         LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n            Else;\n       \
    \       # Loop through list of objects\n              sObjects = pObject;\n            \
    \  nObjectDelimIndex = 1;\n\n              While( nObjectDelimIndex <> 0 );\n          \
    \      nObjectDelimIndex = Scan( pDelim, sObjects );\n                If( nObjectDelimIndex\
    \ = 0 );\n                  sObject = sObjects;\n                Else;\n               \
    \   sObject = Trim( SubSt( sObjects, 1, nObjectDelimIndex - 1 ) );\n                  sObjects\
    \ = Trim( Subst( sObjects, nObjectDelimIndex + Long(pDelim), Long( sObjects ) ) );\n   \
    \             EndIf;\n                If( Scan( '*', sObject ) = 0);\n                #\
    \ Don't attempt to process a blank object\n                  If( sObject @<> '' );\n   \
    \                 # Check that object exists\n                    If( DimIx( sObjectTypeDimension,\
    \ sObject ) = 0 );\n                        nErrors = 1;\n                        sMessage\
    \ = 'Object: ' | sObject | ' does not exists';\n                        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n                    ELSE;\n                      # Assign\
    \ Security\n                      If( CellIsUpdateable( cSecurityCube, sObject, sGroup )\
    \ = 1 );\n                        If( nErrors = 0);\n                          CellPutS(\
    \ pSecurityLevel, cSecurityCube, sObject, sGroup );\n                        EndIf;\n  \
    \                    EndIf;\n                    EndIf;\n                  EndIf;\n    \
    \            ELSE;\n                # Wildcard search string\n                sObject =\
    \ '''|sObject|''';\n                sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sObjectTypeDimension|\
    \ '])},'| sObject| ')}';\n                If( SubsetExists( sObjectTypeDimension, cTempSub\
    \ ) = 1 );\n                    # If a delimited list of objects includes wildcards then\
    \ we may have to re-use the subset multiple times\n                    SubsetMDXSet( sObjectTypeDimension,\
    \ cTempSub, sMDX );\n                Else;\n                    # temp subset, therefore\
    \ no need to destroy in epilog\n                    SubsetCreatebyMDX( cTempSub, sMDX, sObjectTypeDimension,\
    \ 1 );\n                EndIf;\n                  nCountObj = SubsetGetSize( sObjectTypeDimension,\
    \ cTempSub );\n                  While( nCountObj >= 1 );\n                      sObject\
    \ = SubsetGetElementName( sObjectTypeDimension, cTempSub, nCountObj );\n               \
    \       # Assign Security\n                      If( CellIsUpdateable( cSecurityCube, sObject,\
    \ sGroup ) = 1 );\n                        If( nErrors = 0);\n                         \
    \ CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\n                        EndIf;\n\
    \                      EndIf;\n                      nCountObj = nCountObj - 1;\n      \
    \            End;\n                EndIf;\n              End;\n            Endif;\n    \
    \        nCountGroup = nCountGroup - 1;\n        End;\n  Endif;    \nEnd;\n\n### Refresh\
    \ Security ###\n\nIf( Upper( pSecurityRefresh ) @= 'YES' );\n  SecurityRefresh;\nEndIf;\n\
    \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully assigned object %pObject% of type %pObjectType%\
    \ security level %pSecurityLevel% for group %pGroup%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der die TM1-Sicherheit aktualisiert.
    Der Prozess sollte in Entwicklungs- oder Produktionsumgebungen verwendet werden, insbesondere
    wenn neue Clients oder Sicherheitsgruppen hinzugefügt wurden oder wenn Sicherheits-Cubes
    mit geänderten Regeln vorliegen. Beachte, dass dies ein zeitaufwendiger Prozess sein kann
    und möglicherweise über Nacht durchgeführt werden muss.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process refreshes TM1 security.\n\n# Use case: Intended\
    \ for development or production.\n# 1/ Refresh security after new clients or security groups\
    \ are added.\n# 2/ If security cubes have rules and they had to be changed.\n\n# Note:\n\
    # This can be a time consuming process and may need to be run overnight.\n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName = GetProcessName();\ncTimeStamp\
    \ = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  =\
    \ 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Refresh Security ###\n\nSecurityRefresh;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully refreshed security.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that refreshes TM1 security. The process
    is intended for use in development or production environments, particularly when new clients
    or security groups are added or when security cubes have rules that had to be changed. Note
    that this can be a time-consuming process and may need to be run overnight.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process refreshes TM1 security.\n\n# Use case: Intended\
    \ for development or production.\n# 1/ Refresh security after new clients or security groups\
    \ are added.\n# 2/ If security cubes have rules and they had to be changed.\n\n# Note:\n\
    # This can be a time consuming process and may need to be run overnight.\n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName = GetProcessName();\ncTimeStamp\
    \ = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  =\
    \ 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Refresh Security ###\n\nSecurityRefresh;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully refreshed security.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Erstelle einen IBM Turbo Integrator Prozess, um persistente Feeders zu löschen.
    Dieser Vorgang sollte sowohl für Entwicklungs- als auch für Produktionsumgebungen geeignet
    sein. Dabei ist sicherzustellen, dass persistente Feeders in der Konfigurationsdatei deaktiviert
    sind und dass der Bedarf besteht, die Feeders erneut zu verarbeiten. Beachte, dass die erneute
    Verarbeitung der Feeders viel Zeit in Anspruch nehmen kann und es ratsam sein könnte, diesen
    Prozess über Nacht auszuführen.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Delete Persistent feeders.\n\n# Use\
    \ case: Intended for development or production.\n# 1/ Persistent feeders turned off in config\
    \ file.\n# 2/ Want to reprocess feeders.\n\n# Note:\n# Reprocessing feeders could take a\
    \ long time and it may be better to run this overnight.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pRun:%pRun% .'; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Delete Feeders\
    \ ###\nIf( pRun @= 'Y' );\n    DeleteAllPersistentFeeders;\nEndIf;\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted persistant\
    \ feeders.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process to delete persistent feeders. This process
    should be suitable for both development and production environments. Ensure that persistent
    feeders are turned off in the config file and that there is a need to reprocess the feeders.
    Note that reprocessing the feeders could take a significant amount of time and it might
    be advisable to run this process overnight.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Delete Persistent feeders.\n\n# Use\
    \ case: Intended for development or production.\n# 1/ Persistent feeders turned off in config\
    \ file.\n# 2/ Want to reprocess feeders.\n\n# Note:\n# Reprocessing feeders could take a\
    \ long time and it may be better to run this overnight.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pRun:%pRun% .'; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Delete Feeders\
    \ ###\nIf( pRun @= 'Y' );\n    DeleteAllPersistentFeeders;\nEndIf;\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted persistant\
    \ feeders.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der das Sichern des Datenverzeichnisses
    automatisiert. Dieser Prozess soll sowohl in der Entwicklungs- als auch in der Produktionsumgebung
    eingesetzt werden. Die Sicherung des Datenverzeichnisses soll täglich während der Entwicklungsphase
    und während des Planungszyklus durchgeführt werden. Beachte, dass ein gültiges Datenverzeichnis
    (pSrcDir) und ein Zielverzeichnis (pTgtDir) erforderlich sind, da der Prozess andernfalls
    abbricht. Beschreibe die einzelnen Schritte und die Logik, die im Prozess verwendet werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will back up the Data Directory.\n\n# Use\
    \ case: Intended for development and production.\n# 1/ Backup Data directory every day during\
    \ development.\n# 2/ Backup Data directory every day during planning cycle.\n\n# Note:\n\
    # Naturally, a valid data directory (pSrcDir) and targer directory (pTgtDir) is mandatory\
    \ otherwise the process will abort.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% Message:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pSrcDir:%pSrcDir%, pTgtDir:%pTgtDir%, pExcludeFilter:%pExcludeFilter%,\
    \ pDelim:%pDelim%, pSubDirCopy:%pSubDirCopy%, pRobocopy:%pRobocopy%.' ;\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \n### Validate Parameters ###\nnErrors             = 0;\n\n# Remove leading and/or trailing\
    \ spaces\npSrcDir             = Trim( pSrcDir );\npTgtDir             = Trim( pTgtDir );\n\
    \n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n\
    \  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory )\
    \ > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\n\
    EndIf;\n\n# Remove trailing \\ from directory names if present\nIf( SubSt( pSrcDir, Long(\
    \ pSrcDir ), 1 ) @= sOSDelim );\n    pSrcDir         = SubSt( pSrcDir, 1, Long( pSrcDir\
    \ ) - 1 );\nEndIf;\nIf( SubSt( pTgtDir, Long( pTgtDir ),1 ) @= sOSDelim );\n    pTgtDir\
    \         = SubSt( pTgtDir, 1, Long( pTgtDir ) - 1 );\nEndIf;\n\n# Check that data directory\
    \ has been specified\nIf( pSrcDir @= '' );\n    nErrors         = 1;\n    sMessage     \
    \   = 'No data directory specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( FileExists( pSrcDir ) = 0 );\n    nErrors         = 1;\n    sMessage   \
    \     = 'Source data directory for backup does not exist: ' | pSrcDir;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check that target directory has been specified\n\
    If( pTgtDir @= '' );\n    nErrors         = 1;\n    sMessage        = 'No backup directory\
    \ specified';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( FileExists(\
    \ pTgtDir ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Destination directory\
    \ for backup does not exist: ' | pTgtDir;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Save\
    \ the model to disk\nExecuteProcess( '}bedrock.server.savedataall', 'pStrictErrorHandling',\
    \ pStrictErrorHandling );\nsMessage = 'TM1 Save Data All Complete.';\nIf( pLogoutput = 1\
    \ );\n\tLogOutput('INFO', sMessage ); \nEndIf;\n\n### Create batch files\nDatasourceASCIIQuoteCharacter='';\n\
    \n### Create Make Directory Batch File\nsFileName           = 'Bedrock.MkDir.bat' ;\nsBackupDir\
    \          = pTgtDir | sOSDelim | 'TM1Backup_' | cTimeStamp;\nIf(sOS @= 'Windows');\n  ASCIIOUTPUT(\
    \ sFileName, 'md '' | sBackupDir |''' );\nEndIf;\n\n### Create Exclude File ###\nIf(pRobocopy\
    \ = 1);\n\t# robocopy uses different file format with rcj file and * wildcard character\n\
    \tsFileNameExclude =  pSrcDir | sOSDelim | 'Excludes' | cTimeStamp | cRandomInt| '.rcj';\n\
    \    ASCIIOUTPUT( sFileNameExclude, '/xf');\n    sExcludeWCPrefix = '*';\nElse;\n\tsFileNameExclude\
    \ =  'Excludes' | cTimeStamp | cRandomInt| '.txt';\n    sExcludeWCPrefix = '';\nEndIf;\n\
    pExcludeFilter = TRIM(pExcludeFilter);\n\nIf(pExcludeFilter @<> ''); \n    If( SCAN(pDelim,\
    \ pExcludeFilter) > 0);\n        # parse multiple exclusions\n        While(LONG(pExcludeFilter)\
    \ > 0);\n            If(SCAN(pDelim, pExcludeFilter) > 0);\n                sExcludePart\
    \ = TRIM(SUBST(pExcludeFilter, 1, SCAN(pDelim, pExcludeFilter) - 1));\n                pExcludeFilter\
    \ = TRIM(DELET(pExcludeFilter, 1,SCAN(pDelim, pExcludeFilter) + LONG(pDelim) - 1));\n  \
    \          Else;\n                sExcludePart = pExcludeFilter;\n                pExcludeFilter\
    \ = '';\n            EndIf;\n            ASCIIOUTPUT( sFileNameExclude, sExcludeWCPrefix\
    \ | sExcludePart);\n        End;\n    Else;\n        ASCIIOUTPUT( sFileNameExclude, sExcludeWCPrefix\
    \ | pExcludeFilter);\n    EndIf;\nElse;\n    ASCIIOUTPUT( sFileNameExclude, '');\nEndIf;\n\
    \n### Create Batch File ###\nsFileName = 'Bedrock.Server.DataDir.Backup.bat';\nIf(sOS @=\
    \ 'Windows');\n  If(pSubDirCopy = 1);\n  \tcSubDirCopy = '/s /e';\n  Else;\n  \tcSubDirCopy\
    \ = '';\n  EndIf;\n  If(pRobocopy = 1);\n  \tsText = 'robocopy ''| pSrcDir |'' ''| sBackupDir\
    \ | '' '  | cSubDirCopy | ' /job:''| sFileNameExclude | ''';\n  Else;\n  \tsText = 'XCOPY\
    \ ''| pSrcDir |'' ''| sBackupDir|'' /i /c '| cSubDirCopy |' /y /exclude:'| sFileNameExclude;\n\
    \  EndIf;\n  ASCIIOUTPUT( sFileName, '@ECHO OFF');\n  ASCIIOUTPUT( sFileName, sText );\n\
    Else;\n  #sOS is Linux\n  If(pSubDirCopy = 1);\n  \tcSubDirCopy = 'r';\n  Else;\n  \tcSubDirCopy\
    \ = '';\n  EndIf;\n  sText = 'rsync -' | cSubDirCopy | 't --exclude-from=' | sFileNameExclude\
    \ | ' '' | pSrcDir | '' '' | sBackupDir |''';\nEndIf;\n\nsMessage = 'Command Line: ' | sText;\n\
    If( pLogoutput = 1 );\n\tLogOutput('INFO', sMessage ); \nEndIf;\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#Section Daten\n\n#Section Epilog\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# Create backup directory\nIf(sOS @= 'Windows');\n\
    \  ExecuteCommand ( 'Bedrock.MkDir.bat', 1 );\nElse;\n  ExecuteCommand ( 'mkdir '' | sBackupDir\
    \ |''', 1);\nEndIf;\n# Ensure backup directory created else abort\nIf( FileExists( sBackupDir\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'Process Quit: Could not create backup directory:\
    \ ' | sBackupDir;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ProcessQuit;\n\
    ELSE;\n      sMessage = 'Backup directory exists: ' | sBackupDir;\n      LogOutput('INFO',\
    \ sMessage ); \nEndIf;\n\n### Copy Data Dir to Backup ###\nIf(sOS @= 'Windows');\n  ExecuteCommand\
    \ ( 'Bedrock.Server.DataDir.Backup.bat', 1 );\nElse;\n  ExecuteCommand ( sText, 1 );\nEndIf;\n\
    \n### Delete temporary files ###\nsFileName = 'Bedrock.Server.DataDir.Backup.bat' ;\nASCIIDelete(\
    \ LOWER(sFileName) );\nsFileName = 'Bedrock.MkDir.bat';\nASCIIDelete( LOWER(sFileName) );\n\
    sFileName = sFileNameExclude;\nASCIIDelete( LOWER(sFileNameExclude) );\n\nsMessage = 'Temporary\
    \ files deleted.';\nIf( pLogoutput = 1 );\n \tLogOutput('INFO', sMessage ); \nEndIf;\n\n\
    ### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully Backed up Dir %pSrcDir% to dir %pTgtDir%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that automates the backup of the Data Directory.
    This process is intended for use in both development and production environments. The backup
    of the Data Directory should occur daily during the development phase and the planning cycle.
    Note that a valid data directory (pSrcDir) and a target directory (pTgtDir) are mandatory;
    otherwise, the process will abort. Describe the individual steps and the logic used in the
    process.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will back up the Data Directory.\n\n# Use\
    \ case: Intended for development and production.\n# 1/ Backup Data directory every day during\
    \ development.\n# 2/ Backup Data directory every day during planning cycle.\n\n# Note:\n\
    # Naturally, a valid data directory (pSrcDir) and targer directory (pTgtDir) is mandatory\
    \ otherwise the process will abort.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% Message:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pSrcDir:%pSrcDir%, pTgtDir:%pTgtDir%, pExcludeFilter:%pExcludeFilter%,\
    \ pDelim:%pDelim%, pSubDirCopy:%pSubDirCopy%, pRobocopy:%pRobocopy%.' ;\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \n### Validate Parameters ###\nnErrors             = 0;\n\n# Remove leading and/or trailing\
    \ spaces\npSrcDir             = Trim( pSrcDir );\npTgtDir             = Trim( pTgtDir );\n\
    \n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n\
    \  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory )\
    \ > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\n\
    EndIf;\n\n# Remove trailing \\ from directory names if present\nIf( SubSt( pSrcDir, Long(\
    \ pSrcDir ), 1 ) @= sOSDelim );\n    pSrcDir         = SubSt( pSrcDir, 1, Long( pSrcDir\
    \ ) - 1 );\nEndIf;\nIf( SubSt( pTgtDir, Long( pTgtDir ),1 ) @= sOSDelim );\n    pTgtDir\
    \         = SubSt( pTgtDir, 1, Long( pTgtDir ) - 1 );\nEndIf;\n\n# Check that data directory\
    \ has been specified\nIf( pSrcDir @= '' );\n    nErrors         = 1;\n    sMessage     \
    \   = 'No data directory specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( FileExists( pSrcDir ) = 0 );\n    nErrors         = 1;\n    sMessage   \
    \     = 'Source data directory for backup does not exist: ' | pSrcDir;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check that target directory has been specified\n\
    If( pTgtDir @= '' );\n    nErrors         = 1;\n    sMessage        = 'No backup directory\
    \ specified';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( FileExists(\
    \ pTgtDir ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Destination directory\
    \ for backup does not exist: ' | pTgtDir;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Save\
    \ the model to disk\nExecuteProcess( '}bedrock.server.savedataall', 'pStrictErrorHandling',\
    \ pStrictErrorHandling );\nsMessage = 'TM1 Save Data All Complete.';\nIf( pLogoutput = 1\
    \ );\n\tLogOutput('INFO', sMessage ); \nEndIf;\n\n### Create batch files\nDatasourceASCIIQuoteCharacter='';\n\
    \n### Create Make Directory Batch File\nsFileName           = 'Bedrock.MkDir.bat' ;\nsBackupDir\
    \          = pTgtDir | sOSDelim | 'TM1Backup_' | cTimeStamp;\nIf(sOS @= 'Windows');\n  ASCIIOUTPUT(\
    \ sFileName, 'md '' | sBackupDir |''' );\nEndIf;\n\n### Create Exclude File ###\nIf(pRobocopy\
    \ = 1);\n\t# robocopy uses different file format with rcj file and * wildcard character\n\
    \tsFileNameExclude =  pSrcDir | sOSDelim | 'Excludes' | cTimeStamp | cRandomInt| '.rcj';\n\
    \    ASCIIOUTPUT( sFileNameExclude, '/xf');\n    sExcludeWCPrefix = '*';\nElse;\n\tsFileNameExclude\
    \ =  'Excludes' | cTimeStamp | cRandomInt| '.txt';\n    sExcludeWCPrefix = '';\nEndIf;\n\
    pExcludeFilter = TRIM(pExcludeFilter);\n\nIf(pExcludeFilter @<> ''); \n    If( SCAN(pDelim,\
    \ pExcludeFilter) > 0);\n        # parse multiple exclusions\n        While(LONG(pExcludeFilter)\
    \ > 0);\n            If(SCAN(pDelim, pExcludeFilter) > 0);\n                sExcludePart\
    \ = TRIM(SUBST(pExcludeFilter, 1, SCAN(pDelim, pExcludeFilter) - 1));\n                pExcludeFilter\
    \ = TRIM(DELET(pExcludeFilter, 1,SCAN(pDelim, pExcludeFilter) + LONG(pDelim) - 1));\n  \
    \          Else;\n                sExcludePart = pExcludeFilter;\n                pExcludeFilter\
    \ = '';\n            EndIf;\n            ASCIIOUTPUT( sFileNameExclude, sExcludeWCPrefix\
    \ | sExcludePart);\n        End;\n    Else;\n        ASCIIOUTPUT( sFileNameExclude, sExcludeWCPrefix\
    \ | pExcludeFilter);\n    EndIf;\nElse;\n    ASCIIOUTPUT( sFileNameExclude, '');\nEndIf;\n\
    \n### Create Batch File ###\nsFileName = 'Bedrock.Server.DataDir.Backup.bat';\nIf(sOS @=\
    \ 'Windows');\n  If(pSubDirCopy = 1);\n  \tcSubDirCopy = '/s /e';\n  Else;\n  \tcSubDirCopy\
    \ = '';\n  EndIf;\n  If(pRobocopy = 1);\n  \tsText = 'robocopy ''| pSrcDir |'' ''| sBackupDir\
    \ | '' '  | cSubDirCopy | ' /job:''| sFileNameExclude | ''';\n  Else;\n  \tsText = 'XCOPY\
    \ ''| pSrcDir |'' ''| sBackupDir|'' /i /c '| cSubDirCopy |' /y /exclude:'| sFileNameExclude;\n\
    \  EndIf;\n  ASCIIOUTPUT( sFileName, '@ECHO OFF');\n  ASCIIOUTPUT( sFileName, sText );\n\
    Else;\n  #sOS is Linux\n  If(pSubDirCopy = 1);\n  \tcSubDirCopy = 'r';\n  Else;\n  \tcSubDirCopy\
    \ = '';\n  EndIf;\n  sText = 'rsync -' | cSubDirCopy | 't --exclude-from=' | sFileNameExclude\
    \ | ' '' | pSrcDir | '' '' | sBackupDir |''';\nEndIf;\n\nsMessage = 'Command Line: ' | sText;\n\
    If( pLogoutput = 1 );\n\tLogOutput('INFO', sMessage ); \nEndIf;\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#Section Daten\n\n#Section Epilog\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# Create backup directory\nIf(sOS @= 'Windows');\n\
    \  ExecuteCommand ( 'Bedrock.MkDir.bat', 1 );\nElse;\n  ExecuteCommand ( 'mkdir '' | sBackupDir\
    \ |''', 1);\nEndIf;\n# Ensure backup directory created else abort\nIf( FileExists( sBackupDir\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'Process Quit: Could not create backup directory:\
    \ ' | sBackupDir;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ProcessQuit;\n\
    ELSE;\n      sMessage = 'Backup directory exists: ' | sBackupDir;\n      LogOutput('INFO',\
    \ sMessage ); \nEndIf;\n\n### Copy Data Dir to Backup ###\nIf(sOS @= 'Windows');\n  ExecuteCommand\
    \ ( 'Bedrock.Server.DataDir.Backup.bat', 1 );\nElse;\n  ExecuteCommand ( sText, 1 );\nEndIf;\n\
    \n### Delete temporary files ###\nsFileName = 'Bedrock.Server.DataDir.Backup.bat' ;\nASCIIDelete(\
    \ LOWER(sFileName) );\nsFileName = 'Bedrock.MkDir.bat';\nASCIIDelete( LOWER(sFileName) );\n\
    sFileName = sFileNameExclude;\nASCIIDelete( LOWER(sFileNameExclude) );\n\nsMessage = 'Temporary\
    \ files deleted.';\nIf( pLogoutput = 1 );\n \tLogOutput('INFO', sMessage ); \nEndIf;\n\n\
    ### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully Backed up Dir %pSrcDir% to dir %pTgtDir%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der alle Dateien und Prozesse im Datenverzeichnis
    auflistet und die Ausgabe als Textdatei im selben Verzeichnis speichert. Der Prozess sollte
    für die Produktionsumgebung geeignet sein und eine Auflistung von Dateien in jedem Ordner
    ermöglichen. Beachte, dass der TI-Prozess zuerst eine Batch-Datei erstellt, die verschiedene
    Objekttypen separat auflistet und sie dann ausführt. In einigen Fällen muss der Pfad zur
    Batch-Datei im Datenverzeichnis vollständig qualifiziert sein. Die Batch-Datei wird im Epilog
    gelöscht.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will list all files and processes in the\
    \ data directory as text file output in the data directory itself.\n\n# Use case: Intended\
    \ for production.\n# 1/ Obtain a listing of files in any folder.\n\n# Note:\n# The TI 1st\
    \ creates a batch file that will list all the different type of objects seperately and then\
    \ executes it.\n# In some cases the path to the batch file (in the data directory) must\
    \ be fully qualified.\n# The batch file is deleted in Epilog.\n#EndRegion @DOC\n\n### TO\
    \ DELETE - just included as temp measure so process compiles\npDebug = 0;\n### TO DELETE\
    \ - just included as temp measure so process compiles\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pSrcDir:%pSrcDir%.' ;  \n#cDebugFile = GetProcessErrorFileDirectory\
    \ | cProcess | '.' | cTimeStamp | '.' | sRandomInt ;\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n## check operating system\n\
    If( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim\
    \ = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\nIf( sOS @= 'Linux' );\n\
    \  cBatchFile = LOWER(cThisProcName) | '.sh';\nElse;\n  cBatchFile = cThisProcName | '.bat';\n\
    EndIf;\n\n### Build Command ###\nnErrors         = 0;\n\nIf( pSrcDir @= '' );\n    # If\
    \ no data directory provided then use current directory\n    sCommand    = cBatchFile;\n\
    Else;\n    # Trim off trailing backslash if present\n    If( SubSt( pSrcDir, Long( pSrcDir\
    \ ), 1 ) @= sOSDelim );\n        pSrcDir = SubSt( pSrcDir, 1, Long( pSrcDir ) - 1 );\n \
    \   EndIf;\n    # Check that data directory exists\n    If( FileExists( pSrcDir ) = 0 );\n\
    \        nErrors  = 1;\n        sMessage = 'Data directory does not exist: ' | pSrcDir;\n\
    \        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n        sCommand\
    \ = pSrcDir | sOSDelim | cBatchFile;\n    EndIf;\nEndIf;\n\n### Create Batch File ###\n\
    DatasourceASCIIQuoteCharacter='';\nIf( sOS @= 'Windows');\n  ASCIIOUTPUT( sCommand, 'dir\
    \ /b /s *.* > List_All_Data_Directory_Files.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b /s\
    \ }*.* > List_All_Control_Objects.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b *.cub > List_All_Cubes.txt');\n\
    \  \n  ASCIIOUTPUT( sCommand, 'dir /b *.dim > List_All_Dimensions.txt');\n  ASCIIOUTPUT(\
    \ sCommand, 'dir /b *.pro > List_All_Processes.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b\
    \ *.cho > List_All_Chores.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b *Bedrock*.pro > List_All_Bedrock_Processes.txt');\n\
    \  \n  ASCIIOUTPUT( sCommand, 'dir /b /s *.vue > List_All_Views.txt');\n  ASCIIOUTPUT( sCommand,\
    \ 'dir /b /s *.sub > List_All_Subsets.txt');\nElse;\n  ASCIIOUTPUT( sCommand, 'find '$PWD'\
    \ -type f > List_All_Data_Directory_Files.txt ;');\n  ASCIIOUTPUT( sCommand, 'find '$PWD'\
    \ -type f -name '}*' > List_All_Control_Objects.txt ;');\n  ASCIIOUTPUT( sCommand, 'find\
    \ '$PWD' -type f -name '*.cub' > List_All_Cubes.txt ;');\n  \n  ASCIIOUTPUT( sCommand, 'find\
    \ '$PWD' -type f -name '*.dim' > List_All_Dimensions.txt ;');\n  ASCIIOUTPUT( sCommand,\
    \ 'find '$PWD' -type f -name '*.pro' > List_All_Processes.txt ;');\n  ASCIIOUTPUT( sCommand,\
    \ 'find '$PWD' -type f -name '*.cho' > List_All_Chores.txt ;');\n  ASCIIOUTPUT( sCommand,\
    \ 'find '$PWD' -type f -iname '*Bedrock*.pro' > List_All_Bedrock_Processes.txt ;');\n  \n\
    \  ASCIIOUTPUT( sCommand, 'find '$PWD' -type f -name '*.vue' > List_All_Views.txt ;');\n\
    \  ASCIIOUTPUT( sCommand, 'find '$PWD' -type f -name '*.sub' > List_All_Subsets.txt ;');\n\
    EndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### VALIDATION ###\n# Check that batch file exists\n\
    If( FileExists( sCommand ) = 0 );\n    nErrors = 1;\n    sMessage = 'Batch file not found:\
    \ ' | sCommand;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    ### Execute Batch File ###\nIf( nErrors = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand\
    \ ( sCommand, 1 );\n  Else;\n    ExecuteCommand ( 'sh ' | sCommand, 1 );\n  EndIf;\nEndIf;\n\
    \n### Delete temporary batch file\nASCIIDelete ( sCommand );\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully listed contents\
    \ from %pSrcDir% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that lists all files and processes in the
    data directory and outputs them as a text file in the same directory. The process should
    be suitable for a production environment and allow for listing files in any folder. Note
    that the TI first creates a batch file that lists different types of objects separately
    and then executes it. In some instances, the path to the batch file in the data directory
    must be fully qualified. The batch file is deleted in the epilog.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will list all files and processes in the\
    \ data directory as text file output in the data directory itself.\n\n# Use case: Intended\
    \ for production.\n# 1/ Obtain a listing of files in any folder.\n\n# Note:\n# The TI 1st\
    \ creates a batch file that will list all the different type of objects seperately and then\
    \ executes it.\n# In some cases the path to the batch file (in the data directory) must\
    \ be fully qualified.\n# The batch file is deleted in Epilog.\n#EndRegion @DOC\n\n### TO\
    \ DELETE - just included as temp measure so process compiles\npDebug = 0;\n### TO DELETE\
    \ - just included as temp measure so process compiles\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp  \
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pSrcDir:%pSrcDir%.' ;  \n#cDebugFile = GetProcessErrorFileDirectory\
    \ | cProcess | '.' | cTimeStamp | '.' | sRandomInt ;\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n## check operating system\n\
    If( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim\
    \ = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\nIf( sOS @= 'Linux' );\n\
    \  cBatchFile = LOWER(cThisProcName) | '.sh';\nElse;\n  cBatchFile = cThisProcName | '.bat';\n\
    EndIf;\n\n### Build Command ###\nnErrors         = 0;\n\nIf( pSrcDir @= '' );\n    # If\
    \ no data directory provided then use current directory\n    sCommand    = cBatchFile;\n\
    Else;\n    # Trim off trailing backslash if present\n    If( SubSt( pSrcDir, Long( pSrcDir\
    \ ), 1 ) @= sOSDelim );\n        pSrcDir = SubSt( pSrcDir, 1, Long( pSrcDir ) - 1 );\n \
    \   EndIf;\n    # Check that data directory exists\n    If( FileExists( pSrcDir ) = 0 );\n\
    \        nErrors  = 1;\n        sMessage = 'Data directory does not exist: ' | pSrcDir;\n\
    \        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n        sCommand\
    \ = pSrcDir | sOSDelim | cBatchFile;\n    EndIf;\nEndIf;\n\n### Create Batch File ###\n\
    DatasourceASCIIQuoteCharacter='';\nIf( sOS @= 'Windows');\n  ASCIIOUTPUT( sCommand, 'dir\
    \ /b /s *.* > List_All_Data_Directory_Files.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b /s\
    \ }*.* > List_All_Control_Objects.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b *.cub > List_All_Cubes.txt');\n\
    \  \n  ASCIIOUTPUT( sCommand, 'dir /b *.dim > List_All_Dimensions.txt');\n  ASCIIOUTPUT(\
    \ sCommand, 'dir /b *.pro > List_All_Processes.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b\
    \ *.cho > List_All_Chores.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b *Bedrock*.pro > List_All_Bedrock_Processes.txt');\n\
    \  \n  ASCIIOUTPUT( sCommand, 'dir /b /s *.vue > List_All_Views.txt');\n  ASCIIOUTPUT( sCommand,\
    \ 'dir /b /s *.sub > List_All_Subsets.txt');\nElse;\n  ASCIIOUTPUT( sCommand, 'find '$PWD'\
    \ -type f > List_All_Data_Directory_Files.txt ;');\n  ASCIIOUTPUT( sCommand, 'find '$PWD'\
    \ -type f -name '}*' > List_All_Control_Objects.txt ;');\n  ASCIIOUTPUT( sCommand, 'find\
    \ '$PWD' -type f -name '*.cub' > List_All_Cubes.txt ;');\n  \n  ASCIIOUTPUT( sCommand, 'find\
    \ '$PWD' -type f -name '*.dim' > List_All_Dimensions.txt ;');\n  ASCIIOUTPUT( sCommand,\
    \ 'find '$PWD' -type f -name '*.pro' > List_All_Processes.txt ;');\n  ASCIIOUTPUT( sCommand,\
    \ 'find '$PWD' -type f -name '*.cho' > List_All_Chores.txt ;');\n  ASCIIOUTPUT( sCommand,\
    \ 'find '$PWD' -type f -iname '*Bedrock*.pro' > List_All_Bedrock_Processes.txt ;');\n  \n\
    \  ASCIIOUTPUT( sCommand, 'find '$PWD' -type f -name '*.vue' > List_All_Views.txt ;');\n\
    \  ASCIIOUTPUT( sCommand, 'find '$PWD' -type f -name '*.sub' > List_All_Subsets.txt ;');\n\
    EndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### VALIDATION ###\n# Check that batch file exists\n\
    If( FileExists( sCommand ) = 0 );\n    nErrors = 1;\n    sMessage = 'Batch file not found:\
    \ ' | sCommand;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    ### Execute Batch File ###\nIf( nErrors = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand\
    \ ( sCommand, 1 );\n  Else;\n    ExecuteCommand ( 'sh ' | sCommand, 1 );\n  EndIf;\nEndIf;\n\
    \n### Delete temporary batch file\nASCIIDelete ( sCommand );\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully listed contents\
    \ from %pSrcDir% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der alle Dateien in einem Verzeichnis
    entschlüsselt, indem das Dienstprogramm tm1crypt verwendet wird. Berücksichtige dabei den
    Anwendungsfall, dass mehrere Dateien in einem Verzeichnis verschlüsselt oder entschlüsselt
    werden sollen, und es Unterprozesse aufruft. Beachte: Die generierten Befehle funktionieren
    nur, wenn die TM1-Instanz verschlüsselt ist.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process unencrypts all files existing\
    \ in a directory, using the tm1crypt utility\n\n# Use case: To encrypts / unencrypts multile\
    \ file in a directory. Calls sub-process.\n\n\n# Note: Generated commands will only work\
    \ when the TM1 isntance is entrypted\n# \n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\\
    h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName  \
    \         = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pType:%pType%, pDirectory:%pDirectory%, pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%,\
    \ pTM1CryptLocation:%pTM1CryptLocation%, pAction:%pAction%.' ;  \ncMsgInfoContent     =\
    \ 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\nnDataCount        = 0;\n\
    nErrors           = 0;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## Validate the\
    \ source directory\nIf ( pDirectory @= '' );\n    nErrors         = 1;\n    sMessage   \
    \     = 'pDirectory is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\nsSourcePath = pDirectory;\nIf ( SubSt ( pDirectory, Long ( pDirectory ),\
    \ 1 ) @<> sOSDelim );\n  sSourcePath = sSourcePath | sOSDelim;\nEndIf;\n\n## Validate the\
    \ action\nsAction = '';\nIf ( pAction @= '4' % pAction @= '5');\n    sAction = pAction;\n\
    ELSE;\n    nErrors         = 1;\n    sMessage        = 'Specified Action is not valid';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate config\
    \ and exe\nIf ( FileExists( pConfigLocation ) = 0 );\n    nErrors         = 1;\n    sMessage\
    \        = 'Specified config file not found';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;  \n\nIf ( FileExists( pTM1CryptLocation ) = 0 );\n    nErrors         = 1;\n\
    \    sMessage        = 'Specified tm1crypt file not found';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n## Validate the dest path\nsDestPath = pDestPath;\n\
    If ( pDestPath @= '' );\n    sMessage        = 'pDestPath is Blank, using logging dir';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf ( SubSt ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath\
    \ | sOSDelim;\nEndIf;\n\nIf ( sDestPath @= sSourcePath );\n    nErrors         = 1;\n  \
    \  sMessage        = 'Destination is the same as source';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\nIf(\
    \ nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n  \
    \    ProcessBreak;\n  EndIf;\nEndIf;\n\nsFile = '';\nsPrev = '';\nsFile = WildcardFileSearch(\
    \ sSourcePath | '****' | pType , sPrev);\n\nWhile ( sFile @<> '' );\n  IF( pLogoutput =\
    \ 1 );\n      sMessage = 'Processing file: ' | sFile;\n      LogOutput('INFO', Expand( cMsgInfoContent\
    \ ) );\n  ENDIF;\n  nRet = ExecuteProcess('}bedrock.server.encrypt.file',\n     'pSourcePath',\
    \ sSourcePath,\n     'pSourceFile', sFile,\n     'pDestPath', sDestPath,\n     'pConfigLocation',\
    \ pConfigLocation,\n     'pTM1CryptLocation', pTM1CryptLocation,\n     'pAction', pAction\n\
    \    );\n  If( nRet <> ProcessExitNormal() );\n      nErrors = nErrors + 1;\n      sMessage=\
    \ 'Error in processing file: %sFile%.';\n      DataSourceType = 'NULL';\n      LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  EndIf;\n  sPrev = sFile;\n  sFile = WildcardFileSearch(\
    \ sSourcePath | '*' | pType , sPrev);\nEnd;  \n  \n#Section Metadaten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Epilog\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully processed directory %pDirectory%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that unencrypts all files in a directory
    using the tm1crypt utility. Consider the use case of encrypting or unencrypting multiple
    files in a directory and calling sub-processes. Note: The generated commands will only work
    when the TM1 instance is encrypted.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process unencrypts all files existing\
    \ in a directory, using the tm1crypt utility\n\n# Use case: To encrypts / unencrypts multile\
    \ file in a directory. Calls sub-process.\n\n\n# Note: Generated commands will only work\
    \ when the TM1 isntance is entrypted\n# \n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\\
    h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName  \
    \         = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pType:%pType%, pDirectory:%pDirectory%, pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%,\
    \ pTM1CryptLocation:%pTM1CryptLocation%, pAction:%pAction%.' ;  \ncMsgInfoContent     =\
    \ 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\nnDataCount        = 0;\n\
    nErrors           = 0;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n\
    \  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## Validate the\
    \ source directory\nIf ( pDirectory @= '' );\n    nErrors         = 1;\n    sMessage   \
    \     = 'pDirectory is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\nsSourcePath = pDirectory;\nIf ( SubSt ( pDirectory, Long ( pDirectory ),\
    \ 1 ) @<> sOSDelim );\n  sSourcePath = sSourcePath | sOSDelim;\nEndIf;\n\n## Validate the\
    \ action\nsAction = '';\nIf ( pAction @= '4' % pAction @= '5');\n    sAction = pAction;\n\
    ELSE;\n    nErrors         = 1;\n    sMessage        = 'Specified Action is not valid';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate config\
    \ and exe\nIf ( FileExists( pConfigLocation ) = 0 );\n    nErrors         = 1;\n    sMessage\
    \        = 'Specified config file not found';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;  \n\nIf ( FileExists( pTM1CryptLocation ) = 0 );\n    nErrors         = 1;\n\
    \    sMessage        = 'Specified tm1crypt file not found';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n## Validate the dest path\nsDestPath = pDestPath;\n\
    If ( pDestPath @= '' );\n    sMessage        = 'pDestPath is Blank, using logging dir';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf ( SubSt ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath\
    \ | sOSDelim;\nEndIf;\n\nIf ( sDestPath @= sSourcePath );\n    nErrors         = 1;\n  \
    \  sMessage        = 'Destination is the same as source';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\nIf(\
    \ nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n  \
    \    ProcessBreak;\n  EndIf;\nEndIf;\n\nsFile = '';\nsPrev = '';\nsFile = WildcardFileSearch(\
    \ sSourcePath | '****' | pType , sPrev);\n\nWhile ( sFile @<> '' );\n  IF( pLogoutput =\
    \ 1 );\n      sMessage = 'Processing file: ' | sFile;\n      LogOutput('INFO', Expand( cMsgInfoContent\
    \ ) );\n  ENDIF;\n  nRet = ExecuteProcess('}bedrock.server.encrypt.file',\n     'pSourcePath',\
    \ sSourcePath,\n     'pSourceFile', sFile,\n     'pDestPath', sDestPath,\n     'pConfigLocation',\
    \ pConfigLocation,\n     'pTM1CryptLocation', pTM1CryptLocation,\n     'pAction', pAction\n\
    \    );\n  If( nRet <> ProcessExitNormal() );\n      nErrors = nErrors + 1;\n      sMessage=\
    \ 'Error in processing file: %sFile%.';\n      DataSourceType = 'NULL';\n      LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  EndIf;\n  sPrev = sFile;\n  sFile = WildcardFileSearch(\
    \ sSourcePath | '*' | pType , sPrev);\nEnd;  \n  \n#Section Metadaten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Epilog\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n\
    \    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully processed directory %pDirectory%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\
    \   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Beschreibe einen IBM Turbo Integrator Prozess, der die Verschlüsselung und Entschlüsselung
    einer Datei unter Verwendung des tm1crypt-Dienstprogramms durchführt. Der Prozess sollte
    eine einzelne Datei zum Verschlüsseln oder Entschlüsseln verwenden können. Beachte, dass
    die generierten Befehle nur funktionieren, wenn die TM1-Instanz verschlüsselt ist.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process encrypts / unencrypts a file\
    \ using the tm1crypt utility\n# Use case: To encrypts / unencrypts a single file\n# Note:\
    \ Generated commands will only work when the TM1 isntance is entrypted\n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pSourcePath:%pSourcePath%,\
    \ pSourceFile:%pSourceFile%, pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%, pTM1CryptLocation:%pTM1CryptLocation%,\
    \ pAction:%pAction%.' ;  \ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ InfoMsg:%sMessage%';\nnDataCount        = 0;\nnErrors           = 0;\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n## Validate the action\nsAction = '';\nIf ( pAction @= '4' % pAction @=\
    \ '5');\n    sAction = pAction;\nELSE;\n    nErrors         = 1;\n    sMessage        =\
    \ 'Specified Action is not valid';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate config and exe\nIf ( FileExists( pConfigLocation ) = 0 );\n\
    \    nErrors         = 1;\n    sMessage        = 'Specified config file not found';\n  \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nIf ( FileExists(\
    \ pTM1CryptLocation ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified\
    \ tm1crypt file not found';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;  \n\n## Validate the source file/path and dest file/path\nIf ( pSourcePath @= ''\
    \ );\n    nErrors         = 1;\n    sMessage        = 'pSourcePath is Blank';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsSourcePath = pSourcePath;\nIf\
    \ ( SubSt ( pSourcePath, Long ( pSourcePath ), 1 ) @<> sOSDelim );\n  sSourcePath = sSourcePath\
    \ | sOSDelim;\nEndIf;\n\nsDestPath = pDestPath;\nIf ( pDestPath @= '' );\n    sMessage \
    \       = 'pDestPath is Blank, using logging dir';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\nEndIf;\nIf ( SubSt\
    \ ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath | sOSDelim;\n\
    EndIf;\n\nIf ( pSourceFile @= '' );\n    nErrors         = 1;\n    sMessage        = 'pSourceFile\
    \ is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsFileSrc\
    \ = sSourcePath | pSourceFile;\n\nIf ( FileExists( sFileSrc ) = 0 );\n    nErrors      \
    \   = 1;\n    sMessage        = '%sFileSrc% not found';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\nsFileDest = sDestPath;\nIf ( SubSt ( sFileDest,\
    \ Long ( sFileDest ), 1 ) @= sOSDelim );\n  sFileDest = SubSt ( sFileDest, 1, Long ( sFileDest\
    \ ) - 1 );\nEndIf;\n\nIf ( sFileDest @= sSourcePath );\n    nErrors         = 1;\n    sMessage\
    \        = 'Destination is the same as source';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Create contents of the bat file\n\nDatasourceASCIIQuoteCharacter=\
    \ '';\n\nsBat = ''' | pTM1CryptLocation | '' -i '' | pConfigLocation | '' -action ' | sAction\
    \ | ' -filesrc '' | sFileSrc | '' -filedest '' | sFileDest |''';\nIf( sOS @= 'Windows' );\n\
    \    sBatFile = sDestPath | pSourceFile | '.bat';\nElse;\n    sBatFile = sDestPath | pSourceFile\
    \ | '.sh';\nEndIf;\nASCIIOutput( sBatFile, sBat);\n\n#Section Metadaten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Epilog\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Run that bat file\n\nIf( nErrors\
    \ = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand( sBatfile, 1 );\n  Else;\n    ExecuteCommand\
    \ ( 'sh ' | sBatfile, 1 );\n  EndIf;\n  ASCIIDelete( sBatFile );\nEndIf;\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully processed file\
    \ %pSourceFile%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Describe an IBM Turbo Integrator process that performs the encryption and decryption
    of a file using the tm1crypt utility. The process should be able to encrypt or decrypt a
    single file. Note that the generated commands will only work when the TM1 instance is encrypted.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process encrypts / unencrypts a file\
    \ using the tm1crypt utility\n# Use case: To encrypts / unencrypts a single file\n# Note:\
    \ Generated commands will only work when the TM1 isntance is entrypted\n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pSourcePath:%pSourcePath%,\
    \ pSourceFile:%pSourceFile%, pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%, pTM1CryptLocation:%pTM1CryptLocation%,\
    \ pAction:%pAction%.' ;  \ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ InfoMsg:%sMessage%';\nnDataCount        = 0;\nnErrors           = 0;\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n## Validate the action\nsAction = '';\nIf ( pAction @= '4' % pAction @=\
    \ '5');\n    sAction = pAction;\nELSE;\n    nErrors         = 1;\n    sMessage        =\
    \ 'Specified Action is not valid';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate config and exe\nIf ( FileExists( pConfigLocation ) = 0 );\n\
    \    nErrors         = 1;\n    sMessage        = 'Specified config file not found';\n  \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nIf ( FileExists(\
    \ pTM1CryptLocation ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified\
    \ tm1crypt file not found';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;  \n\n## Validate the source file/path and dest file/path\nIf ( pSourcePath @= ''\
    \ );\n    nErrors         = 1;\n    sMessage        = 'pSourcePath is Blank';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsSourcePath = pSourcePath;\nIf\
    \ ( SubSt ( pSourcePath, Long ( pSourcePath ), 1 ) @<> sOSDelim );\n  sSourcePath = sSourcePath\
    \ | sOSDelim;\nEndIf;\n\nsDestPath = pDestPath;\nIf ( pDestPath @= '' );\n    sMessage \
    \       = 'pDestPath is Blank, using logging dir';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\nEndIf;\nIf ( SubSt\
    \ ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath | sOSDelim;\n\
    EndIf;\n\nIf ( pSourceFile @= '' );\n    nErrors         = 1;\n    sMessage        = 'pSourceFile\
    \ is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsFileSrc\
    \ = sSourcePath | pSourceFile;\n\nIf ( FileExists( sFileSrc ) = 0 );\n    nErrors      \
    \   = 1;\n    sMessage        = '%sFileSrc% not found';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\nsFileDest = sDestPath;\nIf ( SubSt ( sFileDest,\
    \ Long ( sFileDest ), 1 ) @= sOSDelim );\n  sFileDest = SubSt ( sFileDest, 1, Long ( sFileDest\
    \ ) - 1 );\nEndIf;\n\nIf ( sFileDest @= sSourcePath );\n    nErrors         = 1;\n    sMessage\
    \        = 'Destination is the same as source';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Create contents of the bat file\n\nDatasourceASCIIQuoteCharacter=\
    \ '';\n\nsBat = ''' | pTM1CryptLocation | '' -i '' | pConfigLocation | '' -action ' | sAction\
    \ | ' -filesrc '' | sFileSrc | '' -filedest '' | sFileDest |''';\nIf( sOS @= 'Windows' );\n\
    \    sBatFile = sDestPath | pSourceFile | '.bat';\nElse;\n    sBatFile = sDestPath | pSourceFile\
    \ | '.sh';\nEndIf;\nASCIIOutput( sBatFile, sBat);\n\n#Section Metadaten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Epilog\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Run that bat file\n\nIf( nErrors\
    \ = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand( sBatfile, 1 );\n  Else;\n    ExecuteCommand\
    \ ( 'sh ' | sBatfile, 1 );\n  EndIf;\n  ASCIIDelete( sBatFile );\nEndIf;\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully processed file\
    \ %pSourceFile%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der die Verschlüsselung bzw. Entschlüsselung
    einer Datei unter Verwendung des tm1crypt-Dienstprogramms ermöglicht. Der Anwendungsfall
    besteht darin, eine einzelne Datei zu verschlüsseln oder zu entschlüsseln. Beachte, dass
    die generierten Befehle nur funktionieren, wenn die TM1-Instanz verschlüsselt ist.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process encrypts / unencrypts a file\
    \ using the tm1crypt utility\n\n# Use case: To encrypts / unencrypts a single file\n\n#\
    \ Note: Generated commands will only work when the TM1 isntance is entrypted\n# \n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pSourcePath:%pSourcePath%,\
    \ pSourceFile:%pSourceFile%, pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%, pTM1CryptLocation:%pTM1CryptLocation%,\
    \ pAction:%pAction%.' ;  \ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ InfoMsg:%sMessage%';\nnDataCount        = 0;\nnErrors           = 0;\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n## Validate the action\nsAction = '';\nIf ( pAction @= '4' % pAction @=\
    \ '5');\n    sAction = pAction;\nELSE;\n    nErrors         = 1;\n    sMessage        =\
    \ 'Specified Action is not valid';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate config and exe\nIf ( FileExists( pConfigLocation ) = 0 );\n\
    \    nErrors         = 1;\n    sMessage        = 'Specified config file not found';\n  \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nIf ( FileExists(\
    \ pTM1CryptLocation ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified\
    \ tm1crypt file not found';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;  \n\n## Validate the source file/path and dest file/path\nIf ( pSourcePath @= ''\
    \ );\n    nErrors         = 1;\n    sMessage        = 'pSourcePath is Blank';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsSourcePath = pSourcePath;\nIf\
    \ ( SubSt ( pSourcePath, Long ( pSourcePath ), 1 ) @<> sOSDelim );\n  sSourcePath = sSourcePath\
    \ | sOSDelim;\nEndIf;\n\nsDestPath = pDestPath;\nIf ( pDestPath @= '' );\n    sMessage \
    \       = 'pDestPath is Blank, using logging dir';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\nEndIf;\nIf ( SubSt\
    \ ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath | sOSDelim;\n\
    EndIf;\n\nIf ( pSourceFile @= '' );\n    nErrors         = 1;\n    sMessage        = 'pSourceFile\
    \ is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsFileSrc\
    \ = sSourcePath | pSourceFile;\n\nIf ( FileExists( sFileSrc ) = 0 );\n    nErrors      \
    \   = 1;\n    sMessage        = '%sFileSrc% not found';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\nsFileDest = sDestPath;\nIf ( SubSt ( sFileDest,\
    \ Long ( sFileDest ), 1 ) @= sOSDelim );\n  sFileDest = SubSt ( sFileDest, 1, Long ( sFileDest\
    \ ) - 1 );\nEndIf;\n\nIf ( sFileDest @= sSourcePath );\n    nErrors         = 1;\n    sMessage\
    \        = 'Destination is the same as source';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Create contents of the bat file\n\nDatasourceASCIIQuoteCharacter=\
    \ '';\n\nsBat = ''' | pTM1CryptLocation | '' -i '' | pConfigLocation | '' -action ' | sAction\
    \ | ' -filesrc '' | sFileSrc | '' -filedest '' | sFileDest |''';\nIf( sOS @= 'Windows' );\n\
    \    sBatFile = sDestPath | pSourceFile | '.bat';\nElse;\n    sBatFile = sDestPath | pSourceFile\
    \ | '.sh';\nEndIf;\nASCIIOutput( sBatFile, sBat);\n\n#Section Metadaten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Epilog\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Run that bat file\n\nIf( nErrors\
    \ = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand( sBatfile, 1 );\n  Else;\n    ExecuteCommand\
    \ ( 'sh ' | sBatfile, 1 );\n  EndIf;\n  ASCIIDelete( sBatFile );\nEndIf;\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully processed file\
    \ %pSourceFile%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that enables the encryption or decryption
    of a file using the tm1crypt utility. The use case is to encrypt or decrypt a single file.
    Note that the generated commands will only work when the TM1 instance is encrypted.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process encrypts / unencrypts a file\
    \ using the tm1crypt utility\n\n# Use case: To encrypts / unencrypts a single file\n\n#\
    \ Note: Generated commands will only work when the TM1 isntance is entrypted\n# \n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\n\
    cMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pSourcePath:%pSourcePath%,\
    \ pSourceFile:%pSourceFile%, pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%, pTM1CryptLocation:%pTM1CryptLocation%,\
    \ pAction:%pAction%.' ;  \ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ InfoMsg:%sMessage%';\nnDataCount        = 0;\nnErrors           = 0;\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate\
    \ Parameters ###\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n## Validate the action\nsAction = '';\nIf ( pAction @= '4' % pAction @=\
    \ '5');\n    sAction = pAction;\nELSE;\n    nErrors         = 1;\n    sMessage        =\
    \ 'Specified Action is not valid';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate config and exe\nIf ( FileExists( pConfigLocation ) = 0 );\n\
    \    nErrors         = 1;\n    sMessage        = 'Specified config file not found';\n  \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nIf ( FileExists(\
    \ pTM1CryptLocation ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified\
    \ tm1crypt file not found';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;  \n\n## Validate the source file/path and dest file/path\nIf ( pSourcePath @= ''\
    \ );\n    nErrors         = 1;\n    sMessage        = 'pSourcePath is Blank';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsSourcePath = pSourcePath;\nIf\
    \ ( SubSt ( pSourcePath, Long ( pSourcePath ), 1 ) @<> sOSDelim );\n  sSourcePath = sSourcePath\
    \ | sOSDelim;\nEndIf;\n\nsDestPath = pDestPath;\nIf ( pDestPath @= '' );\n    sMessage \
    \       = 'pDestPath is Blank, using logging dir';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\nEndIf;\nIf ( SubSt\
    \ ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath | sOSDelim;\n\
    EndIf;\n\nIf ( pSourceFile @= '' );\n    nErrors         = 1;\n    sMessage        = 'pSourceFile\
    \ is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsFileSrc\
    \ = sSourcePath | pSourceFile;\n\nIf ( FileExists( sFileSrc ) = 0 );\n    nErrors      \
    \   = 1;\n    sMessage        = '%sFileSrc% not found';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\nsFileDest = sDestPath;\nIf ( SubSt ( sFileDest,\
    \ Long ( sFileDest ), 1 ) @= sOSDelim );\n  sFileDest = SubSt ( sFileDest, 1, Long ( sFileDest\
    \ ) - 1 );\nEndIf;\n\nIf ( sFileDest @= sSourcePath );\n    nErrors         = 1;\n    sMessage\
    \        = 'Destination is the same as source';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Create contents of the bat file\n\nDatasourceASCIIQuoteCharacter=\
    \ '';\n\nsBat = ''' | pTM1CryptLocation | '' -i '' | pConfigLocation | '' -action ' | sAction\
    \ | ' -filesrc '' | sFileSrc | '' -filedest '' | sFileDest |''';\nIf( sOS @= 'Windows' );\n\
    \    sBatFile = sDestPath | pSourceFile | '.bat';\nElse;\n    sBatFile = sDestPath | pSourceFile\
    \ | '.sh';\nEndIf;\nASCIIOutput( sBatFile, sBat);\n\n#Section Metadaten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Epilog\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Run that bat file\n\nIf( nErrors\
    \ = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand( sBatfile, 1 );\n  Else;\n    ExecuteCommand\
    \ ( 'sh ' | sBatfile, 1 );\n  EndIf;\n  ASCIIDelete( sBatFile );\nEndIf;\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully processed file\
    \ %pSourceFile%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der die ExecuteCommand Funktion ausführt
    und die Ausgabe in den Serverprotokollen druckt. Dieser Prozess ist für den produktiven
    Einsatz gedacht und bietet folgende Anwendungsfälle: 1) Führe die ExecuteCommand Funktion
    von jedem Teil des Modells aus, einschließlich RushTI oder einem Drittanbietersystem, ohne
    direkten Zugriff auf den TI-Editor. 2) Entferne die Notwendigkeit, einen einmaligen Prozess
    zur Nutzung dieser Funktion zu erstellen. 3) Komprimiere oder dekomprimiere Dateien. 4)
    Kopiere Dateien und Ordner vom TM1-Server. 5) Lösche Dateien und Ordner vom TM1-Server.
    6) Liste und beende Aufgaben, die auf dem TM1-Server ausgeführt werden. 7) Exportiere und
    importiere Registrierungsschlüssel wie ODBC-Datenquellen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will run the TI ExecuteCommand function and\
    \ print the output to Server Logs.\n\n# Use case: Intended for production.\n# 1/ To run\
    \ an ExecuteCommand function from any part of the model, including RushTI or third party\
    \ system without direct access to TI Editor.\n# 2/ To remove the requirement of creating\
    \ a one off process to use this function\n# 3/ To compress/uncompress files\n# 4/ To copy\
    \ files and folders from the TM1 server\n# 5/ To delete files and folders from the TM1 server\n\
    # 6/ To list and kill tasks running in the TM1 server\n# 7/ To export and import registry\
    \ keys such as ODBC data sources\n\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName = GetProcessName();\ncUser = TM1User();\ncUserName = CellGetS('}ElementAttributes_}Clients',\
    \ cUser, '}TM1_DefaultDisplayValue');\ncUserName = IF( cUserName @<> '', cUserName, 'admin'\
    \ );\ncMsgErrorLevel = 'ERROR';\ncMsgErrorContent = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncCmdOutputDir = GetProcessErrorFileDirectory;\ncCmdOutputFile =\
    \ cCmdOutputDir | GetProcessName() | '.txt';\n\n## LogOutput parameters\nIf( pLogOutput\
    \ = 1 );\n  sLogInfo = Expand('Process '%cThisProcName%' run with parameters: pCommand:\
    \ '%pCommand%', pWait: %pWait%, pPowerShell: %pPowerShell%'); \n  LogOutput ( 'INFO', sLogInfo\
    \ );\n  nStart = Now();\nEndIf;\n\n### Validate Parameters ###\nnErrors = 0;\nIf ( pCommand\
    \ @= '' );\n  sMessage = 'parameter pCommand is blank';\n  LogOutput ( 'ERROR', sMessage\
    \ );\n  ProcessQuit;\nEndIf;\n\n### ExecuteCommand ###\n\n# Check if the pCommand parameter\
    \ is enclosed in quotes and remove it if it is\nIf( Subst(pCommand, 1, 1) @= ''' );\n  sCommand\
    \ = Delet(pCommand, 1, 1);\n  sCommand = Delet(sCommand, Long(sCommand), 1);\nElse;\n  sCommand\
    \ = pCommand;\nEndIf;\n\nIf( pPowerShell = 1 );\n  #Prepare the full command for Powershell\n\
    \  sCommand = 'POWERSHELL.EXE -Command '& {' | pCommand | '}' 1> ' | cCmdOutputFile | '\
    \ 2>&1';\nElse;\n  #Prepare the full command for Windows CMD\n  sCommand = 'CMD.EXE /C ''\
    \ | sCommand | '' 1> ' | cCmdOutputFile | ' 2>&1';\nEndIf;\n\n#Execute the command in the\
    \ TM1 server\nExecuteCommand ( sCommand, pWait );\n\n#If pLogOutput is true then define\
    \ the command output file as data source\nIf( pLogOutput = 1 );\n  DataSourceType = 'CHARACTERDELIMITED';\n\
    \  DatasourceNameForServer = cCmdOutputFile;\nEndIf;\n#Section Metadaten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n# Write the command output to Server\
    \ Logs\nsLogInfo = Expand('Process '%cThisProcName%': %vCommandOutput%');\nLogOutput( 'INFO',\
    \ sLogInfo);\n#Section Epilog\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### LogOutput ###\n\nIf( pLogOutput = 1 );\n    sSec     = NumberToStringEx(\
    \ 86400*(Now() - nStart),'#,##0.0', '.', ',' );\n    sLogInfo = Expand('Process '%cThisProcName%'\
    \ completed in %sSec% seconds.'); \n    LogOutput( 'INFO', sLogInfo );\nEndIf;\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process '%cThisProcName%' completed with errors. Check\
    \ tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process '%cThisProcName%' completed\
    \ successfully.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### Optional: Clean the command\
    \ output file\n#sCommand = 'CMD.EXE /C 'TYPE NUL > '' | cCmdOutputFile | '' '';\n#ExecuteCommand(\
    \ sCommand, 0 );\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that executes the ExecuteCommand function
    and prints the output to the Server Logs. This process is intended for production use and
    offers the following use cases: 1) Execute the ExecuteCommand function from any part of
    the model, including RushTI or a third-party system, without direct access to the TI Editor.
    2) Eliminate the need to create a one-off process to use this function. 3) Compress or decompress
    files. 4) Copy files and folders from the TM1 server. 5) Delete files and folders from the
    TM1 server. 6) List and kill tasks running on the TM1 server. 7) Export and import registry
    keys such as ODBC data sources.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will run the TI ExecuteCommand function and\
    \ print the output to Server Logs.\n\n# Use case: Intended for production.\n# 1/ To run\
    \ an ExecuteCommand function from any part of the model, including RushTI or third party\
    \ system without direct access to TI Editor.\n# 2/ To remove the requirement of creating\
    \ a one off process to use this function\n# 3/ To compress/uncompress files\n# 4/ To copy\
    \ files and folders from the TM1 server\n# 5/ To delete files and folders from the TM1 server\n\
    # 6/ To list and kill tasks running in the TM1 server\n# 7/ To export and import registry\
    \ keys such as ODBC data sources\n\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName = GetProcessName();\ncUser = TM1User();\ncUserName = CellGetS('}ElementAttributes_}Clients',\
    \ cUser, '}TM1_DefaultDisplayValue');\ncUserName = IF( cUserName @<> '', cUserName, 'admin'\
    \ );\ncMsgErrorLevel = 'ERROR';\ncMsgErrorContent = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncCmdOutputDir = GetProcessErrorFileDirectory;\ncCmdOutputFile =\
    \ cCmdOutputDir | GetProcessName() | '.txt';\n\n## LogOutput parameters\nIf( pLogOutput\
    \ = 1 );\n  sLogInfo = Expand('Process '%cThisProcName%' run with parameters: pCommand:\
    \ '%pCommand%', pWait: %pWait%, pPowerShell: %pPowerShell%'); \n  LogOutput ( 'INFO', sLogInfo\
    \ );\n  nStart = Now();\nEndIf;\n\n### Validate Parameters ###\nnErrors = 0;\nIf ( pCommand\
    \ @= '' );\n  sMessage = 'parameter pCommand is blank';\n  LogOutput ( 'ERROR', sMessage\
    \ );\n  ProcessQuit;\nEndIf;\n\n### ExecuteCommand ###\n\n# Check if the pCommand parameter\
    \ is enclosed in quotes and remove it if it is\nIf( Subst(pCommand, 1, 1) @= ''' );\n  sCommand\
    \ = Delet(pCommand, 1, 1);\n  sCommand = Delet(sCommand, Long(sCommand), 1);\nElse;\n  sCommand\
    \ = pCommand;\nEndIf;\n\nIf( pPowerShell = 1 );\n  #Prepare the full command for Powershell\n\
    \  sCommand = 'POWERSHELL.EXE -Command '& {' | pCommand | '}' 1> ' | cCmdOutputFile | '\
    \ 2>&1';\nElse;\n  #Prepare the full command for Windows CMD\n  sCommand = 'CMD.EXE /C ''\
    \ | sCommand | '' 1> ' | cCmdOutputFile | ' 2>&1';\nEndIf;\n\n#Execute the command in the\
    \ TM1 server\nExecuteCommand ( sCommand, pWait );\n\n#If pLogOutput is true then define\
    \ the command output file as data source\nIf( pLogOutput = 1 );\n  DataSourceType = 'CHARACTERDELIMITED';\n\
    \  DatasourceNameForServer = cCmdOutputFile;\nEndIf;\n#Section Metadaten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n# Write the command output to Server\
    \ Logs\nsLogInfo = Expand('Process '%cThisProcName%': %vCommandOutput%');\nLogOutput( 'INFO',\
    \ sLogInfo);\n#Section Epilog\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### LogOutput ###\n\nIf( pLogOutput = 1 );\n    sSec     = NumberToStringEx(\
    \ 86400*(Now() - nStart),'#,##0.0', '.', ',' );\n    sLogInfo = Expand('Process '%cThisProcName%'\
    \ completed in %sSec% seconds.'); \n    LogOutput( 'INFO', sLogInfo );\nEndIf;\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process '%cThisProcName%' completed with errors. Check\
    \ tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process '%cThisProcName%' completed\
    \ successfully.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### Optional: Clean the command\
    \ output file\n#sCommand = 'CMD.EXE /C 'TYPE NUL > '' | cCmdOutputFile | '' '';\n#ExecuteCommand(\
    \ sCommand, 0 );\n\n### End Epilog ###"
- question: Erstelle einen IBM Turbo Integrator Prozess, der die Lokalisierung von Würfel- und
    Dimensionsnamen übernimmt. Zusätzlich soll der Prozess optional die Attribute für angegebene
    Dimensionen, sowie Teilmengen für angegebene Dimensionen und Ansichten für angegebene Würfel
    lokalisieren. Beachte, dass wenn keine Dimensionen- oder Würfelnamen spezifiziert sind,
    nur die Standardlokalisierung von Würfel- und Dimensionsnamen durchgeführt wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process localizes cube & dimension names & optionally\
    \ localizes:\n# * attributes for specified dimension(s)\n# * subsets for specified dimension(s)\n\
    # * views for specified cube(s)\n\n# Note:\n# If no dimension or cube names are passed,\
    \ then just cube & dimension names will be localized.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\nIf( Trim( pDelim ) @= '' );\n    pDelim = '&';\nEndIf;\n\nIf( pSub\
    \ <> 1 );\n    pSub = 0;\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\nIF( CubeExists( '}CubeAttributes' ) = 0 );\n    CubeAttrInsert( '',\
    \ 'Caption', 'S');\nELSEIF( DimIx( '}CubeAttributes', 'Caption' ) = 0 );\n    CubeAttrInsert(\
    \ '', 'Caption', 'S');\nENDIF;\nIF( CubeExists( '}DimensionAttributes' ) = 0 );\n    DimensionAttrInsert(\
    \ '', 'Caption', 'S');\nELSEIF( DimIx( '}DimensionAttributes', 'Caption' ) = 0 );\n    DimensionAttrInsert(\
    \ '', 'Caption', 'S');\nENDIF;\n\nIF( CubeExists( '}LocalizedCubeAttributes' ) = 0 );\n\
    \    CubeAttrPutS( '', '}CubeAttributes', 'Caption', 'en');\nENDIF;\nIF( CubeExists( '}LocalizedDimensionAttributes'\
    \ ) = 0 );\n    DimensionAttrPutS( '', '}Cultures', 'Caption', 'en');\nENDIF;\n\n### Localization\
    \ of attributes (& subsets) for any dimension passed\n# Loop through dimensions in pDim\
    \ \nsDims               = Trim( pDim );\nnDimDelimiterIndex  = 1;\n# Get 1st dimension\n\
    While( pDim @<> '' & nDimDelimiterIndex > 0 );\n    # Extract 1st dimension > sDim\n   \
    \ nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex = 0 );\n     \
    \   sDim        = sDims;\n    Else;\n        sDim        = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n        sDims       = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim),\
    \ Long( sDims ) ) );\n    EndIf;\n    \n    # Check if sDim has wildcard\n    If( Scan(\
    \ '*', sDim ) = 0);\n        If( DimensionExists(sDim) = 0 );\n            nErrors = 1;\n\
    \            sMessage = Expand( 'Dimension '%sDim%' does not exist.' );\n            LogOutput(\
    \ 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            sAttrDim = '}ElementAttributes_'\
    \ | sDim;\n            sLocAttrDim = '}LocalizedElementAttributes_' | sDim; \n         \
    \   sSubDim = '}Subsets_' | sDim;\n            sSubAttr = '}SubsetAttributes_' | sDim;\n\
    \            sLocSubAttr = '}LocalizedSubsetAttributes_' | sDim;\n            IF( CubeExists(\
    \ sAttrDim ) = 0 );\n                AttrInsert( sDim, '', 'Caption', 'S' );\n         \
    \   ELSEIF( DimIx( sAttrDim, 'Caption' ) = 0 );\n                AttrInsert( sDim, '', 'Caption',\
    \ 'S' );\n            ENDIF;\n            IF( CubeExists( sLocAttrDim ) = 0 );\n       \
    \         sFirstEle = '';\n                sFirstEle = DimNm( sDim, 1 );\n             \
    \   IF( sFirstEle @<> '' );\n                    AttrPutS( '', sDim, sFirstEle, 'Caption',\
    \ 'en' );\n                ENDIF;\n            ENDIF;\n            If( pSub = 1 & DimSiz(\
    \ sSubDim ) > 0 );\n                If( CubeExists( sSubAttr ) = 0 );\n                \
    \    SubsetAttrInsert( sDim, '', 'Caption', 'S' );\n                EndIf;\n           \
    \     If( CubeExists( sLocSubAttr ) = 0 );\n                    sSub = DimNm( sSubDim, 1\
    \ );\n                    If( Scan( ':', sSub ) > 0 );\n                        sDim = sDim\
    \ |':'| SubSt( sSub, 1, Scan( ':', sSub ) - 1 );\n                        sSub = SubSt(\
    \ sSub, Scan( ':', sSub ) + 1, Long( sSub ) );\n                    EndIf;\n           \
    \         SubsetAttrPutS( '', sDim, sSub, 'Caption', 'en' );\n                EndIf;\n \
    \           EndIf;\n        Endif;\n    Else;\n        # Create subset of dimensions using\
    \ Wildcard to loop through dimensions in pDim with wildcard\n        sMdx = Expand('{TM1FILTERBYPATTERN(\
    \ EXCEPT ( EXCEPT ( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) , '*:*') ), TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '}ElementAttributes_*')\
    \ ) , '%sDim%' )}');\n        If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n    \
    \        # If a delimited list of dim names includes wildcards then we may have to re-use\
    \ the subset multiple times\n            SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n\
    \        Else;\n            # temp subset, therefore no need to destroy in epilog\n    \
    \        SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\n        EndIf;\n     \
    \   \n        # Loop through dimensions in subset created based on wildcard\n        nCountDim\
    \ = SubsetGetSize( '}Dimensions' , cTempSub );\n        While( nCountDim >= 1 );\n     \
    \       sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim );\n          \
    \  If( DimensionExists(sDim) = 0 );\n                nErrors = 1;\n                sMessage\
    \ = Expand( 'Dimension %sDim% does not exist.' );\n                LogOutput( 'ERROR', Expand(\
    \ cMsgErrorContent ) );\n            Else;\n                sAttrDim = '}ElementAttributes_'\
    \ | sDim;\n                sLocAttrDim = '}LocalizedElementAttributes_' | sDim; \n     \
    \           sSubDim = '}Subsets_' | sDim;\n                sSubAttr = '}SubsetAttributes_'\
    \ | sDim;\n                sLocSubAttr = '}LocalizedSubsetAttributes_' | sDim;\n       \
    \         IF( CubeExists( sAttrDim ) = 0 );\n                    AttrInsert( sDim, '', 'Caption',\
    \ 'S' );\n                ELSEIF( DimIx( sAttrDim, 'Caption' ) = 0 );\n                \
    \    AttrInsert( sDim, '', 'Caption', 'S' );\n                ENDIF;\n                IF(\
    \ CubeExists( sLocAttrDim ) = 0 );\n                    sFirstEle = '';\n              \
    \      sFirstEle = DimNm( sDim, 1 );\n                    IF( sFirstEle @<> '' );\n    \
    \                    AttrPutS( '', sDim, sFirstEle, 'Caption', 'en' );\n               \
    \     ENDIF;\n                ENDIF;\n                If( pSub = 1 );\n                \
    \    If( CubeExists( sSubAttr ) = 0 );\n                        SubsetAttrInsert( sDim,\
    \ '', 'Caption', 'S' );\n                    EndIf;\n                    If( CubeExists(\
    \ sLocSubAttr ) = 0 & DimSiz( sSubDim ) > 0 );\n                        sSub = DimNm( sSubDim,\
    \ 1 );\n                        If( Scan( ':', sSub ) > 0 );\n                         \
    \   sDim = sDim |':'| SubSt( sSub, 1, Scan( ':', sSub ) - 1 );\n                       \
    \     sSub = SubSt( sSub, Scan( ':', sSub ) + 1, Long( sSub ) );\n                     \
    \   EndIf;\n                        SubsetAttrPutS( '', sDim, sSub, 'Caption', 'en' );\n\
    \                    EndIf;\n                EndIf;\n            Endif;\n            nCountDim\
    \ = nCountDim - 1;\n        End;\n    EndIf;\nEnd;\n\n### Localization of views for any\
    \ cube passed\n# Loop through cubes in pCube \nsCubes              = Trim( pCube );\nnCubDelimiterIndex\
    \  = 1;\n# Get 1st Cube\nWhile( pCube @<> '' & nCubDelimiterIndex > 0 );\n    # Extract\
    \ 1st cube > sCube\n    nCubDelimiterIndex = Scan( pDelim, sCubes );\n    If( nCubDelimiterIndex\
    \ = 0 );\n        sCube       = sCubes;\n    Else;\n        sCube       = Trim( SubSt( sCubes,\
    \ 1, nCubDelimiterIndex - 1 ) );\n        sCubes      = Trim( Subst( sCubes, nCubDelimiterIndex\
    \ + Long(pDelim), Long( sCubes ) ) );\n    EndIf;\n    \n    # Check if sCube has wildcard\n\
    \    If( Scan( '*', sCube ) = 0);\n        If( CubeExists(sCube) = 0 );\n            nErrors\
    \ = 1;\n            sMessage = Expand( 'Cube '%sCube%' does not exist.' );\n           \
    \ LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            sViewDim\
    \ = '}Views_' | sCube;\n            sViewAttr = '}ViewAttributes_' | sCube;\n          \
    \  sLocViewAttr = '}LocalizedViewAttributes_' | sCube;\n            IF( CubeExists( sViewAttr\
    \ ) = 0 & DimensionExists( sViewDim ) = 1 );\n                ViewAttrInsert( sCube, '',\
    \ 'Caption', 'S' );\n            ENDIF;\n            IF( CubeExists( sLocViewAttr ) = 0\
    \ & DimSiz( sViewDim ) >= 1 );\n                ViewAttrPutS( '', sCube, DimNm( sViewDim,\
    \ 1 ), 'Caption', 'en' );\n            ENDIF;\n        Endif;\n    Else;\n        # Create\
    \ subset of cubes using Wildcard to loop through cubes in pCube with wildcard\n        sMdx\
    \ = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ),  '%sCube%' )}');\n        If(\
    \ SubsetExists( '}Cubes' , cTempSub ) = 1 );\n            # If a delimited list of Cub names\
    \ includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ '}Cubes' , cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need\
    \ to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n\
    \        EndIf;\n        \n        # Loop through cubes in subset created based on wildcard\n\
    \        nCountCub = SubsetGetSize( '}Cubes' , cTempSub );\n        While( nCountCub >=\
    \ 1 );\n            sCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCub );\n  \
    \          If( CubeExists(sCube) = 0 );\n                nErrors = 1;\n                sMessage\
    \ = Expand( 'Cube %sCube% does not exist.' );\n                LogOutput( 'ERROR', Expand(\
    \ cMsgErrorContent ) );\n            Else;\n                sViewDim = '}Views_' | sCube;\n\
    \                sViewAttr = '}ViewAttributes_' | sCube;\n                sLocViewAttr =\
    \ '}LocalizedViewAttributes_' | sCube;\n                IF( CubeExists( sViewAttr ) = 0\
    \ & DimensionExists( sViewDim ) = 1 );\n                    ViewAttrInsert( sCube, '', 'Caption',\
    \ 'S' );\n                ENDIF;\n                IF( CubeExists( sLocViewAttr ) = 0 & DimSiz(\
    \ sViewDim ) >= 1 );\n                    ViewAttrPutS( '', sCube, DimNm( sViewDim, 1 ),\
    \ 'Caption', 'en' );\n                ENDIF;\n            Endif;\n            nCountCub\
    \ = nCountCub - 1;\n        End;\n    EndIf;\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% localized cube & dimension\
    \ names & localized attributes for dimensions %pDim%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###"
- question: Create an IBM Turbo Integrator process that handles the localization of cube and
    dimension names. Additionally, the process should optionally localize attributes for specified
    dimensions, subsets for specified dimensions, and views for specified cubes. Note that if
    no dimension or cube names are specified, only the standard localization of cube and dimension
    names will be performed.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process localizes cube & dimension names & optionally\
    \ localizes:\n# * attributes for specified dimension(s)\n# * subsets for specified dimension(s)\n\
    # * views for specified cube(s)\n\n# Note:\n# If no dimension or cube names are passed,\
    \ then just cube & dimension names will be localized.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\nIf( Trim( pDelim ) @= '' );\n    pDelim = '&';\nEndIf;\n\nIf( pSub\
    \ <> 1 );\n    pSub = 0;\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\nIF( CubeExists( '}CubeAttributes' ) = 0 );\n    CubeAttrInsert( '',\
    \ 'Caption', 'S');\nELSEIF( DimIx( '}CubeAttributes', 'Caption' ) = 0 );\n    CubeAttrInsert(\
    \ '', 'Caption', 'S');\nENDIF;\nIF( CubeExists( '}DimensionAttributes' ) = 0 );\n    DimensionAttrInsert(\
    \ '', 'Caption', 'S');\nELSEIF( DimIx( '}DimensionAttributes', 'Caption' ) = 0 );\n    DimensionAttrInsert(\
    \ '', 'Caption', 'S');\nENDIF;\n\nIF( CubeExists( '}LocalizedCubeAttributes' ) = 0 );\n\
    \    CubeAttrPutS( '', '}CubeAttributes', 'Caption', 'en');\nENDIF;\nIF( CubeExists( '}LocalizedDimensionAttributes'\
    \ ) = 0 );\n    DimensionAttrPutS( '', '}Cultures', 'Caption', 'en');\nENDIF;\n\n### Localization\
    \ of attributes (& subsets) for any dimension passed\n# Loop through dimensions in pDim\
    \ \nsDims               = Trim( pDim );\nnDimDelimiterIndex  = 1;\n# Get 1st dimension\n\
    While( pDim @<> '' & nDimDelimiterIndex > 0 );\n    # Extract 1st dimension > sDim\n   \
    \ nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex = 0 );\n     \
    \   sDim        = sDims;\n    Else;\n        sDim        = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n        sDims       = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim),\
    \ Long( sDims ) ) );\n    EndIf;\n    \n    # Check if sDim has wildcard\n    If( Scan(\
    \ '*', sDim ) = 0);\n        If( DimensionExists(sDim) = 0 );\n            nErrors = 1;\n\
    \            sMessage = Expand( 'Dimension '%sDim%' does not exist.' );\n            LogOutput(\
    \ 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            sAttrDim = '}ElementAttributes_'\
    \ | sDim;\n            sLocAttrDim = '}LocalizedElementAttributes_' | sDim; \n         \
    \   sSubDim = '}Subsets_' | sDim;\n            sSubAttr = '}SubsetAttributes_' | sDim;\n\
    \            sLocSubAttr = '}LocalizedSubsetAttributes_' | sDim;\n            IF( CubeExists(\
    \ sAttrDim ) = 0 );\n                AttrInsert( sDim, '', 'Caption', 'S' );\n         \
    \   ELSEIF( DimIx( sAttrDim, 'Caption' ) = 0 );\n                AttrInsert( sDim, '', 'Caption',\
    \ 'S' );\n            ENDIF;\n            IF( CubeExists( sLocAttrDim ) = 0 );\n       \
    \         sFirstEle = '';\n                sFirstEle = DimNm( sDim, 1 );\n             \
    \   IF( sFirstEle @<> '' );\n                    AttrPutS( '', sDim, sFirstEle, 'Caption',\
    \ 'en' );\n                ENDIF;\n            ENDIF;\n            If( pSub = 1 & DimSiz(\
    \ sSubDim ) > 0 );\n                If( CubeExists( sSubAttr ) = 0 );\n                \
    \    SubsetAttrInsert( sDim, '', 'Caption', 'S' );\n                EndIf;\n           \
    \     If( CubeExists( sLocSubAttr ) = 0 );\n                    sSub = DimNm( sSubDim, 1\
    \ );\n                    If( Scan( ':', sSub ) > 0 );\n                        sDim = sDim\
    \ |':'| SubSt( sSub, 1, Scan( ':', sSub ) - 1 );\n                        sSub = SubSt(\
    \ sSub, Scan( ':', sSub ) + 1, Long( sSub ) );\n                    EndIf;\n           \
    \         SubsetAttrPutS( '', sDim, sSub, 'Caption', 'en' );\n                EndIf;\n \
    \           EndIf;\n        Endif;\n    Else;\n        # Create subset of dimensions using\
    \ Wildcard to loop through dimensions in pDim with wildcard\n        sMdx = Expand('{TM1FILTERBYPATTERN(\
    \ EXCEPT ( EXCEPT ( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) , '*:*') ), TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '}ElementAttributes_*')\
    \ ) , '%sDim%' )}');\n        If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n    \
    \        # If a delimited list of dim names includes wildcards then we may have to re-use\
    \ the subset multiple times\n            SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n\
    \        Else;\n            # temp subset, therefore no need to destroy in epilog\n    \
    \        SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\n        EndIf;\n     \
    \   \n        # Loop through dimensions in subset created based on wildcard\n        nCountDim\
    \ = SubsetGetSize( '}Dimensions' , cTempSub );\n        While( nCountDim >= 1 );\n     \
    \       sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim );\n          \
    \  If( DimensionExists(sDim) = 0 );\n                nErrors = 1;\n                sMessage\
    \ = Expand( 'Dimension %sDim% does not exist.' );\n                LogOutput( 'ERROR', Expand(\
    \ cMsgErrorContent ) );\n            Else;\n                sAttrDim = '}ElementAttributes_'\
    \ | sDim;\n                sLocAttrDim = '}LocalizedElementAttributes_' | sDim; \n     \
    \           sSubDim = '}Subsets_' | sDim;\n                sSubAttr = '}SubsetAttributes_'\
    \ | sDim;\n                sLocSubAttr = '}LocalizedSubsetAttributes_' | sDim;\n       \
    \         IF( CubeExists( sAttrDim ) = 0 );\n                    AttrInsert( sDim, '', 'Caption',\
    \ 'S' );\n                ELSEIF( DimIx( sAttrDim, 'Caption' ) = 0 );\n                \
    \    AttrInsert( sDim, '', 'Caption', 'S' );\n                ENDIF;\n                IF(\
    \ CubeExists( sLocAttrDim ) = 0 );\n                    sFirstEle = '';\n              \
    \      sFirstEle = DimNm( sDim, 1 );\n                    IF( sFirstEle @<> '' );\n    \
    \                    AttrPutS( '', sDim, sFirstEle, 'Caption', 'en' );\n               \
    \     ENDIF;\n                ENDIF;\n                If( pSub = 1 );\n                \
    \    If( CubeExists( sSubAttr ) = 0 );\n                        SubsetAttrInsert( sDim,\
    \ '', 'Caption', 'S' );\n                    EndIf;\n                    If( CubeExists(\
    \ sLocSubAttr ) = 0 & DimSiz( sSubDim ) > 0 );\n                        sSub = DimNm( sSubDim,\
    \ 1 );\n                        If( Scan( ':', sSub ) > 0 );\n                         \
    \   sDim = sDim |':'| SubSt( sSub, 1, Scan( ':', sSub ) - 1 );\n                       \
    \     sSub = SubSt( sSub, Scan( ':', sSub ) + 1, Long( sSub ) );\n                     \
    \   EndIf;\n                        SubsetAttrPutS( '', sDim, sSub, 'Caption', 'en' );\n\
    \                    EndIf;\n                EndIf;\n            Endif;\n            nCountDim\
    \ = nCountDim - 1;\n        End;\n    EndIf;\nEnd;\n\n### Localization of views for any\
    \ cube passed\n# Loop through cubes in pCube \nsCubes              = Trim( pCube );\nnCubDelimiterIndex\
    \  = 1;\n# Get 1st Cube\nWhile( pCube @<> '' & nCubDelimiterIndex > 0 );\n    # Extract\
    \ 1st cube > sCube\n    nCubDelimiterIndex = Scan( pDelim, sCubes );\n    If( nCubDelimiterIndex\
    \ = 0 );\n        sCube       = sCubes;\n    Else;\n        sCube       = Trim( SubSt( sCubes,\
    \ 1, nCubDelimiterIndex - 1 ) );\n        sCubes      = Trim( Subst( sCubes, nCubDelimiterIndex\
    \ + Long(pDelim), Long( sCubes ) ) );\n    EndIf;\n    \n    # Check if sCube has wildcard\n\
    \    If( Scan( '*', sCube ) = 0);\n        If( CubeExists(sCube) = 0 );\n            nErrors\
    \ = 1;\n            sMessage = Expand( 'Cube '%sCube%' does not exist.' );\n           \
    \ LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            sViewDim\
    \ = '}Views_' | sCube;\n            sViewAttr = '}ViewAttributes_' | sCube;\n          \
    \  sLocViewAttr = '}LocalizedViewAttributes_' | sCube;\n            IF( CubeExists( sViewAttr\
    \ ) = 0 & DimensionExists( sViewDim ) = 1 );\n                ViewAttrInsert( sCube, '',\
    \ 'Caption', 'S' );\n            ENDIF;\n            IF( CubeExists( sLocViewAttr ) = 0\
    \ & DimSiz( sViewDim ) >= 1 );\n                ViewAttrPutS( '', sCube, DimNm( sViewDim,\
    \ 1 ), 'Caption', 'en' );\n            ENDIF;\n        Endif;\n    Else;\n        # Create\
    \ subset of cubes using Wildcard to loop through cubes in pCube with wildcard\n        sMdx\
    \ = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ),  '%sCube%' )}');\n        If(\
    \ SubsetExists( '}Cubes' , cTempSub ) = 1 );\n            # If a delimited list of Cub names\
    \ includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ '}Cubes' , cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need\
    \ to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n\
    \        EndIf;\n        \n        # Loop through cubes in subset created based on wildcard\n\
    \        nCountCub = SubsetGetSize( '}Cubes' , cTempSub );\n        While( nCountCub >=\
    \ 1 );\n            sCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCub );\n  \
    \          If( CubeExists(sCube) = 0 );\n                nErrors = 1;\n                sMessage\
    \ = Expand( 'Cube %sCube% does not exist.' );\n                LogOutput( 'ERROR', Expand(\
    \ cMsgErrorContent ) );\n            Else;\n                sViewDim = '}Views_' | sCube;\n\
    \                sViewAttr = '}ViewAttributes_' | sCube;\n                sLocViewAttr =\
    \ '}LocalizedViewAttributes_' | sCube;\n                IF( CubeExists( sViewAttr ) = 0\
    \ & DimensionExists( sViewDim ) = 1 );\n                    ViewAttrInsert( sCube, '', 'Caption',\
    \ 'S' );\n                ENDIF;\n                IF( CubeExists( sLocViewAttr ) = 0 & DimSiz(\
    \ sViewDim ) >= 1 );\n                    ViewAttrPutS( '', sCube, DimNm( sViewDim, 1 ),\
    \ 'Caption', 'en' );\n                ENDIF;\n            Endif;\n            nCountCub\
    \ = nCountCub - 1;\n        End;\n    EndIf;\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% localized cube & dimension\
    \ names & localized attributes for dimensions %pDim%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\
    \n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der Logdateien, CSV-Dateien und Debug-Dateien
    löscht, die 'x' Tage alt sind. Dieser Prozess ist für den produktiven Einsatz gedacht und
    dient dazu, alte Dateien zu bereinigen, um Speicherplatz auf der Festplatte zu sparen. Beachten
    Sie, dass das Zielverzeichnis (pTgtDir) auf den Standardwert in der TM1-Konfigurationsdatei
    zurückgesetzt wird, wenn es leer gelassen wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will deletes the log files, csv file, debug\
    \ files which are 'x' days old.\n\n# Use case: Intended for production.\n# 1/ Process cleans\
    \ up old files to save space on hard disk.\n\n# Note:\n# The target directory (pTgtDir)\
    \ will default to setting in TM1 configuration file if left blank.\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pTgtDir:%pTgtDir%, pLogDays:%pLogDays%, pErrorDays:%pErrorDays%, pBedrockDays:%pBedrockDays%,\
    \ pCSVDays:%pCSVDays%.' ;  \n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIF( pTgtDir @=\
    \ '');\n    pTgtDir = GetProcessErrorFileDirectory;\nELSE;\n    ## Remove leading and/or\
    \ trailing spaces\n    pTgtDir = Trim( pTgtDir );\nENDIF;\n\n## Remove trailing \\ from\
    \ directory names if present\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n\
    \    pTgtDir = SubSt( pTgtDir, 1, Long( pTgtDir ) - 1 );\nEndIf;\n\n# Check that target\
    \ Logging Directory exists\nIf( FileExists( pTgtDir ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Logging directory does not exist: ' | pTgtDir;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\nsLogDays        = NumberToString( ROUND( pLogDays ) );\nsErrorDays\
    \      = NumberToString( ROUND( pErrorDays ) );\nsBedrockDays    = NumberToString( ROUND(\
    \ pBedrockDays ) );\nsCSVDays        = NumberToString( ROUND( pCSVDays ) );\n\n### Create\
    \ Execute File File ###\nDatasourceASCIIQuoteCharacter='';\n\nIf( sOS @= 'Windows');\n \
    \ sFileName = GetProcessName() | '.bat';\n  If( SubSt(pTgtDir, 1, 2) @<> '\\' );\n    #\
    \ local or mapped drive, use forfiles to delete files matching pattern and expiry days\n\
    \    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%' -s -m tm1s*.log -d -%sLogDays%\
    \ -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%'\
    \ -s -m tm1auditstore*.log -d -%sLogDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('forfiles -p '%pTgtDir%' -s -m TM1ProcessError*.log -d -%sErrorDays% -c 'cmd /c\
    \ del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%' -s -m Bedrock*.*\
    \ -d -%sBedrockDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles\
    \ -p '%pTgtDir%' -s -m *.csv -d -%sCSVDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('forfiles -p '%pTgtDir%' -s -m *.cma -d -%sCSVDays% -c 'cmd /c del @path''));\n\
    \    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%' -s -m *.txt -d -%sCSVDays% -c\
    \ 'cmd /c del @path''));\n  Else;\n    # UNC shared folder path (forfiles command doesn't\
    \ work with UNC use robocopy instead, create temp dir, move files to temp dir, then delete\
    \ folder and contents)\n    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\b\
    edrocklogclear' 'tm1s*.log' /mov /purge /MINAGE:%sLogDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear' 'tm1auditstore*.log' /mov /purge\
    \ /MINAGE:%sLogDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%'\
    \ '%pTgtDir%\bedrocklogclear' 'Bedrock*.*' /mov /purge /MINAGE:%sErrorDays% /copyall /s'));\n\
    \    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear' 'TM1ProcessError*.log'\
    \ /mov /purge /MINAGE:%sBedrockDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy\
    \ '%pTgtDir%' '%pTgtDir%\bedrocklogclear' '*.csv' /mov /purge /MINAGE:%sCSVDays% /copyall\
    \ /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear'\
    \ '*.cma' /mov /purge /MINAGE:%sCSVDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy\
    \ '%pTgtDir%' '%pTgtDir%\bedrocklogclear' '*.txt' /mov /purge /MINAGE:%sCSVDays% /copyall\
    \ /s'));\n    ASCIIOUTPUT(sFileName, Expand('rmdir /s /q '%pTgtDir%\bedrocklogclear''));\n\
    \  EndIf;\nElse;\n  sFileName = GetProcessName() | '.sh';\n  ASCIIOUTPUT(sFileName, Expand('find\
    \ '%pTgtDir%' -type f -mtime +%sLogDays% -name 'tm1s*.log' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName,\
    \ Expand('find '%pTgtDir%' -type f -mtime +%sLogDays% -name 'tm1auditstore*.log' -exec rm\
    \ {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f -mtime +%sErrorDays%\
    \ -name 'TM1ProcessError*.log' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find\
    \ '%pTgtDir%' -type f -mtime +%sBedrockDays% -name 'bedrock*.*' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName,\
    \ Expand('find '%pTgtDir%' -type f -mtime +%sCSVDays% -name '*.csv' -exec rm {}\\;'));\n\
    \  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f -mtime +%sCSVDays% -name '*.cma'\
    \ -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f -mtime +%sCSVDays%\
    \ -name '*.txt' -exec rm {}\\;'));\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Copy Data\
    \ Dir to Backup ###\nsCommand = sFileName;\n\nIf(sOS @= 'Windows');\n  ExecuteCommand( sCommand,\
    \ 1 );\nElse;\n  ExecuteCommand( 'sh ' | sCommand, 1 );\nEndIf;\nASCIIDelete( sFileName);\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted log files from %pTgtDir% older then  %pLogDays%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that deletes log files, CSV files, and debug
    files which are 'x' days old. This process is intended for production use and serves to
    clean up old files to save space on the hard disk. Note that the target directory (pTgtDir)
    will default to the setting in the TM1 configuration file if left blank.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will deletes the log files, csv file, debug\
    \ files which are 'x' days old.\n\n# Use case: Intended for production.\n# 1/ Process cleans\
    \ up old files to save space on hard disk.\n\n# Note:\n# The target directory (pTgtDir)\
    \ will default to setting in TM1 configuration file if left blank.\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pTgtDir:%pTgtDir%, pLogDays:%pLogDays%, pErrorDays:%pErrorDays%, pBedrockDays:%pBedrockDays%,\
    \ pCSVDays:%pCSVDays%.' ;  \n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim =\
    \ '';\nEndIf;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIF( pTgtDir @=\
    \ '');\n    pTgtDir = GetProcessErrorFileDirectory;\nELSE;\n    ## Remove leading and/or\
    \ trailing spaces\n    pTgtDir = Trim( pTgtDir );\nENDIF;\n\n## Remove trailing \\ from\
    \ directory names if present\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n\
    \    pTgtDir = SubSt( pTgtDir, 1, Long( pTgtDir ) - 1 );\nEndIf;\n\n# Check that target\
    \ Logging Directory exists\nIf( FileExists( pTgtDir ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Logging directory does not exist: ' | pTgtDir;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\nsLogDays        = NumberToString( ROUND( pLogDays ) );\nsErrorDays\
    \      = NumberToString( ROUND( pErrorDays ) );\nsBedrockDays    = NumberToString( ROUND(\
    \ pBedrockDays ) );\nsCSVDays        = NumberToString( ROUND( pCSVDays ) );\n\n### Create\
    \ Execute File File ###\nDatasourceASCIIQuoteCharacter='';\n\nIf( sOS @= 'Windows');\n \
    \ sFileName = GetProcessName() | '.bat';\n  If( SubSt(pTgtDir, 1, 2) @<> '\\' );\n    #\
    \ local or mapped drive, use forfiles to delete files matching pattern and expiry days\n\
    \    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%' -s -m tm1s*.log -d -%sLogDays%\
    \ -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%'\
    \ -s -m tm1auditstore*.log -d -%sLogDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('forfiles -p '%pTgtDir%' -s -m TM1ProcessError*.log -d -%sErrorDays% -c 'cmd /c\
    \ del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%' -s -m Bedrock*.*\
    \ -d -%sBedrockDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles\
    \ -p '%pTgtDir%' -s -m *.csv -d -%sCSVDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('forfiles -p '%pTgtDir%' -s -m *.cma -d -%sCSVDays% -c 'cmd /c del @path''));\n\
    \    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%' -s -m *.txt -d -%sCSVDays% -c\
    \ 'cmd /c del @path''));\n  Else;\n    # UNC shared folder path (forfiles command doesn't\
    \ work with UNC use robocopy instead, create temp dir, move files to temp dir, then delete\
    \ folder and contents)\n    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\b\
    edrocklogclear' 'tm1s*.log' /mov /purge /MINAGE:%sLogDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear' 'tm1auditstore*.log' /mov /purge\
    \ /MINAGE:%sLogDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%'\
    \ '%pTgtDir%\bedrocklogclear' 'Bedrock*.*' /mov /purge /MINAGE:%sErrorDays% /copyall /s'));\n\
    \    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear' 'TM1ProcessError*.log'\
    \ /mov /purge /MINAGE:%sBedrockDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy\
    \ '%pTgtDir%' '%pTgtDir%\bedrocklogclear' '*.csv' /mov /purge /MINAGE:%sCSVDays% /copyall\
    \ /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear'\
    \ '*.cma' /mov /purge /MINAGE:%sCSVDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy\
    \ '%pTgtDir%' '%pTgtDir%\bedrocklogclear' '*.txt' /mov /purge /MINAGE:%sCSVDays% /copyall\
    \ /s'));\n    ASCIIOUTPUT(sFileName, Expand('rmdir /s /q '%pTgtDir%\bedrocklogclear''));\n\
    \  EndIf;\nElse;\n  sFileName = GetProcessName() | '.sh';\n  ASCIIOUTPUT(sFileName, Expand('find\
    \ '%pTgtDir%' -type f -mtime +%sLogDays% -name 'tm1s*.log' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName,\
    \ Expand('find '%pTgtDir%' -type f -mtime +%sLogDays% -name 'tm1auditstore*.log' -exec rm\
    \ {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f -mtime +%sErrorDays%\
    \ -name 'TM1ProcessError*.log' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find\
    \ '%pTgtDir%' -type f -mtime +%sBedrockDays% -name 'bedrock*.*' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName,\
    \ Expand('find '%pTgtDir%' -type f -mtime +%sCSVDays% -name '*.csv' -exec rm {}\\;'));\n\
    \  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f -mtime +%sCSVDays% -name '*.cma'\
    \ -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f -mtime +%sCSVDays%\
    \ -name '*.txt' -exec rm {}\\;'));\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Copy Data\
    \ Dir to Backup ###\nsCommand = sFileName;\n\nIf(sOS @= 'Windows');\n  ExecuteCommand( sCommand,\
    \ 1 );\nElse;\n  ExecuteCommand( 'sh ' | sCommand, 1 );\nEndIf;\nASCIIDelete( sFileName);\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed\
    \ with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted log files from %pTgtDir% older then  %pLogDays%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n  \
    \  If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n   \
    \ EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der alle Daten auf die Festplatte
    speichert. Dieser Prozess sollte im Produktionsumfeld eingesetzt werden. Er kann während
    des Planungszyklus mehrmals täglich ausgeführt werden. Beachte, dass je nach vergangener
    Zeit seit dem letzten Datenspeichern dieser Vorgang mehrere Sekunden oder sogar Minuten
    dauern kann. Deshalb sollte die Ausführung idealerweise in eine Mittagspause eingeplant
    werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Save All Data to disk.\n\n# Use case:\
    \ Intended for production.\n# 1/ This could be run mulitple times a day during the planning\
    \ cycle.\n\n# Note:\n# Depending on how long since the last data save this could take several\
    \ seconds if not minutes so schedule if over lunch break.\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\n\n## LogOutput parameters\n\n### Validate\
    \ Parameters ###\n\nnErrors = 0;\n\n### LogOutput ###\nIf( pLogOutput = 1 );\n    sLogInfo\
    \ = Expand('Process:%cThisProcName% commenced.'); \n    LogOutput( 'INFO', sLogInfo );\n\
    \    nStart   = Now();\nEndIf;\n\n### Save Data ###\n\nSaveDataAll;\n\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### LogOutput\
    \ ###\n\nIf( pLogOutput = 1 );\n    sSec     = NumberToStringEx( 86400*(Now() - nStart),'#,##0.0',\
    \ '.', ',' );\n    sLogInfo = Expand('Process:%cThisProcName% completed. Elapsed time %sSec%\
    \ seconds.'); \n    LogOutput( 'INFO', sLogInfo );\nEndIf;\n\n### Return code & final error\
    \ message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1\
    \ error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully saved all cube\
    \ data.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand(\
    \ sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that saves all data to disk. This process
    is intended for use in production environments and can be executed multiple times a day
    during the planning cycle. Note that depending on the time elapsed since the last data save,
    this process may take several seconds or even minutes, so it is advisable to schedule it
    during a lunch break.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Save All Data to disk.\n\n# Use case:\
    \ Intended for production.\n# 1/ This could be run mulitple times a day during the planning\
    \ cycle.\n\n# Note:\n# Depending on how long since the last data save this could take several\
    \ seconds if not minutes so schedule if over lunch break.\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\n\n## LogOutput parameters\n\n### Validate\
    \ Parameters ###\n\nnErrors = 0;\n\n### LogOutput ###\nIf( pLogOutput = 1 );\n    sLogInfo\
    \ = Expand('Process:%cThisProcName% commenced.'); \n    LogOutput( 'INFO', sLogInfo );\n\
    \    nStart   = Now();\nEndIf;\n\n### Save Data ###\n\nSaveDataAll;\n\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### LogOutput\
    \ ###\n\nIf( pLogOutput = 1 );\n    sSec     = NumberToStringEx( 86400*(Now() - nStart),'#,##0.0',\
    \ '.', ',' );\n    sLogInfo = Expand('Process:%cThisProcName% completed. Elapsed time %sSec%\
    \ seconds.'); \n    LogOutput( 'INFO', sLogInfo );\nEndIf;\n\n### Return code & final error\
    \ message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1\
    \ error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully saved all cube\
    \ data.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand(\
    \ sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der einen Eingabestring pInputString
    basierend auf den Regeln in pChanges validiert und Zeichen ändert oder eliminiert, um eine
    globale Variable sOutputString zu erstellen. Diese Variable kann im Quell-TI verwendet werden.
    Beachte: pInputString ist der Eingabestring, der basierend auf Dateisystembeschränkungen
    oder unerwünschten Anfangszeichen validiert werden muss. pUndesirableFileSystem sind Zeichen,
    die in Objekt- oder Elementnamen aufgrund von Dateisystembeschränkungen des Betriebssystems
    als unerwünscht gelten. pUndesirable1st sind Zeichen, die aufgrund von TM1-Beschränkungen
    als erste Zeichen in Objekt- oder Elementnamen unerwünscht sind. pChanges definiert die
    Regel, wie unerwünschte Zeichen geändert werden sollen. Sie kann aus mehreren, durch pDelim
    getrennten Definitionen bestehen. Jede Definition enthält ein unerwünschtes Zeichen und
    das gewünschte Zeichen, getrennt durch pSeperator. pReplaceIfNotFound ist eine allgemeine
    Ersatzregel für Zeichen, die in pUndesirableFileSystem oder pUndesirable1st aufgeführt sind
    und keine Regel in pChanges haben. pDelim ist ein Zeichen, das verwendet wird, um Definitionen
    in pChanges zu trennen. pSeperator trennt das aktuelle von dem gewünschten Zeichen innerhalb
    jeder Definition in pChanges. pMode kann verwendet werden, um zu bestimmen, ob der TI pUndesirableFileSystem
    oder pUndesirable1st betrachtet, ohne die Zeichen in diesen Parametern ändern zu müssen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will validate a string pInputString based\
    \ on rules in pChanges and change or \n# eliminate characters to create a global variable\
    \ sOutputString that can be used in the source TI.\n\n# Note:\n# - pInputString: This is\
    \ the input string that needs to be validated based on file system \n#   limitations or\
    \ undesirable 1st characters.\n\n# - pUndesirableFileSystem: These are characters considered\
    \ undesirable (even forbidden) in \n#   object/element names due to file system limitations\
    \ of the operation system. \n\n# - pUndesirable1st: These are characters considered undesirable\
    \ as 1st characters in object/element\n#   names due to TM1 limitations.\n\n# - pChanges:\
    \ This string defines the rule of how to change undesirable characters. It can be made up\n\
    #   of many definitions delimited by pDelim (e.g. `&` which is not considered undesirable\n\
    #   anywhere). Each definition would contain a character considered undesirable and the\
    \ desired \n#   character separatedby pSeperator (e.g. to change a `%` to Percentage and\
    \ `'` to inches, it would\n#   be `%,Percentage&',inches` if pDelim = `&` and pSeperator\
    \ = `,`).\n\n# - pReplaceIfNotFound: This is a catch all for characters listed in pUndesirableFileSystem\
    \ or \n#   pUndesirable1st that don't have a rule in pChanges.\n\n# - pDelim: This is a\
    \ character that is used to seperate definitions in pChanges.\n\n# - pSeperator: This is\
    \ a character used to seperate the current and desired character within each\n#   definition\
    \ in pChanges.\n\n# - pMode: This can be used to limit whether the TI looks at pUndesirableFileSystem\
    \ or pUndesirable1st \n#   without having to delete the characters in those parameters.\n\
    #EndRegion @DOC\n\n#Region # Variables & Constants\n# Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    StringGlobalVariable('sOutputString');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode\
    \ = 0;\n\n# Constants \ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\n\
    cTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncSubset         = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= '%cThisProcName% : %sMessage% : %cUserName%';\n\
    cLogInfo        = 'Process:%cThisProcName% run with parameters pLogOutput=%pLogOutput%,\
    \ pInputString=%pInputString%, pUndesirableFileSystem=%pUndesirableFileSystem%, pUndesirable1st=%pUndesirable1st%,\
    \ pChanges=%pChanges%, pReplaceIfNotFound=%pReplaceIfNotFound%, pDelim=%pDelim%, pSeperator=%pSeperator%,\
    \ pMode=%pMode%';\n\n# Variables\nnErrors         = 0;\n#EndRegion\n\n#Region # LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\nENDIF;\n\
    #EndRegion\n\n#Region # Validate parameters\n## Validate pInputString parameter\nIF( Trim(\
    \ pInputString ) @= '' );\n    nErrors     =1;\n    sError      = Expand('No element name\
    \ specified in pInputString.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nELSE;\n    sElementToUpdate        = Trim( pInputString ) ;\nENDIF;\n\n## Validate\
    \ pMode parameter\nIF( pMode <>1 & pMode <>2 & pMode <>3 );\n    nErrors     =1;\n    sError\
    \      = Expand('pMode parameter must be 1, 2 or 3 not %pMode%.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nENDIF;\n\n## Validate pDelim parameter\nIF( Trim( pDelim\
    \ ) @= '' );\n    nErrors     =1;\n    sError      = Expand('No delimiter specified in pDelim.');\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nELSE;\n    sDelim      =\
    \ SUBST( Trim( pDelim ) , 1 , 1 );\nENDIF;\n\n## Validate pSeperator parameter\nIF( Trim(\
    \ pSeperator ) @= '' );\n    nErrors     =1;\n    sError      = Expand('No seperator specified\
    \ in pSeperator.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nELSE;\n\
    \    sSeperator      = SUBST( Trim( pSeperator ) , 1 , 1 );\nENDIF;\n\n## Validate pChanges\
    \ parameter\n#pChanges        = Trim( pChanges );\nIF( pChanges @= '' );\n    \nELSEIF(\
    \ SUBST( pChanges , LONG( pChanges ) , 1 )@<> sDelim );\n    pChanges    = pChanges | sDelim\
    \ ;\nENDIF;\n\n#pChanges        = Trim( pChanges );\nIF( pReplaceIfNotFound @= '' );\n \
    \   sReplaceIfNotFound  = '';\nELSE;\n    sReplaceIfNotFound  = Trim( pReplaceIfNotFound\
    \ );\nENDIF;\n\n##### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n#EndRegion\
    \ \n\n#Region # Prepare for While loop to validate each character seperately\nsEle     \
    \                   = TRIM( pInputString );\nnEle                        = LONG( sEle );\n\
    sOutputString               = '';\nnCount                      = 1;\n# Loop through each\
    \ character to see if valid\n# If no script inlcuded in pChanges then the invalid character\
    \ will be replaced  with pReplaceIfNotFound\nWHILE( nCount <= nEle );\n    sChar       \
    \            = SUBST( sEle , nCount , 1 );\n    sChanges                = TRIM( pChanges\
    \ );\n    nUndesirableFileSystem  = SCAN( sChar , pUndesirableFileSystem );\n    nUndesirable1st\
    \         = SCAN( sChar , pUndesirable1st );\n    ## Test if sChar contains undesirable\
    \ \n    IF( nUndesirableFileSystem >0 & ( pMode=1 % pMode=3) );\n        ## Test if sChar\
    \ in pChanges\n        nChange             = SCAN( sChar , sChanges );\n        IF( nChange\
    \ >0 );\n            sChanges        = SUBST( sChanges , nChange , 999 );\n            nNewLong\
    \        = SCAN( sDelim , sChanges );       \n            sNew            = SUBST( sChanges\
    \ , 3  , nNewLong-3 );\n            #sOutputString   = sOutputString | sNew ;\n        ELSE;\n\
    \            sNew            = sReplaceIfNotFound ;\n        ENDIF;   \n    ELSEIF( nUndesirable1st\
    \ >0 & nCount=1 & ( pMode=2 % pMode=3) );\n        ## Test if sChar in pChanges\n      \
    \  nChange             = SCAN( sChar , sChanges );\n        IF( nChange >0 );\n        \
    \    sChanges        = SUBST( sChanges , nChange , 999 );\n            nNewLong        =\
    \ SCAN( sDelim , sChanges );       \n            sNew            = SUBST( sChanges , 3 \
    \ , nNewLong-3 );\n            #sOutputString   = sOutputString | sNew ;\n        ELSE;\n\
    \            sNew            = pReplaceIfNotFound ;\n        ENDIF;        \n    ELSE;\n\
    \        sNew                = sChar;\n    ENDIF;\n    sOutputString           = sOutputString\
    \ | sNew ;\n    # Loop through the rest of the characters\n    nCount                  =\
    \ nCount + 1 ;\nEND;\n#EndRegion\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\nIF( nCount <> 1000000 );\n    #AttrPutS( NumberToString(\
    \ StringToNumber( sUpdatesNew ) )  , sDim2 , sUpdatesNew , 'Number');\nENDIF;\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% has validated the string the\
    \ element '%pInputString%' and returned '%sOutputString%'.' );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If(\
    \ pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that validates an input string pInputString
    based on the rules in pChanges and changes or eliminates characters to create a global variable
    sOutputString that can be used in the source TI. Note: pInputString is the input string
    that needs to be validated based on file system limitations or undesirable initial characters.
    pUndesirableFileSystem are characters considered undesirable (or forbidden) in object/element
    names due to the operating system''s file system limitations. pUndesirable1st are characters
    considered undesirable as first characters in object/element names due to TM1 limitations.
    pChanges defines the rule of how to change undesirable characters. It can consist of many
    definitions separated by pDelim. Each definition contains an undesirable character and the
    desired character, separated by pSeperator. pReplaceIfNotFound is a catch-all for characters
    listed in pUndesirableFileSystem or pUndesirable1st that do not have a rule in pChanges.
    pDelim is a character used to separate definitions in pChanges. pSeperator is used to separate
    the current and desired character within each definition in pChanges. pMode can be used
    to determine whether the TI looks at pUndesirableFileSystem or pUndesirable1st without having
    to change the characters in these parameters.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will validate a string pInputString based\
    \ on rules in pChanges and change or \n# eliminate characters to create a global variable\
    \ sOutputString that can be used in the source TI.\n\n# Note:\n# - pInputString: This is\
    \ the input string that needs to be validated based on file system \n#   limitations or\
    \ undesirable 1st characters.\n\n# - pUndesirableFileSystem: These are characters considered\
    \ undesirable (even forbidden) in \n#   object/element names due to file system limitations\
    \ of the operation system. \n\n# - pUndesirable1st: These are characters considered undesirable\
    \ as 1st characters in object/element\n#   names due to TM1 limitations.\n\n# - pChanges:\
    \ This string defines the rule of how to change undesirable characters. It can be made up\n\
    #   of many definitions delimited by pDelim (e.g. `&` which is not considered undesirable\n\
    #   anywhere). Each definition would contain a character considered undesirable and the\
    \ desired \n#   character separatedby pSeperator (e.g. to change a `%` to Percentage and\
    \ `'` to inches, it would\n#   be `%,Percentage&',inches` if pDelim = `&` and pSeperator\
    \ = `,`).\n\n# - pReplaceIfNotFound: This is a catch all for characters listed in pUndesirableFileSystem\
    \ or \n#   pUndesirable1st that don't have a rule in pChanges.\n\n# - pDelim: This is a\
    \ character that is used to seperate definitions in pChanges.\n\n# - pSeperator: This is\
    \ a character used to seperate the current and desired character within each\n#   definition\
    \ in pChanges.\n\n# - pMode: This can be used to limit whether the TI looks at pUndesirableFileSystem\
    \ or pUndesirable1st \n#   without having to delete the characters in those parameters.\n\
    #EndRegion @DOC\n\n#Region # Variables & Constants\n# Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    StringGlobalVariable('sOutputString');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode\
    \ = 0;\n\n# Constants \ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\n\
    cTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncSubset         = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= '%cThisProcName% : %sMessage% : %cUserName%';\n\
    cLogInfo        = 'Process:%cThisProcName% run with parameters pLogOutput=%pLogOutput%,\
    \ pInputString=%pInputString%, pUndesirableFileSystem=%pUndesirableFileSystem%, pUndesirable1st=%pUndesirable1st%,\
    \ pChanges=%pChanges%, pReplaceIfNotFound=%pReplaceIfNotFound%, pDelim=%pDelim%, pSeperator=%pSeperator%,\
    \ pMode=%pMode%';\n\n# Variables\nnErrors         = 0;\n#EndRegion\n\n#Region # LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\nENDIF;\n\
    #EndRegion\n\n#Region # Validate parameters\n## Validate pInputString parameter\nIF( Trim(\
    \ pInputString ) @= '' );\n    nErrors     =1;\n    sError      = Expand('No element name\
    \ specified in pInputString.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nELSE;\n    sElementToUpdate        = Trim( pInputString ) ;\nENDIF;\n\n## Validate\
    \ pMode parameter\nIF( pMode <>1 & pMode <>2 & pMode <>3 );\n    nErrors     =1;\n    sError\
    \      = Expand('pMode parameter must be 1, 2 or 3 not %pMode%.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nENDIF;\n\n## Validate pDelim parameter\nIF( Trim( pDelim\
    \ ) @= '' );\n    nErrors     =1;\n    sError      = Expand('No delimiter specified in pDelim.');\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nELSE;\n    sDelim      =\
    \ SUBST( Trim( pDelim ) , 1 , 1 );\nENDIF;\n\n## Validate pSeperator parameter\nIF( Trim(\
    \ pSeperator ) @= '' );\n    nErrors     =1;\n    sError      = Expand('No seperator specified\
    \ in pSeperator.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nELSE;\n\
    \    sSeperator      = SUBST( Trim( pSeperator ) , 1 , 1 );\nENDIF;\n\n## Validate pChanges\
    \ parameter\n#pChanges        = Trim( pChanges );\nIF( pChanges @= '' );\n    \nELSEIF(\
    \ SUBST( pChanges , LONG( pChanges ) , 1 )@<> sDelim );\n    pChanges    = pChanges | sDelim\
    \ ;\nENDIF;\n\n#pChanges        = Trim( pChanges );\nIF( pReplaceIfNotFound @= '' );\n \
    \   sReplaceIfNotFound  = '';\nELSE;\n    sReplaceIfNotFound  = Trim( pReplaceIfNotFound\
    \ );\nENDIF;\n\n##### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n#EndRegion\
    \ \n\n#Region # Prepare for While loop to validate each character seperately\nsEle     \
    \                   = TRIM( pInputString );\nnEle                        = LONG( sEle );\n\
    sOutputString               = '';\nnCount                      = 1;\n# Loop through each\
    \ character to see if valid\n# If no script inlcuded in pChanges then the invalid character\
    \ will be replaced  with pReplaceIfNotFound\nWHILE( nCount <= nEle );\n    sChar       \
    \            = SUBST( sEle , nCount , 1 );\n    sChanges                = TRIM( pChanges\
    \ );\n    nUndesirableFileSystem  = SCAN( sChar , pUndesirableFileSystem );\n    nUndesirable1st\
    \         = SCAN( sChar , pUndesirable1st );\n    ## Test if sChar contains undesirable\
    \ \n    IF( nUndesirableFileSystem >0 & ( pMode=1 % pMode=3) );\n        ## Test if sChar\
    \ in pChanges\n        nChange             = SCAN( sChar , sChanges );\n        IF( nChange\
    \ >0 );\n            sChanges        = SUBST( sChanges , nChange , 999 );\n            nNewLong\
    \        = SCAN( sDelim , sChanges );       \n            sNew            = SUBST( sChanges\
    \ , 3  , nNewLong-3 );\n            #sOutputString   = sOutputString | sNew ;\n        ELSE;\n\
    \            sNew            = sReplaceIfNotFound ;\n        ENDIF;   \n    ELSEIF( nUndesirable1st\
    \ >0 & nCount=1 & ( pMode=2 % pMode=3) );\n        ## Test if sChar in pChanges\n      \
    \  nChange             = SCAN( sChar , sChanges );\n        IF( nChange >0 );\n        \
    \    sChanges        = SUBST( sChanges , nChange , 999 );\n            nNewLong        =\
    \ SCAN( sDelim , sChanges );       \n            sNew            = SUBST( sChanges , 3 \
    \ , nNewLong-3 );\n            #sOutputString   = sOutputString | sNew ;\n        ELSE;\n\
    \            sNew            = pReplaceIfNotFound ;\n        ENDIF;        \n    ELSE;\n\
    \        sNew                = sChar;\n    ENDIF;\n    sOutputString           = sOutputString\
    \ | sNew ;\n    # Loop through the rest of the characters\n    nCount                  =\
    \ nCount + 1 ;\nEND;\n#EndRegion\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\nIF( nCount <> 1000000 );\n    #AttrPutS( NumberToString(\
    \ StringToNumber( sUpdatesNew ) )  , sDim2 , sUpdatesNew , 'Number');\nENDIF;\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% has validated the string the\
    \ element '%pInputString%' and returned '%sOutputString%'.' );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If(\
    \ pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der es ermöglicht, einen Prozess in
    einem Wartezustand für die angegebene Zeit in Sekunden zu setzen. Stelle sicher, dass der
    Prozess effektiv pausiert wird und nach der angegebenen Wartezeit ordnungsgemäß fortgesetzt
    wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This Bedrock TM1 TI will put a process in a wait state\
    \ for time specified in seconds.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\nsWaitSec = NumberToString(\
    \ pWaitSec );\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pWaitSec:%sWaitSec%.'; \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n###\
    \ SLEEP ##\nnWaitTime = pWaitSec * 1000;\nSleep ( nWaitTime );\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully waited for %sWaitSec%\
    \ .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n \
    \   nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand(\
    \ sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that allows putting a process into a wait
    state for the specified time in seconds. Ensure that the process is effectively paused and
    resumes properly after the specified wait time.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This Bedrock TM1 TI will put a process in a wait state\
    \ for time specified in seconds.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\nsWaitSec = NumberToString(\
    \ pWaitSec );\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pWaitSec:%sWaitSec%.'; \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n###\
    \ SLEEP ##\nnWaitTime = pWaitSec * 1000;\nSleep ( nWaitTime );\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully waited for %sWaitSec%\
    \ .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n \
    \   nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand(\
    \ sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine Nachricht in das TM1-Server-Message-Log
    schreibt. Dein Prozess sollte die Schritte zur Initialisierung, Ausführung und Fehlerbehandlung
    klar definieren.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will write a Message into the TM1 server\
    \ Message Log. \n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pLevel:%pLevel%, pMessage:%pMessage%.'\
    \ ; \ncLF                 = Char ( 10 );\n\n## LogOutput parameters\nIF( pLogoutput = 1\
    \ );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors             = 0;\nsErrors             = '';\n\n# ValidateType\nsType    \
    \           = Upper ( pLevel );\nIf( sType @<> 'ERROR' & sType @<> 'WARN' & sType @<> 'DEBUG'\
    \ & sType @<> 'INFO' );\n    nErrors         = nErrors + 1;\n    sMessage        = 'Invalid\
    \ Type: ' | pLevel | cLF;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\nIf( Long ( pMessage ) = 0 );\n    nErrors         = nErrors + 1;\n    sMessage \
    \       = sErrors | 'pMessage can not be empty.'  | cLF;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Action ###\nLogOutput ( sType , pMessage );\n\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully wrote message\
    \ type %pLevel% with message %pMessage%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Develop an IBM Turbo Integrator process that writes a message into the TM1 server
    message log. Your process should clearly define the steps for initialization, execution,
    and error handling.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will write a Message into the TM1 server\
    \ Message Log. \n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pLevel:%pLevel%, pMessage:%pMessage%.'\
    \ ; \ncLF                 = Char ( 10 );\n\n## LogOutput parameters\nIF( pLogoutput = 1\
    \ );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors             = 0;\nsErrors             = '';\n\n# ValidateType\nsType    \
    \           = Upper ( pLevel );\nIf( sType @<> 'ERROR' & sType @<> 'WARN' & sType @<> 'DEBUG'\
    \ & sType @<> 'INFO' );\n    nErrors         = nErrors + 1;\n    sMessage        = 'Invalid\
    \ Type: ' | pLevel | cLF;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\nIf( Long ( pMessage ) = 0 );\n    nErrors         = nErrors + 1;\n    sMessage \
    \       = sErrors | 'pMessage can not be empty.'  | cLF;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Action ###\nLogOutput ( sType , pMessage );\n\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\n\
    Else;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully wrote message\
    \ type %pLevel% with message %pMessage%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n       \
    \ LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
