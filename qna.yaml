version: 2
created_by: GMC2alg
task_description: Teach the model how to generate a Turbo Integrator process
created_at: '2024-10-22'
seed_examples:
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der die begrenzten Planungsoptionen in Chores
    überwindet. Dieser Prozess muss der erste in einem Chore sein. Beispiel: Wenn ein Chore jeden Montag
    und Mittwoch ausgeführt werden soll, wird er für die tägliche Ausführung geplant, aber der Parameter
    pWeekdays wird auf Montag und Mittwoch gesetzt. Der Chore startet dann jeden Tag, aber dieser Prozess
    führt an allen Tagen, die nicht in pWeekdays angegeben sind, eine ProcessExitByChoreQuit-Funktion
    aus. Anwendungsfälle: Für produktive Systeme. 1. Ein Chore sollte alle 30 Minuten zwischen 8 Uhr und
    20 Uhr an Wochentagen ausgeführt werden. Planen Sie den Chore für alle 30 Minuten und fügen Sie diesen
    Prozess zuerst im Chore mit den Parametern pWeekDays=MON&TUE&WED&THU&FRI, pStartTime=8, pEndTime=20
    ein. 2. Ein Chore sollte nur am ersten Kalendertag jedes Monats ausgeführt werden. Planen Sie den
    Chore für die tägliche Ausführung und fügen Sie diesen Prozess zuerst im Chore mit dem Parameter pMonthDays=1
    ein. Hinweis: Dieser Prozess beendet einen Chore, wenn zeitgebundene, wochentagsgebundene oder datumsgebundene
    Bedingungen erfüllt sind, die definieren, wann der Chore nicht ausgeführt werden soll. Nur die benötigten
    Parameter sollten angegeben werden. Nur geplante Ausführungen werden außerhalb der Parameter beendet.
    Wenn ein Chore manuell von einem Benutzer ausgeführt wird, werden die Überprüfungen umgangen. Dies
    wird durch die Überprüfung der TM1User-Funktion erreicht. Zeitbedingungen werden in der folgenden
    Prioritätsreihenfolge überprüft: 1. pMonthDays: Tage im Monat, an denen der Chore ausgeführt werden
    darf. Geben Sie eine durch Trennzeichen getrennte Liste von Tagen ein, z.B. 1&2&30&31 (leer = keine
    Beschränkung auf zulässige Monatstage). 2. pWeekDays: Tage in der Woche, an denen der Chore ausgeführt
    werden darf. Geben Sie eine durch Trennzeichen getrennte Liste von Wochentagen ein, z.B. MON&FRI (leer
    = keine Beschränkung auf zulässige Wochentage). 3. pStartTime & pEndTime: Tageszeit, zu der der Chore
    ausgeführt werden darf, z.B. pStartTime=7, pEndTime=22, die Ausführung wird zwischen 7 Uhr und 22
    Uhr erlaubt (leer = keine zeitgebundenen Beschränkungen).'
  answer: "#Section Prolog\n\n#Region @DOC\n# Description:\n# This TI was created to overcome the limited\
    \ scheduling options in chores. In order to use this TI it has to be the 1st TI in the chore.\n# As\
    \ an example, if you need to run a chore every Monday & Wednesday you would schedule it to run EVERY\
    \ day but set the pWeekdays parameter to Mon & Wed.\n# The chore would then kick off every day but\
    \ this TI will perform a ProcessExitByChoreQuit function on all days NOT mentioned in pWeekdays.\n\
    \n# Use case: For productive systems.\n# 1. A chore should run every 30 minutes between 8am & 8pm\
    \ on weekdays. Schedule chore for every 30 minutes and include this process 1st in chore with parameters\
    \ pWeekDays=MON&TUE&WED&THU&FRI pStartTime=8 pEndTime=20.\n# 2. A chore should run only on 1st calendar\
    \ day of each month. Schedule chore for daily execution and include this process 1st in chore with\
    \ parameters pMonthDays=1.\n\n# Note:\n# * This process will quit a chore if any time-bound, weekday-bound\
    \ or date-bound conditions which define when the chore should NOT run are met.\n# * Only the parameter(s)\
    \ needed shoudl be specified.\n# * Only scheduled executions will be quit outside the parameters.\
    \ The checks are bypassed if a chore is manually executed by a user. This is done by checking the\
    \ TM1User function.\n# * Time conditions are checked using these parameters in the following order\
    \ of priority.\n#   1. pMonthDays : Days in month when chore is allowed to run. Enter delimited list\
    \ of days e.g. 1&2&30&31 (blank = no restriction on allowed days of month).\n#   2. pWeekDays : Days\
    \ in week when chore is allowed to run Enter delimited list of weekdays e.g. MON&FRI (blank = no restriction\
    \ on allowed weekdays).\n#   3. pStartTime & pEndTime : Time of day when chore is allowed to run e.g.\
    \ pStartTime=7, pEndTime=22 execution will be allowed between 7AM & 10PM ( blank = no time-bound restrictionss).\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncStartTime\
    \      = NumberToString( pStartTime );\ncEndTime        = NumberToString( pEndTime );\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName% Process:%cThisProcName% Message: %sMsg%';\ncLogInfo\
    \        = 'User:%cUserName% Process:%cThisProcName% run to check if chore should run with parameters\
    \ pMonthDays:%pMonthDays%, pWeekDays:%pWeekDays%, pDelim:%pDelim%, pStartTime:%cStartTime%, pEndTime:%cEndTime%.'\
    \ ; \nnErrors         = 0;\nsMsg            = '';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nEndIf;\n\n### Check params\nIf( pDelim @= '' );\n\
    \    pDelim = '&';\nElse;\n    pDelim = SubSt( pDelim, 1, 1 );\nEndIf;\n\nIf( pMonthDays @= 'ALL'\
    \ );\n    pMonthDays = '';\nEndIf;\nIf( pMonthDays @<> '' );\n    If( SubSt( pMonthDays, Long( pMonthDays\
    \ ), 1 ) @<> pDelim );\n        pMonthDays = pMonthDays | pDelim;\n    EndIf;\nEndIf;\n\nIf( pWeekDays\
    \ @= 'ALL' );\n    pWeekDays = '';\nEndIf;\nIf( pWeekDays @<> '' );\n    pWeekDays = Upper( pWeekDays\
    \ );\n    If( SubSt( pWeekDays, Long( pWeekDays ), 1 ) @<> pDelim );\n        pWeekDays = pWeekDays\
    \ | pDelim;\n    EndIf;\nEndIf;\n\nIf( pStartTime <= 0 % pStartTime > 24 );\n    pStartTime = 0;\n\
    Else;\n    pStartTime = Round(pStartTime);\nEndIf;\nsStartTime = NumberToString( pStartTime );\n\n\
    If( pEndTime <= 0 % pEndTime > 24 );\n    pEndTime = 24;\nElse;\n    pEndTime = Round(pEndTime);\n\
    EndIf;\n\nIf( pEndTime < pStartTime );\n    pEndTime = pStartTime;\nEndIf;\nsEndTime = NumberToString(\
    \ pEndTime );\n\n### Initialize quit Boolean\nbQuit = 0;\n\n### Check the user\nIf( DIMIX( '}Clients',\
    \ cUserName ) > 0 );\n    If( pLogOutput >= 1 );\n        sMsg = 'This chore will NOT quit since executed\
    \ by a user.';\n        LogOutput( 'INFO', Expand( cMsgErrorContent ) );\n    EndIf;\nElse;\n    \n\
    \    ### Check the day of the month\n    If( pMonthDays @<> '' );\n        sDayInMonth = TimSt(Now,\
    \ '\\d');\n        If( Scan( sDayInMonth | pDelim, pMonthDays ) = 0 & Scan( sDayInMonth |' '| pDelim,\
    \ pMonthDays ) = 0 );\n            # could not find the day in the list of acceptable days\n     \
    \       bQuit = 1;\n            sMsg = Expand('Bedrock debug %cThisProcName%: chore will quit. Could\
    \ not find today %sDayInMonth% in list of acceptable days %pMonthDays%');\n            IF( pLogoutput\
    \ = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        Else;\n            sMsg = Expand('Bedrock debug\
    \ %cThisProcName%: today %sDayInMonth% found in list of acceptable days %pMonthDays%');\n        \
    \    IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        EndIF;\n    EndIf;\n\n    ###\
    \ Check the day of the week\n    If( pWeekDays @<> '' );\n        nDayIndex = Mod( DayNo ( Today )\
    \ + 21915, 7 );\n        sWeekday = '';\n        If( nDayIndex = 0 );\n            sWeekday = 'SUN';\n\
    \        ElseIf( nDayIndex = 1 );\n            sWeekday = 'MON';\n        ElseIf( nDayIndex = 2 );\n\
    \            sWeekday = 'TUE';\n        ElseIf( nDayIndex = 3 );\n            sWeekday = 'WED';\n\
    \        ElseIf( nDayIndex = 4 );\n            sWeekday = 'THU';\n        ElseIf( nDayIndex = 5 );\n\
    \            sWeekday = 'FRI';\n        ElseIf( nDayIndex = 6 );\n            sWeekday = 'SAT';\n\
    \        EndIf;\n        If( Scan( sWeekday | pDelim, pWeekDays ) = 0 & Scan( sWeekday |' '| pDelim,\
    \ pWeekDays ) = 0 );\n            # could not find the day in the list of acceptable days\n      \
    \      bQuit = 1;\n            sMsg = Expand('Bedrock debug %cThisProcName%: chore will quit. Could\
    \ not find today %sWeekday% in list of acceptable days %pWeekDays%');\n            IF( pLogoutput\
    \ = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        Else;\n            sMsg = Expand('Bedrock debug\
    \ %cThisProcName%: today %sWeekday% found in list of acceptable days %pWeekDays%');\n            IF(\
    \ pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        EndIF;\n    EndIf;\n    \n    ### Check\
    \ the time of day\n    sMinute = TimSt(Now, '\\h:\\i');\n    vTimeNow = StringToNumber(SubSt(sMinute,\
    \ 1, 2));\n    If( pStartTime = 0 & pEndTime = 24 );\n        # no time exclusion parameters are set\n\
    \    ElseIf( vTimeNow < pStartTime % vTimeNow >= pEndTime );\n        # we are in the exclusion zone\
    \ do not execute chore\n        bQuit = 1;\n        sMsg = Expand('Bedrock debug %cThisProcName%:\
    \ chore will quit. current time %sMinute% is outside the defined execution time from %sStartTime%:00\
    \ to %sEndTime%:00');\n        IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n    Else;\n\
    \        # we are not in the exclusion zone, proceed as normal \n        sMsg = Expand('Bedrock debug\
    \ %cThisProcName%: current time %sMinute% is within the defined execution time from %sStartTime%:00\
    \ to %sEndTime%:00');\n        IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n    EndIF;\n\
    \nEndIf;\n\n### Quit chore if quit conditions met\nIf( bQuit = 1 );\n    sMsg = Expand('Bedrock debug\
    \ %cThisProcName%: terminated the chore for the reasons stated above.');\n    If( pLogoutput = 1 );\
    \ LogOutput( 'INFO' , Expand( cMsgErrorContent ) ); EndIf;\n    nProcessReturnCode = ProcessExitByChoreQuit();\n\
    \    sProcessReturnCode = 'ProcessExitByChoreQuit';\n    ChoreQuit;\nElse;\n    ### Return Code\n\
    \    sProcessAction      = Expand('Bedrock debug %cThisProcName%: validated the chore to run as normal.');\n\
    \    sProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \  = 1;\n    If( pLogoutput = 1 ); LogOutput('INFO', Expand( sProcessAction ) );  EndIf;\nEndIf;\n\
    \n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% completed normally' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###\n"
- question: 'Develop an IBM Turbo Integrator process to overcome the limited scheduling options in chores.
    This process must be the first in a chore. For example, if a chore needs to run every Monday and Wednesday,
    schedule it to run every day but set the pWeekdays parameter to Mon and Wed. The chore will then kick
    off daily, but this process will perform a ProcessExitByChoreQuit function on all days NOT mentioned
    in pWeekdays. Use case: For productive systems. 1. A chore should run every 30 minutes between 8am
    and 8pm on weekdays. Schedule the chore every 30 minutes and include this process first in the chore
    with parameters pWeekDays=MON&TUE&WED&THU&FRI, pStartTime=8, pEndTime=20. 2. A chore should run only
    on the first calendar day of each month. Schedule the chore for daily execution and include this process
    first in the chore with the parameter pMonthDays=1. Note: This process will quit a chore if any time-bound,
    weekday-bound, or date-bound conditions which define when the chore should NOT run are met. Only the
    parameter(s) needed should be specified. Only scheduled executions will be quit outside the parameters.
    The checks are bypassed if a chore is manually executed by a user, achieved by checking the TM1User
    function. Time conditions are checked in the following order of priority: 1. pMonthDays: Days in the
    month when the chore is allowed to run. Enter a delimited list of days, e.g., 1&2&30&31 (blank = no
    restriction on allowed days of the month). 2. pWeekDays: Days of the week when the chore is allowed
    to run. Enter a delimited list of weekdays, e.g., MON&FRI (blank = no restriction on allowed weekdays).
    3. pStartTime & pEndTime: Time of day when the chore is allowed to run, e.g., pStartTime=7, pEndTime=22,
    execution will be allowed between 7AM and 10PM (blank = no time-bound restrictions).'
  answer: "#Section Prolog\n\n#Region @DOC\n# Description:\n# This TI was created to overcome the limited\
    \ scheduling options in chores. In order to use this TI it has to be the 1st TI in the chore.\n# As\
    \ an example, if you need to run a chore every Monday & Wednesday you would schedule it to run EVERY\
    \ day but set the pWeekdays parameter to Mon & Wed.\n# The chore would then kick off every day but\
    \ this TI will perform a ProcessExitByChoreQuit function on all days NOT mentioned in pWeekdays.\n\
    \n# Use case: For productive systems.\n# 1. A chore should run every 30 minutes between 8am & 8pm\
    \ on weekdays. Schedule chore for every 30 minutes and include this process 1st in chore with parameters\
    \ pWeekDays=MON&TUE&WED&THU&FRI pStartTime=8 pEndTime=20.\n# 2. A chore should run only on 1st calendar\
    \ day of each month. Schedule chore for daily execution and include this process 1st in chore with\
    \ parameters pMonthDays=1.\n\n# Note:\n# * This process will quit a chore if any time-bound, weekday-bound\
    \ or date-bound conditions which define when the chore should NOT run are met.\n# * Only the parameter(s)\
    \ needed shoudl be specified.\n# * Only scheduled executions will be quit outside the parameters.\
    \ The checks are bypassed if a chore is manually executed by a user. This is done by checking the\
    \ TM1User function.\n# * Time conditions are checked using these parameters in the following order\
    \ of priority.\n#   1. pMonthDays : Days in month when chore is allowed to run. Enter delimited list\
    \ of days e.g. 1&2&30&31 (blank = no restriction on allowed days of month).\n#   2. pWeekDays : Days\
    \ in week when chore is allowed to run Enter delimited list of weekdays e.g. MON&FRI (blank = no restriction\
    \ on allowed weekdays).\n#   3. pStartTime & pEndTime : Time of day when chore is allowed to run e.g.\
    \ pStartTime=7, pEndTime=22 execution will be allowed between 7AM & 10PM ( blank = no time-bound restrictionss).\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncStartTime\
    \      = NumberToString( pStartTime );\ncEndTime        = NumberToString( pEndTime );\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName% Process:%cThisProcName% Message: %sMsg%';\ncLogInfo\
    \        = 'User:%cUserName% Process:%cThisProcName% run to check if chore should run with parameters\
    \ pMonthDays:%pMonthDays%, pWeekDays:%pWeekDays%, pDelim:%pDelim%, pStartTime:%cStartTime%, pEndTime:%cEndTime%.'\
    \ ; \nnErrors         = 0;\nsMsg            = '';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nEndIf;\n\n### Check params\nIf( pDelim @= '' );\n\
    \    pDelim = '&';\nElse;\n    pDelim = SubSt( pDelim, 1, 1 );\nEndIf;\n\nIf( pMonthDays @= 'ALL'\
    \ );\n    pMonthDays = '';\nEndIf;\nIf( pMonthDays @<> '' );\n    If( SubSt( pMonthDays, Long( pMonthDays\
    \ ), 1 ) @<> pDelim );\n        pMonthDays = pMonthDays | pDelim;\n    EndIf;\nEndIf;\n\nIf( pWeekDays\
    \ @= 'ALL' );\n    pWeekDays = '';\nEndIf;\nIf( pWeekDays @<> '' );\n    pWeekDays = Upper( pWeekDays\
    \ );\n    If( SubSt( pWeekDays, Long( pWeekDays ), 1 ) @<> pDelim );\n        pWeekDays = pWeekDays\
    \ | pDelim;\n    EndIf;\nEndIf;\n\nIf( pStartTime <= 0 % pStartTime > 24 );\n    pStartTime = 0;\n\
    Else;\n    pStartTime = Round(pStartTime);\nEndIf;\nsStartTime = NumberToString( pStartTime );\n\n\
    If( pEndTime <= 0 % pEndTime > 24 );\n    pEndTime = 24;\nElse;\n    pEndTime = Round(pEndTime);\n\
    EndIf;\n\nIf( pEndTime < pStartTime );\n    pEndTime = pStartTime;\nEndIf;\nsEndTime = NumberToString(\
    \ pEndTime );\n\n### Initialize quit Boolean\nbQuit = 0;\n\n### Check the user\nIf( DIMIX( '}Clients',\
    \ cUserName ) > 0 );\n    If( pLogOutput >= 1 );\n        sMsg = 'This chore will NOT quit since executed\
    \ by a user.';\n        LogOutput( 'INFO', Expand( cMsgErrorContent ) );\n    EndIf;\nElse;\n    \n\
    \    ### Check the day of the month\n    If( pMonthDays @<> '' );\n        sDayInMonth = TimSt(Now,\
    \ '\\d');\n        If( Scan( sDayInMonth | pDelim, pMonthDays ) = 0 & Scan( sDayInMonth |' '| pDelim,\
    \ pMonthDays ) = 0 );\n            # could not find the day in the list of acceptable days\n     \
    \       bQuit = 1;\n            sMsg = Expand('Bedrock debug %cThisProcName%: chore will quit. Could\
    \ not find today %sDayInMonth% in list of acceptable days %pMonthDays%');\n            IF( pLogoutput\
    \ = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        Else;\n            sMsg = Expand('Bedrock debug\
    \ %cThisProcName%: today %sDayInMonth% found in list of acceptable days %pMonthDays%');\n        \
    \    IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        EndIF;\n    EndIf;\n\n    ###\
    \ Check the day of the week\n    If( pWeekDays @<> '' );\n        nDayIndex = Mod( DayNo ( Today )\
    \ + 21915, 7 );\n        sWeekday = '';\n        If( nDayIndex = 0 );\n            sWeekday = 'SUN';\n\
    \        ElseIf( nDayIndex = 1 );\n            sWeekday = 'MON';\n        ElseIf( nDayIndex = 2 );\n\
    \            sWeekday = 'TUE';\n        ElseIf( nDayIndex = 3 );\n            sWeekday = 'WED';\n\
    \        ElseIf( nDayIndex = 4 );\n            sWeekday = 'THU';\n        ElseIf( nDayIndex = 5 );\n\
    \            sWeekday = 'FRI';\n        ElseIf( nDayIndex = 6 );\n            sWeekday = 'SAT';\n\
    \        EndIf;\n        If( Scan( sWeekday | pDelim, pWeekDays ) = 0 & Scan( sWeekday |' '| pDelim,\
    \ pWeekDays ) = 0 );\n            # could not find the day in the list of acceptable days\n      \
    \      bQuit = 1;\n            sMsg = Expand('Bedrock debug %cThisProcName%: chore will quit. Could\
    \ not find today %sWeekday% in list of acceptable days %pWeekDays%');\n            IF( pLogoutput\
    \ = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        Else;\n            sMsg = Expand('Bedrock debug\
    \ %cThisProcName%: today %sWeekday% found in list of acceptable days %pWeekDays%');\n            IF(\
    \ pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n        EndIF;\n    EndIf;\n    \n    ### Check\
    \ the time of day\n    sMinute = TimSt(Now, '\\h:\\i');\n    vTimeNow = StringToNumber(SubSt(sMinute,\
    \ 1, 2));\n    If( pStartTime = 0 & pEndTime = 24 );\n        # no time exclusion parameters are set\n\
    \    ElseIf( vTimeNow < pStartTime % vTimeNow >= pEndTime );\n        # we are in the exclusion zone\
    \ do not execute chore\n        bQuit = 1;\n        sMsg = Expand('Bedrock debug %cThisProcName%:\
    \ chore will quit. current time %sMinute% is outside the defined execution time from %sStartTime%:00\
    \ to %sEndTime%:00');\n        IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n    Else;\n\
    \        # we are not in the exclusion zone, proceed as normal \n        sMsg = Expand('Bedrock debug\
    \ %cThisProcName%: current time %sMinute% is within the defined execution time from %sStartTime%:00\
    \ to %sEndTime%:00');\n        IF( pLogoutput = 1 ); LogOutput( 'INFO', sMsg ); EndIf;\n    EndIF;\n\
    \nEndIf;\n\n### Quit chore if quit conditions met\nIf( bQuit = 1 );\n    sMsg = Expand('Bedrock debug\
    \ %cThisProcName%: terminated the chore for the reasons stated above.');\n    If( pLogoutput = 1 );\
    \ LogOutput( 'INFO' , Expand( cMsgErrorContent ) ); EndIf;\n    nProcessReturnCode = ProcessExitByChoreQuit();\n\
    \    sProcessReturnCode = 'ProcessExitByChoreQuit';\n    ChoreQuit;\nElse;\n    ### Return Code\n\
    \    sProcessAction      = Expand('Bedrock debug %cThisProcName%: validated the chore to run as normal.');\n\
    \    sProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \  = 1;\n    If( pLogoutput = 1 ); LogOutput('INFO', Expand( sProcessAction ) );  EndIf;\nEndIf;\n\
    \n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% completed normally' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###\n"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der die Replikation eines vorhandenen Würfels
    ermöglicht. Der Prozess sollte die Option bieten, sowohl Daten als auch Regeln einzuschließen. Nutzen
    Sie diesen Prozess vorrangig für Entwicklungs- und Prototyping-Zwecke. Der Prozess umfasst: 1. Eine
    Momentaufnahme der Würfeldaten, wobei alle Regeln in Werte konvertiert werden, 2. Eine exakte Kopie
    des Würfels in einem einfachen Schritt als Ausgangspunkt für Regeländerungen oder die Entwicklung
    neuer Funktionen. Beachten Sie dabei folgende Punkte: Es gibt Parameteroptionen, um Daten (pIncludeData)
    und Regeln (pIncludeRules) bei der Erstellung einzuschließen. Wenn der Quellwürfel (pSrcCube) leer
    bleibt oder nicht existiert, wird der Prozess ohne Aktion beendet. Genauso wird der Prozess beendet,
    wenn der Zielwürfel (pTgtCube) bereits existiert. Sollte der Zielwürfel leer oder identisch mit dem
    Quellwürfel sein, erhält der Klon-Würfel den Namen des Quellwürfels mit dem Anhang ''_Clone''. Falls
    die Quellwürfeldaten nur teilweise kopiert werden sollen, nutzen Sie den Parameter pFilter.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process replicates an existing cube. It can include data &\
    \ rules too.\n\n# Use case: Intended for development/prototyping.\n# 1. Take a snapshot of cube data\
    \ copying all rules to values.\n# 2. Take an exact copy of a cube in a 'one click action' as a starting\
    \ point for prototyping rule changes or developing new features.\n\n# Note:\n# * There are parameter\
    \ options to include data (pIncludeData) and rules (pIncludeRules) with the creation of the cube.\n\
    # * If the source cube (pSrcCube) is left blank or doesn't exist in the model, process will terminate\
    \ withoud doing anything.\n# * If the target cube (pTgtCube) already exists in the model, process\
    \ will terminate withoud doing anything.\n# * If the target cube is left blank or is the same as the\
    \ source cube the cloned cube will inherit the source cube name with '_Clone' appended.\n# * If the\
    \ source cube data only needs to be partially copied, then the pFilter parameter should be entered\
    \ otherwise all other parameters can be left as is.\n# * In productive systems this process may be\
    \ called internally by other processes (}bedrock.cube.data.copy, }bedrock.cube.data.copy.intercube)\
    \ if copying data via intermediate cloned cube.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\\
    h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with\
    \ parameters pSrcCube:%pSrcCube%, pTgtCube:%pTgtCube%, pIncludeRules:%pIncludeRules%, pIncludeData:%pIncludeData%,\
    \ pFilter:%pFilter%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%,\
    \ pSuppressRules:%pSuppressRules%, pTemp:%pTemp%, pCubeLogging:%pCubeLogging%.' ;   \ncDimCountMax\
    \    = 30 ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Initialise ###\nnErrors         = 0;\nnDataCheck      = 0;\nsDimCountMax\
    \    = NumberToString( cDimCountMax );\nsDimsString     = '';\nsDelim          = '+';\n\n### Validate\
    \ Parameters ###\n\n## Default filter delimiters\nIf( pDimDelim     @= '' );\n    pDimDelim     =\
    \ '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n    pEleStartDelim= '¦';\nEndIf;\nIf( pEleDelim     @=\
    \ '' );\n    pEleDelim     = '+';\nEndIf;\n\n# Validate source cube\nIf( Trim( pSrcCube ) @= '' );\n\
    \    nErrors = 1;\n    sMessage = 'No cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pSrcCube ) = 0 );    \n    sMessage = Expand( 'Invalid source cube specified:\
    \ %pSrcCube%.' );\n    nErrors = 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate target cube\nIf( pTgtCube @= '' % pTgtCube @= pSrcCube );\n    pTgtCube = pSrcCube\
    \ | '_Clone';\nEndIf;\nIf( CubeExists( pTgtCube ) = 1 );    \n    sMessage = Expand( 'Invalid target\
    \ cube : %pTgtCube%.' );\n    nErrors = 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Create the clone cube ###\nnDimCount = 1;\nWhile( TabDim( pSrcCube, nDimCount\
    \ ) @<> '' );\n  sDimName = TabDim (pSrcCube, nDimCount);\n  sDimsString = sDimsString | sDimName\
    \ | sDelim;\n  nDimCount = nDimCount + 1;\nEnd;\nnDimCount = nDimCount - 1;\nsDimsString = Subst(sDimsString,1,long(sDimsString)-long(sDelim));\n\
    \nIf( nDimCount > cDimCountMax );\n  nErrors = 1;\n  sMessage = Expand( 'Cube has too many dimensions:\
    \ %pSrcCube% max %sDimCountMax% dims catered for, TI must be altered to accomodate.' );\n  DataSourceType\
    \ = 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n\
    \  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsProc = '}bedrock.cube.create';\nnRet = ExecuteProcess(\
    \ sProc,\n  'pLogOutput', pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pCube',\
    \ pTgtCube,\n  'pDims', sDimsString,\n  'pRecreate', 1,\n  'pDelim', sDelim\n  );\n\nIF(nRet <> 0);\n\
    \  sMessage = 'Error creating the target cube.';\n  nErrors = 1;\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nENDIF;\n\n\n### copy data ####\nIf( pIncludeData = 1 );\nnRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n  \t'pSrcCube',pSrcCube,\n\
    \  \t'pFilter',pFilter,\n  \t'pTgtCube',pTgtCube,\n  \t'pMappingToNewDims','',\n  \t'pSuppressConsol',1,\n\
    \  \t'pSuppressRules',pSuppressRules,\n  \t'pZeroTarget',0,\n  \t'pZeroSource',0,\n  \t'pFactor',1,\n\
    \    'pDimDelim', pDimDelim,\n    'pEleStartDelim', pEleStartDelim,\n    'pEleDelim', pEleDelim,\n\
    \    'pTemp', pTemp,\n    'pCubeLogging', pCubeLogging);\n\n  IF(nRet <> 0);\n    sMessage = 'Error\
    \ copying data.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\n  ENDIF;\n\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n\n\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Attach rules to cloned cube ###\nIf( nErrors = 0 & pIncludeRules\
    \ = 1 );\n  sRuleFile = pSrcCube | '.rux';\n  If( FileExists( sRuleFile ) = 1 );\n    If( nErrors\
    \ = 0 );\n      RuleLoadFromFile( pTgtCube, sRuleFile );\n    EndIf;\n  EndIf;\nEndIf;\n    \n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully cloned the %pSrcCube% cube to %pTgtCube%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that replicates an existing cube. The process should
    include options to incorporate both data and rules. This process is primarily intended for development
    and prototyping purposes. It includes: 1. Taking a snapshot of the cube data with all rules converted
    to values, 2. Making an exact copy of a cube in a single step as a starting point for rule changes
    or developing new features. Please note: There are parameter options to include data (pIncludeData)
    and rules (pIncludeRules) in the creation. If the source cube (pSrcCube) is left blank or doesn''t
    exist, the process will terminate without any action. Similarly, if the target cube (pTgtCube) already
    exists, the process will stop. If the target cube is left blank or is the same as the source cube,
    the cloned cube will inherit the source cube name with ''_Clone'' appended. If only partial data from
    the source cube is needed, use the pFilter parameter.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process replicates an existing cube. It can include data &\
    \ rules too.\n\n# Use case: Intended for development/prototyping.\n# 1. Take a snapshot of cube data\
    \ copying all rules to values.\n# 2. Take an exact copy of a cube in a 'one click action' as a starting\
    \ point for prototyping rule changes or developing new features.\n\n# Note:\n# * There are parameter\
    \ options to include data (pIncludeData) and rules (pIncludeRules) with the creation of the cube.\n\
    # * If the source cube (pSrcCube) is left blank or doesn't exist in the model, process will terminate\
    \ withoud doing anything.\n# * If the target cube (pTgtCube) already exists in the model, process\
    \ will terminate withoud doing anything.\n# * If the target cube is left blank or is the same as the\
    \ source cube the cloned cube will inherit the source cube name with '_Clone' appended.\n# * If the\
    \ source cube data only needs to be partially copied, then the pFilter parameter should be entered\
    \ otherwise all other parameters can be left as is.\n# * In productive systems this process may be\
    \ called internally by other processes (}bedrock.cube.data.copy, }bedrock.cube.data.copy.intercube)\
    \ if copying data via intermediate cloned cube.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\\
    h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with\
    \ parameters pSrcCube:%pSrcCube%, pTgtCube:%pTgtCube%, pIncludeRules:%pIncludeRules%, pIncludeData:%pIncludeData%,\
    \ pFilter:%pFilter%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%,\
    \ pSuppressRules:%pSuppressRules%, pTemp:%pTemp%, pCubeLogging:%pCubeLogging%.' ;   \ncDimCountMax\
    \    = 30 ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Initialise ###\nnErrors         = 0;\nnDataCheck      = 0;\nsDimCountMax\
    \    = NumberToString( cDimCountMax );\nsDimsString     = '';\nsDelim          = '+';\n\n### Validate\
    \ Parameters ###\n\n## Default filter delimiters\nIf( pDimDelim     @= '' );\n    pDimDelim     =\
    \ '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n    pEleStartDelim= '¦';\nEndIf;\nIf( pEleDelim     @=\
    \ '' );\n    pEleDelim     = '+';\nEndIf;\n\n# Validate source cube\nIf( Trim( pSrcCube ) @= '' );\n\
    \    nErrors = 1;\n    sMessage = 'No cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pSrcCube ) = 0 );    \n    sMessage = Expand( 'Invalid source cube specified:\
    \ %pSrcCube%.' );\n    nErrors = 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate target cube\nIf( pTgtCube @= '' % pTgtCube @= pSrcCube );\n    pTgtCube = pSrcCube\
    \ | '_Clone';\nEndIf;\nIf( CubeExists( pTgtCube ) = 1 );    \n    sMessage = Expand( 'Invalid target\
    \ cube : %pTgtCube%.' );\n    nErrors = 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Create the clone cube ###\nnDimCount = 1;\nWhile( TabDim( pSrcCube, nDimCount\
    \ ) @<> '' );\n  sDimName = TabDim (pSrcCube, nDimCount);\n  sDimsString = sDimsString | sDimName\
    \ | sDelim;\n  nDimCount = nDimCount + 1;\nEnd;\nnDimCount = nDimCount - 1;\nsDimsString = Subst(sDimsString,1,long(sDimsString)-long(sDelim));\n\
    \nIf( nDimCount > cDimCountMax );\n  nErrors = 1;\n  sMessage = Expand( 'Cube has too many dimensions:\
    \ %pSrcCube% max %sDimCountMax% dims catered for, TI must be altered to accomodate.' );\n  DataSourceType\
    \ = 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n\
    \  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsProc = '}bedrock.cube.create';\nnRet = ExecuteProcess(\
    \ sProc,\n  'pLogOutput', pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pCube',\
    \ pTgtCube,\n  'pDims', sDimsString,\n  'pRecreate', 1,\n  'pDelim', sDelim\n  );\n\nIF(nRet <> 0);\n\
    \  sMessage = 'Error creating the target cube.';\n  nErrors = 1;\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nENDIF;\n\n\n### copy data ####\nIf( pIncludeData = 1 );\nnRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n  \t'pSrcCube',pSrcCube,\n\
    \  \t'pFilter',pFilter,\n  \t'pTgtCube',pTgtCube,\n  \t'pMappingToNewDims','',\n  \t'pSuppressConsol',1,\n\
    \  \t'pSuppressRules',pSuppressRules,\n  \t'pZeroTarget',0,\n  \t'pZeroSource',0,\n  \t'pFactor',1,\n\
    \    'pDimDelim', pDimDelim,\n    'pEleStartDelim', pEleStartDelim,\n    'pEleDelim', pEleDelim,\n\
    \    'pTemp', pTemp,\n    'pCubeLogging', pCubeLogging);\n\n  IF(nRet <> 0);\n    sMessage = 'Error\
    \ copying data.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\n  ENDIF;\n\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n\n\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Attach rules to cloned cube ###\nIf( nErrors = 0 & pIncludeRules\
    \ = 1 );\n  sRuleFile = pSrcCube | '.rux';\n  If( FileExists( sRuleFile ) = 1 );\n    If( nErrors\
    \ = 0 );\n      RuleLoadFromFile( pTgtCube, sRuleFile );\n    EndIf;\n  EndIf;\nEndIf;\n    \n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully cloned the %pSrcCube% cube to %pTgtCube%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Beschreiben Sie einen IBM Turbo Integrator Prozess zur Löschung bestimmter Daten aus einem
    Cube, bevor Daten in diesen Cube kopiert werden. Der Prozess wird hauptsächlich in Produktionssystemen
    eingesetzt. Er wird im Prolog von benutzerdefinierten Prozessen aufgerufen, bevor eine Datenquelle
    abgefragt wird, um die Cube-Daten zu aktualisieren. Während der Entwicklung oder Prototyping kann
    dieser Prozess manuell ausgeführt werden, um einen Teil eines Cubes zu leeren. Es können Wildcards
    verwendet oder eine Liste von Cubes angegeben werden, um Daten aus mehreren Cubes gleichzeitig zu
    löschen. Wenn kein Cube (pCube) oder ein ungültiger Cube angegeben wird, wird der Prozess abgebrochen.
    ACHTUNG: Wenn weder ein View (pView) noch ein Filter (pFilter) angegeben wird, werden die gesamten
    Cube-Daten gelöscht. Wenn ein gültiger View angegeben ist, werden einfach nur die Daten in diesem
    View auf Null gesetzt, und ein etwaiger Filter (pFilter) wird ignoriert. Wenn kein gültiger View angegeben
    ist, wird basierend auf dem Filter ein temporärer View erstellt, dessen Daten gelöscht werden. Der
    Filter kann spezifische Elemente für beliebig viele Dimensionen und Elemente verarbeiten. Der Parameter
    pFilter enthält die Dimension und die zu filternden Elemente. Die Namen der Dimensionen müssen nicht
    in der Reihenfolge der Indexe im Cube angegeben werden. Der Dimensionsname wird als erstes Mitglied
    der durch Trennzeichen getrennten Zeichenfolge von Elementen angegeben. Wenn der Parameter pFilterParallel
    verwendet wird, darf die **einzelne Dimension**, die als ''Parallelisierungsscherber'' verwendet wird,
    nicht in den pFilter-Parametern erscheinen. Beim Einsatz der Parallelisierung über die Funktion *RunProcess*
    werden die in pFilterParallel aufgelisteten Elemente eins nach dem anderen aufgeteilt und an einen
    rekursiven Aufruf des Prozesses übergeben, wodurch sie zu pFilter hinzugefügt werden.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process could be used extensively by custom TIs in production\
    \ to clear certain data out of a cube before copying data to that cube.\n\n# Use case: Primarily for\
    \ production systems.\n# 1/ In production system this is a 'workhorse' process called from the prolog\
    \ of most custom processes prior to querying a data source to refresh cube data.\n# 2/ During development/prototyping\
    \ can be run manually to clear out a portion of a cube.\n\n# Note:\n# Wildcards can be used or a list\
    \ of cubes specified to clear data out of multiple cubes simultaneouly. \n# If no cube (pCube) or\
    \ an invalid cube is specified, the process will abort.\n# CAUTION: If no view (pView) or filter (pFilter)\
    \ is specified, the entire cube(s) will be cleared out.\n# If a valid view is specified the process\
    \ will simply zero out that view and ignore any filter (pFilter) specified.\n# If no valid view is\
    \ specified then a temporary view will be built using the filter and its data deleted.\n# The filter\
    \ can handle specific element references for any number of dimensions and elements.\n# - The pFilter\
    \ parameter contains the dimension and elements to be used for filtering.\n# - The dimension parameters\
    \ do not need to be given in the index order of dimensions in the cube.\n# - The dimension name is\
    \ specified as the first member of the delimited string of elements.\n# If using the pFilterParallel\
    \ parameter the **single dimension** used as the 'parallelization slicer' cannot appear in\n# the\
    \ pFilter parameters.\n# When using parallelization via the *RunProcess* function the elements listed\
    \ in pFilterParallel will be split one_at_a_time\n# and passed to a recursive call of the process\
    \ being added to pFilter.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \   = GetProcessName();\ncUserName       = TM1User();\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent=\
    \ 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with\
    \ parameters pCube:%pCube%, pView:%pView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%,\
    \ pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%, pSuppressConsolStrings:%pSuppressConsolStrings%,\
    \ pCubeLogging:%pCubeLogging%, pTemp:%pTemp%, pSandbox:%pSandbox%';  \ncTimeStamp      = TimSt( Now,\
    \ '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncDefaultView\
    \    = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\ncTempSub        = cDefaultView | '_Temp';\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \n# Trim delimiters\nsDelimDim           = TRIM(pDimDelim);\nsElementStartDelim  = TRIM(pEleStartDelim);\n\
    sDelimElem          = TRIM(pEleDelim);\n\n### Validate Parameters ###\nnErrors = 0;\n\n## Default\
    \ filter delimiters\nIf( pDimDelim     @= '' );\n  pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@=\
    \ '' );\n  pEleStartDelim= '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n  pEleDelim     = '+';\nEndIf;\n\
    \n# Check the delimiters\nIf( Trim( pFilter ) @<> '' );\n If( sDelimDim @= sElementStartDelim % sDelimDim\
    \ @= sDelimElem % sElementStartDelim @= sDelimElem );\n    sMessage = 'The delimiters cannot be the\
    \ same.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \  EndIf;\nEndIf;   \n\n# consolidated strings\nIf( pSuppressConsolStrings <> 0 );\n    pSuppressConsolStrings\
    \ = 1;\nEndIf;\n\n# Validate cubelogging parameter\nIf( pCubeLogging <> 0 & pCubeLogging <> 1 & pCubeLogging\
    \ <> 2);\n  sMessage = 'The cube logging parameter incorrect';\n  nErrors = nErrors + 1;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If no cube has been specified then terminate\
    \ process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'No cube(s) specified.';\n  nErrors = nErrors\
    \ + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate parallelization\
    \ filter\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n  sDimParallel = SubSt( pFilterParallel,\
    \ 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n  If( Scan( Lower(sDimParallel) | pEleStartDelim,\
    \ Lower(pFilter) ) > 0 );\n    sMessage = 'Parallelization dimension %sDimParallel% cannot exist in\
    \ filter.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n  EndIf;\nEndIf;\n\n# Validate Max Threads\nIf( pParallelThreads >= 1 );\n  nMaxThreads = Round(pParallelThreads);\n\
    Else;\n  # Single thread mode\n  nMaxThreads = 1;\nEndIf;\n\n# Validate Sandbox\nIf( TRIM( pSandbox\
    \ ) @<> '' );\n    If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty(\
    \ 0 );\n        nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is invalid for\
    \ the current user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n\
    \        ServerActiveSandboxSet( pSandbox );\n        SetUseActiveSandboxProperty( 1 );\n    EndIf;\n\
    Else;\n    SetUseActiveSandboxProperty( 0 );\nEndIf;\n\n### Check for errors before continuing\nIf(\
    \ nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n# Loop through cubes in pCube\nsCubes = pCube;\nnCubeDelimiterIndex = 1;\n# Get\
    \ 1st cube\nWhile( nCubeDelimiterIndex <> 0 );\n\n  # Extract 1st cube > sCube\n  nCubeDelimiterIndex\
    \ = Scan( pDimDelim, sCubes );\n  If( nCubeDelimiterIndex = 0 );\n    sCube   = sCubes;\n  Else;\n\
    \    sCube   = Trim( SubSt( sCubes, 1, nCubeDelimiterIndex - 1 ) );\n    sCubes  = Trim( Subst( sCubes,\
    \ nCubeDelimiterIndex + Long(pDimDelim), Long( sCubes ) ) );\n  EndIf;\n  \n  bParallel = 0;\n  \n\
    \  # Check if sCube has wildcard\n  If( Scan( '*', sCube ) = 0);\n    # Validate cube\n    If( CubeExists(sCube)\
    \ = 0 );\n      nErrors     = 1;\n      sMessage    = Expand( 'Cube %sCube% does not exist.' );\n\
    \      LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n      If( pStrictErrorHandling = 1 ); \n\
    \          ProcessQuit; \n      Else;\n          ProcessBreak;\n      EndIf;\n    Else;\n      If(\
    \ Scan( pEleStartDelim, pFilterParallel ) > 0 );\n        nDim = 1;\n        sDim = TABDIM( sCube,\
    \ nDim);\n        While ( sDim @<> '' );\n          sDim = TABDIM( sCube, nDim);\n          If ( sDim\
    \ @= sDimParallel );\n            bParallel = 1;\n            sDim = '';\n          EndIf;\n     \
    \     nDim = nDim + 1;\n        End;\n      EndIf;\n      If( bParallel = 1 );\n        sDimParallel\
    \ = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n        sElementList\
    \ = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) + 1, Long( pFilterParallel ) );\n\
    \        If( SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\n            sElementList\
    \ = sElementList | pEleDelim;\n        EndIf;\n        ## Counting elements in element list\n    \
    \    sElementListCount = sElementList;\n        nElements = 0;\n        While( Scan( pEleDelim, sElementListCount\
    \ ) > 0 );\n          nElements = nElements + 1;\n          sElementListCount = SubSt( sElementListCount,\
    \ Scan( pEleDelim, sElementListCount ) + 1, Long( sElementListCount ) );\n        End;\n        IF(\
    \ Mod( nElements, nMaxThreads ) = 0 );\n          nElemsPerThread = INT( nElements / nMaxThreads );\n\
    \        ELSE;\n          nElemsPerThread = INT( nElements / nMaxThreads ) + 1;\n        ENDIF;\n\
    \        nThreadElCounter = 0;\n        While( Scan( pEleDelim, sElementList ) > 0 );\n          sSlicerEle\
    \ = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\n          sElementList = SubSt(\
    \ sElementList, Scan( pEleDelim, sElementList ) + 1, Long( sElementList ) );\n          # Do recursive\
    \ process call with new RunProcess function\n          nThreadElCounter = nThreadElCounter + 1;\n\
    \          sDimDelim = If(pFilter @= '', '', pDimDelim );\n          IF( nThreadElCounter = 1 );\n\
    \            sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \          ELSE;\n            sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n          ENDIF;\n\
    \          IF( nThreadElCounter >= nElemsPerThread );\n            RunProcess( cThisProcName, 'pLogoutput',\
    \ pLogoutput,\n        \t    'pCube', pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel',\
    \ '', \n        \t    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\
    \ \n        \t    'pSuppressConsolStrings', pSuppressConsolStrings, 'pCubeLogging', pCubeLogging,\
    \ 'pTemp', pTemp, 'pSandbox', pSandbox\n        \t  );\n        \t  nThreadElCounter = 0;\n      \
    \  \t  sFilter = '';\n        \t ENDIF;\n        End;\n        ## Process last elements - only when\
    \ filter is not empty (there are still elements) otherwise the entire cube is emptied\n        IF(\
    \ sFilter @<> '' );\n          RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n      \t    'pCube',\
    \ pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel', '', \n      \t    'pDimDelim', pDimDelim,\
    \ 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim, \n      \t    'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n   \
    \   \t  );\n    \t  ENDIF;\n      Else;\n        ## Validate the View & filter parameter\n       \
    \ If( Trim( pView ) @= '' & Trim( pFilter ) @= '' & Trim( pSandbox ) @= '' );\n          sMessage\
    \  = Expand('No view OR filter specified so the entire %sCube% cube has been cleared.');\n\t  IF(\
    \ pLogoutput = 1 );\n          \tLogOutput( 'INFO' , Expand( 'Process:%cThisProcName% Message:%sMessage%'\
    \ ) );\n\t  ENDIF;\n          CubeClearData( sCube );\n        Else;\n          # Use different view/subset\
    \ for different cubes\n          sTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n         \
    \ sRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n          cDefaultView    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%'\
    \ );\n          #cTempSub        = cDefaultView;\n          \n          If( Trim( pView ) @= '' );\n\
    \            cView   = cDefaultView ;\n          Else;\n            cView = Trim( pView );\n     \
    \     EndIf;\n          \n          # Clear view\n          If( ViewExists( sCube , cView ) = 0 );\n\
    \            ## Validate that a Filter has been provided so that a view can be created.\n        \
    \    If( Trim( pFilter ) @= '' );\n              sMessage = Expand('View %cView% does not exist in\
    \ the %sCube% cube AND no Filter has not been specified in order to create a view.');\n          \
    \    LogOutput( 'INFO' , Expand( cMsgErrorContent ) );\n              #ProcessBreak;\n           \
    \ EndIf;\n\n            ### Create View using filter (temp view, therefore no need to destroy) ###\n\
    \            sProc = '}bedrock.cube.view.create';\n            nRet = ExecuteProcess( sProc,\n   \
    \                 'pLogOutput', pLogOutput,\n                    'pStrictErrorHandling', pStrictErrorHandling,\n\
    \                    'pCube', sCube, 'pView', cView, 'pFilter', pFilter,\n                    'pSuppressZero',\
    \ 1, 'pSuppressConsol', 1, 'pSuppressRules', 1, 'pSuppressConsolStrings', pSuppressConsolStrings,\n\
    \                    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n\
    \                    'pTemp', pTemp, 'pSubN', pSubN\n                   );\n\n              # Validate\
    \ Sandbox\n              If( TRIM( pSandbox ) @<> '' );\n              If( ServerSandboxExists( pSandbox\
    \ ) = 0 );\n                SetUseActiveSandboxProperty( 0 );\n                nErrors = nErrors +\
    \ 1;\n                sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\n\
    \                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n              Else;\n \
    \               ServerActiveSandboxSet( pSandbox );\n                SetUseActiveSandboxProperty(\
    \ 1 );\n              EndIf;\n              Else;\n                 SetUseActiveSandboxProperty( 0\
    \ );\n              EndIf;\n\n            ### Zero Out View ###\n            If ( nRet = ProcessExitNormal()\
    \ );\n              If ( pCubeLogging <= 1 );\n                sCubeLogging = CellGetS('}CubeProperties',\
    \ sCube, 'LOGGING' );\n                CubeSetLogChanges( sCube, pCubeLogging);\n              EndIf;\n\
    \              ViewZeroOut( sCube, cView );\n              sMessage = Expand( 'Succeeded in creating\
    \ the %cView% view in the %sCube% cube and data has been cleared.' );\n\t      IF( pLogoutput = 1\
    \ );\n              \tLogOutput( 'INFO', Expand( 'Process:%cThisProcName% Message:%sMessage%' ) );\n\
    \t      ENDIF;\n              If ( pCubeLogging <= 1 );\n                CubeSetLogChanges( sCube,\
    \ IF(sCubeLogging@='YES',1,0) );  \n              EndIf;\n            Else;\n              nErrors\
    \ = nErrors + 1;\n              sMessage = Expand( 'Creating view by %sProc% has failed. Nothing has\
    \ been cleared in the %sCube% cube.' );\n              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            EndIf;\n          Else;\n            If ( pCubeLogging <= 1 );\n             \
    \ sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\n              CubeSetLogChanges(\
    \ sCube, pCubeLogging);\n            EndIf;\n            ViewZeroOut( sCube, cView );\n          \
    \  If ( pCubeLogging <= 1 );\n              CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0)\
    \ ); \n            EndIf;\n          Endif;\n        Endif;\n      EndIf;\n    Endif;\n  Else;\n \
    \   # Create subset of cubes using Wildcard to loop through cubes in pCube with wildcard\n    sCubeExp\
    \ = '''|sCube|''';\n    sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL( [}Cubes] )},'|sCubeExp| ')}';\n\
    \    If( SubsetExists( '}Cubes' , cTempSub ) = 1 );\n      # If a delimited list of cube names includes\
    \ wildcards then we may have to re-use the subset multiple times\n      SubsetMDXSet( '}Cubes' , cTempSub,\
    \ sMDX );\n    Else;\n      # temp subset, therefore no need to destroy in epilog\n      SubsetCreatebyMDX(\
    \ cTempSub, sMDX, '}Cubes' , 1 );\n    EndIf;\n    \n    # Loop through cubes in subset created based\
    \ on wildcard\n    nCountCube = SubsetGetSize( '}Cubes' , cTempSub );\n    While( nCountCube >= 1\
    \ );\n      # Use different view/subset for different cubes\n      sTimeStamp      = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\n      sRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n      cDefaultView\
    \    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%' );\n      sCube           = SubsetGetElementName(\
    \ '}Cubes' , cTempSub, nCountCube );\n      # Validate cube name  Not necessary as derived from subset\
    \ of }Cubes\n      If( CubeExists(sCube) = 0 );\n        nErrors = 1;\n        sMessage = Expand(\
    \ '%sCube% does not exist.' );\n        LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n      Else;\n\
    \        If( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n          nDim = 1;\n          sDim =\
    \ TABDIM( sCube, nDim);\n          While ( sDim @<> '' );\n            sDim = TABDIM( sCube, nDim);\n\
    \            If ( sDim @= sDimParallel );\n              bParallel = 1;\n              sDim = '';\n\
    \            EndIf;\n            nDim = nDim + 1;\n          End;\n        EndIf;\n        If( bParallel\
    \ = 1 );\n          sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel\
    \ ) - 1 );\n          sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel\
    \ ) + 1, Long( pFilterParallel ) );\n          If( SubSt( sElementList, Long( sElementList ), 1 )\
    \ @<> pEleDelim );\n              sElementList = sElementList | pEleDelim;\n          EndIf;\n   \
    \     ## Counting elements in element list\n        sElementListCount = sElementList;\n        nElements\
    \ = 0;\n        While( Scan( pEleDelim, sElementListCount ) > 0 );\n          nElements = nElements\
    \ + 1;\n          sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount\
    \ ) + 1, Long( sElementListCount ) );\n        End;\n        IF( Mod( nElements, nMaxThreads ) = 0\
    \ );\n          nElemsPerThread = INT( nElements / nMaxThreads );\n        ELSE;\n          nElemsPerThread\
    \ = INT( nElements / nMaxThreads ) + 1;\n        ENDIF;\n        nThreadElCounter = 0;\n         \
    \ While( Scan( pEleDelim, sElementList ) > 0 );\n            sSlicerEle = SubSt( sElementList, 1,\
    \ Scan( pEleDelim, sElementList ) - 1 );\n            sElementList = SubSt( sElementList, Scan( pEleDelim,\
    \ sElementList ) + 1, Long( sElementList ) );\n            # Do recursive process call with new RunProcess\
    \ function\n          nThreadElCounter = nThreadElCounter + 1;\n          sDimDelim = If(pFilter @=\
    \ '', '', pDimDelim );\n          IF( nThreadElCounter = 1 );\n            sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \          ELSE;\n            sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n          ENDIF;\n\
    \          IF( nThreadElCounter >= nElemsPerThread );\n            RunProcess( cThisProcName, 'pLogoutput',\
    \ pLogoutput,\n        \t    'pCube', pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel',\
    \ '', \n        \t    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\
    \ \n        \t    'pSuppressConsolStrings', pSuppressConsolStrings, 'pCubeLogging', pCubeLogging,\
    \ 'pTemp', pTemp, 'pSandbox', pSandbox\n        \t  );\n        \t  nThreadElCounter = 0;\n      \
    \  \t  sFilter = '';\n        \t ENDIF;\n        End;\n        ## Process last elements\n        IF(\
    \ sFilter @<> '' );\n          RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n      \t    'pCube',\
    \ pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel', '', \n      \t    'pDimDelim', pDimDelim,\
    \ 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim, \n      \t    'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n   \
    \   \t  );\n    \t  ENDIF;\n        Else;\n          ## Validate the View & filter parameter\n   \
    \       If( Trim( pView ) @= '' & Trim( pFilter ) @= '' & Trim( pSandbox ) @= '' );\n            #\
    \ Clear entire cube\n            sMessage  = Expand('No view OR filter specified so the entire %sCube%\
    \ cube has been cleared.');\n\t    IF( pLogoutput = 1 );\n            \tLogOutput( 'INFO' , Expand(\
    \ 'Process:%cThisProcName% Message:%sMessage%' ) );\n\t    ENDIF;\n            CubeClearData( sCube\
    \ );\n          Else;\n            # Clear view cView\n            If( Trim( pView ) @= '' );\n  \
    \            cView   = cDefaultView ;\n            Else;\n              cView = Trim( pView );\n \
    \           EndIf;\n        \n            If( ViewExists( sCube, cView ) = 0 );\n              ##\
    \ Validate that a Filter has been provided so that a view can be created.\n              If( Trim(\
    \ pFilter ) @= '' );\n                sMessage = Expand('View %cView% does not exist for %sCube% AND\
    \ no Filter has not been specified in order to create a view.');\n                LogOutput( 'ERROR'\
    \ , Expand( cMsgErrorContent ) );\n                #ProcessBreak;\n              EndIf;\n  \n    \
    \          ### Create View using filter (temp view, therefore no need to destroy) ###\n          \
    \    sProc = '}bedrock.cube.view.create';\n              nRet = ExecuteProcess( sProc,\n         \
    \         'pLogOutput', pLogOutput,\n                  'pStrictErrorHandling', pStrictErrorHandling,\n\
    \                  'pCube', sCube, 'pView', cView, 'pFilter', pFilter,\n                  'pSuppressZero',\
    \ 1, 'pSuppressConsol', 1, 'pSuppressRules', 1, 'pSuppressConsolStrings', pSuppressConsolStrings,\n\
    \                  'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n\
    \                  'pTemp', pTemp, 'pSubN', pSubN\n                  );\n                  \n    \
    \          # Validate Sandbox\n              If( TRIM( pSandbox ) @<> '' );\n              If( ServerSandboxExists(\
    \ pSandbox ) = 0 );\n                SetUseActiveSandboxProperty( 0 );\n                nErrors =\
    \ nErrors + 1;\n                sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\n\
    \                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n              Else;\n \
    \               ServerActiveSandboxSet( pSandbox );\n                SetUseActiveSandboxProperty(\
    \ 1 );\n              EndIf;\n              Else;\n                 SetUseActiveSandboxProperty( 0\
    \ );\n              EndIf;\n                  \n  \n              ### Zero Out View ###\n        \
    \      IF ( nRet = ProcessExitNormal() );\n                If ( pCubeLogging <= 1 );\n           \
    \       sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\n                  CubeSetLogChanges(\
    \ sCube, pCubeLogging);\n                EndIf;\n                ViewZeroOut( sCube, cView );\n  \
    \              sMessage = Expand( 'Succeeded in creating the %cView% view in the %sCube% cube and\
    \ data has been cleared.' );\n\t\tIF( pLogoutput = 1 );\n                    LogOutput( 'INFO', Expand(\
    \ 'Process:%cThisProcName% Message:%sMessage%' ) );\n\t\tENDIF;\n                If ( pCubeLogging\
    \ <= 1 );\n                  CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0) );  \n        \
    \        EndIf;\n              ELSE;\n                nErrors = nErrors + 1;\n                sMessage\
    \ = Expand( 'Creating view by %sProc% has failed. Nothing has been cleared in the %sCube% cube.' );\n\
    \                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n              ENDIF;\n\
    \            Else;\n              If ( pCubeLogging <= 1 );\n                sCubeLogging = CellGetS('}CubeProperties',\
    \ sCube, 'LOGGING' );\n                CubeSetLogChanges( sCube, pCubeLogging);\n              EndIf;\n\
    \              ViewZeroOut( sCube, cView );\n              If ( pCubeLogging <= 1 );\n           \
    \     CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0) ); \n              EndIf;\n          \
    \  Endif;\n          EndIf;\n        EndIf;\n        nCountCube = nCountCube - 1;\n        # Use different\
    \ view/subset for different cubes\n        sTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n\
    \        sRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n        cDefaultView    = Expand(\
    \ '%cThisProcName%_%sTimeStamp%_%sRandomInt%' );\n        #cTempSub        = cDefaultView; \n    \
    \  EndIf;\n    End;\n  EndIf;\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cleared\
    \ data out of the %pCube% cube(s).' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Describe an IBM Turbo Integrator process for clearing specific data out of a cube before
    copying data into that cube. The process is primarily used in production systems. It is called from
    the prolog of custom processes before querying a data source to refresh cube data. During development
    or prototyping, this process can be run manually to clear out a portion of a cube. Wildcards can be
    used, or a list of cubes specified to clear data from multiple cubes simultaneously. If no cube (pCube)
    or an invalid cube is specified, the process will abort. CAUTION: If no view (pView) or filter (pFilter)
    is specified, the entire cube(s) will be cleared. If a valid view is specified, the process will simply
    zero out that view, ignoring any specified filter (pFilter). If no valid view is specified, a temporary
    view will be built based on the filter and its data deleted. The filter can handle specific element
    references for any number of dimensions and elements. The pFilter parameter includes the dimensions
    and elements to be used for filtering. The dimension names do not need to be in the index order of
    the dimensions in the cube. The dimension name is specified as the first member of the delimited string
    of elements. If using the pFilterParallel parameter, the **single dimension** used as the ''parallelization
    slicer'' cannot appear in the pFilter parameters. When using parallelization via the *RunProcess*
    function, the elements listed in pFilterParallel will be split one at a time and passed to a recursive
    call of the process, being added to pFilter.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process could be used extensively by custom TIs in production\
    \ to clear certain data out of a cube before copying data to that cube.\n\n# Use case: Primarily for\
    \ production systems.\n# 1/ In production system this is a 'workhorse' process called from the prolog\
    \ of most custom processes prior to querying a data source to refresh cube data.\n# 2/ During development/prototyping\
    \ can be run manually to clear out a portion of a cube.\n\n# Note:\n# Wildcards can be used or a list\
    \ of cubes specified to clear data out of multiple cubes simultaneouly. \n# If no cube (pCube) or\
    \ an invalid cube is specified, the process will abort.\n# CAUTION: If no view (pView) or filter (pFilter)\
    \ is specified, the entire cube(s) will be cleared out.\n# If a valid view is specified the process\
    \ will simply zero out that view and ignore any filter (pFilter) specified.\n# If no valid view is\
    \ specified then a temporary view will be built using the filter and its data deleted.\n# The filter\
    \ can handle specific element references for any number of dimensions and elements.\n# - The pFilter\
    \ parameter contains the dimension and elements to be used for filtering.\n# - The dimension parameters\
    \ do not need to be given in the index order of dimensions in the cube.\n# - The dimension name is\
    \ specified as the first member of the delimited string of elements.\n# If using the pFilterParallel\
    \ parameter the **single dimension** used as the 'parallelization slicer' cannot appear in\n# the\
    \ pFilter parameters.\n# When using parallelization via the *RunProcess* function the elements listed\
    \ in pFilterParallel will be split one_at_a_time\n# and passed to a recursive call of the process\
    \ being added to pFilter.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \   = GetProcessName();\ncUserName       = TM1User();\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent=\
    \ 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with\
    \ parameters pCube:%pCube%, pView:%pView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%,\
    \ pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%, pSuppressConsolStrings:%pSuppressConsolStrings%,\
    \ pCubeLogging:%pCubeLogging%, pTemp:%pTemp%, pSandbox:%pSandbox%';  \ncTimeStamp      = TimSt( Now,\
    \ '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncDefaultView\
    \    = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\ncTempSub        = cDefaultView | '_Temp';\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \n# Trim delimiters\nsDelimDim           = TRIM(pDimDelim);\nsElementStartDelim  = TRIM(pEleStartDelim);\n\
    sDelimElem          = TRIM(pEleDelim);\n\n### Validate Parameters ###\nnErrors = 0;\n\n## Default\
    \ filter delimiters\nIf( pDimDelim     @= '' );\n  pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@=\
    \ '' );\n  pEleStartDelim= '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n  pEleDelim     = '+';\nEndIf;\n\
    \n# Check the delimiters\nIf( Trim( pFilter ) @<> '' );\n If( sDelimDim @= sElementStartDelim % sDelimDim\
    \ @= sDelimElem % sElementStartDelim @= sDelimElem );\n    sMessage = 'The delimiters cannot be the\
    \ same.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \  EndIf;\nEndIf;   \n\n# consolidated strings\nIf( pSuppressConsolStrings <> 0 );\n    pSuppressConsolStrings\
    \ = 1;\nEndIf;\n\n# Validate cubelogging parameter\nIf( pCubeLogging <> 0 & pCubeLogging <> 1 & pCubeLogging\
    \ <> 2);\n  sMessage = 'The cube logging parameter incorrect';\n  nErrors = nErrors + 1;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If no cube has been specified then terminate\
    \ process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'No cube(s) specified.';\n  nErrors = nErrors\
    \ + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate parallelization\
    \ filter\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n  sDimParallel = SubSt( pFilterParallel,\
    \ 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n  If( Scan( Lower(sDimParallel) | pEleStartDelim,\
    \ Lower(pFilter) ) > 0 );\n    sMessage = 'Parallelization dimension %sDimParallel% cannot exist in\
    \ filter.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n  EndIf;\nEndIf;\n\n# Validate Max Threads\nIf( pParallelThreads >= 1 );\n  nMaxThreads = Round(pParallelThreads);\n\
    Else;\n  # Single thread mode\n  nMaxThreads = 1;\nEndIf;\n\n# Validate Sandbox\nIf( TRIM( pSandbox\
    \ ) @<> '' );\n    If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty(\
    \ 0 );\n        nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is invalid for\
    \ the current user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n\
    \        ServerActiveSandboxSet( pSandbox );\n        SetUseActiveSandboxProperty( 1 );\n    EndIf;\n\
    Else;\n    SetUseActiveSandboxProperty( 0 );\nEndIf;\n\n### Check for errors before continuing\nIf(\
    \ nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n# Loop through cubes in pCube\nsCubes = pCube;\nnCubeDelimiterIndex = 1;\n# Get\
    \ 1st cube\nWhile( nCubeDelimiterIndex <> 0 );\n\n  # Extract 1st cube > sCube\n  nCubeDelimiterIndex\
    \ = Scan( pDimDelim, sCubes );\n  If( nCubeDelimiterIndex = 0 );\n    sCube   = sCubes;\n  Else;\n\
    \    sCube   = Trim( SubSt( sCubes, 1, nCubeDelimiterIndex - 1 ) );\n    sCubes  = Trim( Subst( sCubes,\
    \ nCubeDelimiterIndex + Long(pDimDelim), Long( sCubes ) ) );\n  EndIf;\n  \n  bParallel = 0;\n  \n\
    \  # Check if sCube has wildcard\n  If( Scan( '*', sCube ) = 0);\n    # Validate cube\n    If( CubeExists(sCube)\
    \ = 0 );\n      nErrors     = 1;\n      sMessage    = Expand( 'Cube %sCube% does not exist.' );\n\
    \      LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n      If( pStrictErrorHandling = 1 ); \n\
    \          ProcessQuit; \n      Else;\n          ProcessBreak;\n      EndIf;\n    Else;\n      If(\
    \ Scan( pEleStartDelim, pFilterParallel ) > 0 );\n        nDim = 1;\n        sDim = TABDIM( sCube,\
    \ nDim);\n        While ( sDim @<> '' );\n          sDim = TABDIM( sCube, nDim);\n          If ( sDim\
    \ @= sDimParallel );\n            bParallel = 1;\n            sDim = '';\n          EndIf;\n     \
    \     nDim = nDim + 1;\n        End;\n      EndIf;\n      If( bParallel = 1 );\n        sDimParallel\
    \ = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n        sElementList\
    \ = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) + 1, Long( pFilterParallel ) );\n\
    \        If( SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\n            sElementList\
    \ = sElementList | pEleDelim;\n        EndIf;\n        ## Counting elements in element list\n    \
    \    sElementListCount = sElementList;\n        nElements = 0;\n        While( Scan( pEleDelim, sElementListCount\
    \ ) > 0 );\n          nElements = nElements + 1;\n          sElementListCount = SubSt( sElementListCount,\
    \ Scan( pEleDelim, sElementListCount ) + 1, Long( sElementListCount ) );\n        End;\n        IF(\
    \ Mod( nElements, nMaxThreads ) = 0 );\n          nElemsPerThread = INT( nElements / nMaxThreads );\n\
    \        ELSE;\n          nElemsPerThread = INT( nElements / nMaxThreads ) + 1;\n        ENDIF;\n\
    \        nThreadElCounter = 0;\n        While( Scan( pEleDelim, sElementList ) > 0 );\n          sSlicerEle\
    \ = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\n          sElementList = SubSt(\
    \ sElementList, Scan( pEleDelim, sElementList ) + 1, Long( sElementList ) );\n          # Do recursive\
    \ process call with new RunProcess function\n          nThreadElCounter = nThreadElCounter + 1;\n\
    \          sDimDelim = If(pFilter @= '', '', pDimDelim );\n          IF( nThreadElCounter = 1 );\n\
    \            sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \          ELSE;\n            sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n          ENDIF;\n\
    \          IF( nThreadElCounter >= nElemsPerThread );\n            RunProcess( cThisProcName, 'pLogoutput',\
    \ pLogoutput,\n        \t    'pCube', pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel',\
    \ '', \n        \t    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\
    \ \n        \t    'pSuppressConsolStrings', pSuppressConsolStrings, 'pCubeLogging', pCubeLogging,\
    \ 'pTemp', pTemp, 'pSandbox', pSandbox\n        \t  );\n        \t  nThreadElCounter = 0;\n      \
    \  \t  sFilter = '';\n        \t ENDIF;\n        End;\n        ## Process last elements - only when\
    \ filter is not empty (there are still elements) otherwise the entire cube is emptied\n        IF(\
    \ sFilter @<> '' );\n          RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n      \t    'pCube',\
    \ pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel', '', \n      \t    'pDimDelim', pDimDelim,\
    \ 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim, \n      \t    'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n   \
    \   \t  );\n    \t  ENDIF;\n      Else;\n        ## Validate the View & filter parameter\n       \
    \ If( Trim( pView ) @= '' & Trim( pFilter ) @= '' & Trim( pSandbox ) @= '' );\n          sMessage\
    \  = Expand('No view OR filter specified so the entire %sCube% cube has been cleared.');\n\t  IF(\
    \ pLogoutput = 1 );\n          \tLogOutput( 'INFO' , Expand( 'Process:%cThisProcName% Message:%sMessage%'\
    \ ) );\n\t  ENDIF;\n          CubeClearData( sCube );\n        Else;\n          # Use different view/subset\
    \ for different cubes\n          sTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n         \
    \ sRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n          cDefaultView    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%'\
    \ );\n          #cTempSub        = cDefaultView;\n          \n          If( Trim( pView ) @= '' );\n\
    \            cView   = cDefaultView ;\n          Else;\n            cView = Trim( pView );\n     \
    \     EndIf;\n          \n          # Clear view\n          If( ViewExists( sCube , cView ) = 0 );\n\
    \            ## Validate that a Filter has been provided so that a view can be created.\n        \
    \    If( Trim( pFilter ) @= '' );\n              sMessage = Expand('View %cView% does not exist in\
    \ the %sCube% cube AND no Filter has not been specified in order to create a view.');\n          \
    \    LogOutput( 'INFO' , Expand( cMsgErrorContent ) );\n              #ProcessBreak;\n           \
    \ EndIf;\n\n            ### Create View using filter (temp view, therefore no need to destroy) ###\n\
    \            sProc = '}bedrock.cube.view.create';\n            nRet = ExecuteProcess( sProc,\n   \
    \                 'pLogOutput', pLogOutput,\n                    'pStrictErrorHandling', pStrictErrorHandling,\n\
    \                    'pCube', sCube, 'pView', cView, 'pFilter', pFilter,\n                    'pSuppressZero',\
    \ 1, 'pSuppressConsol', 1, 'pSuppressRules', 1, 'pSuppressConsolStrings', pSuppressConsolStrings,\n\
    \                    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n\
    \                    'pTemp', pTemp, 'pSubN', pSubN\n                   );\n\n              # Validate\
    \ Sandbox\n              If( TRIM( pSandbox ) @<> '' );\n              If( ServerSandboxExists( pSandbox\
    \ ) = 0 );\n                SetUseActiveSandboxProperty( 0 );\n                nErrors = nErrors +\
    \ 1;\n                sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\n\
    \                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n              Else;\n \
    \               ServerActiveSandboxSet( pSandbox );\n                SetUseActiveSandboxProperty(\
    \ 1 );\n              EndIf;\n              Else;\n                 SetUseActiveSandboxProperty( 0\
    \ );\n              EndIf;\n\n            ### Zero Out View ###\n            If ( nRet = ProcessExitNormal()\
    \ );\n              If ( pCubeLogging <= 1 );\n                sCubeLogging = CellGetS('}CubeProperties',\
    \ sCube, 'LOGGING' );\n                CubeSetLogChanges( sCube, pCubeLogging);\n              EndIf;\n\
    \              ViewZeroOut( sCube, cView );\n              sMessage = Expand( 'Succeeded in creating\
    \ the %cView% view in the %sCube% cube and data has been cleared.' );\n\t      IF( pLogoutput = 1\
    \ );\n              \tLogOutput( 'INFO', Expand( 'Process:%cThisProcName% Message:%sMessage%' ) );\n\
    \t      ENDIF;\n              If ( pCubeLogging <= 1 );\n                CubeSetLogChanges( sCube,\
    \ IF(sCubeLogging@='YES',1,0) );  \n              EndIf;\n            Else;\n              nErrors\
    \ = nErrors + 1;\n              sMessage = Expand( 'Creating view by %sProc% has failed. Nothing has\
    \ been cleared in the %sCube% cube.' );\n              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            EndIf;\n          Else;\n            If ( pCubeLogging <= 1 );\n             \
    \ sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\n              CubeSetLogChanges(\
    \ sCube, pCubeLogging);\n            EndIf;\n            ViewZeroOut( sCube, cView );\n          \
    \  If ( pCubeLogging <= 1 );\n              CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0)\
    \ ); \n            EndIf;\n          Endif;\n        Endif;\n      EndIf;\n    Endif;\n  Else;\n \
    \   # Create subset of cubes using Wildcard to loop through cubes in pCube with wildcard\n    sCubeExp\
    \ = '''|sCube|''';\n    sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL( [}Cubes] )},'|sCubeExp| ')}';\n\
    \    If( SubsetExists( '}Cubes' , cTempSub ) = 1 );\n      # If a delimited list of cube names includes\
    \ wildcards then we may have to re-use the subset multiple times\n      SubsetMDXSet( '}Cubes' , cTempSub,\
    \ sMDX );\n    Else;\n      # temp subset, therefore no need to destroy in epilog\n      SubsetCreatebyMDX(\
    \ cTempSub, sMDX, '}Cubes' , 1 );\n    EndIf;\n    \n    # Loop through cubes in subset created based\
    \ on wildcard\n    nCountCube = SubsetGetSize( '}Cubes' , cTempSub );\n    While( nCountCube >= 1\
    \ );\n      # Use different view/subset for different cubes\n      sTimeStamp      = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\n      sRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n      cDefaultView\
    \    = Expand( '%cThisProcName%_%sTimeStamp%_%sRandomInt%' );\n      sCube           = SubsetGetElementName(\
    \ '}Cubes' , cTempSub, nCountCube );\n      # Validate cube name  Not necessary as derived from subset\
    \ of }Cubes\n      If( CubeExists(sCube) = 0 );\n        nErrors = 1;\n        sMessage = Expand(\
    \ '%sCube% does not exist.' );\n        LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n      Else;\n\
    \        If( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n          nDim = 1;\n          sDim =\
    \ TABDIM( sCube, nDim);\n          While ( sDim @<> '' );\n            sDim = TABDIM( sCube, nDim);\n\
    \            If ( sDim @= sDimParallel );\n              bParallel = 1;\n              sDim = '';\n\
    \            EndIf;\n            nDim = nDim + 1;\n          End;\n        EndIf;\n        If( bParallel\
    \ = 1 );\n          sDimParallel = SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel\
    \ ) - 1 );\n          sElementList = SubSt( pFilterParallel, Scan( pEleStartDelim, pFilterParallel\
    \ ) + 1, Long( pFilterParallel ) );\n          If( SubSt( sElementList, Long( sElementList ), 1 )\
    \ @<> pEleDelim );\n              sElementList = sElementList | pEleDelim;\n          EndIf;\n   \
    \     ## Counting elements in element list\n        sElementListCount = sElementList;\n        nElements\
    \ = 0;\n        While( Scan( pEleDelim, sElementListCount ) > 0 );\n          nElements = nElements\
    \ + 1;\n          sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount\
    \ ) + 1, Long( sElementListCount ) );\n        End;\n        IF( Mod( nElements, nMaxThreads ) = 0\
    \ );\n          nElemsPerThread = INT( nElements / nMaxThreads );\n        ELSE;\n          nElemsPerThread\
    \ = INT( nElements / nMaxThreads ) + 1;\n        ENDIF;\n        nThreadElCounter = 0;\n         \
    \ While( Scan( pEleDelim, sElementList ) > 0 );\n            sSlicerEle = SubSt( sElementList, 1,\
    \ Scan( pEleDelim, sElementList ) - 1 );\n            sElementList = SubSt( sElementList, Scan( pEleDelim,\
    \ sElementList ) + 1, Long( sElementList ) );\n            # Do recursive process call with new RunProcess\
    \ function\n          nThreadElCounter = nThreadElCounter + 1;\n          sDimDelim = If(pFilter @=\
    \ '', '', pDimDelim );\n          IF( nThreadElCounter = 1 );\n            sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n\
    \          ELSE;\n            sFilter = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n          ENDIF;\n\
    \          IF( nThreadElCounter >= nElemsPerThread );\n            RunProcess( cThisProcName, 'pLogoutput',\
    \ pLogoutput,\n        \t    'pCube', pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel',\
    \ '', \n        \t    'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\
    \ \n        \t    'pSuppressConsolStrings', pSuppressConsolStrings, 'pCubeLogging', pCubeLogging,\
    \ 'pTemp', pTemp, 'pSandbox', pSandbox\n        \t  );\n        \t  nThreadElCounter = 0;\n      \
    \  \t  sFilter = '';\n        \t ENDIF;\n        End;\n        ## Process last elements\n        IF(\
    \ sFilter @<> '' );\n          RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n      \t    'pCube',\
    \ pCube, 'pView', pView, 'pFilter', sFilter, 'pFilterParallel', '', \n      \t    'pDimDelim', pDimDelim,\
    \ 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim, \n      \t    'pSuppressConsolStrings',\
    \ pSuppressConsolStrings, 'pCubeLogging', pCubeLogging, 'pTemp', pTemp, 'pSandbox', pSandbox\n   \
    \   \t  );\n    \t  ENDIF;\n        Else;\n          ## Validate the View & filter parameter\n   \
    \       If( Trim( pView ) @= '' & Trim( pFilter ) @= '' & Trim( pSandbox ) @= '' );\n            #\
    \ Clear entire cube\n            sMessage  = Expand('No view OR filter specified so the entire %sCube%\
    \ cube has been cleared.');\n\t    IF( pLogoutput = 1 );\n            \tLogOutput( 'INFO' , Expand(\
    \ 'Process:%cThisProcName% Message:%sMessage%' ) );\n\t    ENDIF;\n            CubeClearData( sCube\
    \ );\n          Else;\n            # Clear view cView\n            If( Trim( pView ) @= '' );\n  \
    \            cView   = cDefaultView ;\n            Else;\n              cView = Trim( pView );\n \
    \           EndIf;\n        \n            If( ViewExists( sCube, cView ) = 0 );\n              ##\
    \ Validate that a Filter has been provided so that a view can be created.\n              If( Trim(\
    \ pFilter ) @= '' );\n                sMessage = Expand('View %cView% does not exist for %sCube% AND\
    \ no Filter has not been specified in order to create a view.');\n                LogOutput( 'ERROR'\
    \ , Expand( cMsgErrorContent ) );\n                #ProcessBreak;\n              EndIf;\n  \n    \
    \          ### Create View using filter (temp view, therefore no need to destroy) ###\n          \
    \    sProc = '}bedrock.cube.view.create';\n              nRet = ExecuteProcess( sProc,\n         \
    \         'pLogOutput', pLogOutput,\n                  'pStrictErrorHandling', pStrictErrorHandling,\n\
    \                  'pCube', sCube, 'pView', cView, 'pFilter', pFilter,\n                  'pSuppressZero',\
    \ 1, 'pSuppressConsol', 1, 'pSuppressRules', 1, 'pSuppressConsolStrings', pSuppressConsolStrings,\n\
    \                  'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim, 'pEleDelim', pEleDelim,\n\
    \                  'pTemp', pTemp, 'pSubN', pSubN\n                  );\n                  \n    \
    \          # Validate Sandbox\n              If( TRIM( pSandbox ) @<> '' );\n              If( ServerSandboxExists(\
    \ pSandbox ) = 0 );\n                SetUseActiveSandboxProperty( 0 );\n                nErrors =\
    \ nErrors + 1;\n                sMessage = Expand('Sandbox %pSandbox% is invalid for the current user.');\n\
    \                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n              Else;\n \
    \               ServerActiveSandboxSet( pSandbox );\n                SetUseActiveSandboxProperty(\
    \ 1 );\n              EndIf;\n              Else;\n                 SetUseActiveSandboxProperty( 0\
    \ );\n              EndIf;\n                  \n  \n              ### Zero Out View ###\n        \
    \      IF ( nRet = ProcessExitNormal() );\n                If ( pCubeLogging <= 1 );\n           \
    \       sCubeLogging = CellGetS('}CubeProperties', sCube, 'LOGGING' );\n                  CubeSetLogChanges(\
    \ sCube, pCubeLogging);\n                EndIf;\n                ViewZeroOut( sCube, cView );\n  \
    \              sMessage = Expand( 'Succeeded in creating the %cView% view in the %sCube% cube and\
    \ data has been cleared.' );\n\t\tIF( pLogoutput = 1 );\n                    LogOutput( 'INFO', Expand(\
    \ 'Process:%cThisProcName% Message:%sMessage%' ) );\n\t\tENDIF;\n                If ( pCubeLogging\
    \ <= 1 );\n                  CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0) );  \n        \
    \        EndIf;\n              ELSE;\n                nErrors = nErrors + 1;\n                sMessage\
    \ = Expand( 'Creating view by %sProc% has failed. Nothing has been cleared in the %sCube% cube.' );\n\
    \                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n              ENDIF;\n\
    \            Else;\n              If ( pCubeLogging <= 1 );\n                sCubeLogging = CellGetS('}CubeProperties',\
    \ sCube, 'LOGGING' );\n                CubeSetLogChanges( sCube, pCubeLogging);\n              EndIf;\n\
    \              ViewZeroOut( sCube, cView );\n              If ( pCubeLogging <= 1 );\n           \
    \     CubeSetLogChanges( sCube, IF(sCubeLogging@='YES',1,0) ); \n              EndIf;\n          \
    \  Endif;\n          EndIf;\n        EndIf;\n        nCountCube = nCountCube - 1;\n        # Use different\
    \ view/subset for different cubes\n        sTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n\
    \        sRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\n        cDefaultView    = Expand(\
    \ '%cThisProcName%_%sTimeStamp%_%sRandomInt%' );\n        #cTempSub        = cDefaultView; \n    \
    \  EndIf;\n    End;\n  EndIf;\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cleared\
    \ data out of the %pCube% cube(s).' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Der vorgestellte Turbo Integrator Prozess dient dazu, Daten aus einem angegebenen Würfel
    in eine Flatfile für einen bestimmten "Ausschnitt" (beliebige Dimension/Element-Kombination) zu exportieren.
    Dieser Prozess kann sowohl für die Entwicklung/Prototypen als auch in Produktionsumgebungen verwendet
    werden. Die Hauptanwendungsfälle umfassen: den Export von Daten zur Einbindung in ein anderes TM1-Modell,
    um die Möglichkeit von Sperren zu eliminieren, sowie den Export von Daten zur Verarbeitung in einem
    ERP-System. Einige Hinweise sind zu beachten: Ein gültiger Würfelname (pCube) ist erforderlich, sonst
    wird der Prozess abgebrochen. Alle anderen Parameter sind optional, jedoch sollte der Filter (pFilter)
    angegeben werden, um die Dateigröße zu beschränken. Der Standard-Ausgabepfad entspricht dem des Fehlerdateipfades.
    Da dieser TI eine Ansicht als Datenquelle nutzt, sind implizite Variablen wie NValue, SValue und Value_is_String
    erforderlich. Um diesen TI im Architect zu bearbeiten, wird empfohlen, einen temporären Würfel mit
    mindestens 24 Dimensionen als Voransichtsdatenquelle zu verwenden oder die Datenquelle auf ASCII zu
    setzen und die TI-Datei manuell im Editor zu bearbeiten, um die notwendigen impliziten Ansichtsvariablen
    hinzuzufügen. Wenn der Parameter pFilterParallel verwendet wird, darf die Dimension, die als "Parallelisierungsschicht"
    dient, nicht im pFilter-Parameter vorkommen. Bei der Parallelisierung mittels der *RunProcess*-Funktion
    werden die im pFilterParallel aufgeführten Elemente einzeln in rekursive Aufrufe des Prozesses übergeben
    und zum pFilter hinzugefügt. Der Dateiname wird mit dem jeweiligen Elementnamen erweitert. Eine Warnung
    ist zu erteilen: Da die *RunProcess*-Funktion derzeit keine Möglichkeit hat, den Zustand des aufgerufenen
    Prozesses zu überprüfen, kann dies dazu führen, dass TM1 alle verfügbaren Serverressourcen nutzt,
    wenn mehr Prozesse als verfügbare CPU-Kerne freigegeben werden. Dies kann zu Leistungsproblemen führen.
    Achten Sie darauf, dass die Anzahl der als Slicer-Elemente im pFilterParallel aufgeführten Elemente
    die verfügbare Anzahl an Kernen nicht überschreitet.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI is designed to export data in a given cube to a flat file\
    \ for a given 'slice' (any dimension/element combination).\n#\n# Use case: Intended for development/prototyping\
    \ or in Production environment.\n# 1. Export data for import into another TM1 model to eliminate possibility\
    \ of locking.\n# 2. Export data for import into ERP system.\n#\n# Note:\n# * Naturally, a valid cube\
    \ name (pCube) is mandatory otherwise the process will abort.\n# * All other parameters are optional,\
    \ however, the filter (pFilter) should be specified to limit the size of the file.\n# * The default\
    \ output path is the same as the error file path.\n# * As this TI has a view as a data source it requires\
    \ the implicit variables NValue, SValue and Value_is_String\n# * To edit this TI in Architect a tmp\
    \ cube with minimum 24 dims is needed as the preview data source or set the data\n#   source to ASCII\
    \ and manually edit the TI in notepad after saving to add back the required implicit view variables\n\
    # * If using the pFilterParallel parameter the **single dimension** used as the 'parallelization slicer'\
    \ cannot appear in\n#   the pFilter parameter\n# * When using parallelization via the *RunProcess*\
    \ function the elements listed in pFilterParallel will be split one_at_a_time\n#   and passed to a\
    \ recursive call of the process being added to pFilter. Each element name will also be appended to\
    \ the filename\n#\n# Warning:\n# As the *RunProcess* function currently has no mechanism to check\
    \ for the state of the called process if more processes are\n# released than available CPU cores on\
    \ the server then this could lead to TM1 consuming all available server resources and a\n# associated\
    \ performance issue. Be careful that the number of slicer elements listed in pFilterParallel should\
    \ not exceed the\n# number of available cores.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nStringGlobalVariable('sBedrockViewCreateParsedFilter');\n\
    \n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp\
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) *\
    \ 1000 ));\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%,\
    \ pView:%pView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%,\
    \ pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%, pSuppressZero:%pSuppressZero%,\
    \ pSuppressConsol:%pSuppressConsol%, pSuppressRules:%pSuppressRules%, pZeroSource:%pZeroSource%, pCubeLogging:%pCubeLogging%,\
    \ pTemp:%pTemp%, pFilePath:%pFilePath%, pFileName:%pFileName%, pDelim:%pDelim%, pQuote:%pQuote%, pTitleRecord:%pTitleRecord%,\
    \ pSandbox:%pSandbox%, pSuppressConsolStrings:%pSuppressConsolStrings%.';\ncDefaultView      = Expand(\
    \ '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\ncLenASCIICode     = 3;\n\npFieldDelim       = TRIM(pDelim);\n\
    pDimDelim         = TRIM(pDimDelim);\npEleStartDelim    = TRIM(pEleStartDelim);\npEleDelim       \
    \  = TRIM(pEleDelim);\npDecimalSeparator = TRIM(pDecimalSeparator);\npThousandSeparator= TRIM(pThousandSeparator);\n\
    nDataCount        = 0;\nnErrors           = 0;\n\n## Default filter delimiters\nIf( pDimDelim    \
    \ @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n    pEleStartDelim= '¦';\n\
    EndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\nEndIf;\nIf( pDecimalSeparator @= ''\
    \ );\n \tpDecimalSeparator = '.';\nEndIf;\nIf( pThousandSeparator @= '' );\n \tpThousandSeparator\
    \ = ',';\nEndIf;\nsDelimDim = pDimDelim;\nsElementStartDelim = pEleStartDelim;\nsDelimelem = pEleDelim;\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\nENDIF;\n\
    \n### Validate Parameters ###\n\n# If no cube has been specified then terminate process\nIf( Trim(\
    \ pCube ) @= '' );\n    sMessage = 'No cube specified.';\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage\
    \ = Expand( 'Cube: %pCube% does not exist.' );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate the View parameter\nIf( TRIM(pView) @= '' );\n\
    \    cView = cDefaultView ;\nElse ;\n    cView = pView ;\nEndIf;\ncSubset = cView;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim\
    \ = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim =\
    \ '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate file path\nIf(Trim( pFilePath\
    \ ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\nEndIf;\nIf( SubSt( pFilePath, Long( pFilePath\
    \ ), 1 ) @= sOSDelim );\n    pFilePath = SubSt( pFilePath, 1, Long( pFilePath ) -1 );\nEndIf;\nIf(\
    \  FileExists( pFilePath ) = 0 );\n    sMessage = Expand('Invalid export directory: %pFilePath%');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    pFilePath = pFilePath | sOSDelim;\n\n# Validate file name\nIf( pFileName @= '' );\n    sBaseFileName\
    \ = Expand('%pCube%_Export');\n    sExt = '.csv';\n    pFileName = sBaseFileName | '.csv';\nElse;\n\
    \    # determine file extension. If no file extension entered then use .csv as default\n    If( Scan(\
    \ '.', pFileName ) = 0 );\n        sExt = '.csv';\n        sBaseFileName = pFileName;\n    Else;\n\
    \        sExt = SubSt( pFileName, Scan( '.', pFileName ), Long( pFileName ) );\n        sBaseFileName\
    \ = SubSt( pFileName, 1, Scan( '.', pFileName ) - 1 );\n    EndIf;\n    pFileName = sBaseFileName\
    \ | sExt;\nEndIf;\ncExportFile = pFilePath | pFileName;\n\n# Validate parallelization filter\nIf(\
    \ Scan( pEleStartDelim, pFilterParallel ) > 0 );\n    sDimParallel = SubSt( pFilterParallel, 1, Scan(\
    \ pEleStartDelim, pFilterParallel ) - 1 );\n    If( Scan( Lower(sDimParallel) | pEleStartDelim, Lower(pFilter)\
    \ ) > 0 );\n        sMessage = 'Parallelization dimension %sDimParallel% cannot exist in filter.';\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \    EndIf;\nEndIf;\n\n# Validate Max Threads\nIf( pParallelThreads > 0 );\n  nMaxThreads = pParallelThreads;\n\
    Else;\n  nMaxThreads = 1;\nEndIf;\n\n# Validate file delimiter & quote character\nIf( pFieldDelim\
    \ @= '' );\n    pFieldDelim = ',';\nElse;\n    # If length of pFieldDelim is exactly 3 chars and each\
    \ of them is decimal digit, then the pFieldDelim is entered as ASCII code\n    nValid = 0;\n    If\
    \ ( LONG(pFieldDelim) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n\
    \        If( CODE( pFieldDelim, nChar ) >= CODE( '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE( '9',\
    \ 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n          Break;\n        EndIf;\n\
    \        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pFieldDelim=CHAR(StringToNumber(\
    \ pFieldDelim ));\n    Else;\n      pFieldDelim = SubSt( Trim( pFieldDelim ), 1, 1 );\n    EndIf;\n\
    EndIf;\n\nIf( pQuote @= '' );\n    ## Use no quote character\nElse;\n    # If length of pQuote is\
    \ exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII code\n  \
    \  nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <=\
    \ cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <=\
    \ CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n          Break;\n\
    \        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n     \
    \ pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n\
    \    EndIf;\nEndIf;\n\nIf ( LONG(pDecimalSeparator) = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n\
    \  While ( nChar <= cLenASCIICode );\n    If( CODE( pDecimalSeparator, nChar ) >= CODE( '0', 1 ) &\
    \ CODE( pDecimalSeparator, nChar ) <= CODE( '9', 1 ) );\n      nValid = 1;\n    Else;\n      nValid\
    \ = 0;\n      Break;\n    EndIf;\n    nChar = nChar + 1;\n  End;\n  If ( nValid<>0 );\n    pDecimalSeparator\
    \ = CHAR(StringToNumber( pDecimalSeparator ));\n  Else;\n    pDecimalSeparator = SubSt( Trim( pDecimalSeparator\
    \ ), 1, 1 );\n  EndIf;\nEndIf;\nsDecimalSeparator = pDecimalSeparator;\n\nIf ( LONG(pThousandSeparator)\
    \ = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n    If( CODE(\
    \ pThousandSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pThousandSeparator, nChar ) <= CODE( '9',\
    \ 1 ) );\n      nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n    EndIf;\n    nChar = nChar\
    \ + 1;\n  End;\n  If ( nValid<>0 );\n    pThousandSeparator = CHAR(StringToNumber( pThousandSeparator\
    \ ));\n  Else;\n    pThousandSeparator = SubSt( Trim( pThousandSeparator ), 1, 1 );\n  EndIf;\nEndIf;\n\
    sThousandSeparator = pThousandSeparator;\n\n# Validate Sandbox\nIf( TRIM( pSandbox ) @<> '' );\n \
    \   If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty( 0 );\n      \
    \  nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is invalid for the current\
    \ user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n        ServerActiveSandboxSet(\
    \ pSandbox );\n        SetUseActiveSandboxProperty( 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty(\
    \ 0 );\nEndIf;\n\n# Validate Character Set\nIf(Trim( pCharacterSet ) @= '' );\n  pCharacterSet = 'TM1CS_UTF8';\n\
    EndIf;\n\n# Jump to Epilog if any errors so far\nIF ( nErrors > 0 );\n    DataSourceType = 'NULL';\n\
    \    If( pStrictErrorHandling = 1 );\n        ProcessQuit;\n    Else;\n        ProcessBreak;\n   \
    \ EndIf;\nENDIF;\n\n# Branch depending on whether to do recursive calls to self on independent threads\
    \ or run all in this thread\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n  sDimParallel =\
    \ SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n  sElementList = SubSt(\
    \ pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) + 1, Long( pFilterParallel ) );\n  If(\
    \ SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\n      sElementList = sElementList\
    \ | pEleDelim;\n  EndIf;\n  ## Counting elements in element list\n  sElementListCount = sElementList;\n\
    \  nElements = 0;\n  While( Scan( pEleDelim, sElementListCount ) > 0 );\n    nElements = nElements\
    \ + 1;\n    sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount ) + 1,\
    \ Long( sElementListCount ) );\n  End;\n  IF( Mod( nElements, nMaxThreads ) = 0 );\n    nElemsPerThread\
    \ = INT( nElements \\ nMaxThreads );\n  ELSE;\n    nElemsPerThread = INT( nElements \\ nMaxThreads\
    \ ) + 1;\n  ENDIF;\n  nThreadElCounter = 0;\n  While( Scan( pEleDelim, sElementList ) > 0 );\n   \
    \   sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\n      sElementList\
    \ = SubSt( sElementList, Scan( pEleDelim, sElementList ) + 1, Long( sElementList ) );\n      # Do\
    \ recursive process call with new RunProcess function\n      nThreadElCounter = nThreadElCounter +\
    \ 1;\n      sDimDelim = If(pFilter @= '', '', pDimDelim );\n      IF( nThreadElCounter = 1 );\n  \
    \      sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n     \
    \   sFileName = Expand('%sBaseFileName%_%sDimParallel%_%sSlicerEle%');\n      ELSE;\n        sFilter\
    \ = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n        sFileName = Expand('%sFileName%+%sSlicerEle%');\n\
    \      ENDIF;\n      IF( nThreadElCounter >= nElemsPerThread );\n        sFileName = Expand('%sFileName%%sExt%');\n\
    \        RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n        \t'pCube', pCube, 'pView',\
    \ '',\n        \t'pFilter', sFilter, 'pFilterParallel', '',\n        \t'pDimDelim', pDimDelim, 'pEleStartDelim',\
    \ pEleStartDelim, 'pEleDelim', pEleDelim,\n        \t'pSuppressZero', pSuppressZero, 'pSuppressConsol',\
    \ pSuppressConsol, 'pSuppressRules', pSuppressRules,\n        \t'pZeroSource', pZeroSource, 'pCubeLogging',\
    \ pCubeLogging,\n        \t'pTemp', pTemp, 'pFilePath', pFilePath, 'pFileName', sFileName,\n     \
    \   \t'pDelim', pFieldDelim, 'pDecimalSeparator', pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n\
    \          'pQuote', pQuote, 'pTitleRecord', pTitleRecord, 'pSandbox', pSandbox, 'pSuppressConsolStrings',\
    \ pSuppressConsolStrings\n        );\n    \t  nThreadElCounter = 0;\n    \t  sFilter = '';\n    \t\
    \  sFileName = '';\n    \t ENDIF;\n  End;\n  ## Process last elements - only when filter is not empty\
    \ (there are still elements)\n  IF( sFilter @<> '' );\n    sFileName = Expand('%sFileName%%sExt%');\n\
    \    RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n    \t'pCube', pCube, 'pView', '',\n  \
    \  \t'pFilter', sFilter, 'pFilterParallel', '',\n    \t'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim,\
    \ 'pEleDelim', pEleDelim,\n    \t'pSuppressZero', pSuppressZero, 'pSuppressConsol', pSuppressConsol,\
    \ 'pSuppressRules', pSuppressRules,\n    \t'pZeroSource', pZeroSource, 'pCubeLogging', pCubeLogging,\n\
    \    \t'pTemp', pTemp, 'pFilePath', pFilePath, 'pFileName', sFileName,\n    \t'pDelim', pFieldDelim,\
    \ 'pDecimalSeparator', pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n      'pQuote',\
    \ pQuote, 'pTitleRecord', pTitleRecord, 'pSandbox', pSandbox, 'pSuppressConsolStrings', pSuppressConsolStrings\n\
    \    );\n  ENDIF;\n  DataSourceType = 'NULL';\n  nParallelRun = 1;\nElse;\n  # No parallelization\
    \ is being used. Proceed as normal and do everything internally\n\n  # Determine number of dims in\
    \ source cube & create strings to expand on title and rows\n  nCount = 1;\n  nDimensionIndex = 0;\n\
    \n  ## Skip cube name from export\n  IF (pCubeNameExport = 0);\n    sTitle = '';\n    sRow = '';\n\
    \n    While( TabDim( pCube, nCount ) @<> '' );\n        sDimension = TabDim( pCube, nCount );\n\n\
    \        ## Determine title string for the source cube\n        sTitle = sTitle|'%pQuote%'|sDimension|'%pQuote%%pFieldDelim%';\n\
    \        # Determine row string for the source cube\n        sRow = sRow|'%pQuote%%V'| numbertostring(nCount)\
    \ |'%%pQuote%%pFieldDelim%';\n\n        nCount = nCount + 1;\n    End;\n    nDimensionCount = nCount\
    \ - 1;\n\n    # Finish off the strings\n    sTitle = sTitle|'%pQuote%Value%pQuote%';\n    sRow = sRow|'%pQuote%%sValue%%pQuote%';\n\
    \n  ELSE;\n    sTitle = '%pQuote%Cube%pQuote%';\n    sRow = '%pQuote%%pCube%%pQuote%';\n\n    While(\
    \ TabDim( pCube, nCount ) @<> '' );\n        sDimension = TabDim( pCube, nCount );\n\n        ## Determine\
    \ title string for the source cube\n        sTitle = sTitle|'%pFieldDelim%%pQuote%'|sDimension|'%pQuote%';\n\
    \        # Determine row string for the source cube\n        sRow = sRow|'%pFieldDelim%%pQuote%%V'|\
    \ numbertostring(nCount) |'%%pQuote%';\n\n        nCount = nCount + 1;\n    End;\n    nDimensionCount\
    \ = nCount - 1;\n\n    # Finish off the strings\n    sTitle = sTitle|'%pFieldDelim%%pQuote%Value%pQuote%';\n\
    \    sRow = sRow|'%pFieldDelim%%pQuote%%sValue%%pQuote%';\n  ENDIF;\n\n  # Create Processing View\
    \ for source version\n  nRet = ExecuteProcess('}bedrock.cube.view.create',\n          'pLogOutput',\
    \ pLogOutput,\n          'pStrictErrorHandling', pStrictErrorHandling,\n          'pCube', pCube,\n\
    \          'pView', cView,\n          'pFilter', pFilter,\n          'pSuppressZero', pSuppressZero,\n\
    \          'pSuppressConsol', pSuppressConsol,\n          'pSuppressRules', pSuppressRules,\n    \
    \      'pSuppressConsolStrings', pSuppressConsolStrings,\n          'pDimDelim', pDimDelim,\n    \
    \      'pEleStartDelim', pEleStartDelim,\n          'pEleDelim', pEleDelim,\n          'pTemp', pTemp,\n\
    \          'pSubN', pSubN\n          );\n\n    # Validate Sandbox\n    If( TRIM( pSandbox ) @<> ''\
    \ );\n      If( ServerSandboxExists( pSandbox ) = 0 );\n          SetUseActiveSandboxProperty( 0 );\n\
    \          nErrors = nErrors + 1;\n          sMessage = Expand('Sandbox %pSandbox% is invalid for\
    \ the current user.');\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n     \
    \ Else;\n          ServerActiveSandboxSet( pSandbox );\n          SetUseActiveSandboxProperty( 1 );\n\
    \      EndIf;\n    Else;\n      SetUseActiveSandboxProperty( 0 );\n    EndIf;\n\n\n  IF( nRet <> ProcessExitNormal()\
    \ );\n      sMessage = 'Error creating the view from the filter.';\n      nErrors = nErrors + 1;\n\
    \      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      If( pStrictErrorHandling =\
    \ 1 );\n          ProcessQuit;\n      Else;\n          ProcessBreak;\n      EndIf;\n  ENDIF;\n\n \
    \ sParsedFilter = sBedrockViewCreateParsedFilter;\n  sFilterRow = '%pQuote%%pCube%%pQuote%%pFieldDelim%%pQuote%Filter%pQuote%%pFieldDelim%%pQuote%%sParsedFilter%%pQuote%%pFieldDelim%%pQuote%%pDimDelim%%pQuote%%pFieldDelim%%pQuote%%pEleStartDelim%%pQuote%%pFieldDelim%%pQuote%%pEleDelim%%pQuote%';\n\
    \n  # Assign Datasource\n  DataSourceType          = 'VIEW';\n  DatasourceNameForServer = pCube;\n\
    \  DatasourceNameForClient = pCube;\n  DatasourceCubeView      = cView;\n  DatasourceAsciiDelimiter=\
    \ pFieldDelim;\n  DatasourceAsciiQuoteCharacter = '';\n  nParallelRun = 0;\nEndIf;\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n# Set\
    \ the output character set\nSetOutputCharacterSet( cExportFile, pCharacterSet );\n\n### Data Count\
    \ ###\nnDataCount = nDataCount + 1;\n\n# Output the title string\nIF( nDataCount = 1 & pTitleRecord\
    \ >= 1 );\n    TextOutput( cExportFile, Expand(sTitle) );\nEndif;\n\n### Export filter into the 1st\
    \ record of the file, it will be used from import process to zero out the corresponding slice, if\
    \ specified\nIF( nDataCount = 1 & pTitleRecord = 2 );\n    TextOutput( cExportFile, Expand(sFilterRow)\
    \ );\nEndif;\n\n### Export data from source version to file ###\nIf( value_is_string = 0 );\n    sValue\
    \ = NumberToStringEx( nValue, '#,0.#############', sDecimalSeparator, sThousandSeparator );\nEndIf;\n\
    \n# Selects the correct TextOutput formula depending upon the number of dimensions in the cube\nIF(SCAN(\
    \ CHAR( 10 ), sValue ) > 0 );\n    sValueCleaned = '';\n    nNoChar = 1;\n    nLimit = LONG( sValue\
    \ );\n    WHILE( nNoChar <= nLimit ) ;\n        sChar = SUBST(  sValue, nNoChar, 1 );\n        IF(\
    \ CODE( sChar, 1 ) <> 10 );\n            sValueCleaned = sValueCleaned | sChar ;\n        ELSE;\n\
    \            sValueCleaned = sValueCleaned | ' ';\n        ENDIF;\n        nNoChar = nNoChar + 1;\n\
    \    END;\n    sValue = sValueCleaned;\nENDIF;\n\n# Output data\nTextOutput( cExportFile, Expand(sRow)\
    \ );\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Delete source data ###\nIf( pZeroSource = 1 & nErrors = 0 & nParallelRun =\
    \ 0 );\n    If ( pCubeLogging <= 1 );\n      sCubeLogging = CellGetS('}CubeProperties', pCube, 'LOGGING'\
    \ );\n      CubeSetLogChanges( pCube, pCubeLogging);\n    EndIf;\n    ViewZeroOut( pCube, cView );\n\
    \    If ( pCubeLogging <= 1 );\n      CubeSetLogChanges( pCube, IF(sCubeLogging@='YES',1,0) );\n \
    \   EndIf;\nEndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 );\n        ProcessQuit;\n    EndIf;\nElse;\n\
    \    sDataCount = NUMBERTOSTRING (nDataCount);\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ exported %sDataCount% records from %pCube% based on filter %pFilter%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\n    EndIf;\n\nEndIf ;\n\n### End\
    \ Epilog ###"
- question: 'The described Turbo Integrator process is designed to export data from a specified cube to
    a flat file for a given "slice" (any dimension/element combination). This process can be used both
    in development/prototyping and production environments. The main use cases include: exporting data
    for import into another TM1 model to eliminate the possibility of locking, and exporting data for
    import into an ERP system. Some notes to keep in mind: A valid cube name (pCube) is mandatory, otherwise
    the process will abort. All other parameters are optional, but the filter (pFilter) should be specified
    to limit the file size. The default output path is the same as the error file path. As this TI uses
    a view as a data source, it requires implicit variables such as NValue, SValue, and Value_is_String.
    To edit this TI in Architect, it is recommended to use a temporary cube with a minimum of 24 dimensions
    as the preview data source or set the data source to ASCII and manually edit the TI file in a text
    editor to add back the necessary implicit view variables. If using the pFilterParallel parameter,
    the single dimension used as the "parallelization slicer" cannot appear in the pFilter parameter.
    When using parallelization via the *RunProcess* function, elements listed in pFilterParallel will
    be split one at a time and passed to a recursive call of the process being added to pFilter. The filename
    will be appended with each element name. A warning to issue: As the *RunProcess* function currently
    has no mechanism to check the state of the called process, it can lead to TM1 consuming all available
    server resources if more processes are released than available CPU cores, potentially causing performance
    issues. Ensure the number of slicer elements listed in pFilterParallel does not exceed the number
    of available cores.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI is designed to export data in a given cube to a flat file\
    \ for a given 'slice' (any dimension/element combination).\n#\n# Use case: Intended for development/prototyping\
    \ or in Production environment.\n# 1. Export data for import into another TM1 model to eliminate possibility\
    \ of locking.\n# 2. Export data for import into ERP system.\n#\n# Note:\n# * Naturally, a valid cube\
    \ name (pCube) is mandatory otherwise the process will abort.\n# * All other parameters are optional,\
    \ however, the filter (pFilter) should be specified to limit the size of the file.\n# * The default\
    \ output path is the same as the error file path.\n# * As this TI has a view as a data source it requires\
    \ the implicit variables NValue, SValue and Value_is_String\n# * To edit this TI in Architect a tmp\
    \ cube with minimum 24 dims is needed as the preview data source or set the data\n#   source to ASCII\
    \ and manually edit the TI in notepad after saving to add back the required implicit view variables\n\
    # * If using the pFilterParallel parameter the **single dimension** used as the 'parallelization slicer'\
    \ cannot appear in\n#   the pFilter parameter\n# * When using parallelization via the *RunProcess*\
    \ function the elements listed in pFilterParallel will be split one_at_a_time\n#   and passed to a\
    \ recursive call of the process being added to pFilter. Each element name will also be appended to\
    \ the filename\n#\n# Warning:\n# As the *RunProcess* function currently has no mechanism to check\
    \ for the state of the called process if more processes are\n# released than available CPU cores on\
    \ the server then this could lead to TM1 consuming all available server resources and a\n# associated\
    \ performance issue. Be careful that the number of slicer elements listed in pFilterParallel should\
    \ not exceed the\n# number of available cores.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nStringGlobalVariable('sBedrockViewCreateParsedFilter');\n\
    \n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp\
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) *\
    \ 1000 ));\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%,\
    \ pView:%pView%, pFilter:%pFilter%, pFilterParallel:%pFilterParallel%, pParallelThreads:%pParallelThreads%,\
    \ pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%, pSuppressZero:%pSuppressZero%,\
    \ pSuppressConsol:%pSuppressConsol%, pSuppressRules:%pSuppressRules%, pZeroSource:%pZeroSource%, pCubeLogging:%pCubeLogging%,\
    \ pTemp:%pTemp%, pFilePath:%pFilePath%, pFileName:%pFileName%, pDelim:%pDelim%, pQuote:%pQuote%, pTitleRecord:%pTitleRecord%,\
    \ pSandbox:%pSandbox%, pSuppressConsolStrings:%pSuppressConsolStrings%.';\ncDefaultView      = Expand(\
    \ '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\ncLenASCIICode     = 3;\n\npFieldDelim       = TRIM(pDelim);\n\
    pDimDelim         = TRIM(pDimDelim);\npEleStartDelim    = TRIM(pEleStartDelim);\npEleDelim       \
    \  = TRIM(pEleDelim);\npDecimalSeparator = TRIM(pDecimalSeparator);\npThousandSeparator= TRIM(pThousandSeparator);\n\
    nDataCount        = 0;\nnErrors           = 0;\n\n## Default filter delimiters\nIf( pDimDelim    \
    \ @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n    pEleStartDelim= '¦';\n\
    EndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\nEndIf;\nIf( pDecimalSeparator @= ''\
    \ );\n \tpDecimalSeparator = '.';\nEndIf;\nIf( pThousandSeparator @= '' );\n \tpThousandSeparator\
    \ = ',';\nEndIf;\nsDelimDim = pDimDelim;\nsElementStartDelim = pEleStartDelim;\nsDelimelem = pEleDelim;\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\nENDIF;\n\
    \n### Validate Parameters ###\n\n# If no cube has been specified then terminate process\nIf( Trim(\
    \ pCube ) @= '' );\n    sMessage = 'No cube specified.';\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage\
    \ = Expand( 'Cube: %pCube% does not exist.' );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate the View parameter\nIf( TRIM(pView) @= '' );\n\
    \    cView = cDefaultView ;\nElse ;\n    cView = pView ;\nEndIf;\ncSubset = cView;\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim\
    \ = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim =\
    \ '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate file path\nIf(Trim( pFilePath\
    \ ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\nEndIf;\nIf( SubSt( pFilePath, Long( pFilePath\
    \ ), 1 ) @= sOSDelim );\n    pFilePath = SubSt( pFilePath, 1, Long( pFilePath ) -1 );\nEndIf;\nIf(\
    \  FileExists( pFilePath ) = 0 );\n    sMessage = Expand('Invalid export directory: %pFilePath%');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    pFilePath = pFilePath | sOSDelim;\n\n# Validate file name\nIf( pFileName @= '' );\n    sBaseFileName\
    \ = Expand('%pCube%_Export');\n    sExt = '.csv';\n    pFileName = sBaseFileName | '.csv';\nElse;\n\
    \    # determine file extension. If no file extension entered then use .csv as default\n    If( Scan(\
    \ '.', pFileName ) = 0 );\n        sExt = '.csv';\n        sBaseFileName = pFileName;\n    Else;\n\
    \        sExt = SubSt( pFileName, Scan( '.', pFileName ), Long( pFileName ) );\n        sBaseFileName\
    \ = SubSt( pFileName, 1, Scan( '.', pFileName ) - 1 );\n    EndIf;\n    pFileName = sBaseFileName\
    \ | sExt;\nEndIf;\ncExportFile = pFilePath | pFileName;\n\n# Validate parallelization filter\nIf(\
    \ Scan( pEleStartDelim, pFilterParallel ) > 0 );\n    sDimParallel = SubSt( pFilterParallel, 1, Scan(\
    \ pEleStartDelim, pFilterParallel ) - 1 );\n    If( Scan( Lower(sDimParallel) | pEleStartDelim, Lower(pFilter)\
    \ ) > 0 );\n        sMessage = 'Parallelization dimension %sDimParallel% cannot exist in filter.';\n\
    \        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \    EndIf;\nEndIf;\n\n# Validate Max Threads\nIf( pParallelThreads > 0 );\n  nMaxThreads = pParallelThreads;\n\
    Else;\n  nMaxThreads = 1;\nEndIf;\n\n# Validate file delimiter & quote character\nIf( pFieldDelim\
    \ @= '' );\n    pFieldDelim = ',';\nElse;\n    # If length of pFieldDelim is exactly 3 chars and each\
    \ of them is decimal digit, then the pFieldDelim is entered as ASCII code\n    nValid = 0;\n    If\
    \ ( LONG(pFieldDelim) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n\
    \        If( CODE( pFieldDelim, nChar ) >= CODE( '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE( '9',\
    \ 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n          Break;\n        EndIf;\n\
    \        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pFieldDelim=CHAR(StringToNumber(\
    \ pFieldDelim ));\n    Else;\n      pFieldDelim = SubSt( Trim( pFieldDelim ), 1, 1 );\n    EndIf;\n\
    EndIf;\n\nIf( pQuote @= '' );\n    ## Use no quote character\nElse;\n    # If length of pQuote is\
    \ exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII code\n  \
    \  nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <=\
    \ cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <=\
    \ CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n          Break;\n\
    \        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n     \
    \ pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n\
    \    EndIf;\nEndIf;\n\nIf ( LONG(pDecimalSeparator) = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n\
    \  While ( nChar <= cLenASCIICode );\n    If( CODE( pDecimalSeparator, nChar ) >= CODE( '0', 1 ) &\
    \ CODE( pDecimalSeparator, nChar ) <= CODE( '9', 1 ) );\n      nValid = 1;\n    Else;\n      nValid\
    \ = 0;\n      Break;\n    EndIf;\n    nChar = nChar + 1;\n  End;\n  If ( nValid<>0 );\n    pDecimalSeparator\
    \ = CHAR(StringToNumber( pDecimalSeparator ));\n  Else;\n    pDecimalSeparator = SubSt( Trim( pDecimalSeparator\
    \ ), 1, 1 );\n  EndIf;\nEndIf;\nsDecimalSeparator = pDecimalSeparator;\n\nIf ( LONG(pThousandSeparator)\
    \ = cLenASCIICode );\n  nValid = 0;\n  nChar = 1;\n  While ( nChar <= cLenASCIICode );\n    If( CODE(\
    \ pThousandSeparator, nChar ) >= CODE( '0', 1 ) & CODE( pThousandSeparator, nChar ) <= CODE( '9',\
    \ 1 ) );\n      nValid = 1;\n    Else;\n      nValid = 0;\n      Break;\n    EndIf;\n    nChar = nChar\
    \ + 1;\n  End;\n  If ( nValid<>0 );\n    pThousandSeparator = CHAR(StringToNumber( pThousandSeparator\
    \ ));\n  Else;\n    pThousandSeparator = SubSt( Trim( pThousandSeparator ), 1, 1 );\n  EndIf;\nEndIf;\n\
    sThousandSeparator = pThousandSeparator;\n\n# Validate Sandbox\nIf( TRIM( pSandbox ) @<> '' );\n \
    \   If( ServerSandboxExists( pSandbox ) = 0 );\n        SetUseActiveSandboxProperty( 0 );\n      \
    \  nErrors = nErrors + 1;\n        sMessage = Expand('Sandbox %pSandbox% is invalid for the current\
    \ user.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n        ServerActiveSandboxSet(\
    \ pSandbox );\n        SetUseActiveSandboxProperty( 1 );\n    EndIf;\nElse;\n    SetUseActiveSandboxProperty(\
    \ 0 );\nEndIf;\n\n# Validate Character Set\nIf(Trim( pCharacterSet ) @= '' );\n  pCharacterSet = 'TM1CS_UTF8';\n\
    EndIf;\n\n# Jump to Epilog if any errors so far\nIF ( nErrors > 0 );\n    DataSourceType = 'NULL';\n\
    \    If( pStrictErrorHandling = 1 );\n        ProcessQuit;\n    Else;\n        ProcessBreak;\n   \
    \ EndIf;\nENDIF;\n\n# Branch depending on whether to do recursive calls to self on independent threads\
    \ or run all in this thread\nIf( Scan( pEleStartDelim, pFilterParallel ) > 0 );\n  sDimParallel =\
    \ SubSt( pFilterParallel, 1, Scan( pEleStartDelim, pFilterParallel ) - 1 );\n  sElementList = SubSt(\
    \ pFilterParallel, Scan( pEleStartDelim, pFilterParallel ) + 1, Long( pFilterParallel ) );\n  If(\
    \ SubSt( sElementList, Long( sElementList ), 1 ) @<> pEleDelim );\n      sElementList = sElementList\
    \ | pEleDelim;\n  EndIf;\n  ## Counting elements in element list\n  sElementListCount = sElementList;\n\
    \  nElements = 0;\n  While( Scan( pEleDelim, sElementListCount ) > 0 );\n    nElements = nElements\
    \ + 1;\n    sElementListCount = SubSt( sElementListCount, Scan( pEleDelim, sElementListCount ) + 1,\
    \ Long( sElementListCount ) );\n  End;\n  IF( Mod( nElements, nMaxThreads ) = 0 );\n    nElemsPerThread\
    \ = INT( nElements \\ nMaxThreads );\n  ELSE;\n    nElemsPerThread = INT( nElements \\ nMaxThreads\
    \ ) + 1;\n  ENDIF;\n  nThreadElCounter = 0;\n  While( Scan( pEleDelim, sElementList ) > 0 );\n   \
    \   sSlicerEle = SubSt( sElementList, 1, Scan( pEleDelim, sElementList ) - 1 );\n      sElementList\
    \ = SubSt( sElementList, Scan( pEleDelim, sElementList ) + 1, Long( sElementList ) );\n      # Do\
    \ recursive process call with new RunProcess function\n      nThreadElCounter = nThreadElCounter +\
    \ 1;\n      sDimDelim = If(pFilter @= '', '', pDimDelim );\n      IF( nThreadElCounter = 1 );\n  \
    \      sFilter = Expand('%pFilter%%sDimDelim%%sDimParallel%%pEleStartDelim%%sSlicerEle%');\n     \
    \   sFileName = Expand('%sBaseFileName%_%sDimParallel%_%sSlicerEle%');\n      ELSE;\n        sFilter\
    \ = Expand('%sFilter%%pEleDelim%%sSlicerEle%');\n        sFileName = Expand('%sFileName%+%sSlicerEle%');\n\
    \      ENDIF;\n      IF( nThreadElCounter >= nElemsPerThread );\n        sFileName = Expand('%sFileName%%sExt%');\n\
    \        RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n        \t'pCube', pCube, 'pView',\
    \ '',\n        \t'pFilter', sFilter, 'pFilterParallel', '',\n        \t'pDimDelim', pDimDelim, 'pEleStartDelim',\
    \ pEleStartDelim, 'pEleDelim', pEleDelim,\n        \t'pSuppressZero', pSuppressZero, 'pSuppressConsol',\
    \ pSuppressConsol, 'pSuppressRules', pSuppressRules,\n        \t'pZeroSource', pZeroSource, 'pCubeLogging',\
    \ pCubeLogging,\n        \t'pTemp', pTemp, 'pFilePath', pFilePath, 'pFileName', sFileName,\n     \
    \   \t'pDelim', pFieldDelim, 'pDecimalSeparator', pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n\
    \          'pQuote', pQuote, 'pTitleRecord', pTitleRecord, 'pSandbox', pSandbox, 'pSuppressConsolStrings',\
    \ pSuppressConsolStrings\n        );\n    \t  nThreadElCounter = 0;\n    \t  sFilter = '';\n    \t\
    \  sFileName = '';\n    \t ENDIF;\n  End;\n  ## Process last elements - only when filter is not empty\
    \ (there are still elements)\n  IF( sFilter @<> '' );\n    sFileName = Expand('%sFileName%%sExt%');\n\
    \    RunProcess( cThisProcName, 'pLogoutput', pLogoutput,\n    \t'pCube', pCube, 'pView', '',\n  \
    \  \t'pFilter', sFilter, 'pFilterParallel', '',\n    \t'pDimDelim', pDimDelim, 'pEleStartDelim', pEleStartDelim,\
    \ 'pEleDelim', pEleDelim,\n    \t'pSuppressZero', pSuppressZero, 'pSuppressConsol', pSuppressConsol,\
    \ 'pSuppressRules', pSuppressRules,\n    \t'pZeroSource', pZeroSource, 'pCubeLogging', pCubeLogging,\n\
    \    \t'pTemp', pTemp, 'pFilePath', pFilePath, 'pFileName', sFileName,\n    \t'pDelim', pFieldDelim,\
    \ 'pDecimalSeparator', pDecimalSeparator, 'pThousandSeparator', pThousandSeparator,\n      'pQuote',\
    \ pQuote, 'pTitleRecord', pTitleRecord, 'pSandbox', pSandbox, 'pSuppressConsolStrings', pSuppressConsolStrings\n\
    \    );\n  ENDIF;\n  DataSourceType = 'NULL';\n  nParallelRun = 1;\nElse;\n  # No parallelization\
    \ is being used. Proceed as normal and do everything internally\n\n  # Determine number of dims in\
    \ source cube & create strings to expand on title and rows\n  nCount = 1;\n  nDimensionIndex = 0;\n\
    \n  ## Skip cube name from export\n  IF (pCubeNameExport = 0);\n    sTitle = '';\n    sRow = '';\n\
    \n    While( TabDim( pCube, nCount ) @<> '' );\n        sDimension = TabDim( pCube, nCount );\n\n\
    \        ## Determine title string for the source cube\n        sTitle = sTitle|'%pQuote%'|sDimension|'%pQuote%%pFieldDelim%';\n\
    \        # Determine row string for the source cube\n        sRow = sRow|'%pQuote%%V'| numbertostring(nCount)\
    \ |'%%pQuote%%pFieldDelim%';\n\n        nCount = nCount + 1;\n    End;\n    nDimensionCount = nCount\
    \ - 1;\n\n    # Finish off the strings\n    sTitle = sTitle|'%pQuote%Value%pQuote%';\n    sRow = sRow|'%pQuote%%sValue%%pQuote%';\n\
    \n  ELSE;\n    sTitle = '%pQuote%Cube%pQuote%';\n    sRow = '%pQuote%%pCube%%pQuote%';\n\n    While(\
    \ TabDim( pCube, nCount ) @<> '' );\n        sDimension = TabDim( pCube, nCount );\n\n        ## Determine\
    \ title string for the source cube\n        sTitle = sTitle|'%pFieldDelim%%pQuote%'|sDimension|'%pQuote%';\n\
    \        # Determine row string for the source cube\n        sRow = sRow|'%pFieldDelim%%pQuote%%V'|\
    \ numbertostring(nCount) |'%%pQuote%';\n\n        nCount = nCount + 1;\n    End;\n    nDimensionCount\
    \ = nCount - 1;\n\n    # Finish off the strings\n    sTitle = sTitle|'%pFieldDelim%%pQuote%Value%pQuote%';\n\
    \    sRow = sRow|'%pFieldDelim%%pQuote%%sValue%%pQuote%';\n  ENDIF;\n\n  # Create Processing View\
    \ for source version\n  nRet = ExecuteProcess('}bedrock.cube.view.create',\n          'pLogOutput',\
    \ pLogOutput,\n          'pStrictErrorHandling', pStrictErrorHandling,\n          'pCube', pCube,\n\
    \          'pView', cView,\n          'pFilter', pFilter,\n          'pSuppressZero', pSuppressZero,\n\
    \          'pSuppressConsol', pSuppressConsol,\n          'pSuppressRules', pSuppressRules,\n    \
    \      'pSuppressConsolStrings', pSuppressConsolStrings,\n          'pDimDelim', pDimDelim,\n    \
    \      'pEleStartDelim', pEleStartDelim,\n          'pEleDelim', pEleDelim,\n          'pTemp', pTemp,\n\
    \          'pSubN', pSubN\n          );\n\n    # Validate Sandbox\n    If( TRIM( pSandbox ) @<> ''\
    \ );\n      If( ServerSandboxExists( pSandbox ) = 0 );\n          SetUseActiveSandboxProperty( 0 );\n\
    \          nErrors = nErrors + 1;\n          sMessage = Expand('Sandbox %pSandbox% is invalid for\
    \ the current user.');\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n     \
    \ Else;\n          ServerActiveSandboxSet( pSandbox );\n          SetUseActiveSandboxProperty( 1 );\n\
    \      EndIf;\n    Else;\n      SetUseActiveSandboxProperty( 0 );\n    EndIf;\n\n\n  IF( nRet <> ProcessExitNormal()\
    \ );\n      sMessage = 'Error creating the view from the filter.';\n      nErrors = nErrors + 1;\n\
    \      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      If( pStrictErrorHandling =\
    \ 1 );\n          ProcessQuit;\n      Else;\n          ProcessBreak;\n      EndIf;\n  ENDIF;\n\n \
    \ sParsedFilter = sBedrockViewCreateParsedFilter;\n  sFilterRow = '%pQuote%%pCube%%pQuote%%pFieldDelim%%pQuote%Filter%pQuote%%pFieldDelim%%pQuote%%sParsedFilter%%pQuote%%pFieldDelim%%pQuote%%pDimDelim%%pQuote%%pFieldDelim%%pQuote%%pEleStartDelim%%pQuote%%pFieldDelim%%pQuote%%pEleDelim%%pQuote%';\n\
    \n  # Assign Datasource\n  DataSourceType          = 'VIEW';\n  DatasourceNameForServer = pCube;\n\
    \  DatasourceNameForClient = pCube;\n  DatasourceCubeView      = cView;\n  DatasourceAsciiDelimiter=\
    \ pFieldDelim;\n  DatasourceAsciiQuoteCharacter = '';\n  nParallelRun = 0;\nEndIf;\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n# Set\
    \ the output character set\nSetOutputCharacterSet( cExportFile, pCharacterSet );\n\n### Data Count\
    \ ###\nnDataCount = nDataCount + 1;\n\n# Output the title string\nIF( nDataCount = 1 & pTitleRecord\
    \ >= 1 );\n    TextOutput( cExportFile, Expand(sTitle) );\nEndif;\n\n### Export filter into the 1st\
    \ record of the file, it will be used from import process to zero out the corresponding slice, if\
    \ specified\nIF( nDataCount = 1 & pTitleRecord = 2 );\n    TextOutput( cExportFile, Expand(sFilterRow)\
    \ );\nEndif;\n\n### Export data from source version to file ###\nIf( value_is_string = 0 );\n    sValue\
    \ = NumberToStringEx( nValue, '#,0.#############', sDecimalSeparator, sThousandSeparator );\nEndIf;\n\
    \n# Selects the correct TextOutput formula depending upon the number of dimensions in the cube\nIF(SCAN(\
    \ CHAR( 10 ), sValue ) > 0 );\n    sValueCleaned = '';\n    nNoChar = 1;\n    nLimit = LONG( sValue\
    \ );\n    WHILE( nNoChar <= nLimit ) ;\n        sChar = SUBST(  sValue, nNoChar, 1 );\n        IF(\
    \ CODE( sChar, 1 ) <> 10 );\n            sValueCleaned = sValueCleaned | sChar ;\n        ELSE;\n\
    \            sValueCleaned = sValueCleaned | ' ';\n        ENDIF;\n        nNoChar = nNoChar + 1;\n\
    \    END;\n    sValue = sValueCleaned;\nENDIF;\n\n# Output data\nTextOutput( cExportFile, Expand(sRow)\
    \ );\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Delete source data ###\nIf( pZeroSource = 1 & nErrors = 0 & nParallelRun =\
    \ 0 );\n    If ( pCubeLogging <= 1 );\n      sCubeLogging = CellGetS('}CubeProperties', pCube, 'LOGGING'\
    \ );\n      CubeSetLogChanges( pCube, pCubeLogging);\n    EndIf;\n    ViewZeroOut( pCube, cView );\n\
    \    If ( pCubeLogging <= 1 );\n      CubeSetLogChanges( pCube, IF(sCubeLogging@='YES',1,0) );\n \
    \   EndIf;\nEndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 );\n        ProcessQuit;\n    EndIf;\nElse;\n\
    \    sDataCount = NUMBERTOSTRING (nDataCount);\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ exported %sDataCount% records from %pCube% based on filter %pFilter%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );\n    EndIf;\n\nEndIf ;\n\n### End\
    \ Epilog ###"
- question: 'Dieser Turbo Integrator-Prozess von IBM dient dazu, Daten auf der Festplatte für die in den
    Parametern angegebenen Würfel zu speichern. Anwendungsfall: Der Prozess ist für Entwicklungs- oder
    Produktionsumgebungen gedacht. Er wird immer dann verwendet, wenn Daten für einen bestimmten Würfel
    gespeichert werden müssen, zum Beispiel nach dem Laden von Daten, um einen bestimmten Würfel zu sichern,
    oder bei manuellen Eingabewürfeln. Hinweis: Ein gültiger Würfelname (pCube) ist zwingend erforderlich,
    andernfalls wird der Prozess abgebrochen. Platzhalter und Listen sind akzeptabel. Dieser Prozess speichert
    die Daten für einen Würfel.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process save data to disk for the cubes provided in parameter.\n\
    \n# Use case: Intended for Development or production.\n#1/ This process would be used any time data\
    \ for a specific cube need to be saved (i.e.: After a data loading to save a specific cube or or for\
    \ manual entry cubes).\n\n# Note:\n# Naturally, a valid  cube name (pCube) is mandatory otherwise\
    \ the process will abort. Wildcards and lists are acceptable.\n# This process will save data for a\
    \ cube.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName = TM1User();\n\
    cTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\nsMessage = \t'';\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\nnErrors = 0;\n\n### Validate Parameters ###\n# If blank delimiter specified then\
    \ convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# If no cubes have been specified\
    \ then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'No cubes specified';\n  nErrors\
    \ = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n### SET\
    \ DATA SOURCE ###\n\nDatasourceType = 'NULL';\n\n\n### Split parameter into individual cubes and delete\
    \ ###\n\nsCubes = pCube;\nnDelimiterIndex = 1;\nsMdx = '';\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex\
    \ = Scan( pDelim, sCubes );\n  If( nDelimiterIndex = 0 );\n    sCube = sCubes;\n  Else;\n    sCube\
    \ = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n    sCubes = Trim( Subst( sCubes, nDelimiterIndex\
    \ + Long(pDelim), Long( sCubes ) ) );\n  EndIf;\n  \n  # Check if a wildcard has been used to specify\
    \ the Cube name.\n  # If it hasn't then just delete the Cube if it exists\n      # If it has then\
    \ search the relevant Cube folder to find the matches\n      If( Scan( '*', sCube ) = 0 );\n     \
    \   If( CubeExists( sCube ) = 1 ); \n          CubeSaveData( sCube );\n        Endif;\n      Else;\n\
    \        # Create subset of cubes using Wildcard\n        sCubeExp = '''|sCube|''';\n        sMdxPart\
    \ = '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'| sCubeExp | ')}';\n        IF( sMdx @= '');\
    \ \n          sMdx = sMdxPart; \n        ELSE;\n          sMdx = sMdx | ' + ' | sMdxPart;\n      \
    \  ENDIF;\n        \n        If( SubsetExists( '}Cubes' , cTempSub ) = 1 );\n            # If a delimited\
    \ list of cube names includes wildcards then we may have to re-use the subset multiple times\n   \
    \         SubsetMDXSet( '}Cubes' , cTempSub, sMDX );\n        Else;\n            # temp subset, therefore\
    \ no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n \
    \       EndIf;\n        \n        # Loop through cubes in subset created based on wildcard\n     \
    \   nCountCubes = SubsetGetSize( '}Cubes' , cTempSub );\n        While( nCountCubes >= 1 );\n    \
    \      sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCubes );\n          # Validate\
    \ cube name\n          If( CubeExists( sCurrCube ) = 1 ); \n            # Save data\n            CubeSaveData(\
    \ sCurrCube );\n          Endif;\n            nCountCubes = nCountCubes - 1;\n        End;\n     \
    \ EndIf;\n\nEnd;\n\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    ### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully saved data for cube %pCube% .' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n\n### End\
    \ Epilog ###"
- question: 'This IBM Turbo Integrator process is designed to save data to disk for the cubes provided
    in the parameters. Use case: The process is intended for development or production environments. It
    is used whenever data for a specific cube needs to be saved, for instance, after loading data to save
    a specific cube or for manual entry cubes. Note: A valid cube name (pCube) is mandatory; otherwise,
    the process will abort. Wildcards and lists are acceptable. This process will save data for a cube'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process save data to disk for the cubes provided in parameter.\n\
    \n# Use case: Intended for Development or production.\n#1/ This process would be used any time data\
    \ for a specific cube need to be saved (i.e.: After a data loading to save a specific cube or or for\
    \ manual entry cubes).\n\n# Note:\n# Naturally, a valid  cube name (pCube) is mandatory otherwise\
    \ the process will abort. Wildcards and lists are acceptable.\n# This process will save data for a\
    \ cube.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName = TM1User();\n\
    cTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\nsMessage = \t'';\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\nnErrors = 0;\n\n### Validate Parameters ###\n# If blank delimiter specified then\
    \ convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# If no cubes have been specified\
    \ then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'No cubes specified';\n  nErrors\
    \ = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n### SET\
    \ DATA SOURCE ###\n\nDatasourceType = 'NULL';\n\n\n### Split parameter into individual cubes and delete\
    \ ###\n\nsCubes = pCube;\nnDelimiterIndex = 1;\nsMdx = '';\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex\
    \ = Scan( pDelim, sCubes );\n  If( nDelimiterIndex = 0 );\n    sCube = sCubes;\n  Else;\n    sCube\
    \ = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n    sCubes = Trim( Subst( sCubes, nDelimiterIndex\
    \ + Long(pDelim), Long( sCubes ) ) );\n  EndIf;\n  \n  # Check if a wildcard has been used to specify\
    \ the Cube name.\n  # If it hasn't then just delete the Cube if it exists\n      # If it has then\
    \ search the relevant Cube folder to find the matches\n      If( Scan( '*', sCube ) = 0 );\n     \
    \   If( CubeExists( sCube ) = 1 ); \n          CubeSaveData( sCube );\n        Endif;\n      Else;\n\
    \        # Create subset of cubes using Wildcard\n        sCubeExp = '''|sCube|''';\n        sMdxPart\
    \ = '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'| sCubeExp | ')}';\n        IF( sMdx @= '');\
    \ \n          sMdx = sMdxPart; \n        ELSE;\n          sMdx = sMdx | ' + ' | sMdxPart;\n      \
    \  ENDIF;\n        \n        If( SubsetExists( '}Cubes' , cTempSub ) = 1 );\n            # If a delimited\
    \ list of cube names includes wildcards then we may have to re-use the subset multiple times\n   \
    \         SubsetMDXSet( '}Cubes' , cTempSub, sMDX );\n        Else;\n            # temp subset, therefore\
    \ no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n \
    \       EndIf;\n        \n        # Loop through cubes in subset created based on wildcard\n     \
    \   nCountCubes = SubsetGetSize( '}Cubes' , cTempSub );\n        While( nCountCubes >= 1 );\n    \
    \      sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCubes );\n          # Validate\
    \ cube name\n          If( CubeExists( sCurrCube ) = 1 ); \n            # Save data\n            CubeSaveData(\
    \ sCurrCube );\n          Endif;\n            nCountCubes = nCountCubes - 1;\n        End;\n     \
    \ EndIf;\n\nEnd;\n\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    ### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully saved data for cube %pCube% .' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n\n### End\
    \ Epilog ###"
- question: Erstelle einen IBM Turbo Integrator Prozess, der verwendet wird, um Cube(s) zu löschen. Diese
    Funktion eignet sich besonders für Aufräumarbeiten nach der Entwicklungs- oder Prototypphase. Der
    Prozess sollte in der Lage sein, alle Cubes zu löschen, die nach der Produktivschaltung nicht mehr
    benötigt werden. Beachte, dass eine Liste von Cube-Namen angegeben oder Platzhalter verwendet werden
    können. Es müssen selbstverständlich gültige Cube-Namen angegeben werden, da der Prozess andernfalls
    abgebrochen wird. Standardmäßig (pCtrlObj) sollen keine Kontroll-Cubes wie Attribute oder Sicherheits-Cubes
    gelöscht werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes cube(s).\n\n# Use case: Intended for cleaning\
    \ up after development/prototyping.\n# 1\\ Delete all cubes not needed after Go Live.\n\n# Note:\n\
    # A list of cubes can be specified and/or wild cards can be used.\n# Naturally valid cube name(s)\
    \ must be specified otherwise the process will abort.\n# By default (pCtrlObj) the process will not\
    \ delete control cubes (i.e. attributes, security etc).\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName\
    \ = GetProcessName();\ncUserName = TM1User();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n\
    cRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%,\
    \ pDelim:%pDelim%, pCtrlObj:%pCtrlObj%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n \
    \   LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors =\
    \ 0;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\n\
    EndIf;\n\n# If no cubes have been specified, then log error message\nIf( Trim( pCube ) @= '' );\n\
    \  nErrors = 1;\n  sMessage = 'No cubes specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n# If no wildcard and no delimiter, log error message if cubename is invalid \nIf( Scan(\
    \ pDelim, pCube ) = 0 & Scan( '*', pCube ) = 0  & Trim( pCube ) @<> '' & CubeExists( pCube ) = 0 );\
    \ \n  nErrors = 1;\n  sMessage = 'Cubename ' | pCube | ' is invalid';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Split parameter into individual cubes and delete ###\n\
    sCubes = pCube;\nnDelimiterIndex = 1;\nsMdx = '';\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex\
    \ = Scan( pDelim, sCubes );\n  If( nDelimiterIndex = 0 );\n    sCube = sCubes;\n  Else;\n    sCube\
    \ = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n    sCubes = Trim( Subst( sCubes, nDelimiterIndex\
    \ + Long(pDelim), Long( sCubes ) ) );\n  EndIf;\n  \n  # Check if a wildcard has been used to specify\
    \ the Cube name.\n  # If it hasn't then just delete the Cube if it exists\n  # If it has then create\
    \ cubes subset using Wildcard expression in Mdx\n  If( Scan( '*', sCube ) = 0 );\n    If( CubeExists(\
    \ sCube ) = 1 ); \n      If(Subst(sCube,1,1) @= '}');\n        If(pCtrlObj = 1);\n          CubeDestroy(\
    \ sCube );\n        Endif;\n      Else;\n        CubeDestroy( sCube );\n      Endif;\n    Endif;\n\
    \  Else;\n      # Create subset of cubes using Wildcard\n    sCubeExp = '''|sCube|''';\n    IF( pCtrlObj\
    \ = 1 );\n      sMdxPart = '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'| sCubeExp | ')}';\n \
    \   ELSE;\n      sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Cubes] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Cubes] ) , '}*' ) ) ,'| sCubeExp | ')}';  \n    ENDIF;\n    IF( sMdx @= ''); \n\
    \      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n    ENDIF;\n    \n   \
    \ If( SubsetExists( '}Cubes' , cTempSub ) = 1 );\n        # If a delimited list of cube names includes\
    \ wildcards then we may have to re-use the subset multiple times\n        SubsetMDXSet( '}Cubes' ,\
    \ cTempSub, sMDX );\n    Else;\n        # temp subset, therefore no need to destroy in epilog\n  \
    \      SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n    EndIf;\n    \n    # Loop through cubes\
    \ in subset created based on wildcard\n    nCountCubes = SubsetGetSize( '}Cubes' , cTempSub );\n \
    \   While( nCountCubes >= 1 );\n      sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCubes\
    \ );\n      # Validate cube name\n      If( CubeExists( sCurrCube ) = 1 ); \n        # Destroy Cube\n\
    \        If(Subst(sCube,1,1) @= '}');\n          If(pCtrlObj = 1);\n            CubeDestroy( sCurrCube\
    \ );\n          Endif;\n        Else;\n          CubeDestroy( sCurrCube );\n        Endif;\n     \
    \ Endif;\n        nCountCubes = nCountCubes - 1;\n    End;\n  EndIf;\n\nEnd;\n\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted cube %pCube%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Create an IBM Turbo Integrator process that is used to delete cube(s). This functionality
    is particularly suitable for cleaning up after development or prototyping. The process should be capable
    of deleting all cubes not needed after Go Live. Note that a list of cube names can be specified or
    wildcards can be used. Naturally, valid cube names must be specified, otherwise the process will abort.
    By default (pCtrlObj), control cubes such as attributes or security cubes should not be deleted.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes cube(s).\n\n# Use case: Intended for cleaning\
    \ up after development/prototyping.\n# 1\\ Delete all cubes not needed after Go Live.\n\n# Note:\n\
    # A list of cubes can be specified and/or wild cards can be used.\n# Naturally valid cube name(s)\
    \ must be specified otherwise the process will abort.\n# By default (pCtrlObj) the process will not\
    \ delete control cubes (i.e. attributes, security etc).\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName\
    \ = GetProcessName();\ncUserName = TM1User();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n\
    cRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%,\
    \ pDelim:%pDelim%, pCtrlObj:%pCtrlObj%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n \
    \   LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors =\
    \ 0;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\n\
    EndIf;\n\n# If no cubes have been specified, then log error message\nIf( Trim( pCube ) @= '' );\n\
    \  nErrors = 1;\n  sMessage = 'No cubes specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n# If no wildcard and no delimiter, log error message if cubename is invalid \nIf( Scan(\
    \ pDelim, pCube ) = 0 & Scan( '*', pCube ) = 0  & Trim( pCube ) @<> '' & CubeExists( pCube ) = 0 );\
    \ \n  nErrors = 1;\n  sMessage = 'Cubename ' | pCube | ' is invalid';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Split parameter into individual cubes and delete ###\n\
    sCubes = pCube;\nnDelimiterIndex = 1;\nsMdx = '';\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex\
    \ = Scan( pDelim, sCubes );\n  If( nDelimiterIndex = 0 );\n    sCube = sCubes;\n  Else;\n    sCube\
    \ = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n    sCubes = Trim( Subst( sCubes, nDelimiterIndex\
    \ + Long(pDelim), Long( sCubes ) ) );\n  EndIf;\n  \n  # Check if a wildcard has been used to specify\
    \ the Cube name.\n  # If it hasn't then just delete the Cube if it exists\n  # If it has then create\
    \ cubes subset using Wildcard expression in Mdx\n  If( Scan( '*', sCube ) = 0 );\n    If( CubeExists(\
    \ sCube ) = 1 ); \n      If(Subst(sCube,1,1) @= '}');\n        If(pCtrlObj = 1);\n          CubeDestroy(\
    \ sCube );\n        Endif;\n      Else;\n        CubeDestroy( sCube );\n      Endif;\n    Endif;\n\
    \  Else;\n      # Create subset of cubes using Wildcard\n    sCubeExp = '''|sCube|''';\n    IF( pCtrlObj\
    \ = 1 );\n      sMdxPart = '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'| sCubeExp | ')}';\n \
    \   ELSE;\n      sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Cubes] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Cubes] ) , '}*' ) ) ,'| sCubeExp | ')}';  \n    ENDIF;\n    IF( sMdx @= ''); \n\
    \      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n    ENDIF;\n    \n   \
    \ If( SubsetExists( '}Cubes' , cTempSub ) = 1 );\n        # If a delimited list of cube names includes\
    \ wildcards then we may have to re-use the subset multiple times\n        SubsetMDXSet( '}Cubes' ,\
    \ cTempSub, sMDX );\n    Else;\n        # temp subset, therefore no need to destroy in epilog\n  \
    \      SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n    EndIf;\n    \n    # Loop through cubes\
    \ in subset created based on wildcard\n    nCountCubes = SubsetGetSize( '}Cubes' , cTempSub );\n \
    \   While( nCountCubes >= 1 );\n      sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCubes\
    \ );\n      # Validate cube name\n      If( CubeExists( sCurrCube ) = 1 ); \n        # Destroy Cube\n\
    \        If(Subst(sCube,1,1) @= '}');\n          If(pCtrlObj = 1);\n            CubeDestroy( sCurrCube\
    \ );\n          Endif;\n        Else;\n          CubeDestroy( sCurrCube );\n        Endif;\n     \
    \ Endif;\n        nCountCubes = nCountCubes - 1;\n    End;\n  EndIf;\n\nEnd;\n\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted cube %pCube%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, um eine Dimension zu einem bereits erstellten
    Würfel hinzuzufügen, wobei die Möglichkeit besteht, Daten zu bewahren. Dieser Prozess soll im Entwicklungs-
    oder Prototyping-Kontext eingesetzt werden, bei dem ein vorhandener Würfel mit einer zusätzlichen
    Dimension ohne Datenverlust neu aufgebaut wird. Beachte, dass ein gültiger Zielwürfelname (pCube)
    zwingend erforderlich ist, da der Prozess sonst abbricht. Ebenso ist ein gültiger neuer Dimensionsname
    (pDim) erforderlich, da der Prozess sonst abbricht. Wenn die Daten beibehalten werden müssen (unter
    Verwendung von pIncludeData), muss ein gültiges Element (pEle) angegeben werden, um die Daten in der
    neuen Dimension zu speichern. Regeln können entweder nur als Sicherungsdatei aufbewahrt oder wieder
    geladen werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI adds a dimension to a cube that has already been built with\
    \ the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n# 1/ Rebuild\
    \ existing cube with extra dimension without losing data.\n\n# Note:\n# Naturally, a valid target\
    \ cube name (pCube) is mandatory otherwise the process will abort.\n# Also, a valid new dimension\
    \ name (pDim) is mandatory otherwise the process will abort.\n# When data needs to be kept (using\
    \ pIncludeData) a valid element (pEle) must be specified where to store the data in new dimension.\n\
    # Rule can be kept as backup file only or reloaded back.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp\
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pDim:%pDim%, pDimIndex:%pDimIndex%, pIncludeData:%pIncludeData%,\
    \ pEle:%pEle%, pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.';\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim\
    \ = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim =\
    \ '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n# Validate cube\nIf( Trim( pCube ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = 'No cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists(\
    \ pCube ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid cube specified: %pCube%.');\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Don't allow system cubes\
    \ to be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\n    nErrors = nErrors + 1;\n\
    \    sMessage = Expand( 'Do not modify system cubes: %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors =\
    \ nErrors + 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'New dimension: %pDim% does not exist');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# check element chosen in new dimension\nIf( pIncludeData = 1 & Trim(pEle)@='' );\n\
    \    nErrors = nErrors + 1;\n    sMessage = Expand( 'No element specified in new dimension %pDim%\
    \ to store cube data.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    If( pIncludeData = 1 & DIMIX(pDim, pEle)=0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand(\
    \ 'Invalid element %pEle% specified for the new dimension %pDim% to store cube data.');\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIF(pIncludeRules = 1 % pIncludeRules =\
    \ 2);\n    cCubeRuleFileName = '.' | sOSDelim | pCube | '.RUX';\n    If(FileExists(cCubeRuleFileName)\
    \ = 0);\n        pIncludeRules = 0;\n        LogOutput( 'INFO', Expand( 'No rule found for %pCube%.'\
    \ ) );\n    Endif;\nEndif;  \n\n### Determine number of dims in source cube & create strings to check\
    \ and recreate ###\nnCount = 1;\nsDimString = '';\nsDimCheck = '';\nsDelim = '+';\nnNewFound = 0;\n\
    nIncrement = 1;\nWhile( TabDim( pCube, nCount ) @<> '' );\n  sDim = TabDim( pCube, nCount );\n  IF(nCount=pDimIndex\
    \ & nNewFound = 0);\n    sNewDim=pDim;\n    nNewFound = 1;\n    nIncrement = 0;\n  else;\n    sNewDim=sDim;\n\
    \    nIncrement = 1;\n  Endif;  \n  IF(nCount = 1);\n    sDimCheck = '+'|sDim|'+';\n    #sDimString\
    \ = sNewDim;\n  elseif(nCount > 1);\n    sDimCheck = sDimCheck|'+'|sDim|'+';\n  Endif;\n  sDimString\
    \ = sDimString|'+'|sNewDim;\n  nCount = nCount + nIncrement;\nEnd;\nnDimensionCount = nCount;\n\n\
    #Remove any leading +\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\n    sDimString      = Subst ( sDimString\
    \ , 2 , 999 );\nEndIf;\n\nIF(scan('+'|pDim|'+',sDimCheck)>0);\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'The chosen new dimension %pDim% already exists in cube %pCube%.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;\n\n# Check if cube exceeds current max dimenions\nIf( nDimensionCount\
    \ > 27 );\n    sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n######  CALLING THE STEP PROCESSES\
    \ #####\n\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n  \n  sProc = '}bedrock.cube.rule.manage';\n\
    \  nRet = EXECUTEPROCESS( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n\
    \    'pCube', pCube,\n    'pMode', 'UNLOAD'\n    );\n    \n  IF(nRet <> 0);\n    sMessage = 'Error\
    \ unloading the rule for %pCube%.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n\
    \        ProcessBreak;\n    EndIf;\n  ENDIF;\n  \nEndif; \n\n# create clone cube with data\nIF(pIncludeData\
    \ = 1);\n  \n    pCloneCube = pCube | '_Clone';\n    nIncludeRules = IF(pIncludeRules = 1 % pIncludeRules\
    \ = 2, 1, 0);\n    nSuppressRules = IF(nIncludeRules = 1,  1, 0);\n  \n    sProc = '}bedrock.cube.clone';\n\
    \    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pSrcCube', pCube,\n        'pTgtCube', pCloneCube,\n        'pIncludeRules',\
    \ nIncludeRules,\n        'pIncludeData', pIncludeData,\n        'pSuppressRules', nSuppressRules,\n\
    \        'pTemp', pTemp,\n        'pCubeLogging', 0\n        );\n\n    IF(nRet <> 0);\n        sMessage\
    \ = 'Error creating cloned cube for keeping data.';\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 ); \n      \
    \      ProcessQuit; \n        Else;\n            ProcessBreak;\n        EndIf;\n    ENDIF;\nEndif;\n\
    \n# recreate the cube\nsProc = '}bedrock.cube.create';\nnRet = ExecuteProcess( sProc,\n    'pLogOutput',\
    \ pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube', pCube,\n    'pDims',\
    \ sDimString,\n    'pRecreate', 1,\n    'pDelim', sDelim\n    );\n\nIF(nRet <> 0);\n    sMessage =\
    \ Expand('Error recreating the cube: %pCube%.');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n   \
    \ Else;\n        ProcessBreak;\n    EndIf;\nENDIF;\n\n# copy back the data\nIF(pIncludeData = 1);\n\
    \    sEleStartDelim = '¦';\n    sMappingToNewDims = pDim|sEleStartDelim|pEle;\n  \n    nRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \  \t'pLogOutput',pLogOutput,\n  \t'pStrictErrorHandling', pStrictErrorHandling,\n  \t'pSrcCube',pCloneCube,\n\
    \  \t'pFilter','',\n  \t'pTgtCube',pCube,\n  \t'pMappingToNewDims',sMappingToNewDims,\n    'pSuppressConsol',\
    \ 1,\n    'pSuppressRules', nSuppressRules,\n  \t'pZeroTarget',0,\n  \t'pZeroSource',0,\n  \t'pFactor',1,\n\
    \  \t'pDimDelim','&',\n  \t'pEleStartDelim',sEleStartDelim,\n  \t'pEleDelim','+',\n  \t'pTemp',pTemp,\n\
    \  \t'pCubeLogging',0);\n    \n    IF(nRet <> 0);\n        sMessage = Expand('Error copying back the\
    \ data from clone cube: %pCloneCube%.');\n        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit;\
    \ \n        Else;\n            ProcessBreak;\n        EndIf;\n    ENDIF;\n  \n    # destroy clone\
    \ cube\n    IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n        nRet = EXECUTEPROCESS(\
    \ sProc,\n            'pLogOutput', pLogOutput,\n            'pStrictErrorHandling', pStrictErrorHandling,\n\
    \            'pCube', pCloneCube,\n            'pCtrlObj', 0\n            );\n\n        IF(nRet <>\
    \ 0);\n            sMessage = Expand('Error deleting the clone cube: %pCloneCube%.');\n          \
    \  nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n            Else;\n\
    \                ProcessBreak;\n            EndIf;\n        ENDIF;\n    Endif;\n\nEndif; \n\n# reload\
    \ the rule\nIF(pIncludeRules = 2);\n  \n    sProc = '}bedrock.cube.rule.manage';\n\n    nRet = EXECUTEPROCESS(\
    \ sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pCube', pCube,\n        'pMode', 'LOAD'\n        );\n    \n    IF(nRet <> 0);\n      sMessage\
    \ = Expand('Error reloading the rule for %pCube%.');\n      nErrors = nErrors + 1;\n      LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      # Create error rule file \n      cErrorRuleName\
    \ = 'ErrorRuleFile.rux';\n      \n      IF(FileExists( cErrorRuleName ) = 0 );\n        sFile = '.'\
    \ | sOSDelim | cErrorRuleName;\n        LogOutput(cMsgErrorLevel, 'Rule could not be attached due\
    \ to invalid !Dimension references. Please recover from the backup and fix manually.');\n      ENDIF;\n\
    \      \n      EXECUTEPROCESS( sProc,\n      'pLogOutput', pLogOutput,\n      'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n      'pCube', pCube,\n      'pFileName', cErrorRuleName,\n      'pMode',\
    \ 'LOAD'\n      );\n      If( pStrictErrorHandling = 1 ); \n          ProcessQuit; \n      Else;\n\
    \          ProcessBreak;\n      EndIf;\n    ENDIF;\n  \nEndif; \n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully added dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process to add a dimension to an already built cube with the
    ability to preserve data. This process is intended for development or prototyping use, where an existing
    cube is rebuilt with an extra dimension without losing data. Note that a valid target cube name (pCube)
    is mandatory; otherwise, the process will abort. Likewise, a valid new dimension name (pDim) is mandatory;
    otherwise, the process will abort. When data needs to be kept (using pIncludeData), a valid element
    (pEle) must be specified to store the data in the new dimension. Rules can be kept as a backup file
    only or reloaded back.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI adds a dimension to a cube that has already been built with\
    \ the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n# 1/ Rebuild\
    \ existing cube with extra dimension without losing data.\n\n# Note:\n# Naturally, a valid target\
    \ cube name (pCube) is mandatory otherwise the process will abort.\n# Also, a valid new dimension\
    \ name (pDim) is mandatory otherwise the process will abort.\n# When data needs to be kept (using\
    \ pIncludeData) a valid element (pEle) must be specified where to store the data in new dimension.\n\
    # Rule can be kept as backup file only or reloaded back.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp\
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pDim:%pDim%, pDimIndex:%pDimIndex%, pIncludeData:%pIncludeData%,\
    \ pEle:%pEle%, pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.';\n\n## check operating\
    \ system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim\
    \ = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim =\
    \ '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n# Validate cube\nIf( Trim( pCube ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = 'No cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists(\
    \ pCube ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid cube specified: %pCube%.');\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Don't allow system cubes\
    \ to be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\n    nErrors = nErrors + 1;\n\
    \    sMessage = Expand( 'Do not modify system cubes: %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors =\
    \ nErrors + 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'New dimension: %pDim% does not exist');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# check element chosen in new dimension\nIf( pIncludeData = 1 & Trim(pEle)@='' );\n\
    \    nErrors = nErrors + 1;\n    sMessage = Expand( 'No element specified in new dimension %pDim%\
    \ to store cube data.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    If( pIncludeData = 1 & DIMIX(pDim, pEle)=0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand(\
    \ 'Invalid element %pEle% specified for the new dimension %pDim% to store cube data.');\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIF(pIncludeRules = 1 % pIncludeRules =\
    \ 2);\n    cCubeRuleFileName = '.' | sOSDelim | pCube | '.RUX';\n    If(FileExists(cCubeRuleFileName)\
    \ = 0);\n        pIncludeRules = 0;\n        LogOutput( 'INFO', Expand( 'No rule found for %pCube%.'\
    \ ) );\n    Endif;\nEndif;  \n\n### Determine number of dims in source cube & create strings to check\
    \ and recreate ###\nnCount = 1;\nsDimString = '';\nsDimCheck = '';\nsDelim = '+';\nnNewFound = 0;\n\
    nIncrement = 1;\nWhile( TabDim( pCube, nCount ) @<> '' );\n  sDim = TabDim( pCube, nCount );\n  IF(nCount=pDimIndex\
    \ & nNewFound = 0);\n    sNewDim=pDim;\n    nNewFound = 1;\n    nIncrement = 0;\n  else;\n    sNewDim=sDim;\n\
    \    nIncrement = 1;\n  Endif;  \n  IF(nCount = 1);\n    sDimCheck = '+'|sDim|'+';\n    #sDimString\
    \ = sNewDim;\n  elseif(nCount > 1);\n    sDimCheck = sDimCheck|'+'|sDim|'+';\n  Endif;\n  sDimString\
    \ = sDimString|'+'|sNewDim;\n  nCount = nCount + nIncrement;\nEnd;\nnDimensionCount = nCount;\n\n\
    #Remove any leading +\nIF( Subst( sDimString , 1 , 1 ) @= '+' );\n    sDimString      = Subst ( sDimString\
    \ , 2 , 999 );\nEndIf;\n\nIF(scan('+'|pDim|'+',sDimCheck)>0);\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'The chosen new dimension %pDim% already exists in cube %pCube%.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;\n\n# Check if cube exceeds current max dimenions\nIf( nDimensionCount\
    \ > 27 );\n    sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n######  CALLING THE STEP PROCESSES\
    \ #####\n\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n  \n  sProc = '}bedrock.cube.rule.manage';\n\
    \  nRet = EXECUTEPROCESS( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n\
    \    'pCube', pCube,\n    'pMode', 'UNLOAD'\n    );\n    \n  IF(nRet <> 0);\n    sMessage = 'Error\
    \ unloading the rule for %pCube%.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n\
    \        ProcessBreak;\n    EndIf;\n  ENDIF;\n  \nEndif; \n\n# create clone cube with data\nIF(pIncludeData\
    \ = 1);\n  \n    pCloneCube = pCube | '_Clone';\n    nIncludeRules = IF(pIncludeRules = 1 % pIncludeRules\
    \ = 2, 1, 0);\n    nSuppressRules = IF(nIncludeRules = 1,  1, 0);\n  \n    sProc = '}bedrock.cube.clone';\n\
    \    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pSrcCube', pCube,\n        'pTgtCube', pCloneCube,\n        'pIncludeRules',\
    \ nIncludeRules,\n        'pIncludeData', pIncludeData,\n        'pSuppressRules', nSuppressRules,\n\
    \        'pTemp', pTemp,\n        'pCubeLogging', 0\n        );\n\n    IF(nRet <> 0);\n        sMessage\
    \ = 'Error creating cloned cube for keeping data.';\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 ); \n      \
    \      ProcessQuit; \n        Else;\n            ProcessBreak;\n        EndIf;\n    ENDIF;\nEndif;\n\
    \n# recreate the cube\nsProc = '}bedrock.cube.create';\nnRet = ExecuteProcess( sProc,\n    'pLogOutput',\
    \ pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube', pCube,\n    'pDims',\
    \ sDimString,\n    'pRecreate', 1,\n    'pDelim', sDelim\n    );\n\nIF(nRet <> 0);\n    sMessage =\
    \ Expand('Error recreating the cube: %pCube%.');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n   \
    \ Else;\n        ProcessBreak;\n    EndIf;\nENDIF;\n\n# copy back the data\nIF(pIncludeData = 1);\n\
    \    sEleStartDelim = '¦';\n    sMappingToNewDims = pDim|sEleStartDelim|pEle;\n  \n    nRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \  \t'pLogOutput',pLogOutput,\n  \t'pStrictErrorHandling', pStrictErrorHandling,\n  \t'pSrcCube',pCloneCube,\n\
    \  \t'pFilter','',\n  \t'pTgtCube',pCube,\n  \t'pMappingToNewDims',sMappingToNewDims,\n    'pSuppressConsol',\
    \ 1,\n    'pSuppressRules', nSuppressRules,\n  \t'pZeroTarget',0,\n  \t'pZeroSource',0,\n  \t'pFactor',1,\n\
    \  \t'pDimDelim','&',\n  \t'pEleStartDelim',sEleStartDelim,\n  \t'pEleDelim','+',\n  \t'pTemp',pTemp,\n\
    \  \t'pCubeLogging',0);\n    \n    IF(nRet <> 0);\n        sMessage = Expand('Error copying back the\
    \ data from clone cube: %pCloneCube%.');\n        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit;\
    \ \n        Else;\n            ProcessBreak;\n        EndIf;\n    ENDIF;\n  \n    # destroy clone\
    \ cube\n    IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n        nRet = EXECUTEPROCESS(\
    \ sProc,\n            'pLogOutput', pLogOutput,\n            'pStrictErrorHandling', pStrictErrorHandling,\n\
    \            'pCube', pCloneCube,\n            'pCtrlObj', 0\n            );\n\n        IF(nRet <>\
    \ 0);\n            sMessage = Expand('Error deleting the clone cube: %pCloneCube%.');\n          \
    \  nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n            Else;\n\
    \                ProcessBreak;\n            EndIf;\n        ENDIF;\n    Endif;\n\nEndif; \n\n# reload\
    \ the rule\nIF(pIncludeRules = 2);\n  \n    sProc = '}bedrock.cube.rule.manage';\n\n    nRet = EXECUTEPROCESS(\
    \ sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pCube', pCube,\n        'pMode', 'LOAD'\n        );\n    \n    IF(nRet <> 0);\n      sMessage\
    \ = Expand('Error reloading the rule for %pCube%.');\n      nErrors = nErrors + 1;\n      LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      # Create error rule file \n      cErrorRuleName\
    \ = 'ErrorRuleFile.rux';\n      \n      IF(FileExists( cErrorRuleName ) = 0 );\n        sFile = '.'\
    \ | sOSDelim | cErrorRuleName;\n        LogOutput(cMsgErrorLevel, 'Rule could not be attached due\
    \ to invalid !Dimension references. Please recover from the backup and fix manually.');\n      ENDIF;\n\
    \      \n      EXECUTEPROCESS( sProc,\n      'pLogOutput', pLogOutput,\n      'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n      'pCube', pCube,\n      'pFileName', cErrorRuleName,\n      'pMode',\
    \ 'LOAD'\n      );\n      If( pStrictErrorHandling = 1 ); \n          ProcessQuit; \n      Else;\n\
    \          ProcessBreak;\n      EndIf;\n    ENDIF;\n  \nEndif; \n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully added dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der dazu dient, eine Dimension aus einem bereits
    erstellten Würfel zu löschen, wobei die Möglichkeit besteht, Daten zu erhalten. Der Prozess richtet
    sich an die Entwicklung und das Prototyping und ermöglicht es, einen bestehenden Würfel mit der Entfernung
    einer Dimension neu zu erstellen, ohne alle Daten zu verlieren. Beachte, dass ein gültiger Würfelname
    (pCube) und ein gültiger Dimensionsname (pDim) erforderlich sind, andernfalls wird der Prozess abgebrochen.
    Wenn Daten erhalten werden müssen (mithilfe von pIncludeData), werden die Daten aus pDim summiert.
    Regeln können nur als Sicherungsdatei beibehalten oder erneut geladen werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI deletes a dimension from a cube that has already been built\
    \ with the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n# 1/ Rebuild\
    \ existing cube with the removal of one dimension without losing all the data.\n\n# Note:\n# Naturally,\
    \ a valid cube name (pCube) is mandatory otherwise the process will abort.\n# Also, a valid dimension\
    \ name (pDim) is mandatory otherwise the process will abort.\n# If data needs to be kept (using pIncludeData),\
    \ data from pDim will be summed.\n# Rule can be kept as backup file only or reloaded back.\n#EndRegion\
    \ @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        =\
    \ 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDim:%pDim%, pIncludeData:%pIncludeData%,\
    \ pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.';\n\n## check operating system\n\
    If( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\n\
    ElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n\
    \  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors =\
    \ 0;\n# Validate cube\nIf( Trim( pCube ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No\
    \ cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists(\
    \ pCube ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid cube specified: %pCube%.');\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Don't allow system cubes\
    \ to be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\n    nErrors = nErrors + 1;\n\
    \    sMessage = Expand( 'Do not modify system cubes: %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors =\
    \ nErrors + 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'New dimension: %pDim% does not exist');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n    cCubeRuleFileName = '.' | sOSDelim\
    \ | pCube | '.RUX';\n    If(FileExists(cCubeRuleFileName) = 0);\n        pIncludeRules = 0;\n    \
    \    LogOutput( 'INFO', Expand( 'No rule found for %pCube%.' ) );\n    Endif;\nEndif;  \n\n### Determine\
    \ number of dims in source cube & create strings to check and recreate ###\nnCount = 1;\nsDimString\
    \ = '';\nsDimCheck = '';\nsDelim = '+';\nnSkip=0;\nnIncrement = 1;\nWhile( TabDim( pCube, nCount )\
    \ @<> '' );\n    sDim = TabDim( pCube, nCount );\n    IF(sDim@=pDim);\n        nSkip = 1;\n    else;\n\
    \        nSkip = 0;\n    Endif; \n    IF(nCount = 1);\n        sDimCheck = '+'|sDim|'+';\n    elseif(nCount\
    \ > 1);\n        sDimCheck = sDimCheck|'+'|sDim|'+';\n    Endif;\n    IF(nCount = 1 & nSkip = 0);\n\
    \        sDimString = sDim;\n    elseif(nCount > 1 & nSkip = 0);\n        sDimString = sDimString|'+'|sDim;\n\
    \    Endif;\n    nCount = nCount + 1;\nEnd;\nnDimensionCount = nCount-1;\n\n#Remove any leading +\n\
    IF( Subst( sDimString , 1 , 1 ) @= '+' );\n    sDimString      = Subst ( sDimString , 2 , 999 );\n\
    EndIf;\n\n\nIF(scan('+'|pDim|'+',sDimCheck)=0);\n    nErrors = nErrors + 1;\n    sMessage = Expand(\
    \ 'The chosen dimension %pDim% does not exists in cube %pCube%.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;\n\n# Check if cube exceeds current max dimenions\nIf( nDimensionCount\
    \ > 27 );\n    sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n######  CALLING THE STEP PROCESSES\
    \ #####\n\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n  \n  sProc = '}bedrock.cube.rule.manage';\n\
    \n  nRet = EXECUTEPROCESS( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n\
    \    'pCube', pCube,\n    'pMode', 'UNLOAD'\n    );\n    \n  IF(nRet <> 0);\n    sMessage = 'Error\
    \ unloading the rule for %pCube%.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n\
    \        ProcessBreak;\n    EndIf;\n  ENDIF;\n  \nEndif; \n\n# create clone cube with data\nIF(pIncludeData\
    \ = 1);\n    pCloneCube = pCube | '_Clone';\n    nIncludeRules = IF(pIncludeRules = 1 % pIncludeRules\
    \ = 2, 1, 0);\n    nSuppressRules = IF(nIncludeRules = 1,  1, 0);\n  \n    sProc = '}bedrock.cube.clone';\n\
    \    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pSrcCube', pCube,\n        'pTgtCube', pCloneCube,\n        'pIncludeRules',\
    \ nIncludeRules,\n        'pIncludeData', pIncludeData,\n        'pSuppressRules', nSuppressRules,\n\
    \        'pTemp', pTemp,\n        'pCubeLogging', 0\n        );\n\n    IF(nRet <> 0);\n        sMessage\
    \ = 'Error creating cloned cube for keeping data.';\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 ); \n      \
    \      ProcessQuit; \n        Else;\n            ProcessBreak;\n        EndIf;\n    ENDIF;\n  \nEndif;\n\
    \n#Processbreak;\n\n# recreate the cube\nsProc = '}bedrock.cube.create';\nnRet = ExecuteProcess( sProc,\n\
    \    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube', pCube,\n\
    \    'pDims', sDimString,\n    'pRecreate', 1,\n    'pDelim', sDelim\n    );\n\nIF(nRet <> 0);\n \
    \   sMessage = Expand('Error recreating the cube: %pCube%.');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    Else;\n        ProcessBreak;\n    EndIf;\nENDIF;\n\n#Processbreak;\n\n# copy back the data\n\
    IF(pIncludeData = 1);\n    sProc = '}bedrock.cube.data.copy.intercube';\n    nRet = ExecuteProcess(\
    \ sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pSrcCube', pCloneCube,\n        'pFilter', '',\n        'pTgtCube', pCube,\n        'pMappingToNewDims',\
    \ '',\n        'pSuppressConsol', 1,\n        'pSuppressRules', nSuppressRules,\n        'pZeroSource',\
    \ 0,\n        'pZeroTarget', 0,\n        'pFactor', 1,\n        'pTemp', pTemp,\n        'pCubeLogging',\
    \ 0\n        );  \n    \n    IF(nRet <> 0);\n        sMessage = Expand('Error copying back the data\
    \ from clone cube: %pCloneCube%.');\n        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit;\
    \ \n        Else;\n            ProcessBreak;\n        EndIf;\n    ENDIF;\n  \n    # destroy clone\
    \ cube\n    IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n        nRet = EXECUTEPROCESS(\
    \ sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pCube', pCloneCube,\n        'pCtrlObj', 0\n        );\n\n        IF(nRet <> 0);\n     \
    \       sMessage = Expand('Error deleting cloned cube: %pCloneCube%.');\n            nErrors = nErrors\
    \ + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            If( pStrictErrorHandling\
    \ = 1 ); \n                ProcessQuit; \n            Else;\n                ProcessBreak;\n     \
    \       EndIf;\n        ENDIF;\n    Endif;\n  \nEndif; \n\n# reload the rule\nIF(pIncludeRules = 2);\n\
    \  \n  sProc = '}bedrock.cube.rule.manage';\n\n  nRet = EXECUTEPROCESS( sProc,\n    'pLogOutput',\
    \ pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube', pCube,\n    'pMode',\
    \ 'LOAD'\n    );\n    \n  IF(nRet <> 0);\n    sMessage = Expand('Error reloading the rule for %pCube%.');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    # Create\
    \ error rule file \n    cErrorRuleName = 'ErrorRuleFile.rux';\n\n    IF(FileExists( cErrorRuleName\
    \ ) = 0 );\n      sFile = '.' | sOSDelim | cErrorRuleName;\n      LogOutput(cMsgErrorLevel, 'Rule\
    \ could not be attached due to invalid !Dimension references. Please recover from the backup and fix\
    \ manually.');\n    ENDIF;\n\n    EXECUTEPROCESS( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    'pCube', pCube,\n    'pFileName', cErrorRuleName,\n    'pMode', 'LOAD'\n\
    \    );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\n  ENDIF;\n  \nEndif; \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted\
    \ dimension %pDim% from the %pCube% cube.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that is designed to delete a dimension from an already
    built cube with the ability to preserve data. The process is intended for development and prototyping
    and allows for rebuilding an existing cube with the removal of one dimension without losing all the
    data. Note that a valid cube name (pCube) and a valid dimension name (pDim) are mandatory; otherwise,
    the process will abort. If data needs to be kept (using pIncludeData), data from pDim will be summed.
    Rules can be kept as a backup file only or reloaded back.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI deletes a dimension from a cube that has already been built\
    \ with the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n# 1/ Rebuild\
    \ existing cube with the removal of one dimension without losing all the data.\n\n# Note:\n# Naturally,\
    \ a valid cube name (pCube) is mandatory otherwise the process will abort.\n# Also, a valid dimension\
    \ name (pDim) is mandatory otherwise the process will abort.\n# If data needs to be kept (using pIncludeData),\
    \ data from pDim will be summed.\n# Rule can be kept as backup file only or reloaded back.\n#EndRegion\
    \ @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        =\
    \ 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDim:%pDim%, pIncludeData:%pIncludeData%,\
    \ pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.';\n\n## check operating system\n\
    If( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\n\
    ElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n\
    \  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors =\
    \ 0;\n# Validate cube\nIf( Trim( pCube ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No\
    \ cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists(\
    \ pCube ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage = Expand( 'Invalid cube specified: %pCube%.');\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Don't allow system cubes\
    \ to be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\n    nErrors = nErrors + 1;\n\
    \    sMessage = Expand( 'Do not modify system cubes: %pCube%.');\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors =\
    \ nErrors + 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = nErrors + 1;\n    sMessage\
    \ = Expand( 'New dimension: %pDim% does not exist');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n    cCubeRuleFileName = '.' | sOSDelim\
    \ | pCube | '.RUX';\n    If(FileExists(cCubeRuleFileName) = 0);\n        pIncludeRules = 0;\n    \
    \    LogOutput( 'INFO', Expand( 'No rule found for %pCube%.' ) );\n    Endif;\nEndif;  \n\n### Determine\
    \ number of dims in source cube & create strings to check and recreate ###\nnCount = 1;\nsDimString\
    \ = '';\nsDimCheck = '';\nsDelim = '+';\nnSkip=0;\nnIncrement = 1;\nWhile( TabDim( pCube, nCount )\
    \ @<> '' );\n    sDim = TabDim( pCube, nCount );\n    IF(sDim@=pDim);\n        nSkip = 1;\n    else;\n\
    \        nSkip = 0;\n    Endif; \n    IF(nCount = 1);\n        sDimCheck = '+'|sDim|'+';\n    elseif(nCount\
    \ > 1);\n        sDimCheck = sDimCheck|'+'|sDim|'+';\n    Endif;\n    IF(nCount = 1 & nSkip = 0);\n\
    \        sDimString = sDim;\n    elseif(nCount > 1 & nSkip = 0);\n        sDimString = sDimString|'+'|sDim;\n\
    \    Endif;\n    nCount = nCount + 1;\nEnd;\nnDimensionCount = nCount-1;\n\n#Remove any leading +\n\
    IF( Subst( sDimString , 1 , 1 ) @= '+' );\n    sDimString      = Subst ( sDimString , 2 , 999 );\n\
    EndIf;\n\n\nIF(scan('+'|pDim|'+',sDimCheck)=0);\n    nErrors = nErrors + 1;\n    sMessage = Expand(\
    \ 'The chosen dimension %pDim% does not exists in cube %pCube%.');\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;\n\n# Check if cube exceeds current max dimenions\nIf( nDimensionCount\
    \ > 27 );\n    sMessage = 'Process needs to be modified to handle cubes with more than 27 dimensions';\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n######  CALLING THE STEP PROCESSES\
    \ #####\n\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n  \n  sProc = '}bedrock.cube.rule.manage';\n\
    \n  nRet = EXECUTEPROCESS( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n\
    \    'pCube', pCube,\n    'pMode', 'UNLOAD'\n    );\n    \n  IF(nRet <> 0);\n    sMessage = 'Error\
    \ unloading the rule for %pCube%.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n\
    \        ProcessBreak;\n    EndIf;\n  ENDIF;\n  \nEndif; \n\n# create clone cube with data\nIF(pIncludeData\
    \ = 1);\n    pCloneCube = pCube | '_Clone';\n    nIncludeRules = IF(pIncludeRules = 1 % pIncludeRules\
    \ = 2, 1, 0);\n    nSuppressRules = IF(nIncludeRules = 1,  1, 0);\n  \n    sProc = '}bedrock.cube.clone';\n\
    \    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pSrcCube', pCube,\n        'pTgtCube', pCloneCube,\n        'pIncludeRules',\
    \ nIncludeRules,\n        'pIncludeData', pIncludeData,\n        'pSuppressRules', nSuppressRules,\n\
    \        'pTemp', pTemp,\n        'pCubeLogging', 0\n        );\n\n    IF(nRet <> 0);\n        sMessage\
    \ = 'Error creating cloned cube for keeping data.';\n        nErrors = nErrors + 1;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 ); \n      \
    \      ProcessQuit; \n        Else;\n            ProcessBreak;\n        EndIf;\n    ENDIF;\n  \nEndif;\n\
    \n#Processbreak;\n\n# recreate the cube\nsProc = '}bedrock.cube.create';\nnRet = ExecuteProcess( sProc,\n\
    \    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube', pCube,\n\
    \    'pDims', sDimString,\n    'pRecreate', 1,\n    'pDelim', sDelim\n    );\n\nIF(nRet <> 0);\n \
    \   sMessage = Expand('Error recreating the cube: %pCube%.');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    Else;\n        ProcessBreak;\n    EndIf;\nENDIF;\n\n#Processbreak;\n\n# copy back the data\n\
    IF(pIncludeData = 1);\n    sProc = '}bedrock.cube.data.copy.intercube';\n    nRet = ExecuteProcess(\
    \ sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pSrcCube', pCloneCube,\n        'pFilter', '',\n        'pTgtCube', pCube,\n        'pMappingToNewDims',\
    \ '',\n        'pSuppressConsol', 1,\n        'pSuppressRules', nSuppressRules,\n        'pZeroSource',\
    \ 0,\n        'pZeroTarget', 0,\n        'pFactor', 1,\n        'pTemp', pTemp,\n        'pCubeLogging',\
    \ 0\n        );  \n    \n    IF(nRet <> 0);\n        sMessage = Expand('Error copying back the data\
    \ from clone cube: %pCloneCube%.');\n        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit;\
    \ \n        Else;\n            ProcessBreak;\n        EndIf;\n    ENDIF;\n  \n    # destroy clone\
    \ cube\n    IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n        nRet = EXECUTEPROCESS(\
    \ sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pCube', pCloneCube,\n        'pCtrlObj', 0\n        );\n\n        IF(nRet <> 0);\n     \
    \       sMessage = Expand('Error deleting cloned cube: %pCloneCube%.');\n            nErrors = nErrors\
    \ + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            If( pStrictErrorHandling\
    \ = 1 ); \n                ProcessQuit; \n            Else;\n                ProcessBreak;\n     \
    \       EndIf;\n        ENDIF;\n    Endif;\n  \nEndif; \n\n# reload the rule\nIF(pIncludeRules = 2);\n\
    \  \n  sProc = '}bedrock.cube.rule.manage';\n\n  nRet = EXECUTEPROCESS( sProc,\n    'pLogOutput',\
    \ pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pCube', pCube,\n    'pMode',\
    \ 'LOAD'\n    );\n    \n  IF(nRet <> 0);\n    sMessage = Expand('Error reloading the rule for %pCube%.');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    # Create\
    \ error rule file \n    cErrorRuleName = 'ErrorRuleFile.rux';\n\n    IF(FileExists( cErrorRuleName\
    \ ) = 0 );\n      sFile = '.' | sOSDelim | cErrorRuleName;\n      LogOutput(cMsgErrorLevel, 'Rule\
    \ could not be attached due to invalid !Dimension references. Please recover from the backup and fix\
    \ manually.');\n    ENDIF;\n\n    EXECUTEPROCESS( sProc,\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    'pCube', pCube,\n    'pFileName', cErrorRuleName,\n    'pMode', 'LOAD'\n\
    \    );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\n  ENDIF;\n  \nEndif; \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted\
    \ dimension %pDim% from the %pCube% cube.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'er angezeigte IBM Turbo Integrator Prozess beschreibt einen Anwendungsfall, bei dem eine
    Dimension aus einem bestehenden Würfel entfernt und eine andere hinzugefügt wird, ohne dass dabei
    Daten verloren gehen. Dieser Prozess ist hauptsächlich für Entwicklungs- und Prototyping-Zwecke gedacht
    und funktioniert folgendermaßen: 1/ Nach der Entfernung einer Dimension und dem Hinzufügen einer anderen
    wird der bestehende Würfel wieder aufgebaut, ohne dass alle Daten verloren gehen. Wichtig zu beachten
    ist, dass ein gültiger Würfelname (pCube) erforderlich ist, da der Prozess ansonsten abgebrochen wird.
    Auch die Namen der relevanten Dimensionen (pSrcDim & pTgtDim) sind obligatorisch, da der Prozess ebenfalls
    bei Ungültigkeit abgebrochen wird. Wenn die Daten beibehalten werden sollen, muss ein gültiges Element
    (pEle) in der neuen Dimension angegeben werden, wo die Daten gespeichert werden sollen. Daten werden
    aus der originalen Dimension summiert. Regeln können sowohl als Backup-Datei gespeichert als auch
    wieder geladen werden.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI deletes a dimension and adds another one to an existing\
    \ cube with the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n#\
    \ 1/ Rebuild existing cube after removal of one dimension and adding anothr one without losing all\
    \ the data.\n\n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process\
    \ will abort.\n# Also, valid dimension names (pSrcDim & pTgtDim) are mandatory otherwise the process\
    \ will abort.\n# When data needs to be kept (using pIncludeData) a valid element (pEle) in new dimension\
    \ must be specified\n# where to store the data. Data is summed from original dimension.\n# Rule can\
    \ be kept as backup file only or reloaded back.\n#EndRegion @DOC\n\n\n# This process selects the cube\
    \ and replaces\n# the source dimensions from a specified target dimensions.\n# This process should\
    \ only be run on an EMPTY cube or a cube that\n# has already had all data exported to a text file\n\
    \n# Note:\n# - This process does not preserve any cube rules as they would likely no longer be\n#\
    \   valid if a dimension is replaced\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\n\n### Constants ###\ncThisProcName     = GetProcessName();\n\
    cUserName         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pSrcDim:%pSrcDim%, pTgtDim:%pTgtDim%, pIncludeData:%pIncludeData%,\
    \ pEle:%pEle%, pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.' ;   \ncDefaultView\
    \      = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\n\n## check operating system\nIf(\
    \ SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf(\
    \ Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n \
    \ sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n### Validate Parameters ###\nnErrors = 0;\n# Validate\
    \ cube\nIf( Trim( pCube ) @= '' );\n    sMessage = 'No cube specified.';\n    nErrors = nErrors +\
    \ 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) =\
    \ 0 );\n    sMessage = Expand( 'Cube %pCube% does not exist.' );\n    nErrors = nErrors + 1;\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Don't allow system cubes to\
    \ be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\n  nErrors = nErrors + 1;\n  sMessage\
    \ = Expand( 'Do not modify system cubes: %pCube%.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate source dimension\nIf( Trim( pSrcDim ) @= '' );\n  nErrors = nErrors +\
    \ 1;\n  sMessage = 'No source dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pSrcDim ) = 0 );\n  nErrors = nErrors + 1;\n  sMessage = Expand(\
    \ 'Source dimension %pSrcDim% does not exist.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate target dimension\nIf( Trim( pTgtDim ) @= '' );\n  nErrors = nErrors +\
    \ 1;\n  sMessage = 'No target dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pTgtDim ) = 0 );\n  nErrors = nErrors + 1;\n  sMessage = Expand(\
    \ 'Target dimension %pTgtDim% does not exist.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Check that the source and target dimensions are different\nIf( pSrcDim @= pTgtDim\
    \ );\n  sMessage = Expand('Source and target dimensions are the same: %pSrcDim%');\n  nErrors = nErrors\
    \ + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# check element chosen\
    \ in new dimension\nIf( pIncludeData = 1 & Trim(pEle)@='' );\n  nErrors = nErrors + 1;\n  sMessage\
    \ = Expand( 'No element specified in new dimension %pTgtDim% to store cube data.');\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pIncludeData = 1 & DIMIX(pTgtDim, pEle)=0\
    \ );\n  nErrors = nErrors + 1;\n  sMessage = Expand( 'Invalid element %pEle% specified for the new\
    \ dimension %pTgtDim% to store cube data.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n  cCubeRuleFileName = '.' | sOSDelim\
    \ | pCube | '.RUX';\n  If(FileExists(cCubeRuleFileName) = 0);\n    pIncludeRules = 0;\n    LogOutput(\
    \ 'INFO', Expand( 'No rule found for %pCube%.' ) );\n  Endif;\nEndif;  \n\n### Determine number of\
    \ dims in source cube & create strings to check and recreate ###\nnCount = 1;\nsDimString = '';\n\
    sDimCheck = '';\nsDelim = '+';\nWhile( TabDim( pCube, nCount ) @<> '' );\n  sDim = TabDim( pCube,\
    \ nCount );\n  IF(sDim@=pSrcDim);\n    sNewDim=pTgtDim;\n  else;\n    sNewDim=sDim;\n  Endif;  \n\
    \  IF(nCount = 1);\n    sDimCheck = '+'|sDim|'+';\n    sDimString = sNewDim;\n  elseif(nCount > 1);\n\
    \    sDimCheck = sDimCheck|'+'|sDim|'+';\n    sDimString = sDimString|'+'|sNewDim;\n  Endif;\n  nCount\
    \ = nCount + 1;\nEnd;\nnDimensionCount = nCount - 1;\n\n#Remove any leading +\nIF( Subst( sDimString\
    \ , 1 , 1 ) @= '+' );\n    sDimString      = Subst ( sDimString , 2 , 999 );\nEndIf;\n\n#check source\
    \ dimension\nIF(scan('+'|pSrcDim|'+', sDimCheck)=0);\n  nErrors = nErrors + 1;\n  sMessage = Expand(\
    \ 'Source Dimension %pSrcDim% does not exist in %pCube%.');\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndif;  \n\n#check target dimension\nIF(scan('+'|pTgtDim|'+', sDimCheck)>0);\n\
    \  nErrors = nErrors + 1;\n  sMessage = Expand( 'Target Dimension %pTgtDim% already exists in %pCube%.');\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n# Check if cube exceeds current\
    \ max dimenions\nIf( nDimensionCount > 27 );\n  sMessage = 'Process needs to be modified to handle\
    \ cubes with more than 27 dimensions';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n \
    \ If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n######  CALLING THE STEP PROCESSES #####\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules\
    \ = 2);\n    sProc = '}bedrock.cube.rule.manage';\n\n    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput',\
    \ pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n        'pCube', pCube,\n  \
    \      'pMode', 'UNLOAD'\n        );\n    \n    IF(nRet <> 0);\n        sMessage = 'Error unloading\
    \ the rule for %pCube%.';\n        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n   \
    \     Else;\n            ProcessBreak;\n        EndIf;        \n    ENDIF;\n  \nEndif; \n\n# create\
    \ clone cube with data\nIF(pIncludeData = 1);\n  \n    pCloneCube = pCube | '_Clone';\n    nIncludeRules\
    \ = IF(pIncludeRules = 1 % pIncludeRules = 2, 1, 0);\n     nSuppressRules = IF(nIncludeRules = 1,\
    \  1, 0);\n  \n    sProc = '}bedrock.cube.clone';\n    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput',\
    \ pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n        'pSrcCube', pCube,\n\
    \        'pTgtCube', pCloneCube,\n        'pIncludeRules', nIncludeRules,\n        'pIncludeData',\
    \ pIncludeData,\n        'pSuppressRules', nSuppressRules,\n        'pTemp', pTemp,\n        'pCubeLogging',\
    \ 0\n        );\n\n    IF(nRet <> 0);\n        sMessage = 'Error creating cloned cube for keeping\
    \ data.';\n        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n     \
    \       ProcessBreak;\n        EndIf;\n    ENDIF;\n  \nEndif;\n\n# recreate the cube\nsProc = '}bedrock.cube.create';\n\
    nRet = ExecuteProcess( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pCube', pCube,\n        'pDims', sDimString,\n        'pRecreate',\
    \ 1,\n        'pDelim', sDelim\n        );\n\nIF(nRet <> 0);\n    sMessage = Expand('Error recreating\
    \ the cube: %pCube%.');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\nENDIF;\n\n\n# copy back the data\nIF(pIncludeData = 1);\n    sEleStartDelim = '¦';\n\
    \    sMappingToNewDims = pTgtDim|sEleStartDelim|pEle;\n  \n    nRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \t    'pLogOutput',pLogOutput,\n\t    'pStrictErrorHandling', pStrictErrorHandling,\n\t    'pSrcCube',pCloneCube,\n\
    \t    'pFilter','',\n\t    'pTgtCube',pCube,\n\t    'pMappingToNewDims',sMappingToNewDims,\n     \
    \   'pSuppressConsol', 1,\n        'pSuppressRules', nSuppressRules,\n\t    'pZeroTarget',0,\n\t \
    \   'pZeroSource',0,\n\t    'pFactor',1,\n\t    'pDimDelim','&',\n\t    'pEleStartDelim',sEleStartDelim,\n\
    \t    'pEleDelim','+',\n\t    'pTemp',pTemp,\n\t    'pCubeLogging',0);\n    \n    IF(nRet <> 0);\n\
    \        sMessage = Expand('Error copying back the data from clone cube: %pCloneCube%.');\n      \
    \  nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    \
    \    If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n\
    \        EndIf;\n    ENDIF;\n  \n    # destroy clone cube\n    IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n\
    \        nRet = EXECUTEPROCESS( sProc,\n            'pLogOutput', pLogOutput,\n            'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n            'pCube', pCloneCube,\n            'pCtrlObj', 0\n           \
    \ );\n\n        IF(nRet <> 0);\n            sMessage = Expand('Error deleting the clone cube: %pCloneCube%.');\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n            Else;\n\
    \                ProcessBreak;\n            EndIf;\n        ENDIF;\n    Endif;\n  \nEndif; \n\n# reload\
    \ the rule\nIF(pIncludeRules = 2);\n  \n    sProc = '}bedrock.cube.rule.manage';\n\n    nRet = EXECUTEPROCESS(\
    \ sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pCube', pCube,\n        'pMode', 'LOAD'\n        );\n    \n    IF(nRet <> 0);\n      sMessage\
    \ = Expand('Error reloading the rule for %pCube%.');\n      nErrors = nErrors + 1;\n      LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      # Create error rule file \n      cErrorRuleName\
    \ = 'ErrorRuleFile.rux';\n\n      IF(FileExists( cErrorRuleName ) = 0 );\n        sFile = '.' | sOSDelim\
    \ | cErrorRuleName;\n        LogOutput(cMsgErrorLevel, 'Rule could not be attached due to invalid\
    \ !Dimension references. Please recover from the backup and fix manually.');\n      ENDIF;\n\n   \
    \   EXECUTEPROCESS( sProc,\n      'pLogOutput', pLogOutput,\n      'pStrictErrorHandling', pStrictErrorHandling,\n\
    \      'pCube', pCube,\n      'pFileName', cErrorRuleName,\n      'pMode', 'LOAD'\n      );\n    \
    \  If( pStrictErrorHandling = 1 ); \n          ProcessQuit; \n      Else;\n          ProcessBreak;\n\
    \      EndIf;\n    ENDIF;\n  \nEndif; \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully replaced\
    \ the %pSrcDim% dimension with the %pTgtDim% in the %pCube% cube. Data was loaded to the %pEle% item.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n  \n### End Epilog ###"
- question: 'The IBM Turbo Integrator process described involves removing one dimension from an existing
    cube and adding another one without losing data. This process is intended primarily for development
    and prototyping purposes and operates as follows: 1/ After removing one dimension and adding another,
    the existing cube is rebuilt without losing all the data. It is important to note that a valid cube
    name (pCube) is mandatory, otherwise, the process will abort. Additionally, the names of the relevant
    dimensions (pSrcDim & pTgtDim) are mandatory, and the process will also abort if they are invalid.
    If data needs to be preserved, a valid element (pEle) in the new dimension must be specified for data
    storage. The data is summed from the original dimension. Rules can be saved as backup files or reloaded.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This TI deletes a dimension and adds another one to an existing\
    \ cube with the ability to preserve data.\n\n# Use case: Intended for development/prototyping.\n#\
    \ 1/ Rebuild existing cube after removal of one dimension and adding anothr one without losing all\
    \ the data.\n\n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process\
    \ will abort.\n# Also, valid dimension names (pSrcDim & pTgtDim) are mandatory otherwise the process\
    \ will abort.\n# When data needs to be kept (using pIncludeData) a valid element (pEle) in new dimension\
    \ must be specified\n# where to store the data. Data is summed from original dimension.\n# Rule can\
    \ be kept as backup file only or reloaded back.\n#EndRegion @DOC\n\n\n# This process selects the cube\
    \ and replaces\n# the source dimensions from a specified target dimensions.\n# This process should\
    \ only be run on an EMPTY cube or a cube that\n# has already had all data exported to a text file\n\
    \n# Note:\n# - This process does not preserve any cube rules as they would likely no longer be\n#\
    \   valid if a dimension is replaced\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\n\n### Constants ###\ncThisProcName     = GetProcessName();\n\
    cUserName         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pSrcDim:%pSrcDim%, pTgtDim:%pTgtDim%, pIncludeData:%pIncludeData%,\
    \ pEle:%pEle%, pIncludeRules:%pIncludeRules%, pCtrlObj:%pCtrlObj%, pTemp:%pTemp%.' ;   \ncDefaultView\
    \      = Expand( '%cThisProcName%_%cTimeStamp%_%cRandomInt%' );\n\n## check operating system\nIf(\
    \ SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf(\
    \ Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n \
    \ sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n### Validate Parameters ###\nnErrors = 0;\n# Validate\
    \ cube\nIf( Trim( pCube ) @= '' );\n    sMessage = 'No cube specified.';\n    nErrors = nErrors +\
    \ 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) =\
    \ 0 );\n    sMessage = Expand( 'Cube %pCube% does not exist.' );\n    nErrors = nErrors + 1;\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Don't allow system cubes to\
    \ be modified\nIf( SubSt( pCube, 1, 1 ) @= '}' & pCtrlObj <= 0 );\n  nErrors = nErrors + 1;\n  sMessage\
    \ = Expand( 'Do not modify system cubes: %pCube%.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate source dimension\nIf( Trim( pSrcDim ) @= '' );\n  nErrors = nErrors +\
    \ 1;\n  sMessage = 'No source dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pSrcDim ) = 0 );\n  nErrors = nErrors + 1;\n  sMessage = Expand(\
    \ 'Source dimension %pSrcDim% does not exist.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate target dimension\nIf( Trim( pTgtDim ) @= '' );\n  nErrors = nErrors +\
    \ 1;\n  sMessage = 'No target dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pTgtDim ) = 0 );\n  nErrors = nErrors + 1;\n  sMessage = Expand(\
    \ 'Target dimension %pTgtDim% does not exist.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Check that the source and target dimensions are different\nIf( pSrcDim @= pTgtDim\
    \ );\n  sMessage = Expand('Source and target dimensions are the same: %pSrcDim%');\n  nErrors = nErrors\
    \ + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# check element chosen\
    \ in new dimension\nIf( pIncludeData = 1 & Trim(pEle)@='' );\n  nErrors = nErrors + 1;\n  sMessage\
    \ = Expand( 'No element specified in new dimension %pTgtDim% to store cube data.');\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pIncludeData = 1 & DIMIX(pTgtDim, pEle)=0\
    \ );\n  nErrors = nErrors + 1;\n  sMessage = Expand( 'Invalid element %pEle% specified for the new\
    \ dimension %pTgtDim% to store cube data.');\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF(pIncludeRules = 1 % pIncludeRules = 2);\n  cCubeRuleFileName = '.' | sOSDelim\
    \ | pCube | '.RUX';\n  If(FileExists(cCubeRuleFileName) = 0);\n    pIncludeRules = 0;\n    LogOutput(\
    \ 'INFO', Expand( 'No rule found for %pCube%.' ) );\n  Endif;\nEndif;  \n\n### Determine number of\
    \ dims in source cube & create strings to check and recreate ###\nnCount = 1;\nsDimString = '';\n\
    sDimCheck = '';\nsDelim = '+';\nWhile( TabDim( pCube, nCount ) @<> '' );\n  sDim = TabDim( pCube,\
    \ nCount );\n  IF(sDim@=pSrcDim);\n    sNewDim=pTgtDim;\n  else;\n    sNewDim=sDim;\n  Endif;  \n\
    \  IF(nCount = 1);\n    sDimCheck = '+'|sDim|'+';\n    sDimString = sNewDim;\n  elseif(nCount > 1);\n\
    \    sDimCheck = sDimCheck|'+'|sDim|'+';\n    sDimString = sDimString|'+'|sNewDim;\n  Endif;\n  nCount\
    \ = nCount + 1;\nEnd;\nnDimensionCount = nCount - 1;\n\n#Remove any leading +\nIF( Subst( sDimString\
    \ , 1 , 1 ) @= '+' );\n    sDimString      = Subst ( sDimString , 2 , 999 );\nEndIf;\n\n#check source\
    \ dimension\nIF(scan('+'|pSrcDim|'+', sDimCheck)=0);\n  nErrors = nErrors + 1;\n  sMessage = Expand(\
    \ 'Source Dimension %pSrcDim% does not exist in %pCube%.');\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndif;  \n\n#check target dimension\nIF(scan('+'|pTgtDim|'+', sDimCheck)>0);\n\
    \  nErrors = nErrors + 1;\n  sMessage = Expand( 'Target Dimension %pTgtDim% already exists in %pCube%.');\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n# Check if cube exceeds current\
    \ max dimenions\nIf( nDimensionCount > 27 );\n  sMessage = 'Process needs to be modified to handle\
    \ cubes with more than 27 dimensions';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n \
    \ If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n######  CALLING THE STEP PROCESSES #####\n# Keep the rule\nIF(pIncludeRules = 1 % pIncludeRules\
    \ = 2);\n    sProc = '}bedrock.cube.rule.manage';\n\n    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput',\
    \ pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n        'pCube', pCube,\n  \
    \      'pMode', 'UNLOAD'\n        );\n    \n    IF(nRet <> 0);\n        sMessage = 'Error unloading\
    \ the rule for %pCube%.';\n        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n   \
    \     Else;\n            ProcessBreak;\n        EndIf;        \n    ENDIF;\n  \nEndif; \n\n# create\
    \ clone cube with data\nIF(pIncludeData = 1);\n  \n    pCloneCube = pCube | '_Clone';\n    nIncludeRules\
    \ = IF(pIncludeRules = 1 % pIncludeRules = 2, 1, 0);\n     nSuppressRules = IF(nIncludeRules = 1,\
    \  1, 0);\n  \n    sProc = '}bedrock.cube.clone';\n    nRet = EXECUTEPROCESS( sProc,\n        'pLogOutput',\
    \ pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n        'pSrcCube', pCube,\n\
    \        'pTgtCube', pCloneCube,\n        'pIncludeRules', nIncludeRules,\n        'pIncludeData',\
    \ pIncludeData,\n        'pSuppressRules', nSuppressRules,\n        'pTemp', pTemp,\n        'pCubeLogging',\
    \ 0\n        );\n\n    IF(nRet <> 0);\n        sMessage = 'Error creating cloned cube for keeping\
    \ data.';\n        nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n     \
    \       ProcessBreak;\n        EndIf;\n    ENDIF;\n  \nEndif;\n\n# recreate the cube\nsProc = '}bedrock.cube.create';\n\
    nRet = ExecuteProcess( sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n        'pCube', pCube,\n        'pDims', sDimString,\n        'pRecreate',\
    \ 1,\n        'pDelim', sDelim\n        );\n\nIF(nRet <> 0);\n    sMessage = Expand('Error recreating\
    \ the cube: %pCube%.');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\nENDIF;\n\n\n# copy back the data\nIF(pIncludeData = 1);\n    sEleStartDelim = '¦';\n\
    \    sMappingToNewDims = pTgtDim|sEleStartDelim|pEle;\n  \n    nRet = ExecuteProcess('}bedrock.cube.data.copy.intercube',\n\
    \t    'pLogOutput',pLogOutput,\n\t    'pStrictErrorHandling', pStrictErrorHandling,\n\t    'pSrcCube',pCloneCube,\n\
    \t    'pFilter','',\n\t    'pTgtCube',pCube,\n\t    'pMappingToNewDims',sMappingToNewDims,\n     \
    \   'pSuppressConsol', 1,\n        'pSuppressRules', nSuppressRules,\n\t    'pZeroTarget',0,\n\t \
    \   'pZeroSource',0,\n\t    'pFactor',1,\n\t    'pDimDelim','&',\n\t    'pEleStartDelim',sEleStartDelim,\n\
    \t    'pEleDelim','+',\n\t    'pTemp',pTemp,\n\t    'pCubeLogging',0);\n    \n    IF(nRet <> 0);\n\
    \        sMessage = Expand('Error copying back the data from clone cube: %pCloneCube%.');\n      \
    \  nErrors = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    \
    \    If( pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n\
    \        EndIf;\n    ENDIF;\n  \n    # destroy clone cube\n    IF(pTemp=1);\n        sProc = '}bedrock.cube.delete';\n\
    \        nRet = EXECUTEPROCESS( sProc,\n            'pLogOutput', pLogOutput,\n            'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n            'pCube', pCloneCube,\n            'pCtrlObj', 0\n           \
    \ );\n\n        IF(nRet <> 0);\n            sMessage = Expand('Error deleting the clone cube: %pCloneCube%.');\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n            Else;\n\
    \                ProcessBreak;\n            EndIf;\n        ENDIF;\n    Endif;\n  \nEndif; \n\n# reload\
    \ the rule\nIF(pIncludeRules = 2);\n  \n    sProc = '}bedrock.cube.rule.manage';\n\n    nRet = EXECUTEPROCESS(\
    \ sProc,\n        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n\
    \        'pCube', pCube,\n        'pMode', 'LOAD'\n        );\n    \n    IF(nRet <> 0);\n      sMessage\
    \ = Expand('Error reloading the rule for %pCube%.');\n      nErrors = nErrors + 1;\n      LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      # Create error rule file \n      cErrorRuleName\
    \ = 'ErrorRuleFile.rux';\n\n      IF(FileExists( cErrorRuleName ) = 0 );\n        sFile = '.' | sOSDelim\
    \ | cErrorRuleName;\n        LogOutput(cMsgErrorLevel, 'Rule could not be attached due to invalid\
    \ !Dimension references. Please recover from the backup and fix manually.');\n      ENDIF;\n\n   \
    \   EXECUTEPROCESS( sProc,\n      'pLogOutput', pLogOutput,\n      'pStrictErrorHandling', pStrictErrorHandling,\n\
    \      'pCube', pCube,\n      'pFileName', cErrorRuleName,\n      'pMode', 'LOAD'\n      );\n    \
    \  If( pStrictErrorHandling = 1 ); \n          ProcessQuit; \n      Else;\n          ProcessBreak;\n\
    \      EndIf;\n    ENDIF;\n  \nEndif; \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully replaced\
    \ the %pSrcDim% dimension with the %pTgtDim% in the %pCube% cube. Data was loaded to the %pEle% item.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n  \n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der das Backup und Entfernen oder das erneute
    Anhängen einer Regeldatei an einen Würfel durchführt. Der Prozess soll im produktiven Umfeld verwendet
    werden und zwei Hauptfunktionen erfüllen: Erstens soll die Regeldatei vor dem Laden von Daten entfernt
    werden, um den Ladeprozess zu beschleunigen. Zweitens soll die Regeldatei nach dem Laden der Daten
    wieder angehängt werden. Beachte, dass ein gültiger Würfelname (pCube) notwendig ist, da der Prozess
    andernfalls abbrechen wird. Der Pflichtparameter pMode muss auf ''Unload'' gesetzt werden, um die
    Regeldatei zu entfernen oder zu entladen. Um die Regeldatei wieder anzuhängen und die Regeln anzuwenden,
    muss der pMode-Parameter auf ''Load'' gesetzt werden.'
  answer: "Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will backup & remove **OR** re-attach the rule file\
    \ to cube.\n\n# Use case: Intended to be used in production.\n# 1/ Remove rule file before data load\
    \ to speed up data load.\n# 2/ Re-attach rule file after data load.\n\n# Note:\n# Naturally, a valid\
    \ cube name (pCube) is mandatory otherwise the process will abort.\n# The mandatory pMode parameter\
    \ must be set to 'Unload' to remove/unload the rule file.\n# The pMode parameter must be set to 'Load'\
    \ to re-attach the rule file and apply the rules.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName | '_' |\
    \ cTimeStamp | '_' | cRandomInt;\ncCubeDim            = '}Cubes';\ncCubeHier           = cCubeDim;\n\
    sPath               = '';\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pMode:%pMode%, pFileName:%pFileName%, pDelim:%pDelim%, pPath:%pPath%.'\
    \ ;  \ncDimCubes           = '}Cubes';\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \n\
    ENDIF;\n\nnErrors = 0;\n\n### PROCESS PROPERTIES\nDatasourceASCIIDelimiter = '';\nDatasourceASCIIQuoteCharacter\
    \ = '';\n\n##Validate Mode\nIf(upper(pMode) @<> 'LOAD' & upper(pMode) @<> 'UNLOAD');\n    sMessage\
    \ = Expand('Invalid Mode: %pMode%. Valid Modes are Load or Unload');\n    nErrors = nErrors + 1;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n##Validate Cube\nIf( Trim(pCube)\
    \ @= '' );\n    sMessage = Expand('No cube specified');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n## Default filter delimiters\nIf( pDelim\
    \     @= '' );\n    pDelim     = '&';\nEndIf;\n\n# define backupdir\nIf(pPath @<> '');\n    If(Subst(pPath,long(pPath),1)\
    \ @= sOSDelim );\n        sPath = pPath;\n    Else;\n        sPath = pPath | sOSDelim;\n    Endif;\n\
    Else;\n  sPath = '.' | sOSDelim;\nEndif;\n\n## Default files names for storing rule and backups\n\
    IF(pFileName@='');\n  sRuleFileName         = '%sCube%.txt';\n  sBackupFileName       = '%sCube%.rux.bkp_%cTimeStamp%.txt';\n\
    Else;\n  sRuleFileName         = pFileName;\n  sBackupFileName       = '%pFileName%.bkp_%cTimeStamp%.txt';\n\
    Endif;  \n  \n# Loop through list of Cubes\nsCubes = pCube;\nnCubeDelimIndex = 1;\n\nWhile( nCubeDelimIndex\
    \ <> 0 );\n  nCubeDelimIndex = Scan( pDelim, sCubes );\n  If( nCubeDelimIndex = 0 );\n    sCube =\
    \ sCubes;\n  Else;\n    If (sOS @= 'Windows');\n      sCube = Trim( SubSt( sCubes, 1, nCubeDelimIndex\
    \ - 1 ) );\n    Else;\n      sCube = LOWER(Trim( SubSt( sCubes, 1, nCubeDelimIndex - 1 ) ));\n   \
    \ EndIf;\n    sCubes = Trim( Subst( sCubes, nCubeDelimIndex + Long(pDelim), Long( sCubes ) ) );\n\
    \  EndIf;\n\n  sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL([}Cubes]), '%sCube%')}' );\n\n  sProc\
    \ = '}bedrock.hier.sub.create.bymdx';\n  ExecuteProcess( sProc,\n    'pLogOutput', pLogOutput,\n \
    \   'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim', cDimCubes,\n    'pHier', '',\n    'pSub',\
    \ cTempSub,\n    'pMDXExpr', sMDX,\n    'pConvertToStatic', 1,\n    'pTemp', 1\n  );\n\n  nCube =\
    \ 1;\n  nCubes = SubsetGetSize( cDimCubes, cTempSub );\n  While( nCube <= nCubes );\n    sCube = SubsetGetElementName(\
    \ cDimCubes, cTempSub, nCube );\n    nCube = nCube + 1;\n    \n    If( sOS @= 'Windows');\n      cCubeRuleFileName\
    \ = '.' | sOSDelim | sCube | '.rux';\n    Else;\n      cCubeRuleFileName = '.' | sOSDelim | LOWER(sCube)\
    \ | '.rux';\n    EndIf;\n    If( sOS @= 'Windows');\n      cStoreDirFile = sPath | Expand(sRuleFileName);\n\
    \      cBackupDirFile = sPath | Expand(sBackupFileName); \n    Else;\n      cStoreDirFile = sPath\
    \ | LOWER(Expand(sRuleFileName));\n      cBackupDirFile = sPath | LOWER(Expand(sBackupFileName));\
    \ \n    EndIf;\n    # if there already is a rule file\n    If(FileExists(cCubeRuleFileName) <> 0);\n\
    \      ##Loading the Rule###\n      If(Upper(pMode) @= 'LOAD');\n        ##Backup the existing rule\
    \ (saved as .bkp.txt in given path or data directory) \n        ##and load the new rule file. New\
    \ Rule file should available in the given path or in data directory\n        If( sOS @= 'Windows');\n\
    \          sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cBackupDirFile | '';          \n     \
    \   Else;\n          sCmd = 'cp '' | cCubeRuleFileName | '' '' | cBackupDirFile | ''';        \n \
    \       EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the backup file exists\n    \
    \    If( FileExists( cBackupDirFile ) <> 0 );\n          RuleLoadFromFile( sCube, cStoreDirFile);\n\
    \        Else;\n          sMessage = Expand('Backup of rule file (%cCubeRuleFileName%) has failed,\
    \ rule was not loaded.');\n          nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit;\
    \ \n          Else;\n              ProcessBreak;\n          EndIf;\n        EndIf;\n      Else;\n\
    \        ##Unloading the Rule###\n        ##Before unloading, backup the existing rule (saved as .bkp.txt\
    \ in data directory or with the suffix parameter)\n        ##and drop current rule\n        If( sOS\
    \ @= 'Windows');\n          sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cBackupDirFile | '';\n\
    \        Else;\n          sCmd = 'cp '' | cCubeRuleFileName | '' '' | cBackupDirFile |''';\n     \
    \   EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the backup file exists\n        If(\
    \ FileExists( cBackupDirFile ) = 0 );\n          sMessage = Expand('Backup of rule file (%cCubeRuleFileName%)\
    \ has failed, rule was not unloaded.');\n          nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit;\
    \ \n          Else;\n              ProcessBreak;\n          EndIf;\n        EndIf;\n        If( sOS\
    \ @= 'Windows');\n          sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cStoreDirFile | '';\n\
    \        Else;\n          sCmd = 'cp '' | cCubeRuleFileName | ''  '' | cStoreDirFile |''';\n     \
    \   EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the saved rule file exists\n    \
    \    If( FileExists( cStoreDirFile ) <> 0 );\n          CubeRuleDestroy( sCube );\n        Else;\n\
    \          sMessage = Expand('Copy of rule file (%cCubeRuleFileName%) has failed, rule was not unloaded.');\n\
    \          nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit; \n          Else;\n \
    \             ProcessBreak;\n          EndIf;\n        EndIf;\n      Endif;\n      \n    Else;\n \
    \     ###To create a new rule file for the cube (no existing rule)\n      If(Upper(pMode) @= 'LOAD');\n\
    \        RuleLoadFromFile( sCube, cStoreDirFile );\n      Else;\n        nErrors = nErrors + 1;\n\
    \        sMessage = 'No Rule file found for cube: ' | sCube;\n        LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n      Endif;\n    Endif;\n  End;\nEnd;\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully %pMode% cube rule from cube %pCube% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that performs the backup and removal or re-attachment
    of a rule file to a cube. This process is intended to be used in a production environment with two
    main functions: Firstly, to remove the rule file before data loading to speed up the data loading
    process. Secondly, to re-attach the rule file after data load. Note that a valid cube name (pCube)
    is mandatory, otherwise the process will abort. The mandatory pMode parameter must be set to ''Unload''
    to remove/unload the rule file. To re-attach the rule file and apply the rules, the pMode parameter
    must be set to ''Load''.'
  answer: "Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will backup & remove **OR** re-attach the rule file\
    \ to cube.\n\n# Use case: Intended to be used in production.\n# 1/ Remove rule file before data load\
    \ to speed up data load.\n# 2/ Re-attach rule file after data load.\n\n# Note:\n# Naturally, a valid\
    \ cube name (pCube) is mandatory otherwise the process will abort.\n# The mandatory pMode parameter\
    \ must be set to 'Unload' to remove/unload the rule file.\n# The pMode parameter must be set to 'Load'\
    \ to re-attach the rule file and apply the rules.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName | '_' |\
    \ cTimeStamp | '_' | cRandomInt;\ncCubeDim            = '}Cubes';\ncCubeHier           = cCubeDim;\n\
    sPath               = '';\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pMode:%pMode%, pFileName:%pFileName%, pDelim:%pDelim%, pPath:%pPath%.'\
    \ ;  \ncDimCubes           = '}Cubes';\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \n\
    ENDIF;\n\nnErrors = 0;\n\n### PROCESS PROPERTIES\nDatasourceASCIIDelimiter = '';\nDatasourceASCIIQuoteCharacter\
    \ = '';\n\n##Validate Mode\nIf(upper(pMode) @<> 'LOAD' & upper(pMode) @<> 'UNLOAD');\n    sMessage\
    \ = Expand('Invalid Mode: %pMode%. Valid Modes are Load or Unload');\n    nErrors = nErrors + 1;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n##Validate Cube\nIf( Trim(pCube)\
    \ @= '' );\n    sMessage = Expand('No cube specified');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n## Default filter delimiters\nIf( pDelim\
    \     @= '' );\n    pDelim     = '&';\nEndIf;\n\n# define backupdir\nIf(pPath @<> '');\n    If(Subst(pPath,long(pPath),1)\
    \ @= sOSDelim );\n        sPath = pPath;\n    Else;\n        sPath = pPath | sOSDelim;\n    Endif;\n\
    Else;\n  sPath = '.' | sOSDelim;\nEndif;\n\n## Default files names for storing rule and backups\n\
    IF(pFileName@='');\n  sRuleFileName         = '%sCube%.txt';\n  sBackupFileName       = '%sCube%.rux.bkp_%cTimeStamp%.txt';\n\
    Else;\n  sRuleFileName         = pFileName;\n  sBackupFileName       = '%pFileName%.bkp_%cTimeStamp%.txt';\n\
    Endif;  \n  \n# Loop through list of Cubes\nsCubes = pCube;\nnCubeDelimIndex = 1;\n\nWhile( nCubeDelimIndex\
    \ <> 0 );\n  nCubeDelimIndex = Scan( pDelim, sCubes );\n  If( nCubeDelimIndex = 0 );\n    sCube =\
    \ sCubes;\n  Else;\n    If (sOS @= 'Windows');\n      sCube = Trim( SubSt( sCubes, 1, nCubeDelimIndex\
    \ - 1 ) );\n    Else;\n      sCube = LOWER(Trim( SubSt( sCubes, 1, nCubeDelimIndex - 1 ) ));\n   \
    \ EndIf;\n    sCubes = Trim( Subst( sCubes, nCubeDelimIndex + Long(pDelim), Long( sCubes ) ) );\n\
    \  EndIf;\n\n  sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL([}Cubes]), '%sCube%')}' );\n\n  sProc\
    \ = '}bedrock.hier.sub.create.bymdx';\n  ExecuteProcess( sProc,\n    'pLogOutput', pLogOutput,\n \
    \   'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim', cDimCubes,\n    'pHier', '',\n    'pSub',\
    \ cTempSub,\n    'pMDXExpr', sMDX,\n    'pConvertToStatic', 1,\n    'pTemp', 1\n  );\n\n  nCube =\
    \ 1;\n  nCubes = SubsetGetSize( cDimCubes, cTempSub );\n  While( nCube <= nCubes );\n    sCube = SubsetGetElementName(\
    \ cDimCubes, cTempSub, nCube );\n    nCube = nCube + 1;\n    \n    If( sOS @= 'Windows');\n      cCubeRuleFileName\
    \ = '.' | sOSDelim | sCube | '.rux';\n    Else;\n      cCubeRuleFileName = '.' | sOSDelim | LOWER(sCube)\
    \ | '.rux';\n    EndIf;\n    If( sOS @= 'Windows');\n      cStoreDirFile = sPath | Expand(sRuleFileName);\n\
    \      cBackupDirFile = sPath | Expand(sBackupFileName); \n    Else;\n      cStoreDirFile = sPath\
    \ | LOWER(Expand(sRuleFileName));\n      cBackupDirFile = sPath | LOWER(Expand(sBackupFileName));\
    \ \n    EndIf;\n    # if there already is a rule file\n    If(FileExists(cCubeRuleFileName) <> 0);\n\
    \      ##Loading the Rule###\n      If(Upper(pMode) @= 'LOAD');\n        ##Backup the existing rule\
    \ (saved as .bkp.txt in given path or data directory) \n        ##and load the new rule file. New\
    \ Rule file should available in the given path or in data directory\n        If( sOS @= 'Windows');\n\
    \          sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cBackupDirFile | '';          \n     \
    \   Else;\n          sCmd = 'cp '' | cCubeRuleFileName | '' '' | cBackupDirFile | ''';        \n \
    \       EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the backup file exists\n    \
    \    If( FileExists( cBackupDirFile ) <> 0 );\n          RuleLoadFromFile( sCube, cStoreDirFile);\n\
    \        Else;\n          sMessage = Expand('Backup of rule file (%cCubeRuleFileName%) has failed,\
    \ rule was not loaded.');\n          nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit;\
    \ \n          Else;\n              ProcessBreak;\n          EndIf;\n        EndIf;\n      Else;\n\
    \        ##Unloading the Rule###\n        ##Before unloading, backup the existing rule (saved as .bkp.txt\
    \ in data directory or with the suffix parameter)\n        ##and drop current rule\n        If( sOS\
    \ @= 'Windows');\n          sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cBackupDirFile | '';\n\
    \        Else;\n          sCmd = 'cp '' | cCubeRuleFileName | '' '' | cBackupDirFile |''';\n     \
    \   EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the backup file exists\n        If(\
    \ FileExists( cBackupDirFile ) = 0 );\n          sMessage = Expand('Backup of rule file (%cCubeRuleFileName%)\
    \ has failed, rule was not unloaded.');\n          nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit;\
    \ \n          Else;\n              ProcessBreak;\n          EndIf;\n        EndIf;\n        If( sOS\
    \ @= 'Windows');\n          sCmd = 'cmd /c 'copy  | cCubeRuleFileName |    | cStoreDirFile | '';\n\
    \        Else;\n          sCmd = 'cp '' | cCubeRuleFileName | ''  '' | cStoreDirFile |''';\n     \
    \   EndIf;\n        ExecuteCommand(sCmd,1);\n        ## Check if the saved rule file exists\n    \
    \    If( FileExists( cStoreDirFile ) <> 0 );\n          CubeRuleDestroy( sCube );\n        Else;\n\
    \          sMessage = Expand('Copy of rule file (%cCubeRuleFileName%) has failed, rule was not unloaded.');\n\
    \          nErrors = nErrors + 1;\n          LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n          If( pStrictErrorHandling = 1 ); \n              ProcessQuit; \n          Else;\n \
    \             ProcessBreak;\n          EndIf;\n        EndIf;\n      Endif;\n      \n    Else;\n \
    \     ###To create a new rule file for the cube (no existing rule)\n      If(Upper(pMode) @= 'LOAD');\n\
    \        RuleLoadFromFile( sCube, cStoreDirFile );\n      Else;\n        nErrors = nErrors + 1;\n\
    \        sMessage = 'No Rule file found for cube: ' | sCube;\n        LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n      Endif;\n    Endif;\n  End;\nEnd;\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully %pMode% cube rule from cube %pCube% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Dieser IBM Turbo Integrator Prozess ist darauf ausgelegt, Feeders neu zu verarbeiten, wenn
    konsolidierte Summen nicht korrekt addiert werden. Der Anwendungsfall erstreckt sich sowohl auf Entwicklungs-
    als auch auf Produktionsumgebungen. Er wird eingesetzt, wenn Feeders neu verarbeitet werden müssen,
    beispielsweise wenn neue Elemente zu irgendeiner Dimension hinzugefügt werden. Beachten Sie, dass
    ein gültiger Würfelname (pCube) zwingend erforderlich ist; andernfalls wird der Prozess abgebrochen.
    Sowohl Platzhalter als auch Listen sind zulässig. Dieser Prozess verarbeitet Feeders für einen Würfel.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process reprocesses feeders when consolidated totals are not\
    \ adding up.\n\n# Use case: Intended for Deveopment or production.\n#1/ This process would be used\
    \ any time feeders need to be reprocessed (e.g. when new elements are added to any of the dimensions).\n\
    \n# Note:\n# Naturally, a valid  cube name (pCube) is mandatory otherwise the process will abort.\
    \ Wildcards and lists are acceptable.\n# This process will process feeders for a cube.\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName = TM1User();\n\
    cTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\nsMessage = \t'';\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\nnErrors = 0;\n\n### Validate Parameters ###\n# If blank delimiter specified then\
    \ convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# If no cubes have been specified\
    \ then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'No cubes specified';\n  nErrors\
    \ = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n\n### SET DATA SOURCE\
    \ ###\n\nDatasourceType = 'NULL';\n\n\n### Split parameter into individual cubes and delete ###\n\n\
    sCubes = pCube;\nnDelimiterIndex = 1;\nsMdx = '';\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex\
    \ = Scan( pDelim, sCubes );\n  If( nDelimiterIndex = 0 );\n    sCube = sCubes;\n  Else;\n    sCube\
    \ = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n    sCubes = Trim( Subst( sCubes, nDelimiterIndex\
    \ + Long(pDelim), Long( sCubes ) ) );\n  EndIf;\n  \n  # Check if a wildcard has been used to specify\
    \ the Cube name.\n  # If it hasn't then just delete the Cube if it exists\n      # If it has then\
    \ search the relevant Cube folder to find the matches\n      If( Scan( '*', sCube ) = 0 );\n     \
    \   If( CubeExists( sCube ) = 1 ); \n          CubeProcessFeeders( sCube );\n        Endif;\n    \
    \  Else;\n        # Create subset of cubes using Wildcard\n        sCubeExp = '''|sCube|''';\n   \
    \     sMdxPart = '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'| sCubeExp | ')}';\n        IF(\
    \ sMdx @= ''); \n          sMdx = sMdxPart; \n        ELSE;\n          sMdx = sMdx | ' + ' | sMdxPart;\n\
    \        ENDIF;\n        \n        If( SubsetExists( '}Cubes' , cTempSub ) = 1 );\n            # If\
    \ a delimited list of cube names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( '}Cubes' , cTempSub, sMDX );\n        Else;\n            # temp\
    \ subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes'\
    \ , 1 );\n        EndIf;\n        \n        # Loop through cubes in subset created based on wildcard\n\
    \        nCountCubes = SubsetGetSize( '}Cubes' , cTempSub );\n        While( nCountCubes >= 1 );\n\
    \          sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCubes );\n          # Validate\
    \ cube name\n          If( CubeExists( sCurrCube ) = 1 ); \n            # Process Feeders\n      \
    \      CubeProcessFeeders( sCurrCube );\n          Endif;\n            nCountCubes = nCountCubes -\
    \ 1;\n        End;\n      EndIf;\n\nEnd;\n\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully processed\
    \ feeders for cube %pCube% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n\n### End Epilog ###"
- question: This IBM Turbo Integrator process is designed to reprocess feeders when consolidated totals
    are not adding up accurately. The use case applies to both development and production environments.
    It is used when feeders need to be reprocessed, such as when new elements are added to any dimensions.
    Note that a valid cube name (pCube) is mandatory; otherwise, the process will abort. Wildcards and
    lists are acceptable. This process processes feeders for a cube.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process reprocesses feeders when consolidated totals are not\
    \ adding up.\n\n# Use case: Intended for Deveopment or production.\n#1/ This process would be used\
    \ any time feeders need to be reprocessed (e.g. when new elements are added to any of the dimensions).\n\
    \n# Note:\n# Naturally, a valid  cube name (pCube) is mandatory otherwise the process will abort.\
    \ Wildcards and lists are acceptable.\n# This process will process feeders for a cube.\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName = TM1User();\n\
    cTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\nsMessage = \t'';\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\nnErrors = 0;\n\n### Validate Parameters ###\n# If blank delimiter specified then\
    \ convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# If no cubes have been specified\
    \ then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'No cubes specified';\n  nErrors\
    \ = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n\n### SET DATA SOURCE\
    \ ###\n\nDatasourceType = 'NULL';\n\n\n### Split parameter into individual cubes and delete ###\n\n\
    sCubes = pCube;\nnDelimiterIndex = 1;\nsMdx = '';\n\nWhile( nDelimiterIndex <> 0 );\n  nDelimiterIndex\
    \ = Scan( pDelim, sCubes );\n  If( nDelimiterIndex = 0 );\n    sCube = sCubes;\n  Else;\n    sCube\
    \ = Trim( SubSt( sCubes, 1, nDelimiterIndex - 1 ) );\n    sCubes = Trim( Subst( sCubes, nDelimiterIndex\
    \ + Long(pDelim), Long( sCubes ) ) );\n  EndIf;\n  \n  # Check if a wildcard has been used to specify\
    \ the Cube name.\n  # If it hasn't then just delete the Cube if it exists\n      # If it has then\
    \ search the relevant Cube folder to find the matches\n      If( Scan( '*', sCube ) = 0 );\n     \
    \   If( CubeExists( sCube ) = 1 ); \n          CubeProcessFeeders( sCube );\n        Endif;\n    \
    \  Else;\n        # Create subset of cubes using Wildcard\n        sCubeExp = '''|sCube|''';\n   \
    \     sMdxPart = '{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ) ,'| sCubeExp | ')}';\n        IF(\
    \ sMdx @= ''); \n          sMdx = sMdxPart; \n        ELSE;\n          sMdx = sMdx | ' + ' | sMdxPart;\n\
    \        ENDIF;\n        \n        If( SubsetExists( '}Cubes' , cTempSub ) = 1 );\n            # If\
    \ a delimited list of cube names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( '}Cubes' , cTempSub, sMDX );\n        Else;\n            # temp\
    \ subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes'\
    \ , 1 );\n        EndIf;\n        \n        # Loop through cubes in subset created based on wildcard\n\
    \        nCountCubes = SubsetGetSize( '}Cubes' , cTempSub );\n        While( nCountCubes >= 1 );\n\
    \          sCurrCube = SubsetGetElementName( '}Cubes' , cTempSub, nCountCubes );\n          # Validate\
    \ cube name\n          If( CubeExists( sCurrCube ) = 1 ); \n            # Process Feeders\n      \
    \      CubeProcessFeeders( sCurrCube );\n          Endif;\n            nCountCubes = nCountCubes -\
    \ 1;\n        End;\n      EndIf;\n\nEnd;\n\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully processed\
    \ feeders for cube %pCube% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine Ansicht erstellt, die zum Exportieren,
    Kopieren oder Nullstellen von Zahlen verwendet werden kann. Der Prozess sollte sowohl für die Entwicklung/Prototyping
    als auch für den produktiven Einsatz geeignet sein. Stelle sicher, dass der Prozess in der Lage ist,
    eine Ansicht zum Nullstellen von Daten zu erstellen und eine weitere Ansicht, die als Quelle für den
    Export oder das Kopieren verwendet werden kann. Beachte, dass ein gültiger Würfelname (pCube) erforderlich
    ist, andernfalls wird der Prozess abgebrochen. Das pFilter-Parameter enthält die Dimensionen und Elemente
    zur Filterung, im Format ''Dim1: Elem1 + Elem2 & Dim2: Elem3 + Elem4''. Die Dimensionsparameter müssen
    nicht in der Reihenfolge der Indizes der Dimensionen im Würfel angegeben werden. Verwende Leerzeichen,
    um den Filter lesbarer zu machen. Das pTemp-Parameter steuert, ob die Ansicht temporär (Wert 1) oder
    dauerhaft (Wert 0) gespeichert wird.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***s\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates a view that can be used for exporting, copying\
    \ or zeroing out numbers.\n\n# Use case: Intended for development/prototyping or production.\n# 1/\
    \ Create a view to zero out data.\n# 2/ Create a view to use as a source for exporting or copying.\n\
    \n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process will abort.\n\
    # The pFilter parameter contains the dimenson and elements to be used for filtering:\n# - The format\
    \ of the pFilter parameter is as follows delimiters of :, & and +: Dim1: Elem1 + Elem2 & Dim2: Elem3\
    \ + Elem4.\n# - The dimension parameters do not need to be given in the index order of dimensions\
    \ in the cube.\n# - The dimension name is specified as the first member of the delimited string of\
    \ elements.\n# - If consols are skipped the N level children of any consolidated filter elements will\
    \ be used.\n# - Spaces are ignored so use them to make your filter more readable.\n# - pTemp: This\
    \ parameter will control whether to make the view temporary (value 1) or if the\n#   view will be\
    \ permanently retained (value 0).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nStringGlobalVariable('sBedrockViewCreateParsedFilter');\n\
    sProcessReturnCode = '';\nnProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\n\
    cUserName         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset       = cThisProcName | '_' | cTimeStamp\
    \ | '_' | cRandomInt;\ncTempFile         = GetProcessErrorFileDirectory | cTempSubset | '.csv';\n\
    sMessage          = '';\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncMsgInfoLevel     =  'INFO';\ncMsgInfoContent   = '%cThisProcName% : %sMessage%\
    \ : %cUserName%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%,\
    \ pView:%pView%, pFilter:%pFilter%, pSuppressZero:%pSuppressZero%, pSuppressConsol:%pSuppressConsol%,\
    \ pSuppressRules:%pSuppressRules%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%,\
    \ pTemp:%pTemp%, pSuppressConsolStrings:%pSuppressConsolStrings%.' ;  \n\n\nsSubset           = pView;\n\
    sDelimDim         = TRIM(pDimDelim);\nsElementStartDelim= TRIM(pEleStartDelim);\nsDelimElem      \
    \  = TRIM(pEleDelim);\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Validate Parameters ###\n\n## Default filter delimiters\n\
    If( pDimDelim     @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n    pEleStartDelim=\
    \ '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\nEndIf;\n\n# If specified cube\
    \ does not exist then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'A cube name must\
    \ be provided.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n  sMessage = 'Cube: ' | pCube | ' does not exist.';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    ## Validate the View parameter\nIf( Trim( pView ) @= '' );\n  sMessage = 'A view name must be provided.';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Check the delimiters\nIf( sDelimDim @= sElementStartDelim % sDelimDim @= sDelimElem % sElementStartDelim\
    \ @= sDelimElem );\n  sMessage = 'The delimiters cannot be the same';\n  nErrors = nErrors + 1;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp<>\
    \ 0 & pTemp<> 1 );\n    nErrors = 1;\n    sMessage = 'Invalid value for pTemp' | NumberToString( pTemp\
    \ ) | '. Valid values are 0 and 1';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### If errors occurred terminate process with a major error status ###\nIf( nErrors <> 0\
    \ );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n  \n# Reset all of the subsets that may be attached to the view in the case that dimensions\
    \ not in the filter\nIf( ViewExists( pCube, pView ) = 1 );\n    ### Reset View ###\n    sMessage =\
    \ 'Resetting view ' | pView | ' on cube ' | pCube;\n    IF ( pLogoutput = 1 );\n       LogOutput(\
    \ cMsgInfoLevel, Expand( cMsgInfoContent ) );\n    EndIf;\n    nCount = 1;\n    While( TabDim( pCube,\
    \ nCount ) @<> '' );\n        sCubeDimName = TabDim( pCube, nCount );\n        # Subset is the same\
    \ name as the view (no way to test if subset assigned, assume it is if same name)\n        If( SubsetExists(\
    \ sCubeDimName, sSubset ) = 1 );\n            # Add all elements\n            If( SubsetIsAllSet(sCubeDimName,\
    \ sSubset, 1) <> 1 );\n                sMessage = Expand('Unable to add all elements on subset %sSubset%\
    \ in dimension %sCubeDimName%');\n                nErrors = nErrors + 1;\n                LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            EndIf;\n        EndIf;\n        nCount\
    \ = nCount + 1;\n    End;\nElse;\n    ### Create View ###\n    sMessage = Expand('Creating view %pView%\
    \ in cube %pCube%');\n    IF ( pLogoutput = 1 );\n       LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent\
    \ ) );\n    EndIf;\n    ViewCreate( pCube, pView, pTemp );\nEndIf;\n\nViewExtractSkipCalcsSet( pCube,\
    \ pView, pSuppressConsol );\nViewExtractSkipZeroesSet( pCube, pView, pSuppressZero );\nViewExtractSkipRuleValuesSet(\
    \ pCube, pView, pSuppressRules );\n# Fix of issue #141, https://github.com/cubewise-code/bedrock/issues/141\n\
    If( pSuppressConsolStrings <> -1 );\n    ViewExtractSkipConsolidatedStringsSet( pCube, pView, pSuppressConsolStrings\
    \ );\nEndIf;\n\n### Split filter and create subsets ###\nsFilter = TRIM( pFilter );\nsParsedFilter\
    \ = '';\nnChar = 1;\nnCharCount = LONG( sFilter );\nsWord = '';\nsLastDelim = '';\nnIndex = 1;\n#\
    \ Add a trailing element delimiter so that the last element is picked up\nIf( nCharCount > 0 );\n\
    \  sFilter = sFilter | sDelimElem;\n  nCharCount = nCharCount + LONG(sDelimElem);\nEndIf;\n\nWHILE\
    \ (nChar <= nCharCount);\n    sChar = SUBST( sFilter, nChar, 1);\n\n    # Used for delimiters, required\
    \ for multiple character delimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n    # Ignore spaces\n\
    \    IF (TRIM(sChar) @<> '' );\n\n      ### Dimension Name ###\n\n      # If the delimiter is more\
    \ than 1 character peek ahead the same amount\n      # Ignore the first character\n      sDelim =\
    \ sChar;\n      nCount = LONG(sElementStartDelim) - 1;\n      If( nCount > 0 & nChar + nCount <= nCharCount\
    \ );\n        # Add the extra characters\n        sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n\
    \        # Move to the end of the delimter\n        nAddExtra = nCount;\n      EndIf;\n\n      If(\
    \ sDelim @= sElementStartDelim );\n\n        sChar = sDelim;\n\n        If( sLastDelim @<> '' & sLastDelim\
    \ @<> sDelimDim );\n            sMessage = 'The name of a dimension must follow a dimension delimiter\
    \ (' | sDelimDim | ')';\n            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        EndIf;\n\n        sDimension = sWord;\n        nOneDimEleAdded\
    \ = 0;\n        \n        If( DimensionExists( sDimension ) = 0 );\n            # The dimension does\
    \ not exist in the model. Cancel process\n            sMessage = 'Dimension: ' | sDimension | ' does\
    \ not exist';\n            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n        EndIf;\n\n        ### Determine the dimension is a member of the\
    \ cube ###\n        nCount = 1;\n        nDimensionIndex = 0;\n        While( TabDim( pCube, nCount\
    \ ) @<> '' );\n            sCubeDimName = TabDim( pCube, nCount );\n            If( sDimension @=\
    \ sCubeDimName );\n                nDimensionIndex = nCount;\n            EndIf;\n            nCount\
    \ = nCount + 1;\n        End;\n\n        If( nDimensionIndex = 0 );\n            # The dimension does\
    \ not exist in the cube. Cancel process\n            sMessage = 'Dimension: ' | sDimension | ' is\
    \ not a member of: '| pCube | 'cube.';\n            nErrors = nErrors + 1;\n            LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        EndIf;\n\n        # Create the subset\n \
    \       If( SubsetExists( sDimension, sSubset ) = 1 );\n            SubsetDeleteAllElements( sDimension,\
    \ sSubset );\n        Else;\n            SubsetCreate( sDimension, sSubset, pTemp );            \n\
    \        EndIf;\n\n        # Attach to the view\n        ViewSubsetAssign( pCube, pView, sDimension,\
    \ sSubset );\n        \n        #Add to the Parsed filter\n        IF(sParsedFilter@='');\n      \
    \    sParsedFilter=sDimension;          \n        Else;\n          sParsedFilter=sParsedFilter|sDelimDim|sDimension;\n\
    \        Endif;  \n\n        nIndex = 1;\n        sLastDelim = sChar;\n        # Clear the word\n\
    \        sWord = '';\n      Else;\n\n        # Reset extra chars\n        nAddExtra = 0;\n\n     \
    \   ### Check both both dim delimiter and element delimiter ###\n        nIsDelimiter = 0;\n\n   \
    \     ## Check dimension delimiter first\n        # If the delimiter is more than 1 character peek\
    \ ahead the same amount\n        # Ignore the first character\n        sDelim = sChar;\n        nCount\
    \ = LONG(sDelimDim) - 1;\n        If( nCount > 0 & nChar + nCount <= nCharCount );\n          # Add\
    \ the extra characters\n          sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n        \
    \  # Move to the end of the delimter\n          nAddExtra = nCount;\n        EndIf;\n\n        If(\
    \ sDelim @= sDelimDim );\n          nIsDelimiter = 1;\n          sChar = sDelim;\n        Else;\n\
    \          # Reset extra chars\n          nAddExtra = 0;\n\n          ## Check element delimiter\n\
    \n          # If the delimiter is more than 1 character peek ahead the same amount\n          # Ignore\
    \ the first character\n          sDelim = sChar;\n          nCount = LONG(sDelimElem) - 1;\n     \
    \     If( nCount > 0 & nChar + nCount <= nCharCount );\n            # Add the extra characters\n \
    \           sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n            # Move to the end of\
    \ the delimter\n            nAddExtra = nCount;\n          EndIf;\n\n          If( sDelim @= sDelimElem\
    \ );\n            nIsDelimiter = 1;\n            sChar = sDelim;\n          Else;\n            # Reset\
    \ extra chars\n            nAddExtra = 0;\n          EndIf;\n\n        EndIf;\n\n        If ( nIsDelimiter\
    \ = 1 );\n\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim );\n            sMessage = 'An\
    \ element delimiter must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            #ProcessError();\n          EndIf;\n\n          sElement = sWord;\n\n        \
    \  If( DIMIX( sDimension, sElement ) = 0 );\n              # The element does not exist in the dimension.\
    \ Cancel process\n              sMessage = 'Element: ' | sElement | ' in dimension ' | sDimension\
    \ | ' does not exist';\n              nErrors = nErrors + 1;\n              LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n              #ProcessError();\n          EndIf;\n          \n  \
    \        sElement = DimensionElementPrincipalName(sDimension,sElement);\n\n          If ( pSuppressConsol\
    \ = 1 & DTYPE( sDimension, sElement) @= 'C'  );\n              # Add all N level elements to the subset\n\
    \              # Loop through all elements and check if it is an ancestor\n              sMessage\
    \ = 'Element ' | sElement | ' is consolidated' ;\n              IF ( pLogoutput = 1 );\n         \
    \       LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n              EndIf;\n           \
    \   nElCount = DIMSIZ ( sDimension );\n              n = 1;\n              WHILE ( n <= nElCount );\n\
    \                  sEl = DIMNM( sDimension, n );\n                  IF( DTYPE( sDimension, sEl) @<>\
    \ 'C' & ELISANC( sDimension, sElement, sEl ) = 1 );\n                      SubsetElementInsert( sDimension,\
    \ sSubset, sEl, 0 );\n                  EndIf;\n                  n = n + 1;\n              END;\n\
    \              \n              # Add the consolidated element to the subset as well to export strings,\
    \ if necessary\n              If ( pSuppressConsolStrings = 0 );\n                SubsetElementInsert(\
    \ sDimension, sSubset, sElement, 0 );\n              EndIf;\n\n          Else;\n              # Add\
    \ the element to the subset\n              SubsetElementInsert( sDimension, sSubset, sElement, 0 );\n\
    \          EndIf;\n          \n          #Add to the Parsed filter\n          If( nOneDimEleAdded\
    \ = 0 );\n            sParsedFilter=sParsedFilter|pEleStartDelim|sElement;\n            nOneDimEleAdded\
    \ = nOneDimEleAdded + 1;\n          Else;\n            sParsedFilter=sParsedFilter|sDelimElem|sElement;\n\
    \          EndIf;\n\n          nIndex = nIndex + 1;\n          sLastDelim = sChar;\n\n          #\
    \ Clear the word\n          sWord = '';\n        Else;\n          sWord = sWord | sChar;\n       \
    \ EndIf;\n\n      EndIf;\n\n    EndIf;\n\n    nChar = nChar + nAddExtra + 1;\n\nEND;\nsBedrockViewCreateParsedFilter\
    \ = sParsedFilter;\n\n# creating N level subset for all dim not included in pFilter \n# useful when\
    \ suppress consolidation is not on\nIf(pSubN = 1);\n    \n    nCountDimC = 1;\n    While( TabDim(\
    \ pCube, nCountDimC ) @<> '' );\n        sDimC = TabDim( pCube, nCountDimC );\n        sDimString\
    \ = lower(sDimC);\n        \n        # filters created by other bedrock processes skip spaces from\
    \ dim names and between separators\n        While(Scan(' ',sDimString)>0);\n            sDimString\
    \ = subst(sDimString, 1, Scan(' ',sDimString)-1)|subst(sDimString,Scan(' ',sDimString)+1,long(sDimString));\n\
    \        End; \n        sTFilter = lower(sFilter);\n        While(Scan(' ',sTFilter)>0);\n       \
    \     sTFilter = subst(sTFilter, 1, Scan(' ',sTFilter)-1)|subst(sTFilter,Scan(' ',sTFilter)+1,long(sTFilter));\n\
    \        End;\n        \n        # to make sure that the name of the dim is not part of the name of\
    \ another dim\n        If(Scan(pDimDelim|sDimString|pEleStartDelim, sTFilter)=0 & Scan(sDimString|pEleStartDelim,\
    \ sTFilter)<>1);\n            sProc   = '}bedrock.hier.sub.create';\n            nRet    = ExecuteProcess(\
    \ sProc,\n                'pLogOutput', pLogOutput,\n                'pStrictErrorHandling', pStrictErrorHandling,\n\
    \                'pDim', sDimC,\n                'pHier', '',\n                'pSub', sSubset,\n\
    \                'pConsol', '',\n                'pAttr', '',\n                'pAttrValue', '',\n\
    \                'pLevelFrom', 0,\n                'pLevelTo', 0,\n                'pExclusions',\
    \ '',\n                'pDelim', pEleDelim,\n                'pAddToSubset', 0,\n                'pAlias',\
    \ '',\n                'pTemp', pTemp\n            );\n            \n            IF(nRet <> 0);\n\
    \                sMessage = 'Error creating the view from the filter.';\n                nErrors =\
    \ nErrors + 1;\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n       \
    \         If( pStrictErrorHandling = 1 ); \n                    ProcessQuit; \n                Else;\n\
    \                    ProcessBreak;\n                EndIf;\n            ENDIF;\n            \n   \
    \         ViewSubsetAssign( pCube, pView, sDimC, sSubset );\n        \n        EndIf;\n        \n\
    \        nCountDimC = nCountDimC + 1;\n    End;\n\n  EndIf;  \n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling ###\nIf( nErrors <> 0\
    \ );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for\
    \ more details.';\n    nProcessReturnCode = 0;\n    LogOutput( 'ERROR' , Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    Else;\n        ProcessBreak;\n    EndIf;\nElse; \n\n    sProcessAction      = Expand( 'Process:%cThisProcName%\
    \ successfully created View %pView% in Cube %pCube%.' );\n    sProcessReturnCode  = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode  = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n  \n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a view which can be used for exporting,
    copying, or zeroing out numbers. The process should be suitable for both development/prototyping and
    production. Ensure that the process is capable of creating a view to zero out data and another view
    to be used as a source for exporting or copying. Note that a valid cube name (pCube) is mandatory;
    otherwise, the process will abort. The pFilter parameter contains the dimensions and elements for
    filtering, in the format ''Dim1: Elem1 + Elem2 & Dim2: Elem3 + Elem4''. The dimension parameters do
    not need to be given in the index order of dimensions in the cube. Use spaces to make the filter more
    readable. The pTemp parameter controls whether to make the view temporary (value 1) or permanently
    retained (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***s\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates a view that can be used for exporting, copying\
    \ or zeroing out numbers.\n\n# Use case: Intended for development/prototyping or production.\n# 1/\
    \ Create a view to zero out data.\n# 2/ Create a view to use as a source for exporting or copying.\n\
    \n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise the process will abort.\n\
    # The pFilter parameter contains the dimenson and elements to be used for filtering:\n# - The format\
    \ of the pFilter parameter is as follows delimiters of :, & and +: Dim1: Elem1 + Elem2 & Dim2: Elem3\
    \ + Elem4.\n# - The dimension parameters do not need to be given in the index order of dimensions\
    \ in the cube.\n# - The dimension name is specified as the first member of the delimited string of\
    \ elements.\n# - If consols are skipped the N level children of any consolidated filter elements will\
    \ be used.\n# - Spaces are ignored so use them to make your filter more readable.\n# - pTemp: This\
    \ parameter will control whether to make the view temporary (value 1) or if the\n#   view will be\
    \ permanently retained (value 0).\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nStringGlobalVariable('sBedrockViewCreateParsedFilter');\n\
    sProcessReturnCode = '';\nnProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\n\
    cUserName         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset       = cThisProcName | '_' | cTimeStamp\
    \ | '_' | cRandomInt;\ncTempFile         = GetProcessErrorFileDirectory | cTempSubset | '.csv';\n\
    sMessage          = '';\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncMsgInfoLevel     =  'INFO';\ncMsgInfoContent   = '%cThisProcName% : %sMessage%\
    \ : %cUserName%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%,\
    \ pView:%pView%, pFilter:%pFilter%, pSuppressZero:%pSuppressZero%, pSuppressConsol:%pSuppressConsol%,\
    \ pSuppressRules:%pSuppressRules%, pDimDelim:%pDimDelim%, pEleStartDelim:%pEleStartDelim%, pEleDelim:%pEleDelim%,\
    \ pTemp:%pTemp%, pSuppressConsolStrings:%pSuppressConsolStrings%.' ;  \n\n\nsSubset           = pView;\n\
    sDelimDim         = TRIM(pDimDelim);\nsElementStartDelim= TRIM(pEleStartDelim);\nsDelimElem      \
    \  = TRIM(pEleDelim);\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Validate Parameters ###\n\n## Default filter delimiters\n\
    If( pDimDelim     @= '' );\n    pDimDelim     = '&';\nEndIf;\nIf( pEleStartDelim@= '' );\n    pEleStartDelim=\
    \ '¦';\nEndIf;\nIf( pEleDelim     @= '' );\n    pEleDelim     = '+';\nEndIf;\n\n# If specified cube\
    \ does not exist then terminate process\nIf( Trim( pCube ) @= '' );\n  sMessage = 'A cube name must\
    \ be provided.';\n  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n  sMessage = 'Cube: ' | pCube | ' does not exist.';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    ## Validate the View parameter\nIf( Trim( pView ) @= '' );\n  sMessage = 'A view name must be provided.';\n\
    \  nErrors = nErrors + 1;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Check the delimiters\nIf( sDelimDim @= sElementStartDelim % sDelimDim @= sDelimElem % sElementStartDelim\
    \ @= sDelimElem );\n  sMessage = 'The delimiters cannot be the same';\n  nErrors = nErrors + 1;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp<>\
    \ 0 & pTemp<> 1 );\n    nErrors = 1;\n    sMessage = 'Invalid value for pTemp' | NumberToString( pTemp\
    \ ) | '. Valid values are 0 and 1';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### If errors occurred terminate process with a major error status ###\nIf( nErrors <> 0\
    \ );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n  \n# Reset all of the subsets that may be attached to the view in the case that dimensions\
    \ not in the filter\nIf( ViewExists( pCube, pView ) = 1 );\n    ### Reset View ###\n    sMessage =\
    \ 'Resetting view ' | pView | ' on cube ' | pCube;\n    IF ( pLogoutput = 1 );\n       LogOutput(\
    \ cMsgInfoLevel, Expand( cMsgInfoContent ) );\n    EndIf;\n    nCount = 1;\n    While( TabDim( pCube,\
    \ nCount ) @<> '' );\n        sCubeDimName = TabDim( pCube, nCount );\n        # Subset is the same\
    \ name as the view (no way to test if subset assigned, assume it is if same name)\n        If( SubsetExists(\
    \ sCubeDimName, sSubset ) = 1 );\n            # Add all elements\n            If( SubsetIsAllSet(sCubeDimName,\
    \ sSubset, 1) <> 1 );\n                sMessage = Expand('Unable to add all elements on subset %sSubset%\
    \ in dimension %sCubeDimName%');\n                nErrors = nErrors + 1;\n                LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            EndIf;\n        EndIf;\n        nCount\
    \ = nCount + 1;\n    End;\nElse;\n    ### Create View ###\n    sMessage = Expand('Creating view %pView%\
    \ in cube %pCube%');\n    IF ( pLogoutput = 1 );\n       LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent\
    \ ) );\n    EndIf;\n    ViewCreate( pCube, pView, pTemp );\nEndIf;\n\nViewExtractSkipCalcsSet( pCube,\
    \ pView, pSuppressConsol );\nViewExtractSkipZeroesSet( pCube, pView, pSuppressZero );\nViewExtractSkipRuleValuesSet(\
    \ pCube, pView, pSuppressRules );\n# Fix of issue #141, https://github.com/cubewise-code/bedrock/issues/141\n\
    If( pSuppressConsolStrings <> -1 );\n    ViewExtractSkipConsolidatedStringsSet( pCube, pView, pSuppressConsolStrings\
    \ );\nEndIf;\n\n### Split filter and create subsets ###\nsFilter = TRIM( pFilter );\nsParsedFilter\
    \ = '';\nnChar = 1;\nnCharCount = LONG( sFilter );\nsWord = '';\nsLastDelim = '';\nnIndex = 1;\n#\
    \ Add a trailing element delimiter so that the last element is picked up\nIf( nCharCount > 0 );\n\
    \  sFilter = sFilter | sDelimElem;\n  nCharCount = nCharCount + LONG(sDelimElem);\nEndIf;\n\nWHILE\
    \ (nChar <= nCharCount);\n    sChar = SUBST( sFilter, nChar, 1);\n\n    # Used for delimiters, required\
    \ for multiple character delimiters\n    sDelim = '';\n    nAddExtra = 0;\n\n    # Ignore spaces\n\
    \    IF (TRIM(sChar) @<> '' );\n\n      ### Dimension Name ###\n\n      # If the delimiter is more\
    \ than 1 character peek ahead the same amount\n      # Ignore the first character\n      sDelim =\
    \ sChar;\n      nCount = LONG(sElementStartDelim) - 1;\n      If( nCount > 0 & nChar + nCount <= nCharCount\
    \ );\n        # Add the extra characters\n        sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n\
    \        # Move to the end of the delimter\n        nAddExtra = nCount;\n      EndIf;\n\n      If(\
    \ sDelim @= sElementStartDelim );\n\n        sChar = sDelim;\n\n        If( sLastDelim @<> '' & sLastDelim\
    \ @<> sDelimDim );\n            sMessage = 'The name of a dimension must follow a dimension delimiter\
    \ (' | sDelimDim | ')';\n            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        EndIf;\n\n        sDimension = sWord;\n        nOneDimEleAdded\
    \ = 0;\n        \n        If( DimensionExists( sDimension ) = 0 );\n            # The dimension does\
    \ not exist in the model. Cancel process\n            sMessage = 'Dimension: ' | sDimension | ' does\
    \ not exist';\n            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n        EndIf;\n\n        ### Determine the dimension is a member of the\
    \ cube ###\n        nCount = 1;\n        nDimensionIndex = 0;\n        While( TabDim( pCube, nCount\
    \ ) @<> '' );\n            sCubeDimName = TabDim( pCube, nCount );\n            If( sDimension @=\
    \ sCubeDimName );\n                nDimensionIndex = nCount;\n            EndIf;\n            nCount\
    \ = nCount + 1;\n        End;\n\n        If( nDimensionIndex = 0 );\n            # The dimension does\
    \ not exist in the cube. Cancel process\n            sMessage = 'Dimension: ' | sDimension | ' is\
    \ not a member of: '| pCube | 'cube.';\n            nErrors = nErrors + 1;\n            LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        EndIf;\n\n        # Create the subset\n \
    \       If( SubsetExists( sDimension, sSubset ) = 1 );\n            SubsetDeleteAllElements( sDimension,\
    \ sSubset );\n        Else;\n            SubsetCreate( sDimension, sSubset, pTemp );            \n\
    \        EndIf;\n\n        # Attach to the view\n        ViewSubsetAssign( pCube, pView, sDimension,\
    \ sSubset );\n        \n        #Add to the Parsed filter\n        IF(sParsedFilter@='');\n      \
    \    sParsedFilter=sDimension;          \n        Else;\n          sParsedFilter=sParsedFilter|sDelimDim|sDimension;\n\
    \        Endif;  \n\n        nIndex = 1;\n        sLastDelim = sChar;\n        # Clear the word\n\
    \        sWord = '';\n      Else;\n\n        # Reset extra chars\n        nAddExtra = 0;\n\n     \
    \   ### Check both both dim delimiter and element delimiter ###\n        nIsDelimiter = 0;\n\n   \
    \     ## Check dimension delimiter first\n        # If the delimiter is more than 1 character peek\
    \ ahead the same amount\n        # Ignore the first character\n        sDelim = sChar;\n        nCount\
    \ = LONG(sDelimDim) - 1;\n        If( nCount > 0 & nChar + nCount <= nCharCount );\n          # Add\
    \ the extra characters\n          sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n        \
    \  # Move to the end of the delimter\n          nAddExtra = nCount;\n        EndIf;\n\n        If(\
    \ sDelim @= sDelimDim );\n          nIsDelimiter = 1;\n          sChar = sDelim;\n        Else;\n\
    \          # Reset extra chars\n          nAddExtra = 0;\n\n          ## Check element delimiter\n\
    \n          # If the delimiter is more than 1 character peek ahead the same amount\n          # Ignore\
    \ the first character\n          sDelim = sChar;\n          nCount = LONG(sDelimElem) - 1;\n     \
    \     If( nCount > 0 & nChar + nCount <= nCharCount );\n            # Add the extra characters\n \
    \           sDelim = sDelim | SUBST( sFilter, nChar + 1, nCount);\n            # Move to the end of\
    \ the delimter\n            nAddExtra = nCount;\n          EndIf;\n\n          If( sDelim @= sDelimElem\
    \ );\n            nIsDelimiter = 1;\n            sChar = sDelim;\n          Else;\n            # Reset\
    \ extra chars\n            nAddExtra = 0;\n          EndIf;\n\n        EndIf;\n\n        If ( nIsDelimiter\
    \ = 1 );\n\n          If( sLastDelim @= '' % sLastDelim @= sDelimDim );\n            sMessage = 'An\
    \ element delimiter must follow a dimension name: ' |  sChar | ' (' | NumberToString(nChar) | ')';\n\
    \            nErrors = nErrors + 1;\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            #ProcessError();\n          EndIf;\n\n          sElement = sWord;\n\n        \
    \  If( DIMIX( sDimension, sElement ) = 0 );\n              # The element does not exist in the dimension.\
    \ Cancel process\n              sMessage = 'Element: ' | sElement | ' in dimension ' | sDimension\
    \ | ' does not exist';\n              nErrors = nErrors + 1;\n              LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n              #ProcessError();\n          EndIf;\n          \n  \
    \        sElement = DimensionElementPrincipalName(sDimension,sElement);\n\n          If ( pSuppressConsol\
    \ = 1 & DTYPE( sDimension, sElement) @= 'C'  );\n              # Add all N level elements to the subset\n\
    \              # Loop through all elements and check if it is an ancestor\n              sMessage\
    \ = 'Element ' | sElement | ' is consolidated' ;\n              IF ( pLogoutput = 1 );\n         \
    \       LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n              EndIf;\n           \
    \   nElCount = DIMSIZ ( sDimension );\n              n = 1;\n              WHILE ( n <= nElCount );\n\
    \                  sEl = DIMNM( sDimension, n );\n                  IF( DTYPE( sDimension, sEl) @<>\
    \ 'C' & ELISANC( sDimension, sElement, sEl ) = 1 );\n                      SubsetElementInsert( sDimension,\
    \ sSubset, sEl, 0 );\n                  EndIf;\n                  n = n + 1;\n              END;\n\
    \              \n              # Add the consolidated element to the subset as well to export strings,\
    \ if necessary\n              If ( pSuppressConsolStrings = 0 );\n                SubsetElementInsert(\
    \ sDimension, sSubset, sElement, 0 );\n              EndIf;\n\n          Else;\n              # Add\
    \ the element to the subset\n              SubsetElementInsert( sDimension, sSubset, sElement, 0 );\n\
    \          EndIf;\n          \n          #Add to the Parsed filter\n          If( nOneDimEleAdded\
    \ = 0 );\n            sParsedFilter=sParsedFilter|pEleStartDelim|sElement;\n            nOneDimEleAdded\
    \ = nOneDimEleAdded + 1;\n          Else;\n            sParsedFilter=sParsedFilter|sDelimElem|sElement;\n\
    \          EndIf;\n\n          nIndex = nIndex + 1;\n          sLastDelim = sChar;\n\n          #\
    \ Clear the word\n          sWord = '';\n        Else;\n          sWord = sWord | sChar;\n       \
    \ EndIf;\n\n      EndIf;\n\n    EndIf;\n\n    nChar = nChar + nAddExtra + 1;\n\nEND;\nsBedrockViewCreateParsedFilter\
    \ = sParsedFilter;\n\n# creating N level subset for all dim not included in pFilter \n# useful when\
    \ suppress consolidation is not on\nIf(pSubN = 1);\n    \n    nCountDimC = 1;\n    While( TabDim(\
    \ pCube, nCountDimC ) @<> '' );\n        sDimC = TabDim( pCube, nCountDimC );\n        sDimString\
    \ = lower(sDimC);\n        \n        # filters created by other bedrock processes skip spaces from\
    \ dim names and between separators\n        While(Scan(' ',sDimString)>0);\n            sDimString\
    \ = subst(sDimString, 1, Scan(' ',sDimString)-1)|subst(sDimString,Scan(' ',sDimString)+1,long(sDimString));\n\
    \        End; \n        sTFilter = lower(sFilter);\n        While(Scan(' ',sTFilter)>0);\n       \
    \     sTFilter = subst(sTFilter, 1, Scan(' ',sTFilter)-1)|subst(sTFilter,Scan(' ',sTFilter)+1,long(sTFilter));\n\
    \        End;\n        \n        # to make sure that the name of the dim is not part of the name of\
    \ another dim\n        If(Scan(pDimDelim|sDimString|pEleStartDelim, sTFilter)=0 & Scan(sDimString|pEleStartDelim,\
    \ sTFilter)<>1);\n            sProc   = '}bedrock.hier.sub.create';\n            nRet    = ExecuteProcess(\
    \ sProc,\n                'pLogOutput', pLogOutput,\n                'pStrictErrorHandling', pStrictErrorHandling,\n\
    \                'pDim', sDimC,\n                'pHier', '',\n                'pSub', sSubset,\n\
    \                'pConsol', '',\n                'pAttr', '',\n                'pAttrValue', '',\n\
    \                'pLevelFrom', 0,\n                'pLevelTo', 0,\n                'pExclusions',\
    \ '',\n                'pDelim', pEleDelim,\n                'pAddToSubset', 0,\n                'pAlias',\
    \ '',\n                'pTemp', pTemp\n            );\n            \n            IF(nRet <> 0);\n\
    \                sMessage = 'Error creating the view from the filter.';\n                nErrors =\
    \ nErrors + 1;\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n       \
    \         If( pStrictErrorHandling = 1 ); \n                    ProcessQuit; \n                Else;\n\
    \                    ProcessBreak;\n                EndIf;\n            ENDIF;\n            \n   \
    \         ViewSubsetAssign( pCube, pView, sDimC, sSubset );\n        \n        EndIf;\n        \n\
    \        nCountDimC = nCountDimC + 1;\n    End;\n\n  EndIf;  \n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling ###\nIf( nErrors <> 0\
    \ );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for\
    \ more details.';\n    nProcessReturnCode = 0;\n    LogOutput( 'ERROR' , Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    Else;\n        ProcessBreak;\n    EndIf;\nElse; \n\n    sProcessAction      = Expand( 'Process:%cThisProcName%\
    \ successfully created View %pView% in Cube %pCube%.' );\n    sProcessReturnCode  = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode  = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n  \n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine dynamische Ansicht aus einem MDX-Ausdruck
    erstellt, der sich zu einer nicht-leeren Menge in der angegebenen Dimension auswertet. Der Prozess
    sollte für Entwicklungs-/Prototyping-Zwecke oder in der Produktion geeignet sein. Die Hauptanwendungsfälle
    umfassen die Erstellung einer Ansicht zum Nullsetzen von Daten und die Erstellung einer Ansicht, die
    als Quelle für den Export oder das Kopieren dient. Beachte, dass ein gültiger Würfelname (pCube) obligatorisch
    ist, da der Prozess ansonsten abgebrochen wird. Sollte der MDX-Ausdruck nicht kompilieren oder eine
    leere Menge erzeugen, wird der Prozess fehlerhaft enden. Ein Parameter (pTemp) steuert, ob die Ansicht
    temporär (Wert 1) oder dauerhaft (Wert 0) gespeichert wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description: \n# This process will Create a dynamic view from an MDX expression\
    \ that evaluates to a non-empty set in the specified dimension.\n\n# Use case: Intended for development/prototyping\
    \ or production.\n# 1/ Create a view to zero out data.\n# 2/ Create a view to use as a source for\
    \ exporting or copying.\n\n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise\
    \ the process will abort.\n# If the MDX does not compile or produces an empty set the process will\
    \ error.\n# pTemp: This parameter will control whether to make the view temporary (value 1) or if\
    \ the\n#   view will be permanently retained (value 0).\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName\
    \     = GetProcessName();\ncUserName = TM1User();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n\
    cRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset = cThisProcName | '_' | cTimeStamp\
    \ | '_' | cRandomInt;\ncTempFile = GetProcessErrorFileDirectory | cTempSubset | '.csv';\nsMessage\
    \ = \t'';\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%,\
    \ pView:%pView%, pMDXExpr:%pMDXExpr%, pTemp:%pTemp%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nsMDXExpr = TRIM( pMDXExpr );\n\
    \n### Validate Parameters ###\nnErrors = 0;\n\n# Validate Cube\nIf( Trim( pCube ) @= '' );\n    sMessage\
    \ = 'No cube specified.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage = Expand('Cube %pCube% does not exist') ;\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate View\nIf( Trim( pView ) @= '' );\n    sMessage = 'No view specified';\n    nErrors =\
    \ nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ MDX\nIf( Trim( sMDXExpr ) @= '' );\n    sMessage = 'No MDX expression specified';\n    nErrors =\
    \ nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ MDX. Checking Cube name mentioned in MDX\nIf( SCAN ( pCube , sMDXExpr ) = 0 );\n    sMessage = 'No\
    \ Cube Name mentioned in MDX. Not a valid MDX expression';\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp<> 0 & pTemp<>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Invalid value for pTemp' | NumberToString( pTemp ) | '.\
    \ Valid values are 0 and 1';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create View ###\nIf( ViewExists(\
    \ pCube , pView ) = 1 );\n    ViewDestroy( pCube , pView );\nEndIf;\n\nViewCreatebyMDX ( pCube , pView\
    \ , sMDXExpr, pTemp ) ; \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully created view %pView% in cube %pCube%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates a dynamic view from an MDX expression
    evaluating to a non-empty set in the specified dimension. The process should be intended for development/prototyping
    or production. The main use cases include creating a view to zero out data and creating a view to
    use as a source for exporting or copying. Note that a valid cube name (pCube) is mandatory; otherwise,
    the process will abort. If the MDX does not compile or produces an empty set, the process will error.
    A parameter (pTemp) will control whether the view is made temporary (value 1) or permanently retained
    (value 0).
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description: \n# This process will Create a dynamic view from an MDX expression\
    \ that evaluates to a non-empty set in the specified dimension.\n\n# Use case: Intended for development/prototyping\
    \ or production.\n# 1/ Create a view to zero out data.\n# 2/ Create a view to use as a source for\
    \ exporting or copying.\n\n# Note:\n# Naturally, a valid cube name (pCube) is mandatory otherwise\
    \ the process will abort.\n# If the MDX does not compile or produces an empty set the process will\
    \ error.\n# pTemp: This parameter will control whether to make the view temporary (value 1) or if\
    \ the\n#   view will be permanently retained (value 0).\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName\
    \     = GetProcessName();\ncUserName = TM1User();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n\
    cRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset = cThisProcName | '_' | cTimeStamp\
    \ | '_' | cRandomInt;\ncTempFile = GetProcessErrorFileDirectory | cTempSubset | '.csv';\nsMessage\
    \ = \t'';\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pCube:%pCube%,\
    \ pView:%pView%, pMDXExpr:%pMDXExpr%, pTemp:%pTemp%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nsMDXExpr = TRIM( pMDXExpr );\n\
    \n### Validate Parameters ###\nnErrors = 0;\n\n# Validate Cube\nIf( Trim( pCube ) @= '' );\n    sMessage\
    \ = 'No cube specified.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage = Expand('Cube %pCube% does not exist') ;\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate View\nIf( Trim( pView ) @= '' );\n    sMessage = 'No view specified';\n    nErrors =\
    \ nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ MDX\nIf( Trim( sMDXExpr ) @= '' );\n    sMessage = 'No MDX expression specified';\n    nErrors =\
    \ nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ MDX. Checking Cube name mentioned in MDX\nIf( SCAN ( pCube , sMDXExpr ) = 0 );\n    sMessage = 'No\
    \ Cube Name mentioned in MDX. Not a valid MDX expression';\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp<> 0 & pTemp<>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Invalid value for pTemp' | NumberToString( pTemp ) | '.\
    \ Valid values are 0 and 1';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create View ###\nIf( ViewExists(\
    \ pCube , pView ) = 1 );\n    ViewDestroy( pCube , pView );\nEndIf;\n\nViewCreatebyMDX ( pCube , pView\
    \ , sMDXExpr, pTemp ) ; \n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully created view %pView% in cube %pCube%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen Turbo Integrator Prozess, der öffentliche Ansichten löscht. Der Anwendungsfall
    umfasst die Entwicklung/Prototypisierung oder Produktion, bei denen nach der Erstellung einer Ansicht
    als Null oder Datenquelle diese gelöscht werden muss, sowie das Bereinigen öffentlicher Ansichten
    nach dem Go-Live. Dieser Prozess kann auf einem oder mehreren Cubes sowie auf einer oder mehreren
    Ansichten angewendet werden. Erläutere die Verwendung von Wildcards bei der Spezifizierung von Ansichts-
    und Cube-Namen durch den *-Zeichensatz. Erkläre die Funktion der verschiedenen Parameter: pCube -
    zur Festlegung, aus welchen Cubes Ansichten gelöscht werden sollen, wobei der Benutzer einzelne oder
    mehrere Cube-Namen angeben kann. Ermögliche das Löschen von Ansichten aus allen Cubes durch die Einstellung
    des pCube-Parameters auf *. Bei ungültigen Cubes wird der Vorgang übersprungen, jedoch fortgesetzt.
    pView - zur Bestimmung, welche Ansichten gelöscht werden sollen, wobei Leerwerte zum Prozessabbruch
    führen. Der Parameter gestattet das Löschen einzelner oder mehrerer Ansichten durch die Verwendung
    von Delimitern. Die Wildcard-Zeichenfolge folgt dem Format von Windows-gestützten Dateiwildcards und
    unterstützt das Löschen von Ansichten, die mit, auf oder innerhalb eines bestimmten Strings beginnen.
    Erkläre pDelim, den Delimiter-Parameter zur Angabe mehrerer Cubes oder Ansichten. Der Standard-Delimiter
    ist &, jedoch kann jeder geeignete Delimiter verwendet werden, der nicht in den Wildcards oder Cubenamen
    enthalten ist.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes public views.\n\n# Use case: Intended for development/prototyping\
    \ or production.\n# 1/ After a view has been created to zero or as a data source it needs to be deleted.\n\
    # 2/ Clean up public views after Go Live.\n\n# Note:\n# This process can work on a single cubes or\
    \ multiple cubes.\n# This process can work on a single view or multiple views.\n# When specifying\
    \ view names wildcards can be included by using the * character. \n#       **Parameter pCube**.\n\
    #   - To specify which cubes to delete views from use the pCubes parameter.\n#   - To delete views\
    \ from a single cube only just specify that cube name e.g. Sales.\n#   - To delete views from multiple\
    \ cubes specify each cube name separated by a delimiter e.g. Sales&Inventory&Cashflow.\n#   - To delete\
    \ views from all cubes then set pCubes as *.\n#   - If any invalid cubes are specified they will be\
    \ skipped but the process will continue to process the other cubes.\n#       **Parameter pView**.\n\
    #   - To specify which views to delete use the pViews parameter.\n#   - This parameter must be specified,\
    \ a blank value will cause the process to terminate.\n#   - To delete a single view only just specify\
    \ that view name e.g. SalesByProduct.\n#   - To delete multiple views specify each view name separated\
    \ by a delimiter e.g. SalesByProduct&SalesByManager&SalesByStore.\n#   - When specifying view names\
    \ wildcards are permitted and all views that match the wildcard search string will be deleted.\n#\
    \   - The wildcard search string follows the same format as windows based file wildcards.\n#   - To\
    \ delete all views that 'start' with a specific string use a trailing * e.g. Bedrock*.\n#   - To delete\
    \ all views that 'end' in a specific string use a leading * e.g. *Bedrock.\n#   - To delete all views\
    \ that 'contain' a specific string use leading and trailing *'s e.g. *Bedrock*.\n#   - To delete a\
    \ single specific view only don't use *'s at all e.g. Bedrock.\n#   - To specify multiple search stings\
    \ list them all separated by a delimiter e.g. Bedrock*;*Temp;*Test*.\n#   - Specific view names and\
    \ wildcard based names can both be used together e.g. SalesByProduct;Bedrock*.\n#       **Parameter\
    \ pDelim**.\n#   - The delimiter can be used when specifying multiple cubes and/or multiple views.\n\
    #   - The default delimiter is &.\n#   - Any delimiter can be used by specifying a value for pDelimiter.\n\
    #   - Choose a delimiter that won't be used in either the wildcard search strings or cube names.\n\
    #EndRegion @DOC\n\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt  \
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset         = cThisProcName | '_' | cTimeStamp\
    \ | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory | cTempSubset | '.csv';\n\
    sMessage            = \t'';\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run\
    \ with parameters pCube:%pCube%, pView:%pView%, pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors         \
    \    = 0;\ncDimension          = '}Cubes';\n\n### Validate Parameters ###\nnErrors = 0;\n\n# Validate\
    \ views\nIf( Trim( pView ) @= '' );\n    sMessage        = 'No views specified.';\n    nErrors   \
    \      = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ delimiter\nIf( Trim( pDelim ) @= '' );\n    pDelim     = '&';\nEndIf;\n\n### Iterate through cubes\
    \ ###\n\n# If no cube has been specified then process all cubes\nIf( Trim( pCube ) @= '' );\n    sMessage\
    \ = 'No cube specified.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors > 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Work through all\
    \ cubes specified in pCube\nsCubes                          = pCube;\nnCubeDelimIndex            \
    \     = 1;\nsDelimiter                      = pDelim;\nsMdx = '';\nWhile( nCubeDelimIndex <> 0 );\n\
    \    nCubeDelimIndex             = Scan( sDelimiter, sCubes  );\n    If( nCubeDelimIndex = 0 );\n\
    \        sCube                   = Trim( sCubes );\n    Else;\n        sCube                   = Trim(\
    \ SubSt( sCubes, 1, nCubeDelimIndex - 1 ) );\n        sCubes                  = Trim( SubSt( sCubes,\
    \ nCubeDelimIndex + Long( sDelimiter ), Long( sCubes ) ) );\n    EndIf;\n\n    # Create subset of\
    \ cubes using Wildcard to loop through cubes in pCube with wildcard\n    sCubeExp = '''|sCube|''';\n\
    \    sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ), %sCubeExp% )}');\n    IF( sMdx\
    \ @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n    ENDIF;\n\
    End;\n    \nIf( SubsetExists( '}Cubes' , cTempSubset ) = 1 );\n    # If a delimited list of cube names\
    \ includes wildcards then we may have to re-use the subset multiple times\n    SubsetMDXSet( '}Cubes'\
    \ , cTempSubset, sMDX );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n    SubsetCreatebyMDX(\
    \ cTempSubset, sMDX, '}Cubes' , 1 );\nEndIf;\n    \n    \n    # Loop through cubess in subset created\
    \ based on wildcard\n    nCountCubes = SubsetGetSize( '}Cubes' , cTempSubset );\n    While( nCountCubes\
    \ >= 1 );\n      sCurrentCube = SubsetGetElementName( '}Cubes' , cTempSubset, nCountCubes );\n   \
    \   # If a valid cube has been specified then delete specified views from it\n      If( CubeExists(\
    \ sCurrentCube ) = 1 );\n          If( pLogOutput = 1 );\n            LogOutput( 'INFO', Expand( 'Processing\
    \ cube %sCurrentCube%.' ) );\n          EndIf;\n          # Work through all views specified in pViews\n\
    \          sViews                  = pView;\n          nViewDelimIndex         = 1;\n          sMdxView\
    \ = '';\n  \n          While( nViewDelimIndex <> 0 );\n              nViewDelimIndex       = Scan(\
    \ sDelimiter, sViews );\n              If( nViewDelimIndex = 0 );\n                  sView       \
    \    = Trim( sViews );\n              Else;\n                  sView           = Trim( SubSt( sViews,\
    \ 1, nViewDelimIndex - 1 ) );\n                  sViews          = Trim( SubSt( sViews, nViewDelimIndex\
    \ + Long( sDelimiter ), Long( sViews ) ) );\n              EndIf;\n  \n              # Check if a\
    \ wildcard has been used to specify the view name.\n              # If it hasn't then just delete\
    \ the view if it exists\n              If( Scan( '*', sView ) = 0 );\n                  If( ViewExists(\
    \ sCurrentCube, sView ) = 1 );\n                      If( pLogOutput = 1 );\n                    \
    \    LogOutput( 'INFO', Expand( '  Destroying view %sView% in cube %sCurrentCube%.' ) );\n       \
    \               EndIf;\n                      ViewDestroy( sCurrentCube, sView );\n              \
    \    EndIf;\n              # If it has then iterate through '}Views_CubeName' dimension\n        \
    \      Else;\n                  sDimViews       = '}Views_' | sCurrentCube ;\n                  If(\
    \ DimensionExists( sDimViews ) = 1 );\n                    # Create subset of views using Wildcard\
    \ to loop through views in current cube\n                    sViewExp = '''|sView|''';\n         \
    \           sMdxViewPart = Expand('{TM1FILTERBYPATTERN( {TM1SUBSETALL([%sDimViews%])}, %sViewExp%\
    \ )}');\n                    IF( sMdxView @= ''); \n                      sMdxview = sMdxViewPart;\
    \ \n                    ELSE;\n                      sMdxView = sMdxView | ' + ' | sMdxViewPart;\n\
    \                    ENDIF;\n                    If( SubsetExists( sDimViews, cTempSubset ) = 1 );\n\
    \                        # If a delimited list of attr names includes wildcards then we may have to\
    \ re-use the subset multiple times\n                        SubsetMDXSet( sDimViews, cTempSubset,\
    \ sMdxView );\n                    Else;\n                        # temp subset, therefore no need\
    \ to destroy in epilog\n                        SubsetCreatebyMDX( cTempSubset, sMdxView, sDimViews,\
    \ 1 );\n                    EndIf;\n                \n                    # Loop through subset of\
    \ views created based on wildcard\n                    nCountView = SubsetGetSize( sDimViews, cTempSubset\
    \ );\n                    While( nCountView >= 1 );\n                        sViewEle = SubsetGetElementName(\
    \ sDimViews, cTempSubset, nCountView );\n                        # Validate attribute name in sDim\n\
    \                        If( ViewExists( sCurrentCube, sViewEle ) = 1 );\n                       \
    \   If( pLogOutput = 1 );\n                            LogOutput( 'INFO', Expand( 'Destroying view\
    \ %sViewEle% in cube %sCurrentCube%.' ) );\n                          EndIf;\n                   \
    \         ViewDestroy( sCurrentCube, sViewEle );\n                        Endif;\n               \
    \         nCountView = nCountView - 1;\n                    End;\n                  EndIf;\n     \
    \         EndIf;\n          \n          End;\n  \n      # Cube does not exist\n      Else;\n     \
    \     sMessage                = Expand('Cube %sCurrentCube% does not exist.');\n          LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      EndIf;\n            \n      nCountCubes = nCountCubes\
    \ - 1;\n    End;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted view %pView% from cube\
    \ %pCube%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n\n### End Epilog ###"
- question: 'Develop a IBM Turbo Integrator process that deletes public views. The use case includes development/prototyping
    or production scenarios where a view needs to be deleted after being created as zero or a data source,
    and cleaning up public views post-Go Live. This process can operate on single or multiple cubes, and
    on single or multiple views. Explain the use of wildcards in specifying view and cube names using
    the * character. Discuss the function of various parameters: pCube - to specify which cubes to delete
    views from, allowing the user to specify single or multiple cube names. Enable view deletion from
    all cubes by setting pCube to *. Any invalid cubes specified will be skipped, but processing of other
    cubes will continue. pView - to specify which views to delete, requiring a non-blank value for process
    continuation. Permits deletion of single or multiple views using delimiters. The wildcard search string
    follows the format of Windows-based file wildcards, supporting deletion of views that start with,
    end with, or contain a specific string. Explain pDelim, the delimiter parameter, for specifying multiple
    cubes or views. The default delimiter is &, but any suitable delimiter can be used that is not part
    of the wildcard search strings or cube names.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes public views.\n\n# Use case: Intended for development/prototyping\
    \ or production.\n# 1/ After a view has been created to zero or as a data source it needs to be deleted.\n\
    # 2/ Clean up public views after Go Live.\n\n# Note:\n# This process can work on a single cubes or\
    \ multiple cubes.\n# This process can work on a single view or multiple views.\n# When specifying\
    \ view names wildcards can be included by using the * character. \n#       **Parameter pCube**.\n\
    #   - To specify which cubes to delete views from use the pCubes parameter.\n#   - To delete views\
    \ from a single cube only just specify that cube name e.g. Sales.\n#   - To delete views from multiple\
    \ cubes specify each cube name separated by a delimiter e.g. Sales&Inventory&Cashflow.\n#   - To delete\
    \ views from all cubes then set pCubes as *.\n#   - If any invalid cubes are specified they will be\
    \ skipped but the process will continue to process the other cubes.\n#       **Parameter pView**.\n\
    #   - To specify which views to delete use the pViews parameter.\n#   - This parameter must be specified,\
    \ a blank value will cause the process to terminate.\n#   - To delete a single view only just specify\
    \ that view name e.g. SalesByProduct.\n#   - To delete multiple views specify each view name separated\
    \ by a delimiter e.g. SalesByProduct&SalesByManager&SalesByStore.\n#   - When specifying view names\
    \ wildcards are permitted and all views that match the wildcard search string will be deleted.\n#\
    \   - The wildcard search string follows the same format as windows based file wildcards.\n#   - To\
    \ delete all views that 'start' with a specific string use a trailing * e.g. Bedrock*.\n#   - To delete\
    \ all views that 'end' in a specific string use a leading * e.g. *Bedrock.\n#   - To delete all views\
    \ that 'contain' a specific string use leading and trailing *'s e.g. *Bedrock*.\n#   - To delete a\
    \ single specific view only don't use *'s at all e.g. Bedrock.\n#   - To specify multiple search stings\
    \ list them all separated by a delimiter e.g. Bedrock*;*Temp;*Test*.\n#   - Specific view names and\
    \ wildcard based names can both be used together e.g. SalesByProduct;Bedrock*.\n#       **Parameter\
    \ pDelim**.\n#   - The delimiter can be used when specifying multiple cubes and/or multiple views.\n\
    #   - The default delimiter is &.\n#   - Any delimiter can be used by specifying a value for pDelimiter.\n\
    #   - Choose a delimiter that won't be used in either the wildcard search strings or cube names.\n\
    #EndRegion @DOC\n\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName\
    \           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt  \
    \        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset         = cThisProcName | '_' | cTimeStamp\
    \ | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory | cTempSubset | '.csv';\n\
    sMessage            = \t'';\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run\
    \ with parameters pCube:%pCube%, pView:%pView%, pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors         \
    \    = 0;\ncDimension          = '}Cubes';\n\n### Validate Parameters ###\nnErrors = 0;\n\n# Validate\
    \ views\nIf( Trim( pView ) @= '' );\n    sMessage        = 'No views specified.';\n    nErrors   \
    \      = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ delimiter\nIf( Trim( pDelim ) @= '' );\n    pDelim     = '&';\nEndIf;\n\n### Iterate through cubes\
    \ ###\n\n# If no cube has been specified then process all cubes\nIf( Trim( pCube ) @= '' );\n    sMessage\
    \ = 'No cube specified.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors > 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Work through all\
    \ cubes specified in pCube\nsCubes                          = pCube;\nnCubeDelimIndex            \
    \     = 1;\nsDelimiter                      = pDelim;\nsMdx = '';\nWhile( nCubeDelimIndex <> 0 );\n\
    \    nCubeDelimIndex             = Scan( sDelimiter, sCubes  );\n    If( nCubeDelimIndex = 0 );\n\
    \        sCube                   = Trim( sCubes );\n    Else;\n        sCube                   = Trim(\
    \ SubSt( sCubes, 1, nCubeDelimIndex - 1 ) );\n        sCubes                  = Trim( SubSt( sCubes,\
    \ nCubeDelimIndex + Long( sDelimiter ), Long( sCubes ) ) );\n    EndIf;\n\n    # Create subset of\
    \ cubes using Wildcard to loop through cubes in pCube with wildcard\n    sCubeExp = '''|sCube|''';\n\
    \    sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ), %sCubeExp% )}');\n    IF( sMdx\
    \ @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n    ENDIF;\n\
    End;\n    \nIf( SubsetExists( '}Cubes' , cTempSubset ) = 1 );\n    # If a delimited list of cube names\
    \ includes wildcards then we may have to re-use the subset multiple times\n    SubsetMDXSet( '}Cubes'\
    \ , cTempSubset, sMDX );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n    SubsetCreatebyMDX(\
    \ cTempSubset, sMDX, '}Cubes' , 1 );\nEndIf;\n    \n    \n    # Loop through cubess in subset created\
    \ based on wildcard\n    nCountCubes = SubsetGetSize( '}Cubes' , cTempSubset );\n    While( nCountCubes\
    \ >= 1 );\n      sCurrentCube = SubsetGetElementName( '}Cubes' , cTempSubset, nCountCubes );\n   \
    \   # If a valid cube has been specified then delete specified views from it\n      If( CubeExists(\
    \ sCurrentCube ) = 1 );\n          If( pLogOutput = 1 );\n            LogOutput( 'INFO', Expand( 'Processing\
    \ cube %sCurrentCube%.' ) );\n          EndIf;\n          # Work through all views specified in pViews\n\
    \          sViews                  = pView;\n          nViewDelimIndex         = 1;\n          sMdxView\
    \ = '';\n  \n          While( nViewDelimIndex <> 0 );\n              nViewDelimIndex       = Scan(\
    \ sDelimiter, sViews );\n              If( nViewDelimIndex = 0 );\n                  sView       \
    \    = Trim( sViews );\n              Else;\n                  sView           = Trim( SubSt( sViews,\
    \ 1, nViewDelimIndex - 1 ) );\n                  sViews          = Trim( SubSt( sViews, nViewDelimIndex\
    \ + Long( sDelimiter ), Long( sViews ) ) );\n              EndIf;\n  \n              # Check if a\
    \ wildcard has been used to specify the view name.\n              # If it hasn't then just delete\
    \ the view if it exists\n              If( Scan( '*', sView ) = 0 );\n                  If( ViewExists(\
    \ sCurrentCube, sView ) = 1 );\n                      If( pLogOutput = 1 );\n                    \
    \    LogOutput( 'INFO', Expand( '  Destroying view %sView% in cube %sCurrentCube%.' ) );\n       \
    \               EndIf;\n                      ViewDestroy( sCurrentCube, sView );\n              \
    \    EndIf;\n              # If it has then iterate through '}Views_CubeName' dimension\n        \
    \      Else;\n                  sDimViews       = '}Views_' | sCurrentCube ;\n                  If(\
    \ DimensionExists( sDimViews ) = 1 );\n                    # Create subset of views using Wildcard\
    \ to loop through views in current cube\n                    sViewExp = '''|sView|''';\n         \
    \           sMdxViewPart = Expand('{TM1FILTERBYPATTERN( {TM1SUBSETALL([%sDimViews%])}, %sViewExp%\
    \ )}');\n                    IF( sMdxView @= ''); \n                      sMdxview = sMdxViewPart;\
    \ \n                    ELSE;\n                      sMdxView = sMdxView | ' + ' | sMdxViewPart;\n\
    \                    ENDIF;\n                    If( SubsetExists( sDimViews, cTempSubset ) = 1 );\n\
    \                        # If a delimited list of attr names includes wildcards then we may have to\
    \ re-use the subset multiple times\n                        SubsetMDXSet( sDimViews, cTempSubset,\
    \ sMdxView );\n                    Else;\n                        # temp subset, therefore no need\
    \ to destroy in epilog\n                        SubsetCreatebyMDX( cTempSubset, sMdxView, sDimViews,\
    \ 1 );\n                    EndIf;\n                \n                    # Loop through subset of\
    \ views created based on wildcard\n                    nCountView = SubsetGetSize( sDimViews, cTempSubset\
    \ );\n                    While( nCountView >= 1 );\n                        sViewEle = SubsetGetElementName(\
    \ sDimViews, cTempSubset, nCountView );\n                        # Validate attribute name in sDim\n\
    \                        If( ViewExists( sCurrentCube, sViewEle ) = 1 );\n                       \
    \   If( pLogOutput = 1 );\n                            LogOutput( 'INFO', Expand( 'Destroying view\
    \ %sViewEle% in cube %sCurrentCube%.' ) );\n                          EndIf;\n                   \
    \         ViewDestroy( sCurrentCube, sViewEle );\n                        Endif;\n               \
    \         nCountView = nCountView - 1;\n                    End;\n                  EndIf;\n     \
    \         EndIf;\n          \n          End;\n  \n      # Cube does not exist\n      Else;\n     \
    \     sMessage                = Expand('Cube %sCurrentCube% does not exist.');\n          LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      EndIf;\n            \n      nCountCubes = nCountCubes\
    \ - 1;\n    End;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted view %pView% from cube\
    \ %pCube%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine private Ansicht in eine öffentliche
    Ansicht für einen angegebenen Client umwandelt. Der Prozess sollte in Entwicklungs-, Prototyping-
    oder Produktionsszenarien eingesetzt werden können. Das Ziel ist, private Ansichten öffentlich zugänglich
    zu machen. Stelle sicher, dass ein gültiger Würfelname (pCube) angegeben ist, da der Prozess sonst
    abbricht. Ebenso muss ein gültiger Ansichtsname (pView) vorhanden sein, da der Prozess ansonsten ebenfalls
    abbricht. Der Prozess muss von dem Benutzer ausgeführt werden, der die private Ansicht besitzt, da
    er nicht von einem anderen Benutzer ausgeführt werden kann. Wenn die Ansicht private Untergruppen
    enthält, müssen auch diese öffentlich gemacht werden, andernfalls schlägt das Veröffentlichen der
    Ansicht fehl.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process converts a private view to a public view for the named\
    \ client.\n#\n# Use case: Intended for development/prototyping or production.\n# 1. Make private view\
    \ public to enable public consumption.\n#\n# Note:\n# * A valid cube name pCube is mandatory otherwise\
    \ the process will abort.\n# * Also, a valid view name pView is mandatory otherwise the process will\
    \ abort.\n# * This process must be run by the user owning the private view; it canot be run by another\
    \ user.\n# * If the view contains private subsets they must also be made public or the view publish\
    \ will fail.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset \
    \        = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory\
    \ | cTempSubset | '.csv';\nsMessage            = \t'';\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pView:%pView%, pSubPublish:%pSubPublish%, pOverwrite:%pOverwrite%.'\
    \ ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# create friendly name for user handle\n\
    If( DimIx( '}ElementAttributes_}Clients', '}TM1_DefaultDisplayValue' ) > 0 );\n    pClient = AttrS(\
    \ '}Clients', cUserName, '}TM1_DefaultDisplayValue' );\n    If( pClient @= '' );\n        pClient\
    \ = cUserName;\n    EndIf;\nElse;\n    pClient = cUserName;\nEndIf;\n\n# Validate Cube\nIf( Trim(\
    \ pCube ) @= '' );\n    sMessage = 'No cube specified';\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage\
    \ = Expand('Cube %pCube% does not exist on server');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate view\nIf( Trim( pView ) @= '' );\n    sMessage\
    \ = 'No view specified';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# No way to check if private view exists except via file system.\n# Could include\
    \ data directory param and concatenate with user, cube and view to check\n# if private view exists\
    \ to handle error in the case that private view does not exist\n\n# Check for valid view name, subset\
    \ publish and overwrite parameters\nIf( pSubPublish <> 0 & pSubPublish <> 1 );\n    sMessage = 'Invalid\
    \ publish private subsets selection: ' | NumberToString( pSubPublish );\n    nErrors = nErrors + 1;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pOverwrite <> 0 & pOverwrite\
    \ <> 1 );\n    sMessage = 'Invalid overwrite existing public view selection: ' | NumberToString( pOverwrite\
    \ );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \nIf( pOverwrite = 0 & ViewExists( pCube, pView ) = 1 );\n    # If NOT overwriting current public\
    \ view AND view of the same name exists then cause minor error ( major error if not handled )\n  \
    \  sMessage = 'Public view of same name already exists and Overwrite=0 specified';\n    nErrors =\
    \ nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check\
    \ for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Publish the view ( and any private subsets\
    \ ) ###\nPublishView( pCube, pView, pSubPublish, pOverwrite );\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully published view %pView% in cube %pCube% created by cient %pClient%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Develop an IBM Turbo Integrator process that converts a private view to a public view for
    the named client. The process should be applicable for development, prototyping, or production scenarios.
    The goal is to make private views publicly consumable. Ensure that a valid cube name (pCube) is provided,
    otherwise the process will abort. Similarly, a valid view name (pView) is mandatory, otherwise the
    process will also abort. The process must be executed by the user owning the private view and cannot
    be run by another user. If the view contains private subsets, these must also be made public, or the
    view publish will fail.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process converts a private view to a public view for the named\
    \ client.\n#\n# Use case: Intended for development/prototyping or production.\n# 1. Make private view\
    \ public to enable public consumption.\n#\n# Note:\n# * A valid cube name pCube is mandatory otherwise\
    \ the process will abort.\n# * Also, a valid view name pView is mandatory otherwise the process will\
    \ abort.\n# * This process must be run by the user owning the private view; it canot be run by another\
    \ user.\n# * If the view contains private subsets they must also be made public or the view publish\
    \ will fail.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSubset \
    \        = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory\
    \ | cTempSubset | '.csv';\nsMessage            = \t'';\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pView:%pView%, pSubPublish:%pSubPublish%, pOverwrite:%pOverwrite%.'\
    \ ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# create friendly name for user handle\n\
    If( DimIx( '}ElementAttributes_}Clients', '}TM1_DefaultDisplayValue' ) > 0 );\n    pClient = AttrS(\
    \ '}Clients', cUserName, '}TM1_DefaultDisplayValue' );\n    If( pClient @= '' );\n        pClient\
    \ = cUserName;\n    EndIf;\nElse;\n    pClient = cUserName;\nEndIf;\n\n# Validate Cube\nIf( Trim(\
    \ pCube ) @= '' );\n    sMessage = 'No cube specified';\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( pCube ) = 0 );\n    sMessage\
    \ = Expand('Cube %pCube% does not exist on server');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate view\nIf( Trim( pView ) @= '' );\n    sMessage\
    \ = 'No view specified';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# No way to check if private view exists except via file system.\n# Could include\
    \ data directory param and concatenate with user, cube and view to check\n# if private view exists\
    \ to handle error in the case that private view does not exist\n\n# Check for valid view name, subset\
    \ publish and overwrite parameters\nIf( pSubPublish <> 0 & pSubPublish <> 1 );\n    sMessage = 'Invalid\
    \ publish private subsets selection: ' | NumberToString( pSubPublish );\n    nErrors = nErrors + 1;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pOverwrite <> 0 & pOverwrite\
    \ <> 1 );\n    sMessage = 'Invalid overwrite existing public view selection: ' | NumberToString( pOverwrite\
    \ );\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \nIf( pOverwrite = 0 & ViewExists( pCube, pView ) = 1 );\n    # If NOT overwriting current public\
    \ view AND view of the same name exists then cause minor error ( major error if not handled )\n  \
    \  sMessage = 'Public view of same name already exists and Overwrite=0 specified';\n    nErrors =\
    \ nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check\
    \ for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Publish the view ( and any private subsets\
    \ ) ###\nPublishView( pCube, pView, pSubPublish, pOverwrite );\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully published view %pView% in cube %pCube% created by cient %pClient%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine Verarbeitungsansicht für einen Würfel
    sowie für ausgewählte Dimensionen dieses Würfels erstellt. Dieser Prozess ist sowohl für Entwicklungs-/Prototyping-
    als auch Produktionsumgebungen gedacht. Zuerst sollte eine Ansicht mit gleichnamigen Teilmengen erstellt
    werden, die leer sind. Beachte, dass leere Teilmengen erstellt und diesen Teilmengen der Ansicht zugewiesen
    werden. Ein nachfolgender Prozess ist erforderlich, um Elemente in die Teilmengen einzufügen, da die
    Ansichten sonst keine Daten enthalten. Ein gültiger Würfelname (pCube) ist zwingend erforderlich,
    da der Prozess andernfalls abgebrochen wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates a processing view for the cube and for specified\
    \ dimensions of the cube. \n\n# Use case: Intended for development/prototyping or in Production environment.\n\
    # 1. Create a view with subsets of the same name that are empty.\n\n# Note:\n# Creates empty subsets\
    \ and assigns the empty subsets to the view. \n# A subsequent process is required to insert elements\
    \ into subsets otherwise the views will not contain any data.\n# Naturally, a valid cube name (pCube)\
    \ is mandatory otherwise the process will abort.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = '%cThisProcName% : %sMessage% : %cUserName%';\ncMsgInfoLevel     =  'INFO';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pView:%pView%, pSubset:%pSub%, pDim:%pDim%, pDelim:%pDelim%,\
    \ pSuppressZero:%pSuppressZero%, pSuppressConsol:%pSuppressConsol%, pSuppressRules:%pSuppressRules%.';\
    \ \ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSubset       = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\nsMessage\
    \          = '';\ncDimCubes         = '}Cubes';\ncDimDimensions    = '}Dimensions';\ncAll        \
    \      = 'ALL';\ncTemp             = If( pTemp >= 1, 1, 0 );\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n\
    nErrors = 0;\n\n# Validate cube\nIf( Trim( pCube ) @= '' );\n    sMessage    = 'No cube specified.';\n\
    \    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate dimensions\nIf( Trim( pDim ) @= '' );\n    sMessage    = 'No dimensions specified.';\n\
    \    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate suppression parameters\nIf( pSuppressZero <> 0 & pSuppressZero <> 1 );\n    sMessage\
    \    = 'Invalid value for suppress zero parameter.';\n    nErrors     = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pSuppressConsol <> 0 & pSuppressConsol\
    \ <> 1 );\n    sMessage    = 'Invalid value for suppress consol parameter.';\n    nErrors     = nErrors\
    \ + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pSuppressRules\
    \ <> 0 & pSuppressRules <> 1 );\n    sMessage    = 'Invalid value for suppress rules parameter.';\n\
    \    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate view and subsets\nIf( pView @= '' & pSub @= '' );\n    ## Use standard view name.\n \
    \   cView       = cTempSubset;\n    cSubset     = cView;\nElseIf( pView @<> '' & pSub @= '' );\n \
    \   ## Use the nominated view name for the subset name.\n    cView       = pView;\n    cSubset   \
    \  = pView;\nElseIf( pView @= '' & pSub @<> '' );\n    ## Use the nominated subset name for the view\
    \ name.\n    cView       = pSub;\n    cSubset     = pSub;\nElse;\n    cView   = pView;\n    cSubset\
    \ = pSub;\nEndIf;\n\n\n# Validate delimiter\nIf( pDelim @= '' );\n    pDelim     = '&';\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Handle All cubes or a\
    \ cubes list\nIf ( TRIM( pCube ) @= cAll );\n  sMDX = Expand( '{TM1SUBSETALL([%cDimCubes%])}' );\n\
    Else;\n  sCubeTokenizer = TRIM( pCube );\n  sMDX = '';\n  ### Loop and tokenize Cube list\n  While\
    \ ( sCubeTokenizer @<> '' );\n    nPos = SCAN( pDelim, sCubeTokenizer );\n    If ( nPos = 0 );\n \
    \     nPos = LONG( sCubeTokenizer ) + 1;\n    EndIf;\n    sSearchCube = TRIM( SUBST( sCubeTokenizer,\
    \ 1, nPos - 1 ) );\n    If ( SCAN( '*', sSearchCube ) <> 0 % SCAN( '?', sSearchCube ) <> 0 );\n  \
    \    If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimCubes%])},\
    \ '%sSearchCube%')}' );\n      Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimCubes%])},\
    \ '%sSearchCube%')}' );\n      EndIf;\n    Else;\n      If ( CubeExists( sSearchCube ) = 0 );\n  \
    \      sMessage = Expand( 'Cube: %sSearchCube% does not exist.' );\n        nErrors = nErrors + 1;\n\
    \        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n        EndIf;\n \
    \     Else;\n        If( sMDX @= '' );\n          sMDX = Expand( '{[%cDimCubes%].[%sSearchCube%]}'\
    \ );\n        Else;\n          sMDX = Expand( '%sMDX% + {[%cDimCubes%].[%sSearchCube%]}' );\n    \
    \    EndIf;\n      EndIf;\n    EndIf;\n    ### Consume dimension and delimiter\n    sCubeTokenizer\
    \ = TRIM( DELET( sCubeTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX = Expand( '{%sMDX%}'\
    \ );\nEndIf;\n\nIf (SubsetExists( cDimCubes, cTempSubset ) = 1 );\n  SubsetDestroy( cDimCubes, cTempSubset\
    \ );\nEndIf;\nSubsetCreateByMDX( cTempSubset, sMDX, cDimCubes, 1 );\n\n### Handle All dimensions or\
    \ a dimension list\n### We must exclude hierarchies\nIf ( TRIM( pDim ) @= cAll );\n  sMDX = Expand(\
    \ '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name, '':'' )\
    \ = 0 )}' );\nElse;\n  sDimTokenizer = TRIM( pDim );\n  sMDX = '';\n  ### Loop and tokenize dimension\
    \ list\n  While ( sDimTokenizer @<> '' );\n    nPos = SCAN( pDelim, sDimTokenizer );\n    If ( nPos\
    \ = 0 );\n      nPos = LONG( sDimTokenizer ) + 1;\n    EndIf;\n    sSearchDim = TRIM( SUBST( sDimTokenizer,\
    \ 1, nPos - 1 ) );\n    If ( SCAN( ':', sSearchDim ) <> 0 );\n      sMessage    = Expand( 'Dimension:\
    \ The process is not accepting hierarchies: %sSearchDim%' );\n      nErrors     = nErrors + 1;\n \
    \     LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ElseIf ( SCAN( '*', sSearchDim\
    \ ) <> 0 % SCAN( '?', sSearchDim ) <> 0 );\n      If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n      Else;\n\
    \        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}, '%sSearchDim%')}' );\n      EndIf;\n    Else;\n      If ( DimensionExists( sSearchDim\
    \ ) = 0 );\n        sMessage    = Expand( 'Dimension: %sSearchDim% does not exist.' );\n        nErrors\
    \     = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If(\
    \ pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n\
    \        EndIf;\n      Else;\n        If( sMDX @= '' );\n          sMDX = Expand( '{[%cDimDimensions%].[%sSearchDim%]}'\
    \ );\n        Else;\n          sMDX = Expand( '%sMDX% + {[%cDimDimensions%].[%sSearchDim%]}' );\n\
    \        EndIf;\n      EndIf;\n    EndIf;\n    ### Consume dimension and delimiter\n    sDimTokenizer\
    \ = TRIM( DELET( sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX = Expand( '{%sMDX%}'\
    \ );\nEndIf;\n\nIf (SubsetExists( cDimDimensions, cTempSubset ) = 1 );\n  SubsetDestroy( cDimDimensions,\
    \ cTempSubset );\nEndIf;\nSubsetCreateByMDX( cTempSubset, sMDX, cDimDimensions, 1 );\n\n### Build\
    \ Subsets and assign to View ###\nnCube = 1;\nWhile ( nCube <= SubsetGetSize( cDimCubes, cTempSubset\
    \ ) );\n  sCube = SubsetGetElementName( cDimCubes, cTempSubset, nCube );\n  ### Build View ###\n \
    \ If( ViewExists( sCube, cView ) = 1 );\n    ViewDestroy( sCube, cView );\n  EndIf;\n  nDim = 1;\n\
    \  sDim = TABDIM( sCube, nDim );\n  While ( sDim @<> '' );\n   # filter selection has non-empty intersect\
    \ with current cube dimensions\n   #If ( SubsetElementExists( cDimDimensions, cTempSubset, sDim )\
    \ = 1 ); - bug does not work\n   IF( SubsetElementGetIndex( cDimDimensions, cTempSubset, sDim, 1 )\
    \ > 0 );\n      # create view if and only if there is at least one match with dimensions\n      If(\
    \ ViewExists( sCube, cView ) = 0 );\n        ViewCreate( sCube, cView, cTemp );\n        ViewExtractSkipZeroesSet(\
    \ sCube, cView, pSuppressZero );\n        ViewExtractSkipCalcsSet( sCube, cView, pSuppressConsol );\n\
    \        ViewExtractSkipRuleValuesSet( sCube, cView, pSuppressRules );\n      EndIf;\n      If ( SubsetExists\
    \ ( sDim, cSubset ) = 1 );\n        If ( SubsetGetSize( sDim, cSubset ) > 0 );\n          SubsetDeleteAllElements(\
    \ sDim, cSubset );\n        EndIf;\n      Else;\n        SubsetCreate( sDim, cSubset, cTemp );\n \
    \     EndIf;\n      ViewSubsetAssign( sCube, cView, sDim, cSubset );\n    EndIf;\n    nDim = nDim\
    \ + 1;\n    sDim = TABDIM( sCube, nDim );\n  End;\n  \n  # creating N level subset for all dim not\
    \ included in pDim for the cube\n  If(pSubN = 1);\n    nCountDimC = 1;\n    While( TabDim( sCube,\
    \ nCountDimC ) @<> '' );\n    sDimC = TabDim( sCube, nCountDimC );\n    If ( ViewExists( sCube, cView\
    \ ) = 1 & SubsetElementGetIndex( cDimDimensions, cTempSubset, sDimC, 1 ) = 0 );\n      If ( SubsetExists\
    \ ( sDimC, cSubset ) = 1 );\n        If ( SubsetGetSize( sDimC, cSubset ) > 0 );\n          SubsetDeleteAllElements(\
    \ sDimC, cSubset );\n        EndIf;\n      Else;\n        SubsetCreate( sDimC, cSubset, cTemp );\n\
    \      Endif;  \n      nElCount = DIMSIZ ( sDimC );\n      nElC = 1;\n      WHILE ( nElC <= nElCount\
    \ );\n        sEl = DIMNM( sDimC, nElC );\n        IF(ElementLevel( sDimC, sDimC, sEl )= 0 );\n  \
    \        SubsetElementInsert( sDimC, cSubset, sEl, 0 );\n        EndIf;\n        nElC = nElC + 1;\n\
    \      END;\n      ViewSubsetAssign( sCube, cView, sDimC, cSubset );\n    Endif;\n    nCountDimC =\
    \ nCountDimC + 1;\n    End;\n  Endif;\n\n\n  nCube = nCube + 1;\nEnd;\n\n\n### End Prolog ###\n\n\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created views and subsets for cube  %pCube%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates a processing view for a cube and specified
    dimensions of the cube. This process is intended for both development/prototyping and production environments.
    First, create a view with subsets of the same name that are empty. Note that empty subsets are created
    and assigned to the view. A subsequent process is required to insert elements into these subsets;
    otherwise, the views will not contain any data. A valid cube name (pCube) is mandatory, as the process
    will abort otherwise.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates a processing view for the cube and for specified\
    \ dimensions of the cube. \n\n# Use case: Intended for development/prototyping or in Production environment.\n\
    # 1. Create a view with subsets of the same name that are empty.\n\n# Note:\n# Creates empty subsets\
    \ and assigns the empty subsets to the view. \n# A subsequent process is required to insert elements\
    \ into subsets otherwise the views will not contain any data.\n# Naturally, a valid cube name (pCube)\
    \ is mandatory otherwise the process will abort.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = '%cThisProcName% : %sMessage% : %cUserName%';\ncMsgInfoLevel     =  'INFO';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pCube:%pCube%, pView:%pView%, pSubset:%pSub%, pDim:%pDim%, pDelim:%pDelim%,\
    \ pSuppressZero:%pSuppressZero%, pSuppressConsol:%pSuppressConsol%, pSuppressRules:%pSuppressRules%.';\
    \ \ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSubset       = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\nsMessage\
    \          = '';\ncDimCubes         = '}Cubes';\ncDimDimensions    = '}Dimensions';\ncAll        \
    \      = 'ALL';\ncTemp             = If( pTemp >= 1, 1, 0 );\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n\
    nErrors = 0;\n\n# Validate cube\nIf( Trim( pCube ) @= '' );\n    sMessage    = 'No cube specified.';\n\
    \    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate dimensions\nIf( Trim( pDim ) @= '' );\n    sMessage    = 'No dimensions specified.';\n\
    \    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate suppression parameters\nIf( pSuppressZero <> 0 & pSuppressZero <> 1 );\n    sMessage\
    \    = 'Invalid value for suppress zero parameter.';\n    nErrors     = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pSuppressConsol <> 0 & pSuppressConsol\
    \ <> 1 );\n    sMessage    = 'Invalid value for suppress consol parameter.';\n    nErrors     = nErrors\
    \ + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pSuppressRules\
    \ <> 0 & pSuppressRules <> 1 );\n    sMessage    = 'Invalid value for suppress rules parameter.';\n\
    \    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate view and subsets\nIf( pView @= '' & pSub @= '' );\n    ## Use standard view name.\n \
    \   cView       = cTempSubset;\n    cSubset     = cView;\nElseIf( pView @<> '' & pSub @= '' );\n \
    \   ## Use the nominated view name for the subset name.\n    cView       = pView;\n    cSubset   \
    \  = pView;\nElseIf( pView @= '' & pSub @<> '' );\n    ## Use the nominated subset name for the view\
    \ name.\n    cView       = pSub;\n    cSubset     = pSub;\nElse;\n    cView   = pView;\n    cSubset\
    \ = pSub;\nEndIf;\n\n\n# Validate delimiter\nIf( pDelim @= '' );\n    pDelim     = '&';\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Handle All cubes or a\
    \ cubes list\nIf ( TRIM( pCube ) @= cAll );\n  sMDX = Expand( '{TM1SUBSETALL([%cDimCubes%])}' );\n\
    Else;\n  sCubeTokenizer = TRIM( pCube );\n  sMDX = '';\n  ### Loop and tokenize Cube list\n  While\
    \ ( sCubeTokenizer @<> '' );\n    nPos = SCAN( pDelim, sCubeTokenizer );\n    If ( nPos = 0 );\n \
    \     nPos = LONG( sCubeTokenizer ) + 1;\n    EndIf;\n    sSearchCube = TRIM( SUBST( sCubeTokenizer,\
    \ 1, nPos - 1 ) );\n    If ( SCAN( '*', sSearchCube ) <> 0 % SCAN( '?', sSearchCube ) <> 0 );\n  \
    \    If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimCubes%])},\
    \ '%sSearchCube%')}' );\n      Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimCubes%])},\
    \ '%sSearchCube%')}' );\n      EndIf;\n    Else;\n      If ( CubeExists( sSearchCube ) = 0 );\n  \
    \      sMessage = Expand( 'Cube: %sSearchCube% does not exist.' );\n        nErrors = nErrors + 1;\n\
    \        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If( pStrictErrorHandling\
    \ = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n        EndIf;\n \
    \     Else;\n        If( sMDX @= '' );\n          sMDX = Expand( '{[%cDimCubes%].[%sSearchCube%]}'\
    \ );\n        Else;\n          sMDX = Expand( '%sMDX% + {[%cDimCubes%].[%sSearchCube%]}' );\n    \
    \    EndIf;\n      EndIf;\n    EndIf;\n    ### Consume dimension and delimiter\n    sCubeTokenizer\
    \ = TRIM( DELET( sCubeTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX = Expand( '{%sMDX%}'\
    \ );\nEndIf;\n\nIf (SubsetExists( cDimCubes, cTempSubset ) = 1 );\n  SubsetDestroy( cDimCubes, cTempSubset\
    \ );\nEndIf;\nSubsetCreateByMDX( cTempSubset, sMDX, cDimCubes, 1 );\n\n### Handle All dimensions or\
    \ a dimension list\n### We must exclude hierarchies\nIf ( TRIM( pDim ) @= cAll );\n  sMDX = Expand(\
    \ '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name, '':'' )\
    \ = 0 )}' );\nElse;\n  sDimTokenizer = TRIM( pDim );\n  sMDX = '';\n  ### Loop and tokenize dimension\
    \ list\n  While ( sDimTokenizer @<> '' );\n    nPos = SCAN( pDelim, sDimTokenizer );\n    If ( nPos\
    \ = 0 );\n      nPos = LONG( sDimTokenizer ) + 1;\n    EndIf;\n    sSearchDim = TRIM( SUBST( sDimTokenizer,\
    \ 1, nPos - 1 ) );\n    If ( SCAN( ':', sSearchDim ) <> 0 );\n      sMessage    = Expand( 'Dimension:\
    \ The process is not accepting hierarchies: %sSearchDim%' );\n      nErrors     = nErrors + 1;\n \
    \     LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ElseIf ( SCAN( '*', sSearchDim\
    \ ) <> 0 % SCAN( '?', sSearchDim ) <> 0 );\n      If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n      Else;\n\
    \        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}, '%sSearchDim%')}' );\n      EndIf;\n    Else;\n      If ( DimensionExists( sSearchDim\
    \ ) = 0 );\n        sMessage    = Expand( 'Dimension: %sSearchDim% does not exist.' );\n        nErrors\
    \     = nErrors + 1;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        If(\
    \ pStrictErrorHandling = 1 ); \n            ProcessQuit; \n        Else;\n            ProcessBreak;\n\
    \        EndIf;\n      Else;\n        If( sMDX @= '' );\n          sMDX = Expand( '{[%cDimDimensions%].[%sSearchDim%]}'\
    \ );\n        Else;\n          sMDX = Expand( '%sMDX% + {[%cDimDimensions%].[%sSearchDim%]}' );\n\
    \        EndIf;\n      EndIf;\n    EndIf;\n    ### Consume dimension and delimiter\n    sDimTokenizer\
    \ = TRIM( DELET( sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX = Expand( '{%sMDX%}'\
    \ );\nEndIf;\n\nIf (SubsetExists( cDimDimensions, cTempSubset ) = 1 );\n  SubsetDestroy( cDimDimensions,\
    \ cTempSubset );\nEndIf;\nSubsetCreateByMDX( cTempSubset, sMDX, cDimDimensions, 1 );\n\n### Build\
    \ Subsets and assign to View ###\nnCube = 1;\nWhile ( nCube <= SubsetGetSize( cDimCubes, cTempSubset\
    \ ) );\n  sCube = SubsetGetElementName( cDimCubes, cTempSubset, nCube );\n  ### Build View ###\n \
    \ If( ViewExists( sCube, cView ) = 1 );\n    ViewDestroy( sCube, cView );\n  EndIf;\n  nDim = 1;\n\
    \  sDim = TABDIM( sCube, nDim );\n  While ( sDim @<> '' );\n   # filter selection has non-empty intersect\
    \ with current cube dimensions\n   #If ( SubsetElementExists( cDimDimensions, cTempSubset, sDim )\
    \ = 1 ); - bug does not work\n   IF( SubsetElementGetIndex( cDimDimensions, cTempSubset, sDim, 1 )\
    \ > 0 );\n      # create view if and only if there is at least one match with dimensions\n      If(\
    \ ViewExists( sCube, cView ) = 0 );\n        ViewCreate( sCube, cView, cTemp );\n        ViewExtractSkipZeroesSet(\
    \ sCube, cView, pSuppressZero );\n        ViewExtractSkipCalcsSet( sCube, cView, pSuppressConsol );\n\
    \        ViewExtractSkipRuleValuesSet( sCube, cView, pSuppressRules );\n      EndIf;\n      If ( SubsetExists\
    \ ( sDim, cSubset ) = 1 );\n        If ( SubsetGetSize( sDim, cSubset ) > 0 );\n          SubsetDeleteAllElements(\
    \ sDim, cSubset );\n        EndIf;\n      Else;\n        SubsetCreate( sDim, cSubset, cTemp );\n \
    \     EndIf;\n      ViewSubsetAssign( sCube, cView, sDim, cSubset );\n    EndIf;\n    nDim = nDim\
    \ + 1;\n    sDim = TABDIM( sCube, nDim );\n  End;\n  \n  # creating N level subset for all dim not\
    \ included in pDim for the cube\n  If(pSubN = 1);\n    nCountDimC = 1;\n    While( TabDim( sCube,\
    \ nCountDimC ) @<> '' );\n    sDimC = TabDim( sCube, nCountDimC );\n    If ( ViewExists( sCube, cView\
    \ ) = 1 & SubsetElementGetIndex( cDimDimensions, cTempSubset, sDimC, 1 ) = 0 );\n      If ( SubsetExists\
    \ ( sDimC, cSubset ) = 1 );\n        If ( SubsetGetSize( sDimC, cSubset ) > 0 );\n          SubsetDeleteAllElements(\
    \ sDimC, cSubset );\n        EndIf;\n      Else;\n        SubsetCreate( sDimC, cSubset, cTemp );\n\
    \      Endif;  \n      nElCount = DIMSIZ ( sDimC );\n      nElC = 1;\n      WHILE ( nElC <= nElCount\
    \ );\n        sEl = DIMNM( sDimC, nElC );\n        IF(ElementLevel( sDimC, sDimC, sEl )= 0 );\n  \
    \        SubsetElementInsert( sDimC, cSubset, sEl, 0 );\n        EndIf;\n        nElC = nElC + 1;\n\
    \      END;\n      ViewSubsetAssign( sCube, cView, sDimC, cSubset );\n    Endif;\n    nCountDimC =\
    \ nCountDimC + 1;\n    End;\n  Endif;\n\n\n  nCube = nCube + 1;\nEnd;\n\n\n### End Prolog ###\n\n\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created views and subsets for cube  %pCube%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Dieser IBM Turbo Integrator-Prozess löscht eine Ansicht und alle Teilmengen desselben Namens.
    Der Anwendungsfall umfasst zwei Hauptszenarien: Erstens wird er in Produktionsumgebungen im Epilog
    verwendet, um Ansichten und Teilmengen zu entfernen, die für die Verarbeitung genutzt werden. Zweitens
    dient er der manuellen Bereinigung von Ansichten und Teilmengen in Entwicklungs- oder Prototypenphasen.
    Bitte beachten Sie, dass Listen und Wildcards in diesem Prozess nicht unterstützt werden. Ein gültiger
    Würfelname (pCube) ist zwingend erforderlich, andernfalls wird der Prozess abgebrochen. Ebenso ist
    ein gültiger Ansichtsname (pView) erforderlich, um den Prozess fortzusetzen. Die Annahme zur Übereinstimmung
    basiert auf dem **Namen**. Teilmengen mit demselben Namen wie die Ansicht werden gelöscht, unabhängig
    davon, ob sie der Ansicht zugeordnet waren oder nicht. Für die Parameter gibt es drei Modi: Modus
    0 löscht Ansichten und löscht Teilmengen **indirekt** über den Bedrock-Prozessaufruf. Sollte eine
    Teilmenge nicht gelöscht werden können, wird der Prozess mit einem geringfügigen Fehlerstatus fortgesetzt.
    Modus 1 löscht Ansichten und löscht Teilmengen **direkt** über die SubsetDestroy-Funktion. Scheitert
    das Löschen einer Teilmenge, wird der Prozess mit großem Fehlerstatus abgebrochen. Modus 2 löscht
    nur Ansichten und belässt Teilmengen unverändert.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a view and all subsets of the same name.\n\n\
    # Use case: \n# 1. In production environment used in Epilog to remove view & subsets used for processing.\n\
    # 2. In development/prototyping to manually clean up views & subsets. \n\n# Note:\n# * Lists and wildcards\
    \ are not supported in this process\n# * A valid cube name pCube is mandatory otherwise the process\
    \ will abort. \n# * A valid view name pView is mandatory otherwise the process will abort.\n# * The\
    \ matching assumption is based on **name**. Subsets of the same name as the view will be deleted (whether\
    \ they were assigned to the view or not).\n# * pMode 0 = Delete views and **indirectly** delete subsets\
    \ via bedrock process call. If a subset cannot be deleted the process will continue and exit with\
    \ minor error status.\n# * pMode 1 = Delete views and **directly** delete subsets via SubsetDestroy\
    \ function. If a subset cannot be deleted the process will abort with major error status.\n# * pMode\
    \ 2 = Delete views only and leave subsets as is.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncMsgInfoLevel     = 'INFO';\n\
    cMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo    \
    \      = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%, pSub:%pSub%, pMode:%pMode%.'\
    \ ;  \ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSubset       = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    sMessage          = '';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n### Validate Paramters\
    \ ##\nIF( pMode <> 0 & pMode <> 1 & pMode <> 2 );\n    sMessage = 'Invailid mode value provided %pMode%.\
    \ Do not destroy views or subsets.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nENDIF;\n\nIf( Trim( pCube ) @= '' );\n    sMessage    = 'No cube specified.';\n\
    \    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ CubeExists( pCube ) = 0 );    \n    sMessage    = Expand( 'Invalid  cube specified: %pCube%.' );\n\
    \    nErrors     = 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ pView \nIf( Trim( pView ) @= '' );\n    sMessage    = 'No view specified.';\n    nErrors     = nErrors\
    \ + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( ViewExists(pCube, pView\
    \ ) = 0 ); \n    sMessage    = Expand('There is no view :%pView% in %pCube% cube.') ;\n    nErrors\
    \     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElse;\n    cView\
    \       = Trim( pView );\nEndIf;\n\n# Validate psubset\nIf( pSub @= '' );\n    cSubset     = Trim(\
    \ pView );\nElse;\n    cSubset     = Trim( pSub );\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors     > 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Clean up view\nViewDestroy( pCube, cView );\n\n## Clean up subsets\nIf( pMode\
    \       <= 1 );\n\n    nDimCount = 0;\n    i = 1;\n    sDimName = TabDim( pCube, i );\n    While(\
    \ sDimName @<> '' );\n        If( SubsetExists ( sDimName, cSubset ) = 1 );\n            If( pMode\
    \ = 0 );\n                # 'indirect' deletion\n                 nRet = ExecuteProcess( '}bedrock.hier.sub.delete',\n\
    \                  'pStrictErrorHandling', pStrictErrorHandling,\n                \t'pLogOutput',\
    \ pLogOutput,\n                \t'pDim', sDimName,\n                \t'pHier','',\n              \
    \  \t'pSub', cSubset,\n                \t'pDelim', If( Scan( '&', cSubset ) = 0, '&', ':' ),\n   \
    \             \t'pMode', 0\n                );\n                If( pLogOutput >= 1 & nRet <> ProcessExitNormal()\
    \ );\n                    nErrors = nErrors + 1;\n                    sMessage = 'Subset %cSubset%\
    \ in dimension %sDimName% could not be deleted. It may be used in another view.';\n              \
    \      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                EndIf;\n        \
    \    ElseIf( pMode = 1 );\n                # pMode=1, 'direct' deletion\n                SubsetDestroy(\
    \ sDimName, cSubset );\n            EndIf;\n        EndIf;\n        i = i + 1;\n        sDimName =\
    \ TabDim( pCube, i );\n    End;\n\nEndIf;\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted views and subsets for\
    \ cube  %pCube%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'This IBM Turbo Integrator process deletes a view and all subsets of the same name. The use
    case includes two main scenarios: First, it is used in production environments in the epilog to remove
    views and subsets used for processing. Second, it is for manually cleaning up views and subsets during
    development or prototyping phases. Please note that lists and wildcards are not supported in this
    process. A valid cube name (pCube) is mandatory; otherwise, the process will abort. Similarly, a valid
    view name (pView) is required to proceed. The matching assumption is based on **name**. Subsets with
    the same name as the view will be deleted, regardless of whether they were assigned to the view or
    not. There are three modes for the parameters: Mode 0 deletes views and **indirectly** deletes subsets
    via bedrock process call. If a subset cannot be deleted, the process will continue and exit with a
    minor error status. Mode 1 deletes views and **directly** deletes subsets via the SubsetDestroy function.
    If a subset cannot be deleted, the process will abort with a major error status. Mode 2 deletes views
    only and leaves subsets unchanged.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a view and all subsets of the same name.\n\n\
    # Use case: \n# 1. In production environment used in Epilog to remove view & subsets used for processing.\n\
    # 2. In development/prototyping to manually clean up views & subsets. \n\n# Note:\n# * Lists and wildcards\
    \ are not supported in this process\n# * A valid cube name pCube is mandatory otherwise the process\
    \ will abort. \n# * A valid view name pView is mandatory otherwise the process will abort.\n# * The\
    \ matching assumption is based on **name**. Subsets of the same name as the view will be deleted (whether\
    \ they were assigned to the view or not).\n# * pMode 0 = Delete views and **indirectly** delete subsets\
    \ via bedrock process call. If a subset cannot be deleted the process will continue and exit with\
    \ minor error status.\n# * pMode 1 = Delete views and **directly** delete subsets via SubsetDestroy\
    \ function. If a subset cannot be deleted the process will abort with major error status.\n# * pMode\
    \ 2 = Delete views only and leave subsets as is.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncMsgInfoLevel     = 'INFO';\n\
    cMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo    \
    \      = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pView:%pView%, pSub:%pSub%, pMode:%pMode%.'\
    \ ;  \ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSubset       = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    sMessage          = '';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n### Validate Paramters\
    \ ##\nIF( pMode <> 0 & pMode <> 1 & pMode <> 2 );\n    sMessage = 'Invailid mode value provided %pMode%.\
    \ Do not destroy views or subsets.';\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nENDIF;\n\nIf( Trim( pCube ) @= '' );\n    sMessage    = 'No cube specified.';\n\
    \    nErrors     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ CubeExists( pCube ) = 0 );    \n    sMessage    = Expand( 'Invalid  cube specified: %pCube%.' );\n\
    \    nErrors     = 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ pView \nIf( Trim( pView ) @= '' );\n    sMessage    = 'No view specified.';\n    nErrors     = nErrors\
    \ + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( ViewExists(pCube, pView\
    \ ) = 0 ); \n    sMessage    = Expand('There is no view :%pView% in %pCube% cube.') ;\n    nErrors\
    \     = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElse;\n    cView\
    \       = Trim( pView );\nEndIf;\n\n# Validate psubset\nIf( pSub @= '' );\n    cSubset     = Trim(\
    \ pView );\nElse;\n    cSubset     = Trim( pSub );\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors     > 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Clean up view\nViewDestroy( pCube, cView );\n\n## Clean up subsets\nIf( pMode\
    \       <= 1 );\n\n    nDimCount = 0;\n    i = 1;\n    sDimName = TabDim( pCube, i );\n    While(\
    \ sDimName @<> '' );\n        If( SubsetExists ( sDimName, cSubset ) = 1 );\n            If( pMode\
    \ = 0 );\n                # 'indirect' deletion\n                 nRet = ExecuteProcess( '}bedrock.hier.sub.delete',\n\
    \                  'pStrictErrorHandling', pStrictErrorHandling,\n                \t'pLogOutput',\
    \ pLogOutput,\n                \t'pDim', sDimName,\n                \t'pHier','',\n              \
    \  \t'pSub', cSubset,\n                \t'pDelim', If( Scan( '&', cSubset ) = 0, '&', ':' ),\n   \
    \             \t'pMode', 0\n                );\n                If( pLogOutput >= 1 & nRet <> ProcessExitNormal()\
    \ );\n                    nErrors = nErrors + 1;\n                    sMessage = 'Subset %cSubset%\
    \ in dimension %sDimName% could not be deleted. It may be used in another view.';\n              \
    \      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                EndIf;\n        \
    \    ElseIf( pMode = 1 );\n                # pMode=1, 'direct' deletion\n                SubsetDestroy(\
    \ sDimName, cSubset );\n            EndIf;\n        EndIf;\n        i = i + 1;\n        sDimName =\
    \ TabDim( pCube, i );\n    End;\n\nEndIf;\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted views and subsets for\
    \ cube  %pCube%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Erstellen Sie einen IBM Turbo Integrator Prozess, der in der Lage ist, ein oder mehrere Attribute
    in eine oder mehrere spezifizierte Dimensionen einzufügen. Dieser Prozess ist hauptsächlich für die
    Entwicklung oder Prototyping vorgesehen. Ihre Aufgabe ist es, einen Prozess zu generieren, der mehrere
    Dimensionen-Attribute hinzufügt. Beachten Sie, dass durch Trennzeichen getrennte Listen und/oder Platzhalter
    (*) für die Parameter pDim und pAttr akzeptabel sind. Es ist jedoch zwingend erforderlich, dass gültige
    Dimensionsnamen (pDim) vorhanden sind, da der Prozess sonst abgebrochen wird. Zu den bekannten Einschränkungen
    gehört, dass dieser Prozess mehrere Attribute zu mehreren Dimensionen hinzufügen kann, jedoch nur
    für einen einzigen Attributtyp.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can insert one or more attributes in one or more specified\
    \ dimensions. \n\n# Use case: Intended for development/prototyping.\n# 1/ Add multiple dimension attributes.\n\
    \n# Note:\n# Delimited lists and/or wild card(*) are acceptable for pDim & pAttr.\n# Naturally, valid\
    \ dimension name(s) (pDim) are mandatory otherwise the process will abort.\n# Known limitation: This\
    \ process can insert multiple attributes to multiple dimensions but only for a single attribute type.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        =\
    \ 'User:%cUserName% Process:%cThisProcName% run with parameters pDim:%pDim%, pPrevAttr:%pPrevAttr%,\
    \ pAttr:%pAttr%, pAttrType:%pAttrType%, pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate attribute\nIF( Trim( pAttr ) @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'No attribute specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate attribute type\npAttrType           = Upper( SubSt( pAttrType, 1, 1 ) );\nIf(\
    \ pAttrType @<> 'A' & pAttrType @<> 'S' & pAttrType @<> 'N' );\n    nErrors         = 1;\n    sMessage\
    \        = 'Invalid attribute type specified: ' | pAttrType | '. Defaulted to String type';\n    LogOutput(\
    \ 'INFO', Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate previous attribute\nIf( DimIx( '}ElementAttributes_'\
    \ | pDim, pPrevAttr ) = 0 % pPrevAttr @= pAttr );\n    pPrevAttr       = '';\nEndIf;\n\n# If blank\
    \ delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim          = '&';\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions\
    \ in pDim and attributes in pAttr\nsDims               = pDim;\nnDimDelimiterIndex  = 1;\n# Get 1st\
    \ dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex\
    \ = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex = 0 );\n        sDim        = sDims;\n    Else;\n\
    \        sDim        = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims       = Trim(\
    \ Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n    # Check\
    \ if sDim has wildcard\n    If( Scan( '*', sDim ) = 0);\n        # Validate dimension\n        If(\
    \ DimensionExists(sDim) = 0 );\n            nErrors = 1;\n            sMessage = Expand( 'Dimension\
    \ '%sDim%' does not exist.' );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n  \
    \          If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n            Else;\n  \
    \              ProcessBreak;\n            EndIf;\n        Else;\n            # Loop through attributes\
    \ in pAttr  \n            sAttrs = pAttr;\n            nDelimiterIndex = 1;\n            sAttrDim\
    \ = '}ElementAttributes_'|sDim ;\n            While( nDelimiterIndex <> 0 );\n    \n             \
    \   nDelimiterIndex = Scan( pDelim, sAttrs );\n                If( nDelimiterIndex = 0 );\n      \
    \              sAttr   = sAttrs;\n                Else;\n                    sAttr   = Trim( SubSt(\
    \ sAttrs, 1, nDelimiterIndex - 1 ) );\n                    sAttrs  = Trim( Subst( sAttrs, nDelimiterIndex\
    \ + Long(pDelim), Long( sAttrs ) ) );\n                EndIf;\n    \n                # Check to see\
    \ if attribute already exists.\n                If( Dimix( sAttrDim , sAttr ) = 1 );\n           \
    \         nErrors = 1;\n                    sMessage = 'Attribute ' | sAttr | ' already exist in dimension\
    \ ' | sDim;\n                    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      \
    \          Else;\n                    AttrInsert( sDim , pPrevAttr , sAttr , pAttrType ) ;\n     \
    \               If( pLogOutput = 1 );\n                        LogOutput( 'INFO', Expand( 'Attribute\
    \ '%sAttr%' added to dimension %sDim%.' ) );\n                    EndIf;\n                Endif;\n\
    \            End;\n        EndIf;    \n    Else;\n        # Create subset using Wildcard to loop through\
    \ dimensions in pDim with wildcard\n        sDimExp = '''|sDim|''';\n        sMdx = '{TM1FILTERBYPATTERN(\
    \ EXCEPT ( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*')\
    \ ) ,'| sDimExp | ')}';\n        If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n           \
    \ # If a delimited list of attr names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n        Else;\n            #\
    \ temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX,\
    \ '}Dimensions' , 1 );\n        EndIf;\n        \n        # Loop through dimensions in subset created\
    \ based on wildcard\n        nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n        While(\
    \ nCountDim >= 1 );\n            \n            sDim = SubsetGetElementName( '}Dimensions' , cTempSub,\
    \ nCountDim );\n            # Validate dimension name\n            If( DimensionExists(sDim) = 0 );\n\
    \                nErrors = 1;\n                sMessage = Expand( 'Dimension '%sDim%' does not exist.'\
    \ );\n                LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n                If( pStrictErrorHandling\
    \ = 1 ); \n                    ProcessQuit; \n                Else;\n                    ProcessBreak;\n\
    \                EndIf;\n            Else;\n            # Loop through attributes in pAttr \n    \
    \            sAttrs = pAttr;\n                nDelimiterIndex = 1;\n                sAttrDim = '}ElementAttributes_'|sDim\
    \ ;\n                While( nDelimiterIndex <> 0 );\n    \n                    nDelimiterIndex = Scan(\
    \ pDelim, sAttrs );\n                    If( nDelimiterIndex = 0 );\n                        sAttr\
    \   = sAttrs;\n                    Else;\n                        sAttr   = Trim( SubSt( sAttrs, 1,\
    \ nDelimiterIndex - 1 ) );\n                        sAttrs  = Trim( Subst( sAttrs, nDelimiterIndex\
    \ + Long(pDelim), Long( sAttrs ) ) );\n                    EndIf;\n    \n                    # Check\
    \ to see if attribute already exists.\n                    If( Dimix( sAttrDim , sAttr ) = 1 );\n\
    \                        nErrors = 1;\n                        sMessage = 'Attribute ' | sAttr | '\
    \ already exist in dimension ' | sDim;\n                        LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n                    Else;\n                        AttrInsert( sDim , pPrevAttr\
    \ , sAttr , pAttrType ) ;\n                        If( pLogOutput = 1 );\n                       \
    \     LogOutput( 'INFO', Expand( 'Attribute '%sAttr%' added to dimension %sDim%.' ) );\n         \
    \               EndIf;\n                    Endif;\n                End; \n            EndIf;\n  \
    \          \n            nCountDim = nCountDim - 1;\n        End;\n    EndIf;\n    \n   \nEnd;\n\n\
    ### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created attribute %pAttr% in dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Create an IBM Turbo Integrator process that is capable of inserting one or more attributes
    into one or more specified dimensions. This process is primarily intended for development or prototyping.
    Your task is to generate a process that adds multiple dimension attributes. Note that delimited lists
    and/or wild cards (*) are acceptable for the parameters pDim and pAttr. However, it is mandatory to
    have valid dimension names (pDim), otherwise, the process will abort. A known limitation is that this
    process can add multiple attributes to multiple dimensions, but only for a single attribute type.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can insert one or more attributes in one or more specified\
    \ dimensions. \n\n# Use case: Intended for development/prototyping.\n# 1/ Add multiple dimension attributes.\n\
    \n# Note:\n# Delimited lists and/or wild card(*) are acceptable for pDim & pAttr.\n# Naturally, valid\
    \ dimension name(s) (pDim) are mandatory otherwise the process will abort.\n# Known limitation: This\
    \ process can insert multiple attributes to multiple dimensions but only for a single attribute type.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        =\
    \ 'User:%cUserName% Process:%cThisProcName% run with parameters pDim:%pDim%, pPrevAttr:%pPrevAttr%,\
    \ pAttr:%pAttr%, pAttrType:%pAttrType%, pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate attribute\nIF( Trim( pAttr ) @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'No attribute specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate attribute type\npAttrType           = Upper( SubSt( pAttrType, 1, 1 ) );\nIf(\
    \ pAttrType @<> 'A' & pAttrType @<> 'S' & pAttrType @<> 'N' );\n    nErrors         = 1;\n    sMessage\
    \        = 'Invalid attribute type specified: ' | pAttrType | '. Defaulted to String type';\n    LogOutput(\
    \ 'INFO', Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate previous attribute\nIf( DimIx( '}ElementAttributes_'\
    \ | pDim, pPrevAttr ) = 0 % pPrevAttr @= pAttr );\n    pPrevAttr       = '';\nEndIf;\n\n# If blank\
    \ delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim          = '&';\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions\
    \ in pDim and attributes in pAttr\nsDims               = pDim;\nnDimDelimiterIndex  = 1;\n# Get 1st\
    \ dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex\
    \ = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex = 0 );\n        sDim        = sDims;\n    Else;\n\
    \        sDim        = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims       = Trim(\
    \ Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n    # Check\
    \ if sDim has wildcard\n    If( Scan( '*', sDim ) = 0);\n        # Validate dimension\n        If(\
    \ DimensionExists(sDim) = 0 );\n            nErrors = 1;\n            sMessage = Expand( 'Dimension\
    \ '%sDim%' does not exist.' );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n  \
    \          If( pStrictErrorHandling = 1 ); \n                ProcessQuit; \n            Else;\n  \
    \              ProcessBreak;\n            EndIf;\n        Else;\n            # Loop through attributes\
    \ in pAttr  \n            sAttrs = pAttr;\n            nDelimiterIndex = 1;\n            sAttrDim\
    \ = '}ElementAttributes_'|sDim ;\n            While( nDelimiterIndex <> 0 );\n    \n             \
    \   nDelimiterIndex = Scan( pDelim, sAttrs );\n                If( nDelimiterIndex = 0 );\n      \
    \              sAttr   = sAttrs;\n                Else;\n                    sAttr   = Trim( SubSt(\
    \ sAttrs, 1, nDelimiterIndex - 1 ) );\n                    sAttrs  = Trim( Subst( sAttrs, nDelimiterIndex\
    \ + Long(pDelim), Long( sAttrs ) ) );\n                EndIf;\n    \n                # Check to see\
    \ if attribute already exists.\n                If( Dimix( sAttrDim , sAttr ) = 1 );\n           \
    \         nErrors = 1;\n                    sMessage = 'Attribute ' | sAttr | ' already exist in dimension\
    \ ' | sDim;\n                    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      \
    \          Else;\n                    AttrInsert( sDim , pPrevAttr , sAttr , pAttrType ) ;\n     \
    \               If( pLogOutput = 1 );\n                        LogOutput( 'INFO', Expand( 'Attribute\
    \ '%sAttr%' added to dimension %sDim%.' ) );\n                    EndIf;\n                Endif;\n\
    \            End;\n        EndIf;    \n    Else;\n        # Create subset using Wildcard to loop through\
    \ dimensions in pDim with wildcard\n        sDimExp = '''|sDim|''';\n        sMdx = '{TM1FILTERBYPATTERN(\
    \ EXCEPT ( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*')\
    \ ) ,'| sDimExp | ')}';\n        If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n           \
    \ # If a delimited list of attr names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n        Else;\n            #\
    \ temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX,\
    \ '}Dimensions' , 1 );\n        EndIf;\n        \n        # Loop through dimensions in subset created\
    \ based on wildcard\n        nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n        While(\
    \ nCountDim >= 1 );\n            \n            sDim = SubsetGetElementName( '}Dimensions' , cTempSub,\
    \ nCountDim );\n            # Validate dimension name\n            If( DimensionExists(sDim) = 0 );\n\
    \                nErrors = 1;\n                sMessage = Expand( 'Dimension '%sDim%' does not exist.'\
    \ );\n                LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n                If( pStrictErrorHandling\
    \ = 1 ); \n                    ProcessQuit; \n                Else;\n                    ProcessBreak;\n\
    \                EndIf;\n            Else;\n            # Loop through attributes in pAttr \n    \
    \            sAttrs = pAttr;\n                nDelimiterIndex = 1;\n                sAttrDim = '}ElementAttributes_'|sDim\
    \ ;\n                While( nDelimiterIndex <> 0 );\n    \n                    nDelimiterIndex = Scan(\
    \ pDelim, sAttrs );\n                    If( nDelimiterIndex = 0 );\n                        sAttr\
    \   = sAttrs;\n                    Else;\n                        sAttr   = Trim( SubSt( sAttrs, 1,\
    \ nDelimiterIndex - 1 ) );\n                        sAttrs  = Trim( Subst( sAttrs, nDelimiterIndex\
    \ + Long(pDelim), Long( sAttrs ) ) );\n                    EndIf;\n    \n                    # Check\
    \ to see if attribute already exists.\n                    If( Dimix( sAttrDim , sAttr ) = 1 );\n\
    \                        nErrors = 1;\n                        sMessage = 'Attribute ' | sAttr | '\
    \ already exist in dimension ' | sDim;\n                        LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n                    Else;\n                        AttrInsert( sDim , pPrevAttr\
    \ , sAttr , pAttrType ) ;\n                        If( pLogOutput = 1 );\n                       \
    \     LogOutput( 'INFO', Expand( 'Attribute '%sAttr%' added to dimension %sDim%.' ) );\n         \
    \               EndIf;\n                    Endif;\n                End; \n            EndIf;\n  \
    \          \n            nCountDim = nCountDim - 1;\n        End;\n    EndIf;\n    \n   \nEnd;\n\n\
    ### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created attribute %pAttr% in dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Entwickle eine Prompt für einen IBM Turbo Integrator Prozess, der Attribute einer Dimension
    aus einer Datei erstellt. Der Prozess soll insbesondere für die Entwicklung oder das Prototyping genutzt
    werden und soll verschiedene Attributtypen hinzufügen können. Beachte, dass das Dateiformat dem einer
    Dimensionsexportdatei entsprechen muss, die auf eine }ElementsAttributes Dimension angewendet wird.
    Es ist zwingend erforderlich, einen gültigen Dimensionsnamen (pDim) sowie einen gültigen Pfad (pSrcDir)
    und Dateinamen (pSrcFile) anzugeben, da der Prozess sonst abgebrochen wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create Attributes of the dimension from a file.\n\
    \n# Use case: Intended for development/prototyping. \n#1/ Add multiple dimension attributes of different\
    \ types.\n\n# Note:\n# The file format is as per the dimension export file applied to an }ElementsAttributes\
    \ dimension.\n# Naturally, a valid diension name (pDim) is mandatory otherwise the process will abort.\n\
    # Also, valid path (pSrcDir) & file name (pSrcFile) are mandatory otherwise the process will abort.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName    \
    \     = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pSrcDir:%pSrcDir%, pSrcFile:%pSrcFile%, pTitleRows:%pTitleRows%, pDelim:%pDelim%, pQuote:%pQuote%.';\
    \ \ncLenASCIICode = 3;\n\npDelimiter        = TRIM(pDelim);\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnMetaDataCount = 0;\n\n### Validate\
    \ Parameters ###\n\nnErrors = 0;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n# Validate source dir\nIf(Trim( pSrcDir ) @= '' );\n    pSrcDir = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @= sOSDelim );\n    pSrcDir = SubSt( pSrcDir, 1,\
    \ Long( pSrcDir ) -1 );\nEndIf;\nIf( FileExists( pSrcDir ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid source directory specified: folder does not exist.';\n    DataSourceType = 'NULL';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npSrcDir = pSrcDir | sOSDelim;\n\
    \n# Validate source file\nsFile = pSrcDir | pSrcFile;\nIF ( Trim ( pSrcFile ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No source file specified.';\n    DataSourceType = 'NULL';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( FileExists( sFile ) = 0 );\n    nErrors =\
    \ 1;\n    sMessage = 'Invalid path or source file specified: It does not exist.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors\
    \ = 1;\n    sMessage = 'Dimension: ' | pDim | ' does not exist on server.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate file delimiter & quote character\nIf( pDelimiter\
    \ @= '' );\n    pDelimiter = ',';\nElse;\n    # If length of pDelimiter is exactly 3 chars and each\
    \ of them is decimal digit, then the pDelimiter is entered as ASCII code\n    nValid = 0;\n    If\
    \ ( LONG(pDelimiter) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n\
    \        If( CODE( pDelimiter, nChar )>=CODE( '0', 1 ) & CODE( pDelimiter, nChar )<=CODE( '9', 1 )\
    \ );\n          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar =\
    \ nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelimiter=CHAR(StringToNumber(\
    \ pDelimiter ));\n    Else;\n      pDelimiter = SubSt( Trim( pDelimiter ), 1, 1 );\n    EndIf;\nEndIf;\n\
    If( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is exactly 3\
    \ chars and each of them is decimal digit, then the pQuote is entered as ASCII code\n    nValid =\
    \ 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode\
    \ );\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1\
    \ ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar\
    \ = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote\
    \ ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Datasource ###\n\nDataSourceType\
    \              = 'CHARACTERDELIMITED';\nDatasourceNameForServer     = sFile;\nDatasourceNameForClient\
    \     = sFile;\nDatasourceASCIIHeaderRecords= pTitleRows;\nDatasourceASCIIDelimiter    = pDelimiter;\n\
    DatasourceASCIIQuoteCharacter= pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n## Metatdata Count\nnMetaDataCount = nMetaDataCount\
    \ + 1;\n\n### Write data from source file to target dimension ###\nsAttrType = Upper(SubSt( vAttrType,\
    \ 1, 1 ));\n\n### Validate Record ###\nIF(\n  sAttrType @= 'A' %\n  sAttrType @= 'N' %\n  sAttrType\
    \ @= 'S' );\n  ## Continute\nELSE;\n  sMessage = 'Invalid attribute type.';\n     ITEMSKIP;\nENDIF;\n\
    \nAttrInsert( pDim, '', vAttr, sAttrType );\n\n### End Metadata ###\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created attributes in %pDim% from file %pSrcFile%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Develop a prompt for an IBM Turbo Integrator process that creates attributes of a dimension
    from a file. The process should be intended for development or prototyping and be capable of adding
    multiple attribute types. Note that the file format must match that of a dimension export file applied
    to an }ElementsAttributes dimension. It is mandatory to provide a valid dimension name (pDim) and
    a valid path (pSrcDir) and file name (pSrcFile); otherwise, the process will terminate.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create Attributes of the dimension from a file.\n\
    \n# Use case: Intended for development/prototyping. \n#1/ Add multiple dimension attributes of different\
    \ types.\n\n# Note:\n# The file format is as per the dimension export file applied to an }ElementsAttributes\
    \ dimension.\n# Naturally, a valid diension name (pDim) is mandatory otherwise the process will abort.\n\
    # Also, valid path (pSrcDir) & file name (pSrcFile) are mandatory otherwise the process will abort.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName    \
    \     = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pSrcDir:%pSrcDir%, pSrcFile:%pSrcFile%, pTitleRows:%pTitleRows%, pDelim:%pDelim%, pQuote:%pQuote%.';\
    \ \ncLenASCIICode = 3;\n\npDelimiter        = TRIM(pDelim);\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnMetaDataCount = 0;\n\n### Validate\
    \ Parameters ###\n\nnErrors = 0;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n# Validate source dir\nIf(Trim( pSrcDir ) @= '' );\n    pSrcDir = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @= sOSDelim );\n    pSrcDir = SubSt( pSrcDir, 1,\
    \ Long( pSrcDir ) -1 );\nEndIf;\nIf( FileExists( pSrcDir ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid source directory specified: folder does not exist.';\n    DataSourceType = 'NULL';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npSrcDir = pSrcDir | sOSDelim;\n\
    \n# Validate source file\nsFile = pSrcDir | pSrcFile;\nIF ( Trim ( pSrcFile ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No source file specified.';\n    DataSourceType = 'NULL';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( FileExists( sFile ) = 0 );\n    nErrors =\
    \ 1;\n    sMessage = 'Invalid path or source file specified: It does not exist.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors\
    \ = 1;\n    sMessage = 'Dimension: ' | pDim | ' does not exist on server.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate file delimiter & quote character\nIf( pDelimiter\
    \ @= '' );\n    pDelimiter = ',';\nElse;\n    # If length of pDelimiter is exactly 3 chars and each\
    \ of them is decimal digit, then the pDelimiter is entered as ASCII code\n    nValid = 0;\n    If\
    \ ( LONG(pDelimiter) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n\
    \        If( CODE( pDelimiter, nChar )>=CODE( '0', 1 ) & CODE( pDelimiter, nChar )<=CODE( '9', 1 )\
    \ );\n          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar =\
    \ nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelimiter=CHAR(StringToNumber(\
    \ pDelimiter ));\n    Else;\n      pDelimiter = SubSt( Trim( pDelimiter ), 1, 1 );\n    EndIf;\nEndIf;\n\
    If( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is exactly 3\
    \ chars and each of them is decimal digit, then the pQuote is entered as ASCII code\n    nValid =\
    \ 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode\
    \ );\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1\
    \ ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar\
    \ = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote\
    \ ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Datasource ###\n\nDataSourceType\
    \              = 'CHARACTERDELIMITED';\nDatasourceNameForServer     = sFile;\nDatasourceNameForClient\
    \     = sFile;\nDatasourceASCIIHeaderRecords= pTitleRows;\nDatasourceASCIIDelimiter    = pDelimiter;\n\
    DatasourceASCIIQuoteCharacter= pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n## Metatdata Count\nnMetaDataCount = nMetaDataCount\
    \ + 1;\n\n### Write data from source file to target dimension ###\nsAttrType = Upper(SubSt( vAttrType,\
    \ 1, 1 ));\n\n### Validate Record ###\nIF(\n  sAttrType @= 'A' %\n  sAttrType @= 'N' %\n  sAttrType\
    \ @= 'S' );\n  ## Continute\nELSE;\n  sMessage = 'Invalid attribute type.';\n     ITEMSKIP;\nENDIF;\n\
    \nAttrInsert( pDim, '', vAttr, sAttrType );\n\n### End Metadata ###\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created attributes in %pDim% from file %pSrcFile%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der die Werte des angegebenen Alias mit dem
    Hauptnamen für alle Elemente der Zieldimension vertauscht. Dieser Prozess ist ausschließlich für Entwicklungs-
    und Prototypisierungsszenarien gedacht und sollte **nicht in einer Produktionsumgebung verwendet werden**.
    Beachte, dass die Funktion SwapAliasWithPrincipalName **nicht unterstützt** für alternative Hierarchien
    ist. Wenn alternative Hierarchien für die Zieldimension existieren, wird der Prozess abgebrochen.
    Achtung: Verwende diesen Prozess mit Vorsicht, da die zugrundeliegende Funktion SwapAliasWithPrincipalName
    von IBM nie offiziell dokumentiert oder unterstützt wurde.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will swap the values of the nominated alias with the\
    \ principal name for all elements of the target dimension.\n#\n# Use case: Strictly for development/prototyping\
    \ scenarios. This process should **not be used** in a production environment. \n# 1. Swap an alias\
    \ with principal name \n#\n# Note:\n# The SwapAliasWithPrincipalName function is **not supported**\
    \ for alternate hierarchies. Therefore this process checks for the \n# existance of alternate hierarches\
    \ and if any exist for the target dimension then the process will abort.\n#\n# Warning: \n# Use with\
    \ care. This process works, however, the underlying SwapAliasWithPrincipalName function  has never\
    \ been officially \n# documented or suported by IBM. \n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable\
    \ ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode = 0;\n\
    \n### Constants ###\ncThisProcName     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\\
    m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncDebugFile       \
    \ = GetProcessErrorFileDirectory | cThisProcName | '.' | cTimeStamp | '.' | cRandomInt ;\ncCubeAttr\
    \         = '}ElementAttributes_' | pDim;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\ncLogInfo          = '***Parameters\
    \ for Process:%cThisProcName% for pDim:%pDim%, pAlias:%pAlias%.' ;  \ncDim              = '}Dimensions';\n\
    cSubset           = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt; \n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\n\nnErrors = 0;\n\n## Validate dimension\nIF( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage\
    \ = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF(\
    \ DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate alias\nIf( Trim( pAlias ) @=\
    \ '' );\n  nErrors = 1;\n  sMessage = 'No alias specified';\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElseIf( DimIx( cCubeAttr, pAlias ) = 0 );\n  nErrors = 1;\n  sMessage = 'Alias:\
    \ ' | pAlias | ' does not exist in dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nsElementType = DType( cCubeAttr, pAlias );\nIf( sElementType @<> 'AA' );\n  nErrors\
    \ = 1;\n  sMessage = 'Attribute: ' | pAlias | ' is not a valid alias.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n### Swap Dimension ###\nSwapAliasWithPrincipalName( pDim, pAlias, 0 );\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully swapped the principal element names of the %pDim%\
    \ with the %pAlias% alias.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that swaps the values of the nominated alias with
    the principal name for all elements of the target dimension. This process is strictly for development
    and prototyping scenarios and should **not be used in a production environment**. Note that the SwapAliasWithPrincipalName
    function is **not supported** for alternate hierarchies. Therefore, if alternate hierarchies exist
    for the target dimension, the process will abort. Warning: Use this process with care, as the underlying
    SwapAliasWithPrincipalName function has never been officially documented or supported by IBM.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will swap the values of the nominated alias with the\
    \ principal name for all elements of the target dimension.\n#\n# Use case: Strictly for development/prototyping\
    \ scenarios. This process should **not be used** in a production environment. \n# 1. Swap an alias\
    \ with principal name \n#\n# Note:\n# The SwapAliasWithPrincipalName function is **not supported**\
    \ for alternate hierarchies. Therefore this process checks for the \n# existance of alternate hierarches\
    \ and if any exist for the target dimension then the process will abort.\n#\n# Warning: \n# Use with\
    \ care. This process works, however, the underlying SwapAliasWithPrincipalName function  has never\
    \ been officially \n# documented or suported by IBM. \n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable\
    \ ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode = 0;\n\
    \n### Constants ###\ncThisProcName     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\\
    m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncDebugFile       \
    \ = GetProcessErrorFileDirectory | cThisProcName | '.' | cTimeStamp | '.' | cRandomInt ;\ncCubeAttr\
    \         = '}ElementAttributes_' | pDim;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\ncLogInfo          = '***Parameters\
    \ for Process:%cThisProcName% for pDim:%pDim%, pAlias:%pAlias%.' ;  \ncDim              = '}Dimensions';\n\
    cSubset           = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt; \n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\n\nnErrors = 0;\n\n## Validate dimension\nIF( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage\
    \ = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF(\
    \ DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate alias\nIf( Trim( pAlias ) @=\
    \ '' );\n  nErrors = 1;\n  sMessage = 'No alias specified';\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElseIf( DimIx( cCubeAttr, pAlias ) = 0 );\n  nErrors = 1;\n  sMessage = 'Alias:\
    \ ' | pAlias | ' does not exist in dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nsElementType = DType( cCubeAttr, pAlias );\nIf( sElementType @<> 'AA' );\n  nErrors\
    \ = 1;\n  sMessage = 'Attribute: ' | pAlias | ' is not a valid alias.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n### Swap Dimension ###\nSwapAliasWithPrincipalName( pDim, pAlias, 0 );\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully swapped the principal element names of the %pDim%\
    \ with the %pAlias% alias.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Beschreibe einen IBM Turbo Integrator Prozess, der eine Quell-Dimension und alle ihre Hierarchien
    klonen kann. Dieser Prozess ist für die Entwicklung und das Prototyping gedacht, insbesondere um eine
    Dimension mit ihren Hierarchien für Testzwecke zu replizieren. Beachte, dass wenn die Ziel-Dimension
    oder Hierarchie bereits existiert, diese überschrieben wird. Es ist zwingend erforderlich, einen gültigen
    Namen für die Quell-Dimension (pSrcDim) anzugeben, da der Prozess andernfalls abgebrochen wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can clone a source dimension and all the Hierarchies.\n\
    \n# Use case: Intended for development/prototyping.\n# 1/ Replicate a dimension with it's hierarchies\
    \ for testing.\n\n# Note:\n# If the target dimension:hierarchy already exists then it will be overwritten.\n\
    # Naturally, a valid source dimension name (pSrcDim) is mandatory otherwise the process will abort.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncSubset           = cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo     \
    \     = '***Parameters for Process:%cThisProcName% for pSrcDim:%pSrcDim%, pTgtDim:%pTgtDim%, pHier:%pHier%,\
    \ pAttr:%pAttr%, pUnwind:%pUnwind%, pDelim:%pDelim%.';\ncLangDim          = '}Cultures';\nnNumLang\
    \          = DimSiz( cLangDim );\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*',\
    \ pSrcDim )=0 &  Scan( '?', pSrcDim )=0 & Scan( pDelim, pSrcDim )=0 & Scan( ':', pSrcDim ) > 0 & pHier\
    \ @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long( pSrcDim\
    \ ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\nEndIf;\n\n## Validate\
    \ dimension\nIF( Trim( pSrcDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No source dimension specified.';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( DimensionExists( pSrcDim ) =\
    \ 0 );\n  nErrors = 1;\n  sMessage = 'Invalid source dimension: ' | pSrcDim;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pTgtDim @= '' % pTgtDim @= pSrcDim );\n  pTgtDim =\
    \ pSrcDim | '_Clone';\nEndIf;\n\n# Validate hierarchy\nIF( Scan( '*', pSrcDim )=0 &  Scan( '?', pSrcDim\
    \ )=0 & Scan( pDelim, pSrcDim )=0 & pHier @= '');\n    pHier = pSrcDim;\nElseIf( Scan( '*', pHier\
    \ )=0 &  Scan( '?', pHier )=0 & Scan( pDelim, pHier )=0 & pHier @<> '' & HierarchyExists(pSrcDim,\
    \ pHier) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension hierarchy: ' | pHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\nIf( Trim( pHier ) @= '' );\n    ## use\
    \ same name as Dimension. Since wildcards are allowed, this is managed inside the code below\nEndIf;\n\
    \n## Default delimiter\nIf( pDelim     @= '' );\n    pDelim     = '&';\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n\
    \  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create target dimension ###\n\nIf(DimensionExists(\
    \ pTgtDim ) = 0 );\n    DimensionCreate( pTgtDim );\nElse;\n    IF(pUnwind = 1 );\n       nRet = ExecuteProcess('}bedrock.hier.unwind',\n\
    \        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n      \
    \  'pDim', pTgtDim,\n        'pHier', pTgtDim,\n        'pConsol', '*',\n        'pRecursive', 1\n\
    \        );\n    ELSEIF(pUnwind = 2 );\n      # Do nothing;\n    ELSE;\n      DimensionDeleteAllElements(\
    \ pTgtDim );\n    EndIf;\nEndIf;\n\n### Set the target Sort Order ###\nsSortElementsType     = CELLGETS(\
    \ '}DimensionProperties', pSrcDim, 'SORTELEMENTSTYPE');\nsSortElementsSense    = CELLGETS( '}DimensionProperties',\
    \ pSrcDim, 'SORTELEMENTSSENSE');\nsSortComponentsType   = CELLGETS( '}DimensionProperties', pSrcDim,\
    \ 'SORTCOMPONENTSTYPE');\nsSortComponentsSense  = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTCOMPONENTSSENSE');\n\
    \nDimensionSortOrder( pTgtDim, sSortComponentsType, sSortComponentsSense, sSortElementsType , sSortElementsSense);\n\
    \n\nnSourceDimSize = DIMSIZ( pSrcDim );\nnIndex = 1;\nWHILE( nIndex <= nSourceDimSize );\n  sElName\
    \ = DIMNM( pSrcDim, nIndex);\n  sElType = DTYPE( pSrcDim, sElName);\n  \n    DimensionElementInsert(\
    \ pTgtDim, '', sElName, sElType );\n\n  nIndex = nIndex + 1;\nEND;\n\n### Assign Data Source ###\n\
    DatasourceNameForServer   = pSrcDim;\nDatasourceNameForClient   = pSrcDim;\nDataSourceType       \
    \     = 'SUBSET';\nDatasourceDimensionSubset = 'ALL';\n\n\n### Replicate Attributes ###\n# Note: DType\
    \ on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\nsAttrDim        = '}ElementAttributes_'\
    \ | pSrcDim;\nsAttrLoc        = '}LocalizedElementAttributes_' | pSrcDim;\nsAttrTargetDim  = '}ElementAttributes_'\
    \ | pTgtDim;\nsAttrLocTarget  = '}LocalizedElementAttributes_' | pTgtDim;\n\nIf( pAttr = 1 & DimensionExists(\
    \ sAttrDim ) = 1 );\n  nNumAttrs = DimSiz( sAttrDim );\n  nCount = 1;\n  While( nCount <= nNumAttrs\
    \ );\n    sAttrName = DimNm( sAttrDim, nCount );\n    sAttCheck = SubSt( DTYPE( sAttrDim, sAttrName\
    \ ), 1, 1 );\n    IF (sAttCheck @= 'A');\n    sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ), 2,\
    \ 1 );\n    Else;\n    sAttrType = sAttcheck;\n    EndIf; \n      \n      If ( DimensionExists( sAttrTargetDim\
    \ ) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n       ElseIF(DimIx(sAttrTargetDim,\
    \ sAttrName) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n      Endif;\n        \n\
    \    nCount = nCount + 1;\n  End;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Check for errors in prolog ###\n\
    \nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Add Elements to target dimension ###\n\nsElType = DType( pSrcDim, vEle );\n\
    IF( sElType @= 'C' & ElCompN( pSrcDim, vEle ) > 0 );\n    nChildren = ElCompN( pSrcDim, vEle );\n\
    \    nCount = 1;\n    While( nCount <= nChildren );\n      sChildElement = ElComp( pSrcDim, vEle,\
    \ nCount );\n      sChildWeight = ElWeight( pSrcDim, vEle, sChildElement );\n      DimensionElementComponentAdd(\
    \ pTgtDim, vEle, sChildElement, sChildWeight );\n      nCount = nCount + 1;\n    End;\nEndIf;\n\n\
    ### End MetaData ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Replicate Attributes ###\n\
    # Note: DTYPE on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\nIf( pAttr =\
    \ 1 & DimensionExists( sAttrDim ) = 1 );\n\n    nAttr = 1;\n    While( nAttr <= nNumAttrs );\n   \
    \     sAttrName = DimNm( sAttrDim, nAttr );\n        sAttCheck = SubSt( DTYPE( sAttrDim, sAttrName\
    \ ), 1, 1 );\n        IF (sAttCheck @= 'A');\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName\
    \ ), 2, 1 );\n        Else;\n        sAttrType = sAttcheck;\n        sMessage = pSrcDim | ' dimension\
    \ contains invalid attribute - ' | sAttrName ;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 );\n          ItemReject(Expand( cMsgErrorContent ));\n\
    \        EndIf;  \n        EndIf;\n        If( CellIsUpdateable( sAttrTargetDim, vEle, sAttrName )\
    \ = 1 );\n            If( sAttrType @= 'S' % sAttrType @= 'A' );\n                #sAttrVal = AttrS(\
    \ pSrcDim, vEle, sAttrName );\n                sAttrVal = CellgetS('}ElementAttributes_'| pSrcDim,\
    \ vEle, sAttrName);\n                If( sAttrVal @<> '' );\n                    If( sAttrType @=\
    \ 'A' );\n                        AttrPutS( sAttrVal, pTgtDim, vEle, sAttrName, 1 );\n           \
    \         Else;\n                        AttrPutS( sAttrVal, pTgtDim, vEle, sAttrName );\n       \
    \             EndIf;\n                EndIf;\n            Else;\n                #nAttrVal = AttrN(\
    \ pSrcDim, vEle, sAttrName );\n                nAttrVal = CellgetN('}ElementAttributes_'| pSrcDim,\
    \ vEle, sAttrName);\n                If( nAttrVal <> 0 );\n                    AttrPutN( nAttrVal,\
    \ pTgtDim, vEle, sAttrName );\n                EndIf;\n            EndIf;\n        EndIf;\n      \
    \  # check for localized attributes\n        If( CubeExists( sAttrLoc ) = 1 );\n            nLang\
    \ = 1;\n            While( nLang <= nNumLang );\n                sLang       = DimNm( cLangDim, nLang\
    \ );\n                If( sAttrType @= 'A' % sAttrType @= 'S' );\n                    sAttrVal   \
    \ = AttrS( pSrcDim, vEle, sAttrName );\n                    sAttrValLoc = AttrSL( pSrcDim, vEle, sAttrName,\
    \ sLang );\n                    If( sAttrValLoc @= sAttrVal ); sAttrValLoc = ''; EndIf;\n        \
    \        Else;\n                    nAttrVal    = AttrN( pSrcDim, vEle, sAttrName );\n           \
    \         nAttrValLoc = AttrNL( pSrcDim, vEle, sAttrName, sLang );\n                EndIf;\n     \
    \           If( CubeExists( sAttrLocTarget ) = 0 );\n                    If( sAttrType @= 'A' );\n\
    \                        AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName, sLang, 1 );\n          \
    \          ElseIf( sAttrType @= 'N' );\n                        If( nAttrValLoc <> nAttrVal );\n \
    \                           AttrPutN( nAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\n          \
    \              EndIf;\n                    Else;\n                        AttrPutS( sAttrValLoc, pTgtDim,\
    \ vEle, sAttrName, sLang );\n                    EndIf;\n                ElseIf( CubeExists( sAttrLocTarget\
    \ ) = 1 );\n                    If( CellIsUpdateable( sAttrLocTarget, vEle, sLang, sAttrName ) = 1\
    \ );\n                        If( sAttrType @= 'A' );\n                            AttrPutS( sAttrValLoc,\
    \ pTgtDim, vEle, sAttrName, sLang, 1 );\n                        ElseIf( sAttrType @= 'N' );\n   \
    \                         If( nAttrValLoc <> nAttrVal );\n                                AttrPutN(\
    \ nAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\n                            EndIf;\n          \
    \              Else;\n                            AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName,\
    \ sLang );\n                        EndIf;\n                    EndIf;\n                EndIf;\n \
    \               nLang   = nLang + 1;\n            End;\n        EndIf;\n        nAttr = nAttr + 1;\n\
    \    End;\n\nEndIf;\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#################################################################################################\
    \ \n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0.0~~##\n\
    #################################################################################################\
    \ \n\n\n### Set the target Sort Order ###\n  CELLPUTS( sSortElementsType, '}DimensionProperties',\
    \ pTgtDim, 'SORTELEMENTSTYPE');\n  CELLPUTS( sSortElementsSense, '}DimensionProperties', pTgtDim,\
    \ 'SORTELEMENTSSENSE');\n  CELLPUTS( sSortComponentsType, '}DimensionProperties', pTgtDim, 'SORTCOMPONENTSTYPE');\n\
    \  CELLPUTS( sSortComponentsSense, '}DimensionProperties', pTgtDim, 'SORTCOMPONENTSSENSE');\n\n###\
    \ Destroy Source Subset ###\n\n  If( SubsetExists( pSrcDim, cSubset ) = 1 );\n    SubsetDestroy( pSrcDim,\
    \ cSubset );\n  EndIf;\n\n##Clone all the Hierarchies except default hierarchy & Leaves\nIf( pHier\
    \ @= '*' );\n    sDim = pSrcDim;\n    sHierDim = '}Hierarchies_' | sDim;\n    sTargetHierarchy = '';\n\
    \    nMax = DimSiz( sHierDim );\n    nCtr = 1;\n    While( nCtr <= nMax );\n        sEle = DimNm(\
    \ sHierDim, nCtr );\n        nElength = Long(sEle);\n        nElestart  = 0;\n        nElestart =\
    \ SCAN(':', sEle) + 1;\n        If(nElestart > 1);\n          vSourceHierarchy = SUBST(sEle,nElestart,nElength);\n\
    \         If ( vSourceHierarchy @<> 'Leaves');\n             nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n\
    \               'pLogOutput', pLogOutput,\n               'pStrictErrorHandling', pStrictErrorHandling,\n\
    \               'pSrcDim', sDim,\n               'pSrcHier', vSourceHierarchy,\n               'pTgtDim',\
    \ pTgtDim,\n               'pTgtHier', vSourceHierarchy,\n               'pAttr', pAttr,\n       \
    \        'pUnwind',pUnwind\n               );\n         Endif;\n         sTargetHierarchy = sTargetHierarchy\
    \ |':'|vSourceHierarchy;\n        Endif;\n        nCtr = nCtr + 1;\n    End;\n### Just one hierarchy\
    \ specified in parameter\nElseIf( Scan( '*', pHier )=0 &  Scan( '?', pHier )=0 & Scan( pDelim, pHier\
    \ )=0 & Trim( pHier ) @<> '' );\n    sDim = pSrcDim;\n    sHierDim = '}Hierarchies_' | sDim;\n   \
    \ sCurrHier = pHier;\n    sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier)\
    \ );\n    # Validate hierarchy name in sHierDim\n    If( Dimix( sHierDim , sDim |':'| sCurrHier )\
    \ = 0 );\n        sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n\
    \        LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n    ElseIf( sCurrHierName @= 'Leaves' );\n\
    \        sMessage = 'Invalid  Hierarchy: ' | sCurrHier | ' will be skipped....';\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ElseIf( sCurrHierName @<> sDim );\n      If(\
    \ pLogOutput = 1 );\n        sMessage = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%'\
    \ being processed....' );\n        LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n      EndIf;\n\
    \      nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n       'pLogOutput', pLogOutput,\n       'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n       'pSrcDim', sDim,\n       'pSrcHier', sCurrHierName,\n       'pTgtDim',\
    \ pTgtDim,\n       'pTgtHier', sCurrHierName,\n       'pAttr', pAttr,\n       'pUnwind',pUnwind\n\
    \      );\n    Endif;\n### Hierachy is a delimited list with no wildcards\nElseIf( Scan( '*', pHier\
    \ )=0 &  Scan( '?', pHier )=0 & Trim( pHier ) @<> '' );\n  \n      # Loop through hierarchies in pHier\n\
    \    sDim = pSrcDim;\n    sHierarchies              = pHier;\n    nDelimiterIndexA    = 1;\n    sHierDim\
    \            = '}Hierarchies_'| sDim ;\n    sMdxHier = '';\n    While( nDelimiterIndexA <> 0 );\n\
    \  \n        nDelimiterIndexA = Scan( pDelim, sHierarchies );\n        If( nDelimiterIndexA = 0 );\n\
    \            sHierarchy   = sHierarchies;\n        Else;\n            sHierarchy   = Trim( SubSt(\
    \ sHierarchies, 1, nDelimiterIndexA - 1 ) );\n            sHierarchies  = Trim( Subst( sHierarchies,\
    \ nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n        EndIf;\n        sCurrHier =\
    \ sHierarchy;\n        sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n\
    \        # Validate hierarchy name in sHierDim\n        If( Dimix( sHierDim , sDim |':'| sCurrHier\
    \ ) = 0 );\n            sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%'\
    \ dimension.');\n            LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n        ElseIf( sCurrHierName\
    \ @= 'Leaves' );\n            sMessage = 'Invalid  Hierarchy: ' | sCurrHier | ' will be skipped....';\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ElseIf( sCurrHierName\
    \ @<> sDim );\n          If( pLogOutput = 1 );\n            sMessage = Expand( 'Hierarchy '%sCurrHierName%'\
    \ in Dimension '%sDim%' being processed....' );\n            LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n          EndIf;\n          nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n           'pLogOutput',\
    \ pLogOutput,\n           'pStrictErrorHandling', pStrictErrorHandling,\n           'pSrcDim', sDim,\n\
    \           'pSrcHier', sCurrHierName,\n           'pTgtDim', pTgtDim,\n           'pTgtHier', sCurrHierName,\n\
    \           'pAttr', pAttr,\n           'pUnwind',pUnwind\n          );\n        Endif;\n    End;\n\
    \n### Hierachy has wildcards inside\nElseIf( Trim( pHier ) @<> '' );\n  \n      # Loop through hierarchies\
    \ in pHier\n    sDim = pSrcDim;\n    sHierarchies              = pHier;\n    nDelimiterIndexA    =\
    \ 1;\n    sHierDim            = '}Hierarchies_'| sDim ;\n    sMdxHier = '';\n    While( nDelimiterIndexA\
    \ <> 0 );\n  \n        nDelimiterIndexA = Scan( pDelim, sHierarchies );\n        If( nDelimiterIndexA\
    \ = 0 );\n            sHierarchy   = sHierarchies;\n        Else;\n            sHierarchy   = Trim(\
    \ SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n            sHierarchies  = Trim( Subst( sHierarchies,\
    \ nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n        EndIf;\n  \n        # Create\
    \ subset of Hierarchies using Wildcard\n        sHierExp = '''| sDim | ':' | sHierarchy|''';\n   \
    \     sMdxHierPart = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp | ')}';\n\
    \        IF( sMdxHier @= ''); \n          sMdxHier = sMdxHierPart; \n        ELSE;\n          sMdxHier\
    \ = sMdxHier | ' + ' | sMdxHierPart;\n        ENDIF;\n    End;\n  \n    If( SubsetExists( sHierDim,\
    \ cSubset ) = 1 );\n        # If a delimited list of attr names includes wildcards then we may have\
    \ to re-use the subset multiple times\n        SubsetMDXSet( sHierDim, cSubset, sMdxHier );\n    Else;\n\
    \        # temp subset, therefore no need to destroy in epilog\n        SubsetCreatebyMDX( cSubset,\
    \ sMdxHier, sHierDim, 1 );\n    EndIf;\n  \n    # Loop through subset of hierarchies created based\
    \ on wildcard\n    nCountHier = SubsetGetSize( sHierDim, cSubset  );\n    While( nCountHier >= 1 );\n\
    \        sCurrHier = SubsetGetElementName( sHierDim, cSubset , nCountHier );\n        sCurrHierName\
    \ = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n        # Validate hierarchy name\
    \ in sHierDim\n        If( Dimix( sHierDim , sCurrHier ) = 0 );\n            sMessage = Expand('The\
    \ '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n            LogOutput( 'INFO'\
    \ , Expand( cMsgInfoContent ) );\n        ElseIf( sCurrHierName @= 'Leaves' );\n            sMessage\
    \ = 'Invalid  Hierarchy: ' | sCurrHier | ' will be skipped....';\n            LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        ElseIf( sCurrHierName @<> sDim );\n          If( pLogOutput\
    \ = 1 );\n            sMessage = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%' being\
    \ processed....' );\n            LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n          EndIf;\n\
    \          nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n           'pLogOutput', pLogOutput,\n  \
    \         'pStrictErrorHandling', pStrictErrorHandling,\n           'pSrcDim', sDim,\n           'pSrcHier',\
    \ sCurrHierName,\n           'pTgtDim', pTgtDim,\n           'pTgtHier', sCurrHierName,\n        \
    \   'pAttr', pAttr,\n           'pUnwind',pUnwind\n          );\n        Endif;\n      \n        nCountHier\
    \ = nCountHier - 1;\n    End;\nEndif;\n\n### Clone dimension subsets\nIf( pSub = 1);\n  nCountSubs\
    \ = DimSiz ('}Subsets_' | sDim);\n  While ( nCountSubs >= 1 );\n    sCurrSub = If( Scan( ':', DimNm\
    \ ('}Subsets_' | sDim, nCountSubs)) = 0, DimNm ('}Subsets_' | sDim, nCountSubs), Subst( DimNm ('}Subsets_'\
    \ | sDim, nCountSubs), Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))+1, Long(DimNm ('}Subsets_'\
    \ | sDim, nCountSubs))-Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))));\n    sCurrHier = If(\
    \ Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs)) = 0, '', Subst(DimNm ('}Subsets_' | sDim, nCountSubs),\
    \ 1, Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))-1));\n\n    ExecuteProcess('}bedrock.hier.sub.clone',\n\
    \      'pLogOutput',0,\n      'pStrictErrorHandling',0,\n      'pSrcDim',sDim,\n      'pSrcHier',sCurrHier,\n\
    \      'pSrcSub',sCurrSub,\n      'pTgtDim', pTgtDim,\n      'pTgtHier', sCurrHier,\n      'pTgtSub',sCurrSub,\n\
    \      'pTemp',0,\n      'pAlias','');\n    nCountSubs = nCountSubs - 1;\n  End;\nEndif;\n       \
    \   \n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% has cloned the %pSrcDim% dimension into %pTgtDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Describe an IBM Turbo Integrator process that can clone a source dimension and all its hierarchies.
    This process is intended for development and prototyping purposes, specifically to replicate a dimension
    with its hierarchies for testing. Note that if the target dimension or hierarchy already exists, it
    will be overwritten. A valid source dimension name (pSrcDim) is mandatory, otherwise the process will
    abort.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can clone a source dimension and all the Hierarchies.\n\
    \n# Use case: Intended for development/prototyping.\n# 1/ Replicate a dimension with it's hierarchies\
    \ for testing.\n\n# Note:\n# If the target dimension:hierarchy already exists then it will be overwritten.\n\
    # Naturally, a valid source dimension name (pSrcDim) is mandatory otherwise the process will abort.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncSubset           = cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo     \
    \     = '***Parameters for Process:%cThisProcName% for pSrcDim:%pSrcDim%, pTgtDim:%pTgtDim%, pHier:%pHier%,\
    \ pAttr:%pAttr%, pUnwind:%pUnwind%, pDelim:%pDelim%.';\ncLangDim          = '}Cultures';\nnNumLang\
    \          = DimSiz( cLangDim );\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*',\
    \ pSrcDim )=0 &  Scan( '?', pSrcDim )=0 & Scan( pDelim, pSrcDim )=0 & Scan( ':', pSrcDim ) > 0 & pHier\
    \ @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long( pSrcDim\
    \ ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\nEndIf;\n\n## Validate\
    \ dimension\nIF( Trim( pSrcDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No source dimension specified.';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( DimensionExists( pSrcDim ) =\
    \ 0 );\n  nErrors = 1;\n  sMessage = 'Invalid source dimension: ' | pSrcDim;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( pTgtDim @= '' % pTgtDim @= pSrcDim );\n  pTgtDim =\
    \ pSrcDim | '_Clone';\nEndIf;\n\n# Validate hierarchy\nIF( Scan( '*', pSrcDim )=0 &  Scan( '?', pSrcDim\
    \ )=0 & Scan( pDelim, pSrcDim )=0 & pHier @= '');\n    pHier = pSrcDim;\nElseIf( Scan( '*', pHier\
    \ )=0 &  Scan( '?', pHier )=0 & Scan( pDelim, pHier )=0 & pHier @<> '' & HierarchyExists(pSrcDim,\
    \ pHier) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension hierarchy: ' | pHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\nIf( Trim( pHier ) @= '' );\n    ## use\
    \ same name as Dimension. Since wildcards are allowed, this is managed inside the code below\nEndIf;\n\
    \n## Default delimiter\nIf( pDelim     @= '' );\n    pDelim     = '&';\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n\
    \  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create target dimension ###\n\nIf(DimensionExists(\
    \ pTgtDim ) = 0 );\n    DimensionCreate( pTgtDim );\nElse;\n    IF(pUnwind = 1 );\n       nRet = ExecuteProcess('}bedrock.hier.unwind',\n\
    \        'pLogOutput', pLogOutput,\n        'pStrictErrorHandling', pStrictErrorHandling,\n      \
    \  'pDim', pTgtDim,\n        'pHier', pTgtDim,\n        'pConsol', '*',\n        'pRecursive', 1\n\
    \        );\n    ELSEIF(pUnwind = 2 );\n      # Do nothing;\n    ELSE;\n      DimensionDeleteAllElements(\
    \ pTgtDim );\n    EndIf;\nEndIf;\n\n### Set the target Sort Order ###\nsSortElementsType     = CELLGETS(\
    \ '}DimensionProperties', pSrcDim, 'SORTELEMENTSTYPE');\nsSortElementsSense    = CELLGETS( '}DimensionProperties',\
    \ pSrcDim, 'SORTELEMENTSSENSE');\nsSortComponentsType   = CELLGETS( '}DimensionProperties', pSrcDim,\
    \ 'SORTCOMPONENTSTYPE');\nsSortComponentsSense  = CELLGETS( '}DimensionProperties', pSrcDim, 'SORTCOMPONENTSSENSE');\n\
    \nDimensionSortOrder( pTgtDim, sSortComponentsType, sSortComponentsSense, sSortElementsType , sSortElementsSense);\n\
    \n\nnSourceDimSize = DIMSIZ( pSrcDim );\nnIndex = 1;\nWHILE( nIndex <= nSourceDimSize );\n  sElName\
    \ = DIMNM( pSrcDim, nIndex);\n  sElType = DTYPE( pSrcDim, sElName);\n  \n    DimensionElementInsert(\
    \ pTgtDim, '', sElName, sElType );\n\n  nIndex = nIndex + 1;\nEND;\n\n### Assign Data Source ###\n\
    DatasourceNameForServer   = pSrcDim;\nDatasourceNameForClient   = pSrcDim;\nDataSourceType       \
    \     = 'SUBSET';\nDatasourceDimensionSubset = 'ALL';\n\n\n### Replicate Attributes ###\n# Note: DType\
    \ on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\nsAttrDim        = '}ElementAttributes_'\
    \ | pSrcDim;\nsAttrLoc        = '}LocalizedElementAttributes_' | pSrcDim;\nsAttrTargetDim  = '}ElementAttributes_'\
    \ | pTgtDim;\nsAttrLocTarget  = '}LocalizedElementAttributes_' | pTgtDim;\n\nIf( pAttr = 1 & DimensionExists(\
    \ sAttrDim ) = 1 );\n  nNumAttrs = DimSiz( sAttrDim );\n  nCount = 1;\n  While( nCount <= nNumAttrs\
    \ );\n    sAttrName = DimNm( sAttrDim, nCount );\n    sAttCheck = SubSt( DTYPE( sAttrDim, sAttrName\
    \ ), 1, 1 );\n    IF (sAttCheck @= 'A');\n    sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ), 2,\
    \ 1 );\n    Else;\n    sAttrType = sAttcheck;\n    EndIf; \n      \n      If ( DimensionExists( sAttrTargetDim\
    \ ) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n       ElseIF(DimIx(sAttrTargetDim,\
    \ sAttrName) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n      Endif;\n        \n\
    \    nCount = nCount + 1;\n  End;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Check for errors in prolog ###\n\
    \nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Add Elements to target dimension ###\n\nsElType = DType( pSrcDim, vEle );\n\
    IF( sElType @= 'C' & ElCompN( pSrcDim, vEle ) > 0 );\n    nChildren = ElCompN( pSrcDim, vEle );\n\
    \    nCount = 1;\n    While( nCount <= nChildren );\n      sChildElement = ElComp( pSrcDim, vEle,\
    \ nCount );\n      sChildWeight = ElWeight( pSrcDim, vEle, sChildElement );\n      DimensionElementComponentAdd(\
    \ pTgtDim, vEle, sChildElement, sChildWeight );\n      nCount = nCount + 1;\n    End;\nEndIf;\n\n\
    ### End MetaData ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Replicate Attributes ###\n\
    # Note: DTYPE on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\nIf( pAttr =\
    \ 1 & DimensionExists( sAttrDim ) = 1 );\n\n    nAttr = 1;\n    While( nAttr <= nNumAttrs );\n   \
    \     sAttrName = DimNm( sAttrDim, nAttr );\n        sAttCheck = SubSt( DTYPE( sAttrDim, sAttrName\
    \ ), 1, 1 );\n        IF (sAttCheck @= 'A');\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName\
    \ ), 2, 1 );\n        Else;\n        sAttrType = sAttcheck;\n        sMessage = pSrcDim | ' dimension\
    \ contains invalid attribute - ' | sAttrName ;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        If( pStrictErrorHandling = 1 );\n          ItemReject(Expand( cMsgErrorContent ));\n\
    \        EndIf;  \n        EndIf;\n        If( CellIsUpdateable( sAttrTargetDim, vEle, sAttrName )\
    \ = 1 );\n            If( sAttrType @= 'S' % sAttrType @= 'A' );\n                #sAttrVal = AttrS(\
    \ pSrcDim, vEle, sAttrName );\n                sAttrVal = CellgetS('}ElementAttributes_'| pSrcDim,\
    \ vEle, sAttrName);\n                If( sAttrVal @<> '' );\n                    If( sAttrType @=\
    \ 'A' );\n                        AttrPutS( sAttrVal, pTgtDim, vEle, sAttrName, 1 );\n           \
    \         Else;\n                        AttrPutS( sAttrVal, pTgtDim, vEle, sAttrName );\n       \
    \             EndIf;\n                EndIf;\n            Else;\n                #nAttrVal = AttrN(\
    \ pSrcDim, vEle, sAttrName );\n                nAttrVal = CellgetN('}ElementAttributes_'| pSrcDim,\
    \ vEle, sAttrName);\n                If( nAttrVal <> 0 );\n                    AttrPutN( nAttrVal,\
    \ pTgtDim, vEle, sAttrName );\n                EndIf;\n            EndIf;\n        EndIf;\n      \
    \  # check for localized attributes\n        If( CubeExists( sAttrLoc ) = 1 );\n            nLang\
    \ = 1;\n            While( nLang <= nNumLang );\n                sLang       = DimNm( cLangDim, nLang\
    \ );\n                If( sAttrType @= 'A' % sAttrType @= 'S' );\n                    sAttrVal   \
    \ = AttrS( pSrcDim, vEle, sAttrName );\n                    sAttrValLoc = AttrSL( pSrcDim, vEle, sAttrName,\
    \ sLang );\n                    If( sAttrValLoc @= sAttrVal ); sAttrValLoc = ''; EndIf;\n        \
    \        Else;\n                    nAttrVal    = AttrN( pSrcDim, vEle, sAttrName );\n           \
    \         nAttrValLoc = AttrNL( pSrcDim, vEle, sAttrName, sLang );\n                EndIf;\n     \
    \           If( CubeExists( sAttrLocTarget ) = 0 );\n                    If( sAttrType @= 'A' );\n\
    \                        AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName, sLang, 1 );\n          \
    \          ElseIf( sAttrType @= 'N' );\n                        If( nAttrValLoc <> nAttrVal );\n \
    \                           AttrPutN( nAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\n          \
    \              EndIf;\n                    Else;\n                        AttrPutS( sAttrValLoc, pTgtDim,\
    \ vEle, sAttrName, sLang );\n                    EndIf;\n                ElseIf( CubeExists( sAttrLocTarget\
    \ ) = 1 );\n                    If( CellIsUpdateable( sAttrLocTarget, vEle, sLang, sAttrName ) = 1\
    \ );\n                        If( sAttrType @= 'A' );\n                            AttrPutS( sAttrValLoc,\
    \ pTgtDim, vEle, sAttrName, sLang, 1 );\n                        ElseIf( sAttrType @= 'N' );\n   \
    \                         If( nAttrValLoc <> nAttrVal );\n                                AttrPutN(\
    \ nAttrValLoc, pTgtDim, vEle, sAttrName, sLang );\n                            EndIf;\n          \
    \              Else;\n                            AttrPutS( sAttrValLoc, pTgtDim, vEle, sAttrName,\
    \ sLang );\n                        EndIf;\n                    EndIf;\n                EndIf;\n \
    \               nLang   = nLang + 1;\n            End;\n        EndIf;\n        nAttr = nAttr + 1;\n\
    \    End;\n\nEndIf;\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#################################################################################################\
    \ \n##~~Join the bedrock TM1 community on GitHub https://github.com/cubewise-code/bedrock Ver 4.0.0~~##\n\
    #################################################################################################\
    \ \n\n\n### Set the target Sort Order ###\n  CELLPUTS( sSortElementsType, '}DimensionProperties',\
    \ pTgtDim, 'SORTELEMENTSTYPE');\n  CELLPUTS( sSortElementsSense, '}DimensionProperties', pTgtDim,\
    \ 'SORTELEMENTSSENSE');\n  CELLPUTS( sSortComponentsType, '}DimensionProperties', pTgtDim, 'SORTCOMPONENTSTYPE');\n\
    \  CELLPUTS( sSortComponentsSense, '}DimensionProperties', pTgtDim, 'SORTCOMPONENTSSENSE');\n\n###\
    \ Destroy Source Subset ###\n\n  If( SubsetExists( pSrcDim, cSubset ) = 1 );\n    SubsetDestroy( pSrcDim,\
    \ cSubset );\n  EndIf;\n\n##Clone all the Hierarchies except default hierarchy & Leaves\nIf( pHier\
    \ @= '*' );\n    sDim = pSrcDim;\n    sHierDim = '}Hierarchies_' | sDim;\n    sTargetHierarchy = '';\n\
    \    nMax = DimSiz( sHierDim );\n    nCtr = 1;\n    While( nCtr <= nMax );\n        sEle = DimNm(\
    \ sHierDim, nCtr );\n        nElength = Long(sEle);\n        nElestart  = 0;\n        nElestart =\
    \ SCAN(':', sEle) + 1;\n        If(nElestart > 1);\n          vSourceHierarchy = SUBST(sEle,nElestart,nElength);\n\
    \         If ( vSourceHierarchy @<> 'Leaves');\n             nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n\
    \               'pLogOutput', pLogOutput,\n               'pStrictErrorHandling', pStrictErrorHandling,\n\
    \               'pSrcDim', sDim,\n               'pSrcHier', vSourceHierarchy,\n               'pTgtDim',\
    \ pTgtDim,\n               'pTgtHier', vSourceHierarchy,\n               'pAttr', pAttr,\n       \
    \        'pUnwind',pUnwind\n               );\n         Endif;\n         sTargetHierarchy = sTargetHierarchy\
    \ |':'|vSourceHierarchy;\n        Endif;\n        nCtr = nCtr + 1;\n    End;\n### Just one hierarchy\
    \ specified in parameter\nElseIf( Scan( '*', pHier )=0 &  Scan( '?', pHier )=0 & Scan( pDelim, pHier\
    \ )=0 & Trim( pHier ) @<> '' );\n    sDim = pSrcDim;\n    sHierDim = '}Hierarchies_' | sDim;\n   \
    \ sCurrHier = pHier;\n    sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier)\
    \ );\n    # Validate hierarchy name in sHierDim\n    If( Dimix( sHierDim , sDim |':'| sCurrHier )\
    \ = 0 );\n        sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n\
    \        LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n    ElseIf( sCurrHierName @= 'Leaves' );\n\
    \        sMessage = 'Invalid  Hierarchy: ' | sCurrHier | ' will be skipped....';\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ElseIf( sCurrHierName @<> sDim );\n      If(\
    \ pLogOutput = 1 );\n        sMessage = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%'\
    \ being processed....' );\n        LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n      EndIf;\n\
    \      nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n       'pLogOutput', pLogOutput,\n       'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n       'pSrcDim', sDim,\n       'pSrcHier', sCurrHierName,\n       'pTgtDim',\
    \ pTgtDim,\n       'pTgtHier', sCurrHierName,\n       'pAttr', pAttr,\n       'pUnwind',pUnwind\n\
    \      );\n    Endif;\n### Hierachy is a delimited list with no wildcards\nElseIf( Scan( '*', pHier\
    \ )=0 &  Scan( '?', pHier )=0 & Trim( pHier ) @<> '' );\n  \n      # Loop through hierarchies in pHier\n\
    \    sDim = pSrcDim;\n    sHierarchies              = pHier;\n    nDelimiterIndexA    = 1;\n    sHierDim\
    \            = '}Hierarchies_'| sDim ;\n    sMdxHier = '';\n    While( nDelimiterIndexA <> 0 );\n\
    \  \n        nDelimiterIndexA = Scan( pDelim, sHierarchies );\n        If( nDelimiterIndexA = 0 );\n\
    \            sHierarchy   = sHierarchies;\n        Else;\n            sHierarchy   = Trim( SubSt(\
    \ sHierarchies, 1, nDelimiterIndexA - 1 ) );\n            sHierarchies  = Trim( Subst( sHierarchies,\
    \ nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n        EndIf;\n        sCurrHier =\
    \ sHierarchy;\n        sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n\
    \        # Validate hierarchy name in sHierDim\n        If( Dimix( sHierDim , sDim |':'| sCurrHier\
    \ ) = 0 );\n            sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%'\
    \ dimension.');\n            LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n        ElseIf( sCurrHierName\
    \ @= 'Leaves' );\n            sMessage = 'Invalid  Hierarchy: ' | sCurrHier | ' will be skipped....';\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ElseIf( sCurrHierName\
    \ @<> sDim );\n          If( pLogOutput = 1 );\n            sMessage = Expand( 'Hierarchy '%sCurrHierName%'\
    \ in Dimension '%sDim%' being processed....' );\n            LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n          EndIf;\n          nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n           'pLogOutput',\
    \ pLogOutput,\n           'pStrictErrorHandling', pStrictErrorHandling,\n           'pSrcDim', sDim,\n\
    \           'pSrcHier', sCurrHierName,\n           'pTgtDim', pTgtDim,\n           'pTgtHier', sCurrHierName,\n\
    \           'pAttr', pAttr,\n           'pUnwind',pUnwind\n          );\n        Endif;\n    End;\n\
    \n### Hierachy has wildcards inside\nElseIf( Trim( pHier ) @<> '' );\n  \n      # Loop through hierarchies\
    \ in pHier\n    sDim = pSrcDim;\n    sHierarchies              = pHier;\n    nDelimiterIndexA    =\
    \ 1;\n    sHierDim            = '}Hierarchies_'| sDim ;\n    sMdxHier = '';\n    While( nDelimiterIndexA\
    \ <> 0 );\n  \n        nDelimiterIndexA = Scan( pDelim, sHierarchies );\n        If( nDelimiterIndexA\
    \ = 0 );\n            sHierarchy   = sHierarchies;\n        Else;\n            sHierarchy   = Trim(\
    \ SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n            sHierarchies  = Trim( Subst( sHierarchies,\
    \ nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n        EndIf;\n  \n        # Create\
    \ subset of Hierarchies using Wildcard\n        sHierExp = '''| sDim | ':' | sHierarchy|''';\n   \
    \     sMdxHierPart = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp | ')}';\n\
    \        IF( sMdxHier @= ''); \n          sMdxHier = sMdxHierPart; \n        ELSE;\n          sMdxHier\
    \ = sMdxHier | ' + ' | sMdxHierPart;\n        ENDIF;\n    End;\n  \n    If( SubsetExists( sHierDim,\
    \ cSubset ) = 1 );\n        # If a delimited list of attr names includes wildcards then we may have\
    \ to re-use the subset multiple times\n        SubsetMDXSet( sHierDim, cSubset, sMdxHier );\n    Else;\n\
    \        # temp subset, therefore no need to destroy in epilog\n        SubsetCreatebyMDX( cSubset,\
    \ sMdxHier, sHierDim, 1 );\n    EndIf;\n  \n    # Loop through subset of hierarchies created based\
    \ on wildcard\n    nCountHier = SubsetGetSize( sHierDim, cSubset  );\n    While( nCountHier >= 1 );\n\
    \        sCurrHier = SubsetGetElementName( sHierDim, cSubset , nCountHier );\n        sCurrHierName\
    \ = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n        # Validate hierarchy name\
    \ in sHierDim\n        If( Dimix( sHierDim , sCurrHier ) = 0 );\n            sMessage = Expand('The\
    \ '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n            LogOutput( 'INFO'\
    \ , Expand( cMsgInfoContent ) );\n        ElseIf( sCurrHierName @= 'Leaves' );\n            sMessage\
    \ = 'Invalid  Hierarchy: ' | sCurrHier | ' will be skipped....';\n            LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        ElseIf( sCurrHierName @<> sDim );\n          If( pLogOutput\
    \ = 1 );\n            sMessage = Expand( 'Hierarchy '%sCurrHierName%' in Dimension '%sDim%' being\
    \ processed....' );\n            LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n          EndIf;\n\
    \          nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n           'pLogOutput', pLogOutput,\n  \
    \         'pStrictErrorHandling', pStrictErrorHandling,\n           'pSrcDim', sDim,\n           'pSrcHier',\
    \ sCurrHierName,\n           'pTgtDim', pTgtDim,\n           'pTgtHier', sCurrHierName,\n        \
    \   'pAttr', pAttr,\n           'pUnwind',pUnwind\n          );\n        Endif;\n      \n        nCountHier\
    \ = nCountHier - 1;\n    End;\nEndif;\n\n### Clone dimension subsets\nIf( pSub = 1);\n  nCountSubs\
    \ = DimSiz ('}Subsets_' | sDim);\n  While ( nCountSubs >= 1 );\n    sCurrSub = If( Scan( ':', DimNm\
    \ ('}Subsets_' | sDim, nCountSubs)) = 0, DimNm ('}Subsets_' | sDim, nCountSubs), Subst( DimNm ('}Subsets_'\
    \ | sDim, nCountSubs), Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))+1, Long(DimNm ('}Subsets_'\
    \ | sDim, nCountSubs))-Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))));\n    sCurrHier = If(\
    \ Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs)) = 0, '', Subst(DimNm ('}Subsets_' | sDim, nCountSubs),\
    \ 1, Scan( ':', DimNm ('}Subsets_' | sDim, nCountSubs))-1));\n\n    ExecuteProcess('}bedrock.hier.sub.clone',\n\
    \      'pLogOutput',0,\n      'pStrictErrorHandling',0,\n      'pSrcDim',sDim,\n      'pSrcHier',sCurrHier,\n\
    \      'pSrcSub',sCurrSub,\n      'pTgtDim', pTgtDim,\n      'pTgtHier', sCurrHier,\n      'pTgtSub',sCurrSub,\n\
    \      'pTemp',0,\n      'pAlias','');\n    nCountSubs = nCountSubs - 1;\n  End;\nEndif;\n       \
    \   \n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% has cloned the %pSrcDim% dimension into %pTgtDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine Dimension oder eine Liste von Dimensionen
    basierend auf einem übereinstimmenden Wildcard-Namen löscht. Dieser Prozess ist für die Entwicklung
    oder Prototypenerstellung gedacht, insbesondere während der agilen Entwicklung, um Dimensionen aufgrund
    von Umbenennungen oder geänderten Anforderungen zu entfernen. Er kann auch verwendet werden, um ungenutzte
    Dimensionen vor dem Systemstart zu bereinigen. Beachte, dass ein gültiger Dimensionsname pDim oder
    eine Liste davon zwingend erforderlich ist, andernfalls wird der Prozess abgebrochen. Attributedimensionen
    sind ausgeschlossen, da diese automatisch durch das Entfernen der Basisdimension bereinigt werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a dimension, list of dimensions, or set of\
    \ dimensions specified by wildcard name match.\n\n# Use case: Intended for development/prototyping.\n\
    # 1. During active agile development to remove dimensions due to renaming, change of requirements,\
    \ etc.\n# 2. Clean up unused dimensions prior to system Go Live.\n\n# Note:\n# * A valid dimension\
    \ name pDim or list thereof is mandatory otherwise the process will abort.\n# * Attribute dimensions\
    \ are deliberately excluded because these are automatically cleaned up by removing the base dimension.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName    \
    \     = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pDelim:%pDelim%.'; \n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \n\
    ENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n\
    \  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndIf;\n\n## Default delimiter\nIf( pDelim     @= '' );\n    pDelim     = '&';\nEndIf;\n\n###\
    \ Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Dimension delete\n# Loop\
    \ through dimensions in pDim \nsDims               = Trim( pDim );\nnDimDelimiterIndex  = 1;\n# Get\
    \ 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex\
    \ = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex = 0 );\n        sDim        = sDims;\n    Else;\n\
    \        sDim        = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims       = Trim(\
    \ Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n    # Check\
    \ if sDim has wildcard\n    If( Scan( '*', sDim ) = 0);\n        # check if dim is used in a cube\n\
    \        sDimIsUsed ='';\n        nDimIsUsed = 0;\n        nCubes = DimSiz( '}Cubes' );\n        nCube\
    \ = 1;\n        While(nCube <= nCubes);\n            sCube = DimNm( '}Cubes' , nCube );\n        \
    \    nDim = 1;\n            While(TabDim(sCube,nDim)@<>'' & Subst( sCube , 1 , 1) @<>'}' );\n    \
    \            sDimInCube = TABDIM(sCube,nDim);\n                If(sDimInCube@=sDim);\n           \
    \         sDimIsUsed = sDimIsUsed | sCube | ' ';\n                    nDimIsUsed = nDimIsUsed+1;\n\
    \                EndIf;\n                nDim = nDim + 1;\n            End;\n            nCube = nCube\
    \ + 1;\n        End;     \n        \n        # Delete if it exists and is not being used in a cube\n\
    \        If( DimensionExists(sDim) = 0 );\n            nErrors = 1;\n            sMessage = Expand(\
    \ 'Dimension '%sDim%' does not exist.' );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n        ElseIF( sDimIsUsed@='');\n            DimensionDestroy( sDim );\n        Else;\n \
    \           nErrors = 1;\n            sMessage = 'The dimension ' | sDim | ' could not be destroyed\
    \ as it is being used for ' | NumberToString(nDimIsUsed)  | ' cube(s) :' | sDimIsUsed;\n         \
    \   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        Endif;\n    Else;\n        #\
    \ Create subset of dimensions using Wildcard to loop through dimensions in pDim with wildcard\n  \
    \      sDimExp = '''|sDim|''';\n        sMdx = '{TM1FILTERBYPATTERN( EXCEPT ( EXCEPT ( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ), TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '}ElementAttributes_*') ) ,'| sDimExp | ')}';\n        If( SubsetExists(\
    \ '}Dimensions' , cTempSub ) = 1 );\n            # If a delimited list of dim names includes wildcards\
    \ then we may have to re-use the subset multiple times\n            SubsetMDXSet( '}Dimensions' ,\
    \ cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\n        EndIf;\n        \n \
    \       # Loop through dimensions in subset created based on wildcard\n        nCountDim = SubsetGetSize(\
    \ '}Dimensions' , cTempSub );\n        While( nCountDim >= 1 );\n            sDim = SubsetGetElementName(\
    \ '}Dimensions' , cTempSub, nCountDim );\n            # check if dim is used in a cube\n         \
    \   sDimIsUsed ='';\n            nDimIsUsed = 0;\n            nCubes = DimSiz( '}Cubes' );\n     \
    \       nCube = 1;\n            While(nCube <= nCubes);\n                sCube = DimNm( '}Cubes' ,\
    \ nCube );\n                nDim = 1;\n                While(TabDim(sCube,nDim)@<>'' & Subst( sCube\
    \ , 1 , 1) @<>'}' );\n                    sDimInCube = TABDIM(sCube,nDim);\n                    If(sDimInCube@=sDim);\n\
    \                        sDimIsUsed = sDimIsUsed | sCube | ' ';\n                        nDimIsUsed\
    \ = nDimIsUsed+1;\n                    EndIf;\n                    nDim = nDim + 1;\n            \
    \    End;\n                nCube = nCube + 1;\n            End;  \n            # Delete if it exists\
    \ and is not being used in a cube\n            If( DimensionExists(sDim) = 0 );\n                nErrors\
    \ = 1;\n                sMessage = Expand( 'Dimension %sDim% does not exist.' );\n               \
    \ LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n            ElseIF( sDimIsUsed@='');\n      \
    \          DimensionDestroy( sDim );\n            Else;\n                nErrors = 1;\n          \
    \      sMessage = 'The dimension ' | sDim | ' could not be destroyed as it is being used for ' | NumberToString(nDimIsUsed)\
    \  | ' cube(s) :' | sDimIsUsed;\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            Endif;\n            IF( SubsetGetSize( '}Dimensions' , cTempSub ) < nCountDim\
    \ - 1 );\n              nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n            ELSE;\n\
    \            nCountDim = nCountDim - 1;\n            ENDIF;\n        End;\n    EndIf;\n   \nEnd;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted dimensions %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Develop an IBM Turbo Integrator process that deletes a dimension or a list of dimensions based
    on a matching wildcard name. This process is intended for development or prototyping, especially during
    active agile development to remove dimensions due to renaming or changing requirements. It can also
    be used to clean up unused dimensions prior to system go-live. Note that a valid dimension name pDim
    or a list thereof is mandatory, otherwise, the process will abort. Attribute dimensions are deliberately
    excluded as they are automatically cleaned up by removing the base dimension.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a dimension, list of dimensions, or set of\
    \ dimensions specified by wildcard name match.\n\n# Use case: Intended for development/prototyping.\n\
    # 1. During active agile development to remove dimensions due to renaming, change of requirements,\
    \ etc.\n# 2. Clean up unused dimensions prior to system Go Live.\n\n# Note:\n# * A valid dimension\
    \ name pDim or list thereof is mandatory otherwise the process will abort.\n# * Attribute dimensions\
    \ are deliberately excluded because these are automatically cleaned up by removing the base dimension.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName    \
    \     = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pDelim:%pDelim%.'; \n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \n\
    ENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n\
    \  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndIf;\n\n## Default delimiter\nIf( pDelim     @= '' );\n    pDelim     = '&';\nEndIf;\n\n###\
    \ Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Dimension delete\n# Loop\
    \ through dimensions in pDim \nsDims               = Trim( pDim );\nnDimDelimiterIndex  = 1;\n# Get\
    \ 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex\
    \ = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex = 0 );\n        sDim        = sDims;\n    Else;\n\
    \        sDim        = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims       = Trim(\
    \ Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n    # Check\
    \ if sDim has wildcard\n    If( Scan( '*', sDim ) = 0);\n        # check if dim is used in a cube\n\
    \        sDimIsUsed ='';\n        nDimIsUsed = 0;\n        nCubes = DimSiz( '}Cubes' );\n        nCube\
    \ = 1;\n        While(nCube <= nCubes);\n            sCube = DimNm( '}Cubes' , nCube );\n        \
    \    nDim = 1;\n            While(TabDim(sCube,nDim)@<>'' & Subst( sCube , 1 , 1) @<>'}' );\n    \
    \            sDimInCube = TABDIM(sCube,nDim);\n                If(sDimInCube@=sDim);\n           \
    \         sDimIsUsed = sDimIsUsed | sCube | ' ';\n                    nDimIsUsed = nDimIsUsed+1;\n\
    \                EndIf;\n                nDim = nDim + 1;\n            End;\n            nCube = nCube\
    \ + 1;\n        End;     \n        \n        # Delete if it exists and is not being used in a cube\n\
    \        If( DimensionExists(sDim) = 0 );\n            nErrors = 1;\n            sMessage = Expand(\
    \ 'Dimension '%sDim%' does not exist.' );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n        ElseIF( sDimIsUsed@='');\n            DimensionDestroy( sDim );\n        Else;\n \
    \           nErrors = 1;\n            sMessage = 'The dimension ' | sDim | ' could not be destroyed\
    \ as it is being used for ' | NumberToString(nDimIsUsed)  | ' cube(s) :' | sDimIsUsed;\n         \
    \   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        Endif;\n    Else;\n        #\
    \ Create subset of dimensions using Wildcard to loop through dimensions in pDim with wildcard\n  \
    \      sDimExp = '''|sDim|''';\n        sMdx = '{TM1FILTERBYPATTERN( EXCEPT ( EXCEPT ( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ), TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '}ElementAttributes_*') ) ,'| sDimExp | ')}';\n        If( SubsetExists(\
    \ '}Dimensions' , cTempSub ) = 1 );\n            # If a delimited list of dim names includes wildcards\
    \ then we may have to re-use the subset multiple times\n            SubsetMDXSet( '}Dimensions' ,\
    \ cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\n        EndIf;\n        \n \
    \       # Loop through dimensions in subset created based on wildcard\n        nCountDim = SubsetGetSize(\
    \ '}Dimensions' , cTempSub );\n        While( nCountDim >= 1 );\n            sDim = SubsetGetElementName(\
    \ '}Dimensions' , cTempSub, nCountDim );\n            # check if dim is used in a cube\n         \
    \   sDimIsUsed ='';\n            nDimIsUsed = 0;\n            nCubes = DimSiz( '}Cubes' );\n     \
    \       nCube = 1;\n            While(nCube <= nCubes);\n                sCube = DimNm( '}Cubes' ,\
    \ nCube );\n                nDim = 1;\n                While(TabDim(sCube,nDim)@<>'' & Subst( sCube\
    \ , 1 , 1) @<>'}' );\n                    sDimInCube = TABDIM(sCube,nDim);\n                    If(sDimInCube@=sDim);\n\
    \                        sDimIsUsed = sDimIsUsed | sCube | ' ';\n                        nDimIsUsed\
    \ = nDimIsUsed+1;\n                    EndIf;\n                    nDim = nDim + 1;\n            \
    \    End;\n                nCube = nCube + 1;\n            End;  \n            # Delete if it exists\
    \ and is not being used in a cube\n            If( DimensionExists(sDim) = 0 );\n                nErrors\
    \ = 1;\n                sMessage = Expand( 'Dimension %sDim% does not exist.' );\n               \
    \ LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n            ElseIF( sDimIsUsed@='');\n      \
    \          DimensionDestroy( sDim );\n            Else;\n                nErrors = 1;\n          \
    \      sMessage = 'The dimension ' | sDim | ' could not be destroyed as it is being used for ' | NumberToString(nDimIsUsed)\
    \  | ' cube(s) :' | sDimIsUsed;\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n            Endif;\n            IF( SubsetGetSize( '}Dimensions' , cTempSub ) < nCountDim\
    \ - 1 );\n              nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n            ELSE;\n\
    \            nCountDim = nCountDim - 1;\n            ENDIF;\n        End;\n    EndIf;\n   \nEnd;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted dimensions %pDim%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Erstellen Sie einen IBM Turbo Integrator Prozess, der Dimensionen löscht, wobei eine Dimension,
    eine Liste von Dimensionen oder ein Satz von Dimensionen durch Übereinstimmung mit einem Platzhalter-namen
    angegeben wird. Dieser Prozess ist für die Entwicklung oder das Prototyping gedacht. Verwenden Sie
    ihn während der aktiven agilen Entwicklung, um Dimensionen aufgrund von Umbenennungen, geänderten
    Anforderungen usw. zu entfernen oder um unbenutzte Dimensionen vor dem System-Go-Live zu bereinigen.
    Beachten Sie, dass ein gültiger Dimensionsname pDim oder eine Liste davon obligatorisch ist, ansonsten
    wird der Prozess abgebrochen. Attributdimensionen sind bewusst ausgeschlossen, da diese automatisch
    entfernt werden, wenn die Basisdimension gelöscht wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will clone the source dimension Hierarchy.\n\n# Use\
    \ case: Mostly in Development.\n# 1/ Create a duplicate of an existing hierarchy for testing.\n\n\
    # Note:\n# Valid source dimension name (pSrcDim) and target dimension (pTgtDim) names are mandatory\
    \ otherwise the process will abort.\n# Valid source hierarchy name (pSrcHier) is mandatory otherwise\
    \ the process will abort.\n\n# Caution:\n# - Target hierarchy cannot be `Leaves`.\n# - If the target\
    \ dimension Hierarchy exists then it will be overwritten.\n#EndRegion @DOC\n\n### Global Varaibales\
    \ ###\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%,\
    \ pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%.';\ncLangDim          =\
    \ '}Cultures';\nnNumLang          = DimSiz( cLangDim );\n\nnProcessSameNamedHier = 0;\nsEpilogTgtHier\
    \ = '';\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier\
    \ @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long(\
    \ pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\nEndIf;\n\n##\
    \ Validate Source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No source\
    \ dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    IF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid source dimension:\
    \ ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ Source hierarchy\nIF( Trim( pSrcHier ) @= '' );\n    pSrcHier = pSrcDim;\nElseIF(HierarchyExists(pSrcDim,pSrcHier\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Target dimension\nIF( Trim(\
    \ pTgtDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No target dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= ''\
    \ );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long(\
    \ pTgtDim ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\nIf\
    \ ( DimensionExists( pTgtDim ) = 0 );\n  DimensionCreate( pTgtDim );\n  ### In this case clone source\
    \ hierarchy into same-named hierarchy of the new target dimension first. This will allow attributes\
    \ to be processed in the data tab.\n  nProcessSameNamedHier = 1;\nEndIf;\n\n# Validate target hierarchy\n\
    If( pSrcDim @= pTgtDim);\n    If( pTgtHier @= '' % pTgtHier @= pSrcHier );\n        pTgtHier = pSrcHier\
    \ | '_Clone';\n    EndIf;\nElseIf(pTgtHier @= '');\n    If( nProcessSameNamedHier = 1 );\n      sEpilogTgtHier\
    \ = pTgtHier;\n      pTgtHier = pTgtDim;\n    Else;\n      pTgtHier = pSrcHier;\n    EndIf;\nElseIf(\
    \ nProcessSameNamedHier = 1 );\n    sEpilogTgtHier = pTgtHier;\n    pTgtHier = pTgtDim;\nEndif;\n\n\
    pTgtHier = Trim(pTgtHier);\n\nIF(pTgtHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Leaves is\
    \ an invalid selection for Target Hierarchy: ' | pTgtDim |':'|pTgtHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( DimensionExists( pTgtDim ) = 0 );\n    If( pUnwind\
    \ >= 1 );\n        pUnwind = 2;\n    EndIf;\nElseIf( HierarchyExists( pTgtDim, pTgtHier ) = 0 );\n\
    \    If( pUnwind >= 1 );\n        pUnwind = 2;\n    EndIf;\nEndIf;    \n\n### Check for errors before\
    \ continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create target dimension Hierarchy ###\nIf( HierarchyExists(\
    \ pTgtDim, pTgtHier) = 0 );\n    HierarchyCreate( pTgtDim, pTgtHier );\nElse;\n    IF(pUnwind = 1\
    \ );\n      nRet = ExecuteProcess('}bedrock.hier.unwind',\n        'pLogOutput', pLogOutput,\n   \
    \     'pStrictErrorHandling', pStrictErrorHandling,\n        'pDim', pTgtDim,\n        'pHier', pTgtHier,\n\
    \        'pConsol', '*',\n        'pRecursive', 1\n        );\n    ELSEIF(pUnwind = 2 );\n      #Do\
    \ nothing\n    ELSEIF(pUnwind = 0 );\n      HierarchyDeleteAllElements( pTgtDim, pTgtHier );\n   \
    \ EndIf;\nEndIf;\n  \nIf(pSrcDim @=pSrcHier);\n   sDimHier = pSrcDim;\n Else;\n   sDimHier =pSrcDim|':'|pSrcHier;\n\
    \ Endif;\n  \n### Set the target Sort Order ###\nsSortElementsType     = CELLGETS( '}DimensionProperties',\
    \ sDimHier, 'SORTELEMENTSTYPE');\nsSortElementsSense    = CELLGETS( '}DimensionProperties', sDimHier,\
    \ 'SORTELEMENTSSENSE');\nsSortComponentsType   = CELLGETS( '}DimensionProperties', sDimHier, 'SORTCOMPONENTSTYPE');\n\
    sSortComponentsSense  = CELLGETS( '}DimensionProperties', sDimHier, 'SORTCOMPONENTSSENSE');\n\nHierarchySortOrder(pTgtDim,\
    \ pTgtHier, sSortComponentsType, sSortComponentsSense, sSortElementsType , sSortElementsSense);\n\n\
    nSourceHierSize = DimSiz(pSrcDim|':'|pSrcHier);\n\nnIndex = 1;\nWHILE( nIndex <= nSourceHierSize );\n\
    \  sElName = ElementName(pSrcDim, pSrcHier, nIndex);\n  sElType = ElementType(pSrcDim, pSrcHier, sElName);\n\
    \  HierarchyElementInsert(pTgtDim, pTgtHier, '', sElName, sElType);\n  nIndex = nIndex + 1;\nEND;\n\
    \n### Assign Data Source ###\n\nDatasourceNameForServer     = pSrcDim|':'|pSrcHier;\nDataSourceType\
    \              = 'SUBSET';\nDatasourceDimensionSubset   = 'ALL';\n\n### Replicate Attributes ###\n\
    \n# Note: DType on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\nsAttrDim \
    \       = '}ElementAttributes_' | pSrcDim;\nsAttrLoc        = '}LocalizedElementAttributes_' | pSrcDim;\n\
    sAttrTragetDim  = '}ElementAttributes_' | pTgtDim;\nsAttrLocTarget  = '}LocalizedElementAttributes_'\
    \ | pTgtDim;\n\nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n  nNumAttrs = DimSiz( sAttrDim\
    \ );\n  nCount = 1;\n  While( nCount <= nNumAttrs );\n    sAttrName = DimNm( sAttrDim, nCount );\n\
    \    sAttrType = SubSt(DType( sAttrDim, sAttrName ), 2, 1 );\n      If ( DimensionExists( sAttrTragetDim\
    \ ) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n       ElseIF(DimIx(sAttrTragetDim,\
    \ sAttrName) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n      Endif;\n    nCount\
    \ = nCount + 1;\n  End;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Check for errors in prolog ###\n\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Add Elements to target dimension ###\n\nsElType = ElementType(pSrcDim, pSrcHier,\
    \ vEle);\n\nIF( sElType @= 'C' & ElementComponentCount( pSrcDim, pSrcHier, vEle  ) > 0 );\n    nChildren\
    \ = ElementComponentCount( pSrcDim, pSrcHier, vEle );\n    nCount = 1;\n    While( nCount <= nChildren\
    \ );\n        sChildElement = ElementComponent( pSrcDim, pSrcHier, vEle, nCount );\n        sChildWeight\
    \ = ElementWeight( pSrcDim,pSrcHier, vEle, sChildElement );\n        HierarchyElementComponentAdd(pTgtDim,\
    \ pTgtHier, vEle, sChildElement, sChildWeight);\n        nCount = nCount + 1;\n    End;\nEndIf;\n\n\
    ### End MetaData ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Replicate Attributes ###\n\
    # Note: DTYPE on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\nIf( pAttr =\
    \ 1 & DimensionExists( sAttrDim ) = 1 );\n\n    nAttr = 1;\n    While( nAttr <= nNumAttrs );\n   \
    \     sAttrName = DimNm( sAttrDim, nAttr );\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName\
    \ ), 2, 1 );\n        \n        If( sAttrType @= 'S' % sAttrType @= 'A' );\n            sAttrVal =\
    \ ElementAttrS( pSrcDim, pSrcHier, vEle, sAttrName );\n            \n            If( sAttrVal @<>\
    \ '' );\n                If( CellIsUpdateable( '}ElementAttributes_' | pTgtDim, pTgtHier:vEle, sAttrName\
    \ ) = 1 );\n                    If( sAttrType @= 'A' );\n                        ElementAttrPutS(\
    \ sAttrVal, pTgtDim, pTgtHier, vEle, sAttrName, 1 );\n                    Else;\n                \
    \        ElementAttrPutS( sAttrVal, pTgtDim, pTgtHier, vEle, sAttrName );\n                    EndIf;\n\
    \                EndIf;\n            EndIf;\n        Else;\n            nAttrVal = ElementAttrN( pSrcDim,\
    \ pSrcHier, vEle, sAttrName );\n            If( nAttrVal <> 0 );\n                If( CellIsUpdateable(\
    \ '}ElementAttributes_' | pTgtDim, pTgtHier:vEle, sAttrName ) = 1 );\n                    ElementAttrPutN(\
    \ nAttrVal, pTgtDim, pTgtHier, vEle, sAttrName );\n                EndIf;\n            EndIf;  \n\
    \        EndIf;\n        # check for localized attributes\n        If( CubeExists( sAttrLoc ) = 1\
    \ );\n            nLang = 1;\n            While( nLang <= nNumLang );\n                sLang     \
    \  = DimNm( cLangDim, nLang );\n                If( sAttrType @= 'A' % sAttrType @= 'S' );\n     \
    \               sAttrVal    = ElementAttrS( pSrcDim, pSrcHier, vEle, sAttrName );\n              \
    \      sAttrValLoc = ElementAttrSL( pSrcDim, pSrcHier, vEle, sAttrName, sLang );\n               \
    \     If( sAttrValLoc @= sAttrVal ); sAttrValLoc = ''; EndIf;\n                Else;\n           \
    \         nAttrVal    = ElementAttrN( pSrcDim, pSrcHier, vEle, sAttrName );\n                    nAttrValLoc\
    \ = ElementAttrNL( pSrcDim, pSrcHier, vEle, sAttrName, sLang );\n                EndIf;\n        \
    \        If( CubeExists( sAttrLocTarget ) = 0 );\n                    If( sAttrType @= 'A' );\n  \
    \                      ElementAttrPutS( sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang, 1\
    \ );\n                    ElseIf( sAttrType @= 'N' );\n                        ElementAttrPutN( nAttrValLoc,\
    \ pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n                    Else;\n                      \
    \  ElementAttrPutS( sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n                  \
    \  EndIf;\n                ElseIf(CubeExists( sAttrLocTarget ) = 1 );\n                    If( CellIsUpdateable(\
    \ sAttrLocTarget, pTgtHier:vEle, sLang, sAttrName ) = 1 );\n                        If( sAttrType\
    \ @= 'A' );\n                            ElementAttrPutS( sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName,\
    \ sLang, 1 );\n                        ElseIf( sAttrType @= 'N' );\n                            ElementAttrPutN(\
    \ nAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n                        Else;\n     \
    \                       ElementAttrPutS( sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n\
    \                        EndIf;\n                    EndIf;\n                EndIf;\n            \
    \    nLang   = nLang + 1;\n            End;\n        EndIf;\n        nAttr = nAttr + 1;\n    End;\n\
    \nEndIf;\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\nIf(pTgtDim @=pTgtHier);\n    sTargetDimHier = pTgtDim;\nElse;\n    sTargetDimHier\
    \ =pTgtDim|':'|pTgtHier;\nEndIf;\n\n### Set the target Sort Order ###\n  CELLPUTS( sSortElementsType,\
    \ '}DimensionProperties', sTargetDimHier, 'SORTELEMENTSTYPE');\n  CELLPUTS( sSortElementsSense, '}DimensionProperties',\
    \ sTargetDimHier, 'SORTELEMENTSSENSE');\n  CELLPUTS( sSortComponentsType, '}DimensionProperties',sTargetDimHier,\
    \ 'SORTCOMPONENTSTYPE');\n  CELLPUTS( sSortComponentsSense, '}DimensionProperties', sTargetDimHier,\
    \ 'SORTCOMPONENTSSENSE');\n  \n### If a new dimension has been created, call the process recursively\
    \ to clone the alternate hierarchy, after the same named hierarchy has been processed\nIf( nProcessSameNamedHier\
    \ = 1 );\n  nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    'pSrcDim', pSrcDim,\n    'pSrcHier',pSrcHier,\n    'pTgtDim', pTgtDim,\n\
    \    'pTgtHier', sEpilogTgtHier,\n    'pAttr', pAttr,\n    'pUnwind', pUnwind\n    );\nEndIf;\n  \n\
    ### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully cloned the %pSrcDim%:%pSrcHier% dimension:hierarchy\
    \ to %pTgtDim%:%pTgtHier%' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Create an IBM Turbo Integrator process that deletes dimensions specified by a wildcard name
    match, including a single dimension, a list of dimensions, or a set of dimensions. This process is
    intended for development or prototyping. Use it during active agile development to remove dimensions
    due to renaming, change of requirements, etc., or to clean up unused dimensions prior to system Go-Live.
    Note that a valid dimension name pDim or list thereof is mandatory; otherwise, the process will abort.
    Attribute dimensions are deliberately excluded because they are automatically cleaned up by removing
    the base dimension.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will clone the source dimension Hierarchy.\n\n# Use\
    \ case: Mostly in Development.\n# 1/ Create a duplicate of an existing hierarchy for testing.\n\n\
    # Note:\n# Valid source dimension name (pSrcDim) and target dimension (pTgtDim) names are mandatory\
    \ otherwise the process will abort.\n# Valid source hierarchy name (pSrcHier) is mandatory otherwise\
    \ the process will abort.\n\n# Caution:\n# - Target hierarchy cannot be `Leaves`.\n# - If the target\
    \ dimension Hierarchy exists then it will be overwritten.\n#EndRegion @DOC\n\n### Global Varaibales\
    \ ###\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%, pSrcHier:%pSrcHier%,\
    \ pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%.';\ncLangDim          =\
    \ '}Cultures';\nnNumLang          = DimSiz( cLangDim );\n\nnProcessSameNamedHier = 0;\nsEpilogTgtHier\
    \ = '';\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier\
    \ @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long(\
    \ pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\nEndIf;\n\n##\
    \ Validate Source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No source\
    \ dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    IF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid source dimension:\
    \ ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ Source hierarchy\nIF( Trim( pSrcHier ) @= '' );\n    pSrcHier = pSrcDim;\nElseIF(HierarchyExists(pSrcDim,pSrcHier\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate Target dimension\nIF( Trim(\
    \ pTgtDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No target dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= ''\
    \ );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long(\
    \ pTgtDim ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\nIf\
    \ ( DimensionExists( pTgtDim ) = 0 );\n  DimensionCreate( pTgtDim );\n  ### In this case clone source\
    \ hierarchy into same-named hierarchy of the new target dimension first. This will allow attributes\
    \ to be processed in the data tab.\n  nProcessSameNamedHier = 1;\nEndIf;\n\n# Validate target hierarchy\n\
    If( pSrcDim @= pTgtDim);\n    If( pTgtHier @= '' % pTgtHier @= pSrcHier );\n        pTgtHier = pSrcHier\
    \ | '_Clone';\n    EndIf;\nElseIf(pTgtHier @= '');\n    If( nProcessSameNamedHier = 1 );\n      sEpilogTgtHier\
    \ = pTgtHier;\n      pTgtHier = pTgtDim;\n    Else;\n      pTgtHier = pSrcHier;\n    EndIf;\nElseIf(\
    \ nProcessSameNamedHier = 1 );\n    sEpilogTgtHier = pTgtHier;\n    pTgtHier = pTgtDim;\nEndif;\n\n\
    pTgtHier = Trim(pTgtHier);\n\nIF(pTgtHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Leaves is\
    \ an invalid selection for Target Hierarchy: ' | pTgtDim |':'|pTgtHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( DimensionExists( pTgtDim ) = 0 );\n    If( pUnwind\
    \ >= 1 );\n        pUnwind = 2;\n    EndIf;\nElseIf( HierarchyExists( pTgtDim, pTgtHier ) = 0 );\n\
    \    If( pUnwind >= 1 );\n        pUnwind = 2;\n    EndIf;\nEndIf;    \n\n### Check for errors before\
    \ continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create target dimension Hierarchy ###\nIf( HierarchyExists(\
    \ pTgtDim, pTgtHier) = 0 );\n    HierarchyCreate( pTgtDim, pTgtHier );\nElse;\n    IF(pUnwind = 1\
    \ );\n      nRet = ExecuteProcess('}bedrock.hier.unwind',\n        'pLogOutput', pLogOutput,\n   \
    \     'pStrictErrorHandling', pStrictErrorHandling,\n        'pDim', pTgtDim,\n        'pHier', pTgtHier,\n\
    \        'pConsol', '*',\n        'pRecursive', 1\n        );\n    ELSEIF(pUnwind = 2 );\n      #Do\
    \ nothing\n    ELSEIF(pUnwind = 0 );\n      HierarchyDeleteAllElements( pTgtDim, pTgtHier );\n   \
    \ EndIf;\nEndIf;\n  \nIf(pSrcDim @=pSrcHier);\n   sDimHier = pSrcDim;\n Else;\n   sDimHier =pSrcDim|':'|pSrcHier;\n\
    \ Endif;\n  \n### Set the target Sort Order ###\nsSortElementsType     = CELLGETS( '}DimensionProperties',\
    \ sDimHier, 'SORTELEMENTSTYPE');\nsSortElementsSense    = CELLGETS( '}DimensionProperties', sDimHier,\
    \ 'SORTELEMENTSSENSE');\nsSortComponentsType   = CELLGETS( '}DimensionProperties', sDimHier, 'SORTCOMPONENTSTYPE');\n\
    sSortComponentsSense  = CELLGETS( '}DimensionProperties', sDimHier, 'SORTCOMPONENTSSENSE');\n\nHierarchySortOrder(pTgtDim,\
    \ pTgtHier, sSortComponentsType, sSortComponentsSense, sSortElementsType , sSortElementsSense);\n\n\
    nSourceHierSize = DimSiz(pSrcDim|':'|pSrcHier);\n\nnIndex = 1;\nWHILE( nIndex <= nSourceHierSize );\n\
    \  sElName = ElementName(pSrcDim, pSrcHier, nIndex);\n  sElType = ElementType(pSrcDim, pSrcHier, sElName);\n\
    \  HierarchyElementInsert(pTgtDim, pTgtHier, '', sElName, sElType);\n  nIndex = nIndex + 1;\nEND;\n\
    \n### Assign Data Source ###\n\nDatasourceNameForServer     = pSrcDim|':'|pSrcHier;\nDataSourceType\
    \              = 'SUBSET';\nDatasourceDimensionSubset   = 'ALL';\n\n### Replicate Attributes ###\n\
    \n# Note: DType on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\nsAttrDim \
    \       = '}ElementAttributes_' | pSrcDim;\nsAttrLoc        = '}LocalizedElementAttributes_' | pSrcDim;\n\
    sAttrTragetDim  = '}ElementAttributes_' | pTgtDim;\nsAttrLocTarget  = '}LocalizedElementAttributes_'\
    \ | pTgtDim;\n\nIf( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n  nNumAttrs = DimSiz( sAttrDim\
    \ );\n  nCount = 1;\n  While( nCount <= nNumAttrs );\n    sAttrName = DimNm( sAttrDim, nCount );\n\
    \    sAttrType = SubSt(DType( sAttrDim, sAttrName ), 2, 1 );\n      If ( DimensionExists( sAttrTragetDim\
    \ ) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n       ElseIF(DimIx(sAttrTragetDim,\
    \ sAttrName) = 0);\n         AttrInsert(pTgtDim,'',sAttrName,sAttrType );\n      Endif;\n    nCount\
    \ = nCount + 1;\n  End;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Check for errors in prolog ###\n\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Add Elements to target dimension ###\n\nsElType = ElementType(pSrcDim, pSrcHier,\
    \ vEle);\n\nIF( sElType @= 'C' & ElementComponentCount( pSrcDim, pSrcHier, vEle  ) > 0 );\n    nChildren\
    \ = ElementComponentCount( pSrcDim, pSrcHier, vEle );\n    nCount = 1;\n    While( nCount <= nChildren\
    \ );\n        sChildElement = ElementComponent( pSrcDim, pSrcHier, vEle, nCount );\n        sChildWeight\
    \ = ElementWeight( pSrcDim,pSrcHier, vEle, sChildElement );\n        HierarchyElementComponentAdd(pTgtDim,\
    \ pTgtHier, vEle, sChildElement, sChildWeight);\n        nCount = nCount + 1;\n    End;\nEndIf;\n\n\
    ### End MetaData ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Replicate Attributes ###\n\
    # Note: DTYPE on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading 'A'\n\nIf( pAttr =\
    \ 1 & DimensionExists( sAttrDim ) = 1 );\n\n    nAttr = 1;\n    While( nAttr <= nNumAttrs );\n   \
    \     sAttrName = DimNm( sAttrDim, nAttr );\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName\
    \ ), 2, 1 );\n        \n        If( sAttrType @= 'S' % sAttrType @= 'A' );\n            sAttrVal =\
    \ ElementAttrS( pSrcDim, pSrcHier, vEle, sAttrName );\n            \n            If( sAttrVal @<>\
    \ '' );\n                If( CellIsUpdateable( '}ElementAttributes_' | pTgtDim, pTgtHier:vEle, sAttrName\
    \ ) = 1 );\n                    If( sAttrType @= 'A' );\n                        ElementAttrPutS(\
    \ sAttrVal, pTgtDim, pTgtHier, vEle, sAttrName, 1 );\n                    Else;\n                \
    \        ElementAttrPutS( sAttrVal, pTgtDim, pTgtHier, vEle, sAttrName );\n                    EndIf;\n\
    \                EndIf;\n            EndIf;\n        Else;\n            nAttrVal = ElementAttrN( pSrcDim,\
    \ pSrcHier, vEle, sAttrName );\n            If( nAttrVal <> 0 );\n                If( CellIsUpdateable(\
    \ '}ElementAttributes_' | pTgtDim, pTgtHier:vEle, sAttrName ) = 1 );\n                    ElementAttrPutN(\
    \ nAttrVal, pTgtDim, pTgtHier, vEle, sAttrName );\n                EndIf;\n            EndIf;  \n\
    \        EndIf;\n        # check for localized attributes\n        If( CubeExists( sAttrLoc ) = 1\
    \ );\n            nLang = 1;\n            While( nLang <= nNumLang );\n                sLang     \
    \  = DimNm( cLangDim, nLang );\n                If( sAttrType @= 'A' % sAttrType @= 'S' );\n     \
    \               sAttrVal    = ElementAttrS( pSrcDim, pSrcHier, vEle, sAttrName );\n              \
    \      sAttrValLoc = ElementAttrSL( pSrcDim, pSrcHier, vEle, sAttrName, sLang );\n               \
    \     If( sAttrValLoc @= sAttrVal ); sAttrValLoc = ''; EndIf;\n                Else;\n           \
    \         nAttrVal    = ElementAttrN( pSrcDim, pSrcHier, vEle, sAttrName );\n                    nAttrValLoc\
    \ = ElementAttrNL( pSrcDim, pSrcHier, vEle, sAttrName, sLang );\n                EndIf;\n        \
    \        If( CubeExists( sAttrLocTarget ) = 0 );\n                    If( sAttrType @= 'A' );\n  \
    \                      ElementAttrPutS( sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang, 1\
    \ );\n                    ElseIf( sAttrType @= 'N' );\n                        ElementAttrPutN( nAttrValLoc,\
    \ pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n                    Else;\n                      \
    \  ElementAttrPutS( sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n                  \
    \  EndIf;\n                ElseIf(CubeExists( sAttrLocTarget ) = 1 );\n                    If( CellIsUpdateable(\
    \ sAttrLocTarget, pTgtHier:vEle, sLang, sAttrName ) = 1 );\n                        If( sAttrType\
    \ @= 'A' );\n                            ElementAttrPutS( sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName,\
    \ sLang, 1 );\n                        ElseIf( sAttrType @= 'N' );\n                            ElementAttrPutN(\
    \ nAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n                        Else;\n     \
    \                       ElementAttrPutS( sAttrValLoc, pTgtDim, pTgtHier, vEle, sAttrName, sLang );\n\
    \                        EndIf;\n                    EndIf;\n                EndIf;\n            \
    \    nLang   = nLang + 1;\n            End;\n        EndIf;\n        nAttr = nAttr + 1;\n    End;\n\
    \nEndIf;\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\nIf(pTgtDim @=pTgtHier);\n    sTargetDimHier = pTgtDim;\nElse;\n    sTargetDimHier\
    \ =pTgtDim|':'|pTgtHier;\nEndIf;\n\n### Set the target Sort Order ###\n  CELLPUTS( sSortElementsType,\
    \ '}DimensionProperties', sTargetDimHier, 'SORTELEMENTSTYPE');\n  CELLPUTS( sSortElementsSense, '}DimensionProperties',\
    \ sTargetDimHier, 'SORTELEMENTSSENSE');\n  CELLPUTS( sSortComponentsType, '}DimensionProperties',sTargetDimHier,\
    \ 'SORTCOMPONENTSTYPE');\n  CELLPUTS( sSortComponentsSense, '}DimensionProperties', sTargetDimHier,\
    \ 'SORTCOMPONENTSSENSE');\n  \n### If a new dimension has been created, call the process recursively\
    \ to clone the alternate hierarchy, after the same named hierarchy has been processed\nIf( nProcessSameNamedHier\
    \ = 1 );\n  nRet = EXECUTEPROCESS('}bedrock.hier.clone',\n    'pLogOutput', pLogOutput,\n    'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n    'pSrcDim', pSrcDim,\n    'pSrcHier',pSrcHier,\n    'pTgtDim', pTgtDim,\n\
    \    'pTgtHier', sEpilogTgtHier,\n    'pAttr', pAttr,\n    'pUnwind', pUnwind\n    );\nEndIf;\n  \n\
    ### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully cloned the %pSrcDim%:%pSrcHier% dimension:hierarchy\
    \ to %pTgtDim%:%pTgtHier%' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der es ermöglicht, ein spezifiziertes C-Level
    Element oder ALLE Konsolidierungen in einer Dimensionshierarchie zu löschen. Dieser Prozess sollte
    sowohl während der Entwicklung als auch in der Produktion verwendbar sein. Der Nutzer muss sicherstellen,
    dass ein gültiger Dimensionsname (pDim) angegeben wird, andernfalls soll der Prozess abgebrochen werden.
    Kontrolldimensionen sind von dieser Operation ausgeschlossen. Wenn keine Hierarchie (pHier) angegeben
    wird, sollte standardmäßig pDim verwendet werden. Andernfalls muss pHier gültig sein, andernfalls
    bricht der Prozess ab. Alle konsolidierten Elemente in der Hierarchie sollen gelöscht werden, wenn
    das konsolidierte Element (pEle) als * angegeben ist, andernfalls sollte es gültige C-Level Elemente
    enthalten. Achtung: Die Zielhierarchie (pHier) darf nicht ''Leaves'' sein.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete a specified C-Level item **or** ALL consolidations\
    \ in the dimension hierarchy. \n\n# Use case: Could be used during development or in production.\n\
    # 1/ Delete a specific or all C-Level items in a hierarchy.\n\n# Note:\n# Valid dimension name (pDim)\
    \ is mandatory otherwise the process will abort. Control dimensions are excluded.\n# The hierarchy\
    \ (pHier) will default to pDim if not specified, otherwise it must be valid else the process will\
    \ abort.\n# **ALL** consoldidated items in hierarchy will be deleted if consolidated item (pEle) is\
    \ specified as \\*, otherwise it needs to contain valid c-level item(s). \n# Caution: Target hierarchy\
    \ (pHier) cannot be `Leaves`.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt   \
    \     = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%, pDelim:%pDelim%.';\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n###\
    \ Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n## Validate Dimension\nIf( Trim( pDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension: ' | pDim\
    \ | ' does not exist on server.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n## Validate Hierarchy\nIF(pHier @= 'Leaves' );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \  Hierarchy: ' | pDim |':'|pHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n## Validate Elements\nIF(pEle @= '' );\n    nErrors = 1;\n    sMessage = 'Element cannot\
    \ be empty. Use * for all elements';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n\nIf( Trim( pHier ) @= '' );\n    sHier = pDim;\nElse;\n    sHier = pHier;\nEndIf;\n\nIf(\
    \ HierarchyExists( pDim, sHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'The Hierarchy ' | sHier\
    \ | ' does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors > 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsEles = pEle;\nnDelimiterIndex\
    \ = 1;\nWhile( nDelimiterIndex <> 0 );\n    \n    nDelimiterIndex = Scan( pDelim, sEles );\n    If(\
    \ nDelimiterIndex = 0 );\n        sEle = sEles;\n    Else;\n        sEle = Trim( SubSt( sEles, 1,\
    \ nDelimiterIndex - 1 ) );\n        sEles = Trim( Subst( sEles, nDelimiterIndex + Long(pDelim), Long(\
    \ sEles ) ) );\n    EndIf;\n  \n    # Check if a wildcard has been used to specify the Element name.\n\
    \    # If it hasn't then just delete the Element if it exists\n    If( sEle @= '*' );\n        nElementIndex\
    \ = Dimsiz(pDim|':'|sHier);\n        While( nElementIndex >= 1 );\n            sEle = ElementName(\
    \ pDim, sHier, nElementIndex );\n            sElType = ElementType( pDim, sHier, sEle );\n       \
    \     If( sElType @= 'C' );\n                HierarchyElementDelete( pDim, sHier,sEle );\n       \
    \     EndIf;\n            nElementIndex = nElementIndex - 1;\n        End;\n    ElseIf( Scan( '*',\
    \ sEle ) = 0);\n        If( HierarchyElementExists( pDim,sHier, sEle ) = 1 );\n            sElType\
    \ = ElementType( pDim, sHier, sEle ); \n            If( sElType @='C' );\n                HierarchyElementDelete(\
    \ pDim, sHier,sEle );\n            EndIf;\n        Else;\n            nErrors = 1;\n            sMessage\
    \ = 'The Hierarchy ' | sHier | ' does not have element ' | sEle;\n            LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        EndIf;\n    Else;\n        # Wildcard search string\n   \
    \     sEle    = '''|sEle|''';\n        sProc   = '}bedrock.hier.sub.create.bymdx';\n        sMdx \
    \   = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |pDim|':'|sHier |' ])},'| sEle| ')}';\n        ExecuteProcess('}bedrock.hier.sub.create.bymdx',\n\
    \          'pLogOutput', pLogOutput,\n          'pStrictErrorHandling', pStrictErrorHandling,\n  \
    \      \t'pDim', pDim,\n        \t'pHier', sHier,\n        \t'pSub', cTempSub,\n        \t'pMDXExpr',\
    \ sMdx,\n        \t'pConvertToStatic', 1,\n        \t'pTemp', 1\n        );\n        nCount = HierarchySubsetGetSize(pDim,\
    \ sHier, cTempSub);\n        While( nCount >= 1 );\n            sElement = HierarchySubsetGetElementName(pDim,\
    \ sHier, cTempSub, nCount);\n            sElType = ElementType( pDim, sHier, sElement );\n       \
    \     If( sElType @= 'C' );\n                HierarchyElementDelete( pDim, sHier,sElement );\n   \
    \         EndIf;  \n            nCount = nCount - 1;\n        End;\n    EndIf;\n\nEnd;\n\n### End\
    \ Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    #Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted the appropriate consolidated elements in\
    \ hierarchy %pDim%:%pHier%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that allows for the deletion of a specified C-Level
    item or ALL consolidations in a dimension hierarchy. This process should be usable both during development
    and in production. The user must ensure that a valid dimension name (pDim) is provided, otherwise
    the process should abort. Control dimensions are excluded from this operation. If no hierarchy (pHier)
    is specified, pDim should be used by default. Otherwise, pHier must be valid, or the process will
    abort. All consolidated items in the hierarchy should be deleted if the consolidated item (pEle) is
    specified as *, otherwise it should contain valid C-Level items. Caution: The target hierarchy (pHier)
    cannot be ''Leaves''.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete a specified C-Level item **or** ALL consolidations\
    \ in the dimension hierarchy. \n\n# Use case: Could be used during development or in production.\n\
    # 1/ Delete a specific or all C-Level items in a hierarchy.\n\n# Note:\n# Valid dimension name (pDim)\
    \ is mandatory otherwise the process will abort. Control dimensions are excluded.\n# The hierarchy\
    \ (pHier) will default to pDim if not specified, otherwise it must be valid else the process will\
    \ abort.\n# **ALL** consoldidated items in hierarchy will be deleted if consolidated item (pEle) is\
    \ specified as \\*, otherwise it needs to contain valid c-level item(s). \n# Caution: Target hierarchy\
    \ (pHier) cannot be `Leaves`.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt   \
    \     = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%, pDelim:%pDelim%.';\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n###\
    \ Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n## Validate Dimension\nIf( Trim( pDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension: ' | pDim\
    \ | ' does not exist on server.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n## Validate Hierarchy\nIF(pHier @= 'Leaves' );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \  Hierarchy: ' | pDim |':'|pHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n## Validate Elements\nIF(pEle @= '' );\n    nErrors = 1;\n    sMessage = 'Element cannot\
    \ be empty. Use * for all elements';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n\nIf( Trim( pHier ) @= '' );\n    sHier = pDim;\nElse;\n    sHier = pHier;\nEndIf;\n\nIf(\
    \ HierarchyExists( pDim, sHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'The Hierarchy ' | sHier\
    \ | ' does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors > 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsEles = pEle;\nnDelimiterIndex\
    \ = 1;\nWhile( nDelimiterIndex <> 0 );\n    \n    nDelimiterIndex = Scan( pDelim, sEles );\n    If(\
    \ nDelimiterIndex = 0 );\n        sEle = sEles;\n    Else;\n        sEle = Trim( SubSt( sEles, 1,\
    \ nDelimiterIndex - 1 ) );\n        sEles = Trim( Subst( sEles, nDelimiterIndex + Long(pDelim), Long(\
    \ sEles ) ) );\n    EndIf;\n  \n    # Check if a wildcard has been used to specify the Element name.\n\
    \    # If it hasn't then just delete the Element if it exists\n    If( sEle @= '*' );\n        nElementIndex\
    \ = Dimsiz(pDim|':'|sHier);\n        While( nElementIndex >= 1 );\n            sEle = ElementName(\
    \ pDim, sHier, nElementIndex );\n            sElType = ElementType( pDim, sHier, sEle );\n       \
    \     If( sElType @= 'C' );\n                HierarchyElementDelete( pDim, sHier,sEle );\n       \
    \     EndIf;\n            nElementIndex = nElementIndex - 1;\n        End;\n    ElseIf( Scan( '*',\
    \ sEle ) = 0);\n        If( HierarchyElementExists( pDim,sHier, sEle ) = 1 );\n            sElType\
    \ = ElementType( pDim, sHier, sEle ); \n            If( sElType @='C' );\n                HierarchyElementDelete(\
    \ pDim, sHier,sEle );\n            EndIf;\n        Else;\n            nErrors = 1;\n            sMessage\
    \ = 'The Hierarchy ' | sHier | ' does not have element ' | sEle;\n            LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n        EndIf;\n    Else;\n        # Wildcard search string\n   \
    \     sEle    = '''|sEle|''';\n        sProc   = '}bedrock.hier.sub.create.bymdx';\n        sMdx \
    \   = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |pDim|':'|sHier |' ])},'| sEle| ')}';\n        ExecuteProcess('}bedrock.hier.sub.create.bymdx',\n\
    \          'pLogOutput', pLogOutput,\n          'pStrictErrorHandling', pStrictErrorHandling,\n  \
    \      \t'pDim', pDim,\n        \t'pHier', sHier,\n        \t'pSub', cTempSub,\n        \t'pMDXExpr',\
    \ sMdx,\n        \t'pConvertToStatic', 1,\n        \t'pTemp', 1\n        );\n        nCount = HierarchySubsetGetSize(pDim,\
    \ sHier, cTempSub);\n        While( nCount >= 1 );\n            sElement = HierarchySubsetGetElementName(pDim,\
    \ sHier, cTempSub, nCount);\n            sElType = ElementType( pDim, sHier, sElement );\n       \
    \     If( sElType @= 'C' );\n                HierarchyElementDelete( pDim, sHier,sElement );\n   \
    \         EndIf;  \n            nCount = nCount - 1;\n        End;\n    EndIf;\n\nEnd;\n\n### End\
    \ Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    #Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted the appropriate consolidated elements in\
    \ hierarchy %pDim%:%pHier%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der wie folgt lautet: Der Prozess fügt das konsolidierte
    Element pTgtConsol in die Dimensionshierarchie hinzu. Anwendungsfall: Für die Entwicklung gedacht,
    kann aber auch in der Produktion verwendet werden. 1/ Erstelle eine neue Hierarchie für Tests. 2/
    Erstelle eine neue Hierarchie, um neue geschäftliche Anforderungen zu reflektieren. Hinweis: Wenn
    das Quell-Elternelement (pSrcConsol) definiert ist, werden alle seine Blattelemente in das Ziel-Elternelement
    konsolidiert. Andernfalls werden alle Blattelemente der Dimensionshierarchie in die Konsolidierung
    des Ziel-Elternelements aufgenommen. Gültige Namen für die Quell-Dimension (pDim), Hierarchie (pHier)
    und das Ziel-Elternelement (pTgtConsol) sind obligatorisch, andernfalls wird der Prozess abgebrochen.
    Das Gewicht aller hinzugefügten Elemente in die Konsolidierung des Ziel-Elternelements wird gemäß
    dem Wert des Parameters pWeight zugewiesen. Achtung: Wenn das Zielelement pTgtConsol in der Hierarchie
    existiert, wird es überschrieben.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Start Prolog ###\n\n#Region @DOC\n# Description:\n# This process will add consolidated element\
    \ pTgtConsol in the dimension hierarchy. \n\n# Use case: Intended for Development but could be used\
    \ in production too.\n# 1/ Create a new hierarchy for testing.\n# 2/ Create a new hierarchy to reflect\
    \ new business needs.\n\n# Note:\n# If source parent element (pSrcConsol) is defined then all its\
    \ leaf elements will be copied to target\n# parent element consolidation. Otherwise all leaf elements\
    \ in the dimension hierarchy will be \n# added into target parent element consolidation.\n# Valid\
    \ source dimension name (pDim), hierarchy (pHier) and taget parent element (pTgtConsol)\n# are mandatory\
    \ otherwise the process will abort.\n# Weight of all added elements into target parent consolidation\
    \ will be assigned accoring to\n# pWeight parameter value.\n\n# Caution: If the target element pTgtConsol\
    \ exists in the hierarchy, then it will be overwritten.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp\
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo      \
    \  = 'Process:%cThisProcName% run with parameters pDim=%pDim%, pHier=%pHier%, pSrcConsol=%pSrcConsol%,\
    \ pTgtConsol=%pTgtConsol%.';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':',\
    \ pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error\
    \ by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim\
    \ ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIF(\
    \ Trim( pDim ) @= '' );\n    ## No dimension nominated.\n    nErrors = 1;\n    sMessage = 'No dimension\
    \ specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( DimensionExists(\
    \ pDim) = 0 );\n    ## Dimension does not exist in the model.\n    nErrors = 1;\n    sMessage = 'The\
    \ dimension does not exist in the model: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( SUBST( pDim, 1, 1 ) @= '}' );\n    ## Nominated dimension is a system dimension.\n\
    \    nErrors = 1;\n    sMessage = 'Can not modify a system dimension with this Bedrock.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate hierarchy\nIF( Trim( pHier\
    \  ) @= '' );\n    pHier = pDim;\nEndIf;\n\nIF( HierarchyExists(pDim, pHier ) = 0 % pHier @= 'Leaves');\n\
    \    nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|pHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate consolidation Parameter\npTgtConsol\
    \ = Trim( pTgtConsol );\nIf( pTgtConsol @= '');\n    nErrors = 1;\n    sMessage = 'No target parent\
    \ element supplied.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( pTgtConsol\
    \ @= pSrcConsol );\n    nErrors = 1;\n    sMessage = 'Target and source consolidations can''t be the\
    \ same elements: ' | pTgtConsol |':'| pSrcConsol;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n\n## Validate Member Consolidation\npSrcConsol = Trim( pSrcConsol );\nIF( pSrcConsol\
    \ @<> '' );\n    ## A source consolidation has been nominated.\n    IF(  ElementIndex( pDim, pHier,\
    \ pSrcConsol ) = 0 );\n    ## The Member Consolidation does not exist in the dimension.\n        nErrors\
    \ = 1;\n        sMessage = Expand('Source consolidation %pSrcConsol% does not exist in the dimension:hierarchy:\
    \ %pDim%:%pHier%.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ENDIF;\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### UNWIND CONSOLIDATION\
    \ ###\nIF( ElementIndex( pDim, pHier, pTgtConsol ) > 0 );\n  ExecuteProcess('}bedrock.hier.unwind'\n\
    \    ,'pStrictErrorHandling', pStrictErrorHandling\n    ,'pDim', pDim\n    ,'pHier',pHier\n    ,'pConsol',\
    \ pTgtConsol\n    ,'pRecursive', 0\n  );\nElse;\n    HierarchyElementInsert( pDim, pHier, '', pTgtConsol,\
    \ 'C' );\nENDIF;\n\n### Assign Datasource ###\nDatasourceNameForServer = pDim|':'|pHier;\nDataSourceDimensionSubset\
    \ = 'All';\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Start Metadata ###\n\n### VALIDATE RECORD ###\n\nsElType = ElementType(\
    \ pDim, pHier, vElement );\nIF( sElType @<> 'N' );\n  ## The element is not a 'N' element.\n  ITEMSKIP;\n\
    ENDIF;\n\nIF( pSrcConsol @<> '' );\n  ## A member consolidation is been used.\n  IF( ElementIsAncestor(\
    \ pDim, pHier, pSrcConsol, vElement ) = 0 );\n  ## The element is not a member of the nominated consolidation.\n\
    \    ITEMSKIP;\n  ENDIF;\nENDIF;  \n\n### BUILD CONSOLIDATION ###\n\nIf( nErrors = 0 );\n  HierarchyElementComponentAdd(\
    \ pDim, pHier, pTgtConsol, vElement, pWeight );\nEndIf;\n\n### End Metadata ###\n#Section Daten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see\
    \ above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created a consolidation %pTgtConsol% in the hierarchy %pDim%:%pHier%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n### End Epilog\
    \ ###"
- question: 'Create an IBM Turbo Integrator process as follows: This process will add the consolidated
    element pTgtConsol in the dimension hierarchy. Use case: Intended for Development but could be used
    in production too. 1/ Create a new hierarchy for testing. 2/ Create a new hierarchy to reflect new
    business needs. Note: If the source parent element (pSrcConsol) is defined, then all its leaf elements
    will be copied to the target parent element consolidation. Otherwise, all leaf elements in the dimension
    hierarchy will be added into the target parent element consolidation. Valid source dimension name
    (pDim), hierarchy (pHier), and target parent element (pTgtConsol) are mandatory, otherwise, the process
    will abort. Weight of all added elements into target parent consolidation will be assigned according
    to the pWeight parameter value. Caution: If the target element pTgtConsol exists in the hierarchy,
    then it will be overwritten.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Start Prolog ###\n\n#Region @DOC\n# Description:\n# This process will add consolidated element\
    \ pTgtConsol in the dimension hierarchy. \n\n# Use case: Intended for Development but could be used\
    \ in production too.\n# 1/ Create a new hierarchy for testing.\n# 2/ Create a new hierarchy to reflect\
    \ new business needs.\n\n# Note:\n# If source parent element (pSrcConsol) is defined then all its\
    \ leaf elements will be copied to target\n# parent element consolidation. Otherwise all leaf elements\
    \ in the dimension hierarchy will be \n# added into target parent element consolidation.\n# Valid\
    \ source dimension name (pDim), hierarchy (pHier) and taget parent element (pTgtConsol)\n# are mandatory\
    \ otherwise the process will abort.\n# Weight of all added elements into target parent consolidation\
    \ will be assigned accoring to\n# pWeight parameter value.\n\n# Caution: If the target element pTgtConsol\
    \ exists in the hierarchy, then it will be overwritten.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp\
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo      \
    \  = 'Process:%cThisProcName% run with parameters pDim=%pDim%, pHier=%pHier%, pSrcConsol=%pSrcConsol%,\
    \ pTgtConsol=%pTgtConsol%.';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':',\
    \ pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error\
    \ by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim\
    \ ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIF(\
    \ Trim( pDim ) @= '' );\n    ## No dimension nominated.\n    nErrors = 1;\n    sMessage = 'No dimension\
    \ specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( DimensionExists(\
    \ pDim) = 0 );\n    ## Dimension does not exist in the model.\n    nErrors = 1;\n    sMessage = 'The\
    \ dimension does not exist in the model: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( SUBST( pDim, 1, 1 ) @= '}' );\n    ## Nominated dimension is a system dimension.\n\
    \    nErrors = 1;\n    sMessage = 'Can not modify a system dimension with this Bedrock.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate hierarchy\nIF( Trim( pHier\
    \  ) @= '' );\n    pHier = pDim;\nEndIf;\n\nIF( HierarchyExists(pDim, pHier ) = 0 % pHier @= 'Leaves');\n\
    \    nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|pHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate consolidation Parameter\npTgtConsol\
    \ = Trim( pTgtConsol );\nIf( pTgtConsol @= '');\n    nErrors = 1;\n    sMessage = 'No target parent\
    \ element supplied.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( pTgtConsol\
    \ @= pSrcConsol );\n    nErrors = 1;\n    sMessage = 'Target and source consolidations can''t be the\
    \ same elements: ' | pTgtConsol |':'| pSrcConsol;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndif;\n\n## Validate Member Consolidation\npSrcConsol = Trim( pSrcConsol );\nIF( pSrcConsol\
    \ @<> '' );\n    ## A source consolidation has been nominated.\n    IF(  ElementIndex( pDim, pHier,\
    \ pSrcConsol ) = 0 );\n    ## The Member Consolidation does not exist in the dimension.\n        nErrors\
    \ = 1;\n        sMessage = Expand('Source consolidation %pSrcConsol% does not exist in the dimension:hierarchy:\
    \ %pDim%:%pHier%.');\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ENDIF;\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### UNWIND CONSOLIDATION\
    \ ###\nIF( ElementIndex( pDim, pHier, pTgtConsol ) > 0 );\n  ExecuteProcess('}bedrock.hier.unwind'\n\
    \    ,'pStrictErrorHandling', pStrictErrorHandling\n    ,'pDim', pDim\n    ,'pHier',pHier\n    ,'pConsol',\
    \ pTgtConsol\n    ,'pRecursive', 0\n  );\nElse;\n    HierarchyElementInsert( pDim, pHier, '', pTgtConsol,\
    \ 'C' );\nENDIF;\n\n### Assign Datasource ###\nDatasourceNameForServer = pDim|':'|pHier;\nDataSourceDimensionSubset\
    \ = 'All';\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Start Metadata ###\n\n### VALIDATE RECORD ###\n\nsElType = ElementType(\
    \ pDim, pHier, vElement );\nIF( sElType @<> 'N' );\n  ## The element is not a 'N' element.\n  ITEMSKIP;\n\
    ENDIF;\n\nIF( pSrcConsol @<> '' );\n  ## A member consolidation is been used.\n  IF( ElementIsAncestor(\
    \ pDim, pHier, pSrcConsol, vElement ) = 0 );\n  ## The element is not a member of the nominated consolidation.\n\
    \    ITEMSKIP;\n  ENDIF;\nENDIF;  \n\n### BUILD CONSOLIDATION ###\n\nIf( nErrors = 0 );\n  HierarchyElementComponentAdd(\
    \ pDim, pHier, pTgtConsol, vElement, pWeight );\nEndIf;\n\n### End Metadata ###\n#Section Daten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see\
    \ above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created a consolidation %pTgtConsol% in the hierarchy %pDim%:%pHier%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess mit den folgenden Anforderungen: Dieser Prozess
    soll eine neue Hierarchie ''pHier'' in der Zieldimension ''pDim'' erstellen. Der Anwendungsfall ist
    primär für die Entwicklung gedacht, kann jedoch auch in der Produktion eingesetzt werden. Der Prozess
    umfasst folgende Schritte: 1) Erstelle eine neue Hierarchie zum Testen. 2) Erstelle eine neue Hierarchie,
    um neue geschäftliche Anforderungen zu reflektieren. Hinweis: Falls die Dimension ''pDim'' nicht existiert,
    soll sie erstellt werden.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a new hierarchy pHier in target dimension\
    \ pDim.\n\n# Use case: Intended for Development but could be used in production too.\n# 1/ Create\
    \ a new hierarchy for testing.\n# 2/ Create a new hierarchy to reflect new business needs.\n\n# Note:\n\
    # If dimension pDim doesn't exist, it will be created.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName         = TM1User();\n\
    cTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo     \
    \     = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pDelim:%pDelim%.';\
    \ \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?',\
    \ pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No\
    \ dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n#\
    \ If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Set up hierachy if not provided\n\
    If( Trim( pHier ) @= '' );\n  pHier = pDim;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims =\
    \ pDim;\nnDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0\
    \ );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If(\
    \ nDimDelimiterIndex = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims,\
    \ 1, nDimDelimiterIndex - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim),\
    \ Long( sDims ) ) );\n    EndIf;\n    \n    ###Creating Dimension if not exist, where no wildcard\n\
    \    If( Scan( '*', sDim ) = 0 & Scan( '?', sDim ) = 0 & Scan( pDelim, sDim ) = 0 & DimensionExists(\
    \ sDim ) = 0 );\n      DimensionCreate( sDim );\n      If( pLogOutput = 1 );\n        sMessage = Expand(\
    \ 'Creating  Dimension %sDim%' );\n        LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n     \
    \ EndIf;\n    EndIf;\n    \n      # Create subset of dimensions using Wildcard to loop through dimensions\
    \ in pDim with wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT(\
    \ TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'|\
    \ sDimExp | ')}';\n    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx |\
    \ ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n\nIf( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n   \
    \ # If a delimited list of dim names includes wildcards then we may have to re-use the subset multiple\
    \ times\n    SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\nElse;\n    # temp subset, therefore\
    \ no need to destroy in epilog\n    SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\nEndIf;\n\
    \n# Loop through dimensions in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions'\
    \ , cTempSub );\nWhile( nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSub,\
    \ nCountDim );\n    # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n        nErrors\
    \ = 1;\n        sMessage = Expand( 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR',\
    \ Expand( cMsgErrorContent ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage = Expand(\
    \ 'Dimension %sDim% being processed....' );\n          LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n        EndIf;\n        # Loop through hierarchies in pHier\n        sHierarchies        \
    \      = pHier;\n        nDelimiterIndexA    = 1;\n        While( nDelimiterIndexA <> 0 );\n\n   \
    \         nDelimiterIndexA = Scan( pDelim, sHierarchies );\n            If( nDelimiterIndexA = 0 );\n\
    \                sHierarchy   = sHierarchies;\n            Else;\n                sHierarchy   = Trim(\
    \ SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n                sHierarchies  = Trim( Subst(\
    \ sHierarchies, nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n            EndIf;\n \
    \           ###Creating Hierarchy\n            If( HierarchyExists( sDim, sHierarchy ) = 1 & sDim\
    \ @<> sHierarchy );\n                nErrors = 1;\n                sMessage = 'The Hierachy ' | pHier\
    \ | ' already exists.';\n                LogOutput( cMsgErrorLevel, sMessage );\n            ElseIf(\
    \ sDim @<> sHierarchy );\n                HierarchyCreate( sDim , sHierarchy );\n                If(\
    \ pLogOutput = 1 );\n                  sMessage = Expand( 'Creating hierarchy %sHierarchy% in Dimension\
    \ %sDim%' );\n                  LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n                EndIf;\n\
    \            EndIf;\n        End;\n    EndIf;\n    \n    nCountDim = nCountDim - 1;\nEnd;\n  \n\n\
    ### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \     = Expand( 'Process:%cThisProcName% successfully created the %pHier% hierarchy in the %pDim%\
    \ dimension.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n  \
    \  nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process with the following requirements: This process should
    create a new hierarchy ''pHier'' in target dimension ''pDim''. The use case is primarily intended
    for development but can also be used in production. The process includes the following steps: 1) Create
    a new hierarchy for testing. 2) Create a new hierarchy to reflect new business needs. Note: If the
    dimension ''pDim'' does not exist, it should be created.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a new hierarchy pHier in target dimension\
    \ pDim.\n\n# Use case: Intended for Development but could be used in production too.\n# 1/ Create\
    \ a new hierarchy for testing.\n# 2/ Create a new hierarchy to reflect new business needs.\n\n# Note:\n\
    # If dimension pDim doesn't exist, it will be created.\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName         = TM1User();\n\
    cTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo     \
    \     = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pDelim:%pDelim%.';\
    \ \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?',\
    \ pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No\
    \ dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n#\
    \ If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Set up hierachy if not provided\n\
    If( Trim( pHier ) @= '' );\n  pHier = pDim;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims =\
    \ pDim;\nnDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0\
    \ );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If(\
    \ nDimDelimiterIndex = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims,\
    \ 1, nDimDelimiterIndex - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim),\
    \ Long( sDims ) ) );\n    EndIf;\n    \n    ###Creating Dimension if not exist, where no wildcard\n\
    \    If( Scan( '*', sDim ) = 0 & Scan( '?', sDim ) = 0 & Scan( pDelim, sDim ) = 0 & DimensionExists(\
    \ sDim ) = 0 );\n      DimensionCreate( sDim );\n      If( pLogOutput = 1 );\n        sMessage = Expand(\
    \ 'Creating  Dimension %sDim%' );\n        LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n     \
    \ EndIf;\n    EndIf;\n    \n      # Create subset of dimensions using Wildcard to loop through dimensions\
    \ in pDim with wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT(\
    \ TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'|\
    \ sDimExp | ')}';\n    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx |\
    \ ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n\nIf( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n   \
    \ # If a delimited list of dim names includes wildcards then we may have to re-use the subset multiple\
    \ times\n    SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\nElse;\n    # temp subset, therefore\
    \ no need to destroy in epilog\n    SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\nEndIf;\n\
    \n# Loop through dimensions in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions'\
    \ , cTempSub );\nWhile( nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSub,\
    \ nCountDim );\n    # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n        nErrors\
    \ = 1;\n        sMessage = Expand( 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR',\
    \ Expand( cMsgErrorContent ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage = Expand(\
    \ 'Dimension %sDim% being processed....' );\n          LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n        EndIf;\n        # Loop through hierarchies in pHier\n        sHierarchies        \
    \      = pHier;\n        nDelimiterIndexA    = 1;\n        While( nDelimiterIndexA <> 0 );\n\n   \
    \         nDelimiterIndexA = Scan( pDelim, sHierarchies );\n            If( nDelimiterIndexA = 0 );\n\
    \                sHierarchy   = sHierarchies;\n            Else;\n                sHierarchy   = Trim(\
    \ SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n                sHierarchies  = Trim( Subst(\
    \ sHierarchies, nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n            EndIf;\n \
    \           ###Creating Hierarchy\n            If( HierarchyExists( sDim, sHierarchy ) = 1 & sDim\
    \ @<> sHierarchy );\n                nErrors = 1;\n                sMessage = 'The Hierachy ' | pHier\
    \ | ' already exists.';\n                LogOutput( cMsgErrorLevel, sMessage );\n            ElseIf(\
    \ sDim @<> sHierarchy );\n                HierarchyCreate( sDim , sHierarchy );\n                If(\
    \ pLogOutput = 1 );\n                  sMessage = Expand( 'Creating hierarchy %sHierarchy% in Dimension\
    \ %sDim%' );\n                  LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n                EndIf;\n\
    \            EndIf;\n        End;\n    EndIf;\n    \n    nCountDim = nCountDim - 1;\nEnd;\n  \n\n\
    ### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \     = Expand( 'Process:%cThisProcName% successfully created the %pHier% hierarchy in the %pDim%\
    \ dimension.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n  \
    \  nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n\n\n### End Epilog ###"
- question: 'Dieser IBM Turbo Integrator Prozess dient dazu, eine neue Dimensionenhierarchie basierend
    auf Attributwerten zu erstellen. Zu beachten ist, dass ein gültiger Dimensionsname (pDim) und Attributname
    (pAttr) zwingend erforderlich sind, andernfalls wird der Prozess abgebrochen. Vorsicht: Es wird angenommen,
    dass jedes Element __nur einmal__ innerhalb der Hierarchie existiert. Dies sollte außer in Ausnahmefällen
    zutreffen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a new dimension hierarchy from attribute\
    \ values.\n\n# Note:\n# Valid dimension name (pDim) and attribute name (pAttr) are mandatory, otherwise\
    \ the\n# process will abort.\n\n# Caution: It is assumed each element exists __only once__ within\
    \ the hierarchy. This should hold true except in exceptional circumstances.\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName    \
    \     = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncSubset           = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pSrcHier:%pSrcHier%,\
    \ pTgtHier:%pTgtHier%, pAttr:%pAttr%, pTopNode:%pTopNode%, pPrefix:%pPrefix%, pSuffix:%pSuffix%, pSkipBlank:%pSkipBlank%,\
    \ pUnallocated:%pUnallocated%.';\ncAttributeDim     = '}ElementAttributes_' | pDim;\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n###\
    \ Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pSrcHier @= '' );\n    # A\
    \ hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pSrcHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim\
    \        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIF( Trim ( pSrcHier ) @= Trim ( pTgtHier\
    \ ));\n    nErrors = 1;\n    sMessage = 'Source and target Herarchy can not be the same';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;    \n    \n## Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Dimension: ' | pDim | ' does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate Hierarchy\n\
    IF( Trim( pSrcHier  ) @= '' );\n    pSrcHier = Trim( pDim );\nEndIf;\n\nIF( HierarchyExists( pDim,\
    \ pSrcHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|pSrcHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\npnew =DType( cAttributeDim,\
    \ pAttr );\n## Validate attribute\nIf( Trim( pAttr ) @= '' );\n    nErrors = 1;\n    sMessage = 'No\
    \ attribute specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimIx(\
    \ cAttributeDim, pAttr ) = 0 );\n    nErrors = 1;\n    sMessage = 'Attribute: ' | pAttr | ' does not\
    \ exists in dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ DType( cAttributeDim, pAttr ) @<> 'AS' & DType( cAttributeDim, pAttr ) @<> 'AN');\n    ### as alias\
    \ values are all unique, not applicable for creating hierarchy\n    nErrors = 1;\n    sMessage = 'Only\
    \ string and numeric attributes may be used for this process.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n##  Validate Top node name\nIF( Trim( pTopNode  ) @= '' );\n  \
    \  sTopNode = 'All ' | pAttr;\nElseIF( Subst(Trim( pTopNode ),1,7 ) @= '<pAttr>'  );\n    sTopNode\
    \ = pAttr | ' ' | Subst( pTopNode, 8, Long( pTopNode ) );\nElseIF( Subst( pTopNode, Long( pTopNode\
    \ )-7, 8 ) @= '<pAttr>'  );\n    sTopNode = Subst( pTopNode, 1, Long( pTopNode )-8 )  | ' ' | pAttr;\n\
    ElseIF( Scan( '<pAttr>', pTopNode ) >0 );\n    sTopNode = Subst( pTopNode, 1, Scan( '<pAttr>', pTopNode\
    \ )-1 ) | pAttr | Subst( pTopNode, Scan( '<pAttr>', pTopNode )+7,Long(pTopNode) );\nElse;\t\n    sTopNode\
    \ = pTopNode;\nEndIf;\n\n##  Validate Unallocated node name\nIF( Trim( pUnallocated  ) @= '' );\n\
    \    pUnallocated = 'Unallocated';\nElseIF( Subst(Trim( pUnallocated ),1,7 ) @= '<pAttr>'  );\n  \
    \  pUnallocated = pAttr | ' ' | Subst( pUnallocated, 8, Long( pUnallocated ) );\nElseIF( Subst( pUnallocated,\
    \ Long( pUnallocated )-7, 8 ) @= '<pAttr>'  );\n    pUnallocated = Subst( pUnallocated, 1, Long( pUnallocated\
    \ )-8 )  | ' ' | pAttr;\nElseIF( Scan( '<pAttr>', pUnallocated ) >0 );\n    pUnallocated = Subst(\
    \ pUnallocated, 1, Scan( '<pAttr>', pUnallocated )-1 ) | pAttr | Subst( pUnallocated, Scan( '<pAttr>',\
    \ pUnallocated )+7,Long(pUnallocated) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Modify attribute for hierarchy name\nsAttribute = Trim(pAttr);\n#If Attribute\
    \ name has ':' then delete as Hierachy names are not allowed with ':' \nIf(Scan(':', sAttribute) >\
    \ 0);\n        nStart = 0;\n        WHILE ( nStart <> 1 );\n            nSpecialChar = SCAN ( ':',\
    \ sAttribute );\n        \tIF ( nSpecialChar <> 0 );\n        \t\tsAttribute  = DELET (sAttribute\
    \ , nSpecialChar, 1 );\n        \tELSE;\n        \t\tnStart = 1;\n        \tENDIF;\n        END;\n\
    EndIf;\n\n### Create target dimension Hierarchy ###\nIf(pTgtHier @= '');\n  sTargetHierarchy = sAttribute;\n\
    Else;\n  sTargetHierarchy = pTgtHier;\nEndIf;\n\nIf( HierarchyExists( pDim, sTargetHierarchy ) = 0\
    \ );\n    HierarchyCreate( pDim, sTargetHierarchy );\nElse;\n  IF ( pUnwind = 1 );\n    ExecuteProcess('}bedrock.hier.unwind',\n\
    \       'pLogOutput', pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n       'pDim',\
    \ pDim,\n       'pHier', sTargetHierarchy,\n       'pConsol', '*',\n       'pRecursive', 0,\n    \
    \   'pDelim', '&'\n      );\n  Else;   \n    HierarchyDeleteAllElements( pDim, sTargetHierarchy );\n\
    \  Endif;  \nEndIf;\n\n#Target consol does not exist then add element to dimension.\nIf( ElementIndex(pDim,\
    \ sTargetHierarchy, sTopNode) = 0);\n    HierarchyElementinsert(pDim, sTargetHierarchy, '',sTopNode,\
    \ 'C');\nEndif;\n\n### Format Prefix and Suffix with trailing or leading ' ' ###\nIF( pPrefix @<>\
    \ '' );\n    IF( SUBST( pPrefix, Long( pPrefix), 1) @<> ' ' );\n        sPrefix = pPrefix | ' ';\n\
    \    ELSE;\n        sPrefix = pPrefix;\n    ENDIF;\nENDIF;\n\nIF( pSuffix @<> '' );\n    IF( SUBST(\
    \ pSuffix, 1, 1) @<> ' ' );\n        sSuffix = ' ' | pSuffix;\n    ELSE;\n        sSuffix = pSuffix;\n\
    \    ENDIF;\nENDIF;\n\n\n### Assign Data Source ###\nDatasourceNameForServer   = pDim|':'|pSrcHier;\n\
    DatasourceNameForClient   = pDim|':'|pSrcHier;\nDataSourceType            = 'SUBSET';\nDatasourceDimensionSubset\
    \ = 'ALL';\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Skip if the Element is not\
    \ leaf element\nIf( ElementType(pDim, pSrcHier, vEle) @<> 'N' );\n    ItemSkip;\nEndif;\n\n# Skip\
    \ if top node\nIf( vEle @= sTopNode );\n    ItemSkip;\nENDIF;\n\nIf( DType( cAttributeDim, pAttr )\
    \ @= 'AS' );\n  sAttrVal = ElementAttrS(pDim, pSrcHier, vEle, pAttr);\nElse; \n  sAttrVal = NumberToString(ElementAttrN(pDim,\
    \ pSrcHier, vEle, pAttr));\nEndIf; \nsParent = sAttrVal;\n\n# Manage not populated attribute.\nIf(\
    \ sParent @= '' & pSkipBlank = 0 );\n    ItemSkip;\nElseIf( sParent @= '' & pSkipBlank <> 0 );  \n\
    \    sParent = pUnallocated;\nEndIf;\n\n#If parent does not exist AND allow insertion of new parents\
    \ is TRUE then insert new consol\n## Add the attribute value to the top node.\n  \n  sElPar = sPrefix\
    \ | sParent | sSuffix;\n\n  HierarchyElementinsert(pDim, sTargetHierarchy, '',sElPar, 'C');\n  HierarchyElementComponentAdd(pDim,\
    \ sTargetHierarchy, sTopNode, sElPar, 1);\n  \n  HierarchyElementinsert(pDim, sTargetHierarchy, '',vEle,\
    \ 'N' );\n  HierarchyElementComponentAdd(pDim, sTargetHierarchy, sElPar, vEle, 1);\n\n### End Metadata\
    \ ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created the %sTargetHierarchy% hierarchy in the\
    \ %pDim% dimension.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'This IBM Turbo Integrator process is designed to create a new dimension hierarchy based on
    attribute values. Please note that a valid dimension name (pDim) and attribute name (pAttr) are mandatory;
    otherwise, the process will abort. Caution: It is assumed that each element exists __only once__ within
    the hierarchy. This should hold true except in exceptional circumstances.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a new dimension hierarchy from attribute\
    \ values.\n\n# Note:\n# Valid dimension name (pDim) and attribute name (pAttr) are mandatory, otherwise\
    \ the\n# process will abort.\n\n# Caution: It is assumed each element exists __only once__ within\
    \ the hierarchy. This should hold true except in exceptional circumstances.\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName    \
    \     = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncSubset           = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pSrcHier:%pSrcHier%,\
    \ pTgtHier:%pTgtHier%, pAttr:%pAttr%, pTopNode:%pTopNode%, pPrefix:%pPrefix%, pSuffix:%pSuffix%, pSkipBlank:%pSkipBlank%,\
    \ pUnallocated:%pUnallocated%.';\ncAttributeDim     = '}ElementAttributes_' | pDim;\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n###\
    \ Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pSrcHier @= '' );\n    # A\
    \ hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pSrcHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim\
    \        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIF( Trim ( pSrcHier ) @= Trim ( pTgtHier\
    \ ));\n    nErrors = 1;\n    sMessage = 'Source and target Herarchy can not be the same';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;    \n    \n## Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Dimension: ' | pDim | ' does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate Hierarchy\n\
    IF( Trim( pSrcHier  ) @= '' );\n    pSrcHier = Trim( pDim );\nEndIf;\n\nIF( HierarchyExists( pDim,\
    \ pSrcHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|pSrcHier;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\npnew =DType( cAttributeDim,\
    \ pAttr );\n## Validate attribute\nIf( Trim( pAttr ) @= '' );\n    nErrors = 1;\n    sMessage = 'No\
    \ attribute specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimIx(\
    \ cAttributeDim, pAttr ) = 0 );\n    nErrors = 1;\n    sMessage = 'Attribute: ' | pAttr | ' does not\
    \ exists in dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ DType( cAttributeDim, pAttr ) @<> 'AS' & DType( cAttributeDim, pAttr ) @<> 'AN');\n    ### as alias\
    \ values are all unique, not applicable for creating hierarchy\n    nErrors = 1;\n    sMessage = 'Only\
    \ string and numeric attributes may be used for this process.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n##  Validate Top node name\nIF( Trim( pTopNode  ) @= '' );\n  \
    \  sTopNode = 'All ' | pAttr;\nElseIF( Subst(Trim( pTopNode ),1,7 ) @= '<pAttr>'  );\n    sTopNode\
    \ = pAttr | ' ' | Subst( pTopNode, 8, Long( pTopNode ) );\nElseIF( Subst( pTopNode, Long( pTopNode\
    \ )-7, 8 ) @= '<pAttr>'  );\n    sTopNode = Subst( pTopNode, 1, Long( pTopNode )-8 )  | ' ' | pAttr;\n\
    ElseIF( Scan( '<pAttr>', pTopNode ) >0 );\n    sTopNode = Subst( pTopNode, 1, Scan( '<pAttr>', pTopNode\
    \ )-1 ) | pAttr | Subst( pTopNode, Scan( '<pAttr>', pTopNode )+7,Long(pTopNode) );\nElse;\t\n    sTopNode\
    \ = pTopNode;\nEndIf;\n\n##  Validate Unallocated node name\nIF( Trim( pUnallocated  ) @= '' );\n\
    \    pUnallocated = 'Unallocated';\nElseIF( Subst(Trim( pUnallocated ),1,7 ) @= '<pAttr>'  );\n  \
    \  pUnallocated = pAttr | ' ' | Subst( pUnallocated, 8, Long( pUnallocated ) );\nElseIF( Subst( pUnallocated,\
    \ Long( pUnallocated )-7, 8 ) @= '<pAttr>'  );\n    pUnallocated = Subst( pUnallocated, 1, Long( pUnallocated\
    \ )-8 )  | ' ' | pAttr;\nElseIF( Scan( '<pAttr>', pUnallocated ) >0 );\n    pUnallocated = Subst(\
    \ pUnallocated, 1, Scan( '<pAttr>', pUnallocated )-1 ) | pAttr | Subst( pUnallocated, Scan( '<pAttr>',\
    \ pUnallocated )+7,Long(pUnallocated) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Modify attribute for hierarchy name\nsAttribute = Trim(pAttr);\n#If Attribute\
    \ name has ':' then delete as Hierachy names are not allowed with ':' \nIf(Scan(':', sAttribute) >\
    \ 0);\n        nStart = 0;\n        WHILE ( nStart <> 1 );\n            nSpecialChar = SCAN ( ':',\
    \ sAttribute );\n        \tIF ( nSpecialChar <> 0 );\n        \t\tsAttribute  = DELET (sAttribute\
    \ , nSpecialChar, 1 );\n        \tELSE;\n        \t\tnStart = 1;\n        \tENDIF;\n        END;\n\
    EndIf;\n\n### Create target dimension Hierarchy ###\nIf(pTgtHier @= '');\n  sTargetHierarchy = sAttribute;\n\
    Else;\n  sTargetHierarchy = pTgtHier;\nEndIf;\n\nIf( HierarchyExists( pDim, sTargetHierarchy ) = 0\
    \ );\n    HierarchyCreate( pDim, sTargetHierarchy );\nElse;\n  IF ( pUnwind = 1 );\n    ExecuteProcess('}bedrock.hier.unwind',\n\
    \       'pLogOutput', pLogOutput,\n       'pStrictErrorHandling', pStrictErrorHandling,\n       'pDim',\
    \ pDim,\n       'pHier', sTargetHierarchy,\n       'pConsol', '*',\n       'pRecursive', 0,\n    \
    \   'pDelim', '&'\n      );\n  Else;   \n    HierarchyDeleteAllElements( pDim, sTargetHierarchy );\n\
    \  Endif;  \nEndIf;\n\n#Target consol does not exist then add element to dimension.\nIf( ElementIndex(pDim,\
    \ sTargetHierarchy, sTopNode) = 0);\n    HierarchyElementinsert(pDim, sTargetHierarchy, '',sTopNode,\
    \ 'C');\nEndif;\n\n### Format Prefix and Suffix with trailing or leading ' ' ###\nIF( pPrefix @<>\
    \ '' );\n    IF( SUBST( pPrefix, Long( pPrefix), 1) @<> ' ' );\n        sPrefix = pPrefix | ' ';\n\
    \    ELSE;\n        sPrefix = pPrefix;\n    ENDIF;\nENDIF;\n\nIF( pSuffix @<> '' );\n    IF( SUBST(\
    \ pSuffix, 1, 1) @<> ' ' );\n        sSuffix = ' ' | pSuffix;\n    ELSE;\n        sSuffix = pSuffix;\n\
    \    ENDIF;\nENDIF;\n\n\n### Assign Data Source ###\nDatasourceNameForServer   = pDim|':'|pSrcHier;\n\
    DatasourceNameForClient   = pDim|':'|pSrcHier;\nDataSourceType            = 'SUBSET';\nDatasourceDimensionSubset\
    \ = 'ALL';\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Skip if the Element is not\
    \ leaf element\nIf( ElementType(pDim, pSrcHier, vEle) @<> 'N' );\n    ItemSkip;\nEndif;\n\n# Skip\
    \ if top node\nIf( vEle @= sTopNode );\n    ItemSkip;\nENDIF;\n\nIf( DType( cAttributeDim, pAttr )\
    \ @= 'AS' );\n  sAttrVal = ElementAttrS(pDim, pSrcHier, vEle, pAttr);\nElse; \n  sAttrVal = NumberToString(ElementAttrN(pDim,\
    \ pSrcHier, vEle, pAttr));\nEndIf; \nsParent = sAttrVal;\n\n# Manage not populated attribute.\nIf(\
    \ sParent @= '' & pSkipBlank = 0 );\n    ItemSkip;\nElseIf( sParent @= '' & pSkipBlank <> 0 );  \n\
    \    sParent = pUnallocated;\nEndIf;\n\n#If parent does not exist AND allow insertion of new parents\
    \ is TRUE then insert new consol\n## Add the attribute value to the top node.\n  \n  sElPar = sPrefix\
    \ | sParent | sSuffix;\n\n  HierarchyElementinsert(pDim, sTargetHierarchy, '',sElPar, 'C');\n  HierarchyElementComponentAdd(pDim,\
    \ sTargetHierarchy, sTopNode, sElPar, 1);\n  \n  HierarchyElementinsert(pDim, sTargetHierarchy, '',vEle,\
    \ 'N' );\n  HierarchyElementComponentAdd(pDim, sTargetHierarchy, sElPar, vEle, 1);\n\n### End Metadata\
    \ ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created the %sTargetHierarchy% hierarchy in the\
    \ %pDim% dimension.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine alternative Hierarchie aus einem konsolidierten
    Element und seinen untergeordneten Elementen in der Standardhierarchie erstellt. Beachte, dass der
    gültige Quell-Dimensionsname (pSrcDim) und die Quelldimension (pSubset) zwingend erforderlich sind.
    Andernfalls wird der Prozess abgebrochen. Wird ein Quell-Hierarchiename (pSrcHier) angegeben, muss
    dieser ebenfalls gültig sein, sonst bricht der Prozess ab. Achte darauf, dass die Zielhierarchie nicht
    `Leaves` genannt werden kann und falls die Zielhierarchie bereits existiert, wird sie überschrieben.
    Nutze diesen Prozess, um eine neue Hierarchie für Tests oder zur Anpassung an neue geschäftliche Anforderungen
    zu erstellen.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make an aternative hierarchy from a consolidated\
    \ element and its children in default hierarchy.\n\n# Use case: Intended for Development but could\
    \ be used in production too.\n# 1/ Create a new hierarchy for testing.\n# 2/ Create a new hierarchy\
    \ to reflect new business needs.\n\n# Note:\n# Valid source dimension name (pSrcDim) and source subset\
    \ (pSubset) are mandatory, otherwise the process will abort.\n# If a source hierarchy name (pSrcHier)\
    \ is specified, it needs to be valid, otherwise the process will abort.\n\n# Caution:\n# - Target\
    \ hierarchy cannot be `Leaves`.\n# - If the target Hierarchy already exists, then it will be overwritten.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%,\
    \ pSrcHier:%pSrcHier%, pConsol:%pConsol%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%,\
    \ pRemove:%pRemove%.';\ncHierAttr         = 'Bedrock.Descendant';\ncAttrVal          = 'Descendant';\n\
    \n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \n\
    ENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= ''\
    \ );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long(\
    \ pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\nEndIf;\n\nIf(\
    \ Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy has been passed as dimension. Handle\
    \ the input error by splitting dim:hier into dimension & hierarchy\n    pTgtHier       = SubSt( pTgtDim,\
    \ Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':',\
    \ pTgtDim ) - 1 );\nEndIf;\n\n# Validate source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \ source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate source Hierarchy\n\
    IF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim, pSrcHier) = 0);\n  \
    \  nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;\n\n\n## Validate consolidation\npConsol = Trim( pConsol );\n\
    If( pConsol @<> '' );\n    If( ElementIndex ( pSrcDim, pSrcHier, pConsol ) = 0 );\n        nErrors\
    \ = 1;\n        sMessage = 'The ' | pConsol | ' consolidation does not exist in the '| pSrcDim |'\
    \ dimension:Hierarchy ' | pSrcDim |':'| pSrcHier;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate target\
    \ Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\nEndif;\n\nIF( DimensionExists( pTgtDim )\
    \ = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n### Create target dimension Hierarchy ###\nIF(pTgtHier\
    \ @= '');\n    pTgtHier = pTgtDim;\nEndIf;\n\n##########################################\n# Bedrock\
    \ subprocesses\n\n#create subset\nExecuteProcess('}bedrock.hier.sub.create',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier,\n\t'pSub',\
    \ cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp', 1\n);\n\nExecuteProcess('}bedrock.hier.create.fromsubset',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pSrcDim',pSrcDim,\n\
    \  'pSrcHier', pSrcHier,\n  'pSubset', cTempSub,\n  'pTgtDim', pTgtDim,\n  'pTgtHier', pTgtHier,\n\
    \  'pAttr', pAttr,\n  'pUnwind', pUnwind\n);\n\nIF(pRemove = 1);\n  ExecuteProcess('}bedrock.hier.unwind',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t\
    'pConsol', pConsol,\n\t'pRecursive', 1\n);\n\n  ExecuteProcess('}bedrock.hier.emptyconsols.delete',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t\
    'pHier', pSrcHier\n);\n\nEndif;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned dimension:hierarchy\
    \ %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based on the %pConsol% consolidated element.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates an alternative hierarchy from a consolidated
    element and its children in the default hierarchy. Note that a valid source dimension name (pSrcDim)
    and source subset (pSubset) are mandatory, otherwise the process will abort. If a source hierarchy
    name (pSrcHier) is specified, it needs to be valid, otherwise the process will abort. Be cautious
    that the target hierarchy cannot be called `Leaves` and, if the target hierarchy already exists, it
    will be overwritten. Use this process to create a new hierarchy for testing or to reflect new business
    needs.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make an aternative hierarchy from a consolidated\
    \ element and its children in default hierarchy.\n\n# Use case: Intended for Development but could\
    \ be used in production too.\n# 1/ Create a new hierarchy for testing.\n# 2/ Create a new hierarchy\
    \ to reflect new business needs.\n\n# Note:\n# Valid source dimension name (pSrcDim) and source subset\
    \ (pSubset) are mandatory, otherwise the process will abort.\n# If a source hierarchy name (pSrcHier)\
    \ is specified, it needs to be valid, otherwise the process will abort.\n\n# Caution:\n# - Target\
    \ hierarchy cannot be `Leaves`.\n# - If the target Hierarchy already exists, then it will be overwritten.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%,\
    \ pSrcHier:%pSrcHier%, pConsol:%pConsol%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%,\
    \ pRemove:%pRemove%.';\ncHierAttr         = 'Bedrock.Descendant';\ncAttrVal          = 'Descendant';\n\
    \n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \n\
    ENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= ''\
    \ );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long(\
    \ pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\nEndIf;\n\nIf(\
    \ Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy has been passed as dimension. Handle\
    \ the input error by splitting dim:hier into dimension & hierarchy\n    pTgtHier       = SubSt( pTgtDim,\
    \ Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':',\
    \ pTgtDim ) - 1 );\nEndIf;\n\n# Validate source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \ source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate source Hierarchy\n\
    IF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim, pSrcHier) = 0);\n  \
    \  nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;\n\n\n## Validate consolidation\npConsol = Trim( pConsol );\n\
    If( pConsol @<> '' );\n    If( ElementIndex ( pSrcDim, pSrcHier, pConsol ) = 0 );\n        nErrors\
    \ = 1;\n        sMessage = 'The ' | pConsol | ' consolidation does not exist in the '| pSrcDim |'\
    \ dimension:Hierarchy ' | pSrcDim |':'| pSrcHier;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n## Validate target\
    \ Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\nEndif;\n\nIF( DimensionExists( pTgtDim )\
    \ = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n### Create target dimension Hierarchy ###\nIF(pTgtHier\
    \ @= '');\n    pTgtHier = pTgtDim;\nEndIf;\n\n##########################################\n# Bedrock\
    \ subprocesses\n\n#create subset\nExecuteProcess('}bedrock.hier.sub.create',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier,\n\t'pSub',\
    \ cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp', 1\n);\n\nExecuteProcess('}bedrock.hier.create.fromsubset',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pSrcDim',pSrcDim,\n\
    \  'pSrcHier', pSrcHier,\n  'pSubset', cTempSub,\n  'pTgtDim', pTgtDim,\n  'pTgtHier', pTgtHier,\n\
    \  'pAttr', pAttr,\n  'pUnwind', pUnwind\n);\n\nIF(pRemove = 1);\n  ExecuteProcess('}bedrock.hier.unwind',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t\
    'pConsol', pConsol,\n\t'pRecursive', 1\n);\n\n  ExecuteProcess('}bedrock.hier.emptyconsols.delete',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t\
    'pHier', pSrcHier\n);\n\nEndif;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned dimension:hierarchy\
    \ %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based on the %pConsol% consolidated element.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine alternative Hierarchie aus einem konsolidierten
    Element und seinen Kindern in der Standardhierarchie erstellt. Der Anwendungsfall umfasst sowohl Entwicklungs-
    als auch Produktionsszenarien, indem entweder eine neue Hierarchie für Testzwecke oder zur Abbildung
    neuer Geschäftsanforderungen geschaffen wird. Beachte, dass ein gültiger Quell-Dimensionsname (pSrcDim)
    und ein Quell-Subset (pSubset) erforderlich sind, andernfalls wird der Prozess abgebrochen. Falls
    ein Quell-Hierarchiename (pSrcHier) angegeben wird, muss dieser ebenfalls gültig sein, um einen Abbruch
    zu vermeiden. Wichtig: Die Zielhierarchie darf nicht ''Leaves'' sein und bestehende Zielhierarchien
    werden überschrieben.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make an aternative hierarchy from a consolidated\
    \ element and its children in default hierarchy.\n\n# Use case: Intended for Development but could\
    \ be used in production too.\n# 1/ Create a new hierarchy for testing.\n# 2/ Create a new hierarchy\
    \ to reflect new business needs.\n\n# Note:\n# Valid source dimension name (pSrcDim) and source subset\
    \ (pSubset) are mandatory, otherwise the process will abort.\n# If a source hierarchy name (pSrcHier)\
    \ is specified, it needs to be valid, otherwise the process will abort.\n\n# Caution:\n# - Target\
    \ hierarchy cannot be `Leaves`.\n# - If the target Hierarchy already exists, then it will be overwritten.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%,\
    \ pSrcHier:%pSrcHier%, pConsol:%pConsol%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%,\
    \ pRemove:%pRemove%, pAliasSwap:%pAliasSwap%.';\ncHierAttr         = 'Bedrock.Descendant';\ncAttrVal\
    \          = 'Descendant';\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim\
    \ ) > 0 & pSrcHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error\
    \ by splitting dim:hier into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':',\
    \ pSrcDim ) + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim )\
    \ - 1 );\nEndIf;\n\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n    pTgtHier\
    \       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim        = SubSt(\
    \ pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n# Validate source dimension\nIF( Trim( pSrcDim\
    \ ) @= '' );\n    nErrors = 1;\n    sMessage = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n\
    \    sMessage = 'Invalid source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate source\
    \ Hierarchy\nIF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim, pSrcHier)\
    \ = 0);\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n\n## Validate consolidation\npConsol =\
    \ Trim( pConsol );\nIf( pConsol @<> '' );\n    If( ElementIndex ( pSrcDim, pSrcHier, pConsol ) = 0\
    \ );\n        nErrors = 1;\n        sMessage = 'The ' | pConsol | ' consolidation does not exist in\
    \ the '| pSrcDim |' dimension:Hierarchy ' | pSrcDim |':'| pSrcHier;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n## Validate Attribute\nIf( pAliasSwap @= ''\
    \ );\n    nErrors = 1;\n    sMessage = 'The name of the attribute to swap not specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Validate target Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\nEndif;\n\
    \nIF( DimensionExists( pTgtDim ) = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n### Create target\
    \ dimension Hierarchy ###\nIF(pTgtHier @= '');\n    pTgtHier = pTgtDim;\nEndIf;\n\n##########################################\n\
    # Bedrock subprocesses\n\n\n#create subset\nExecuteProcess('}bedrock.hier.sub.create',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier,\n\t'pSub',\
    \ cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp', 1\n);\n\ncTempDim = pSrcDim|'_'| cTimeStamp |'_'| cRandomInt;\n\
    \nExecuteProcess('}bedrock.hier.create.fromsubset',\n  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n  'pSrcDim',pSrcDim,\n  'pSrcHier', pSrcHier,\n  'pSubset', cTempSub,\n \
    \ 'pTgtDim', cTempDim,\n  'pTgtHier', cTempDim,\n  'pAttr', 1,\n  'pUnwind', 0\n);\n\nExecuteProcess('}bedrock.dim.attr.create',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pDim',cTempDim,\n\
    \  'pAttr', cTempDim,\n  'pAttrType','A'\n);\n\nExecuteProcess('}bedrock.cube.data.copy',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n  'pCube', '}ElementAttributes_'|cTempDim,\n  'pEleMapping','}ElementAttributes_'|cTempDim|':'|pAliasSwap|'->'|cTempDim\n\
    );\n\nExecuteProcess('}bedrock.dim.attr.swapalias',\n  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n  'pDim',cTempDim,\n  'pAlias', cTempDim\n);\n\nExecuteProcess('}bedrock.hier.sub.create',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim', cTempDim,\n\
    \t'pHier', cTempDim,\n\t'pSub', cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp', 0\n);\n\nExecuteProcess('}bedrock.hier.create.fromsubset',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pSrcDim', cTempDim,\n\
    \  'pSrcHier', cTempDim,\n  'pSubset', cTempSub,\n  'pTgtDim', pTgtDim,\n  'pTgtHier', pTgtHier,\n\
    \  'pAttr', pAttr,\n  'pUnwind', pUnwind\n);\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\nExecuteProcess('}bedrock.dim.attr.delete',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n  'pDim', pTgtDim,\n  'pAttr', cTempDim\n);\n\n\
    ExecuteProcess('}bedrock.dim.delete',\n  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\
    \t'pDim', cTempDim\n);\n\n\nIF(pRemove = 1);\n  ExecuteProcess('}bedrock.hier.unwind',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier,\n\t'pConsol',\
    \ pConsol,\n\t'pRecursive', 1\n);\n\n  ExecuteProcess('}bedrock.hier.emptyconsols.delete',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier\n);\n\nEndif;\n\
    \n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully cloned dimension:hierarchy %pSrcDim%:%pSrcHier%\
    \ to %pTgtDim%:%pTgtHier% based on the %pConsol% consolidated element.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates an alternative hierarchy from a consolidated
    element and its children in the default hierarchy. The use case involves both development and production
    scenarios, either by creating a new hierarchy for testing purposes or to reflect new business needs.
    Note that a valid source dimension name (pSrcDim) and source subset (pSubset) are mandatory, otherwise,
    the process will abort. If a source hierarchy name (pSrcHier) is specified, it also needs to be valid
    to avoid aborting. Caution: The target hierarchy cannot be ''Leaves'' and existing target hierarchies
    will be overwritten.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make an aternative hierarchy from a consolidated\
    \ element and its children in default hierarchy.\n\n# Use case: Intended for Development but could\
    \ be used in production too.\n# 1/ Create a new hierarchy for testing.\n# 2/ Create a new hierarchy\
    \ to reflect new business needs.\n\n# Note:\n# Valid source dimension name (pSrcDim) and source subset\
    \ (pSubset) are mandatory, otherwise the process will abort.\n# If a source hierarchy name (pSrcHier)\
    \ is specified, it needs to be valid, otherwise the process will abort.\n\n# Caution:\n# - Target\
    \ hierarchy cannot be `Leaves`.\n# - If the target Hierarchy already exists, then it will be overwritten.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%,\
    \ pSrcHier:%pSrcHier%, pConsol:%pConsol%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%,\
    \ pRemove:%pRemove%, pAliasSwap:%pAliasSwap%.';\ncHierAttr         = 'Bedrock.Descendant';\ncAttrVal\
    \          = 'Descendant';\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim\
    \ ) > 0 & pSrcHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error\
    \ by splitting dim:hier into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':',\
    \ pSrcDim ) + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim )\
    \ - 1 );\nEndIf;\n\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n    pTgtHier\
    \       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim        = SubSt(\
    \ pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n# Validate source dimension\nIF( Trim( pSrcDim\
    \ ) @= '' );\n    nErrors = 1;\n    sMessage = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n\
    \    sMessage = 'Invalid source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate source\
    \ Hierarchy\nIF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim, pSrcHier)\
    \ = 0);\n    nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\n\n## Validate consolidation\npConsol =\
    \ Trim( pConsol );\nIf( pConsol @<> '' );\n    If( ElementIndex ( pSrcDim, pSrcHier, pConsol ) = 0\
    \ );\n        nErrors = 1;\n        sMessage = 'The ' | pConsol | ' consolidation does not exist in\
    \ the '| pSrcDim |' dimension:Hierarchy ' | pSrcDim |':'| pSrcHier;\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n\n## Validate Attribute\nIf( pAliasSwap @= ''\
    \ );\n    nErrors = 1;\n    sMessage = 'The name of the attribute to swap not specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Validate target Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\nEndif;\n\
    \nIF( DimensionExists( pTgtDim ) = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n### Create target\
    \ dimension Hierarchy ###\nIF(pTgtHier @= '');\n    pTgtHier = pTgtDim;\nEndIf;\n\n##########################################\n\
    # Bedrock subprocesses\n\n\n#create subset\nExecuteProcess('}bedrock.hier.sub.create',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier,\n\t'pSub',\
    \ cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp', 1\n);\n\ncTempDim = pSrcDim|'_'| cTimeStamp |'_'| cRandomInt;\n\
    \nExecuteProcess('}bedrock.hier.create.fromsubset',\n  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n  'pSrcDim',pSrcDim,\n  'pSrcHier', pSrcHier,\n  'pSubset', cTempSub,\n \
    \ 'pTgtDim', cTempDim,\n  'pTgtHier', cTempDim,\n  'pAttr', 1,\n  'pUnwind', 0\n);\n\nExecuteProcess('}bedrock.dim.attr.create',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pDim',cTempDim,\n\
    \  'pAttr', cTempDim,\n  'pAttrType','A'\n);\n\nExecuteProcess('}bedrock.cube.data.copy',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n  'pCube', '}ElementAttributes_'|cTempDim,\n  'pEleMapping','}ElementAttributes_'|cTempDim|':'|pAliasSwap|'->'|cTempDim\n\
    );\n\nExecuteProcess('}bedrock.dim.attr.swapalias',\n  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n  'pDim',cTempDim,\n  'pAlias', cTempDim\n);\n\nExecuteProcess('}bedrock.hier.sub.create',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim', cTempDim,\n\
    \t'pHier', cTempDim,\n\t'pSub', cTempSub,\n\t'pConsol', pConsol,\n\t'pTemp', 0\n);\n\nExecuteProcess('}bedrock.hier.create.fromsubset',\n\
    \  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n  'pSrcDim', cTempDim,\n\
    \  'pSrcHier', cTempDim,\n  'pSubset', cTempSub,\n  'pTgtDim', pTgtDim,\n  'pTgtHier', pTgtHier,\n\
    \  'pAttr', pAttr,\n  'pUnwind', pUnwind\n);\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\nExecuteProcess('}bedrock.dim.attr.delete',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n  'pDim', pTgtDim,\n  'pAttr', cTempDim\n);\n\n\
    ExecuteProcess('}bedrock.dim.delete',\n  'pLogOutput',pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\
    \t'pDim', cTempDim\n);\n\n\nIF(pRemove = 1);\n  ExecuteProcess('}bedrock.hier.unwind',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier,\n\t'pConsol',\
    \ pConsol,\n\t'pRecursive', 1\n);\n\n  ExecuteProcess('}bedrock.hier.emptyconsols.delete',\n  'pLogOutput',pLogOutput,\n\
    \  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pSrcDim,\n\t'pHier', pSrcHier\n);\n\nEndif;\n\
    \n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully cloned dimension:hierarchy %pSrcDim%:%pSrcHier%\
    \ to %pTgtDim%:%pTgtHier% based on the %pConsol% consolidated element.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine Kopie eines bestehenden Dimensions-Subsets
    erstellt und es als neue Dimension-Hierarchie anlegt. Der Prozess ist für Entwicklungszwecke gedacht,
    kann jedoch auch in der Produktion eingesetzt werden. Erstelle eine neue Hierarchie für Tests oder
    um neuen geschäftlichen Anforderungen gerecht zu werden. Beachte, dass der Name der Quelldimension
    (pSrcDim) und das Quell-Subset (pSubset) zwingend erforderlich sind; andernfalls bricht der Prozess
    ab. Wenn ein Name der Quellhierarchie (pSrcHier) angegeben wird, muss dieser gültig sein, ansonsten
    wird der Prozess abgebrochen. Vorsicht: Die Zielhierarchie kann nicht ''Leaves'' sein. Wenn die Zielhierarchie
    bereits existiert, wird sie überschrieben.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make a copy of an existing dimension subset, creating\
    \ it as a new dimension hierarchy.\n\n# Use case: Intended for Development but could be used in production\
    \ too.\n# 1. Create a new hierarchy for testing.\n# 2. Create a new hierarchy to reflect new business\
    \ needs.\n\n# Note:\n# Valid source dimension name (pSrcDim) and source subset (pSubset) are mandatory,\
    \ otherwise the process will abort.\n# If a source hierarchy name (pSrcHier) is specified, it needs\
    \ to be valid, otherwise the process will abort.\n\n# Caution:\n# - Target hierarchy cannot be Leaves.\n\
    # - If the target Hierarchy already exists, then it will be overwritten.\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%,\
    \ pSrcHier:%pSrcHier%, pSubset:%pSubset%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%,\
    \ pFlat:%pFlat%.';\ncHierAttr         = 'Bedrock.Descendant';\ncAttrVal          = 'Descendant';\n\
    \n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \n\
    ENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= ''\
    \ );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long(\
    \ pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\nEndIf;\n\nIf(\
    \ Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy has been passed as dimension. Handle\
    \ the input error by splitting dim:hier into dimension & hierarchy\n    pTgtHier       = SubSt( pTgtDim,\
    \ Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':',\
    \ pTgtDim ) - 1 );\nEndIf;\n\n# Validate source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \ source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n   If( pStrictErrorHandling = 1 );\
    \ \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate source Hierarchy\n\
    IF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim, pSrcHier) = 0);\n  \
    \  nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;\n\n## Validate Source Subset\nIF(HierarchySubsetExists( pSrcDim,\
    \ pSrcHier, pSubset) = 0 );\n    sMessage = 'No valid source subset: ' | pSubset;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nELSE;\n    cSubset = pSubset;\n    nSubsetSize =\
    \ HierarchySubsetGetSize( pSrcDim, pSrcHier, pSubset );\nENDIF;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Validate target Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\nEndif;\n\
    \nIF( DimensionExists( pTgtDim ) = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n### Create target\
    \ dimension Hierarchy ###\nIF(pTgtHier @= '');\n    pTgtHier = pTgtDim;\nEndIf;\n\n\nIf( HierarchyExists(pTgtDim,\
    \ pTgtHier) = 0 );\n    HierarchyCreate( pTgtDim, pTgtHier );\nElse;\n    IF(pUnwind = 1 );\n    \
    \    ExecuteProcess( '}bedrock.hier.unwind', 'pLogOutput', 0,\n            'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n            'pDim', pTgtDim, 'pHier', pTgtHier, 'pConsol', '*',\n       \
    \     'pRecursive', 1\n        );\n    ELSEIF(\n        pUnwind = 2 );\n        #Do nothing\n    ELSE;\n\
    \        HierarchyDeleteAllElements( pTgtDim, pTgtHier );\n    EndIf;\nEndIf;\n\n### Assign Data Source\
    \ ###\nDatasourceNameForServer = pSrcDim|':'|pSrcHier;\nDatasourceNameForClient = pSrcDim|':'|pSrcHier;\n\
    DataSourceType = 'SUBSET';\nDatasourceDimensionSubset = cSubset;\n\n### Set Descendent attribute value\n\
    AttrDelete( pSrcDim, cHierAttr );\nAttrInsert( pSrcDim, '', cHierAttr, 'S' );\n\n# Disable excessive\
    \ transaction logging of the attributes cube if it is logged\nsAttrCube = '}ElementAttributes_' |\
    \ pSrcDim;\nnAttrCubeLogChanges = CubeGetLogChanges(sAttrCube);\nIf( nAttrCubeLogChanges = 1 );\n\
    \   CubeSetLogChanges( sAttrCube, 0 );\nEndIf;\n\nnIndex = 1;\nnLimit = HierarchySubsetGetSize( pSrcDim,\
    \ pSrcHier, pSubset );\nWHILE( nIndex <= nLimit);\n    sElName = SubsetGetElementName( pSrcDim|':'|pSrcHier,\
    \ pSubset, nIndex );\n    ElementAttrPuts( cAttrVal, pSrcDim, pSrcHier, sElName, cHierAttr );\n  \
    \  sElType = ElementType( pSrcDim, pSrcHier, sElName );\n    HierarchyElementInsert(pTgtDim, pTgtHier,\
    \ '',sElName, sELType);\n    nIndex = nIndex + 1;\nEND;\n\n# Re-enable transaction logging setting\
    \ of the attributes cube if required\nIf( nAttrCubeLogChanges = 1 );\n   CubeSetLogChanges( sAttrCube,\
    \ 1 );\nEndIf;\n\n### Replicate Attributes ###\n# Note: DType on Attr dim returns 'AS', 'AN' or 'AA'\
    \ need to strip off leading 'A'\n \nsAttrDim = '}ElementAttributes_' | pSrcDim;\nsLastAttr = '';\n\
    If( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n    nNumAttrs = DimSiz( sAttrDim );\n    nCount\
    \ = 1;\n    While( nCount <= nNumAttrs );\n        sAttrName = DimNm( sAttrDim, nCount );\n      \
    \  sAttrType = SubSt(DType( sAttrDim, sAttrName ), 2, 1 );\n        AttrInsert( pTgtDim, sLastAttr,\
    \ sAttrName, sAttrType );\n        sLastAttr = sAttrName;\n        nCount = nCount + 1;\n    End;\n\
    EndIf;\n \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Check for errors in prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nIf (pFlat = 1);\n\
    \    ##Creating the Flat hierarchy subset in the target dimension\n    sElType = ElementType(pSrcDim,\
    \ pSrcHier, vElement);\n    ## Add the element to the target dimension.\n    ## 'C' elements can't\
    \ be inserted as 'N' elements in the same dimension\n    IF(pTgtdim @= pSrcDim);\n        IF(sElType\
    \ @<> 'C' );\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement, sElType );\n  \
    \      Else;\n            If( pLogOutput = 1 );\n                sMessage = 'Name conflict! Cannot\
    \ create leaf element %vElement% in dimension %pTgtDim% as C element with same name already exists.';\n\
    \                LogOutput( 'WARN', Expand( cMsgErrorContent ) );\n            EndIf;\n        EndIf;\n\
    \    Else;\n        IF(sElType @= 'C' );\n            HierarchyElementInsert( pTgtDim, pTgtHier, '',\
    \ vElement, 'N' );\n        Else;\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement,\
    \ sElType );\n        EndIf;\n    EndIf;\nElse;\n    nIndex = 1;\n    nLimit = ElementComponentCount(\
    \ pSrcDim, pSrcHier, vElement );\n    WHILE( nIndex <= nLimit );\n        sElName = ElementComponent(\
    \ pSrcDim, pSrcHier, vElement, nIndex );\n        sDecendant = ElementAttrS(pSrcDim, pSrcHier, sElName,\
    \ cHierAttr);\n        IF(\n            sDecendant @= cAttrVal);\n            nElWeight = ElementWeight(\
    \ pSrcDim, pSrcHier, vElement, sElName );\n            HierarchyElementComponentAdd( pTgtDim, pTgtHier,\
    \ vElement, sElName, nElWeight );\n        ENDIF;\n        nIndex = nIndex + 1;\n    END;\nEndif;\n\
    \n### End MetaData ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n\n### Check for errors in prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n\n### Replicate\
    \ Attributes ###\n\n# Note: DTYPE on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading\
    \ 'A'\n\nIf( pAttr = 1 );\n\n    nCount = 1;\n    While( nCount <= nNumAttrs );\n        sAttrName\
    \ = DimNm( sAttrDim, nCount );\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ), 2, 1 );\n\
    \        If( sAttrType @= 'S' % sAttrType @= 'A' );\n            sAttrVal = ElementAttrS(pSrcDim,\
    \ pSrcHier, vElement, sAttrName);\n            If( sAttrVal @<> '' );\n                ElementAttrPutS(\
    \ sAttrVal, pTgtDim,pTgtHier, vElement, sAttrName,1 );\n            EndIf;\n        Else;\n      \
    \      nAttrVal = ElementAttrN(pSrcDim, pSrcHier, vElement, sAttrName);\n            If( nAttrVal\
    \ <> 0 );\n                ElementAttrPutN( nAttrVal, pTgtDim, pTgtHier, vElement, sAttrName );\n\
    \            EndIf;\n        EndIf;\n        nCount = nCount + 1;\n    End;\n\n  EndIf;\n\n### End\
    \ Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Set Target dimension sort order ###\n\nIf(pSrcDim @= pSrcHier);\n    sSourceElement = pSrcDim;\n\
    Else;\n    sSourceElement = pSrcDim|':'|pSrcHier;\nEndif;\nIf(pTgtDim @= pTgtHier);\n    sTargetElement\
    \ = pTgtDim;\nElse;\n    sTargetElement = pTgtDim|':'|pTgtHier;\nEndif;\n\nsCube = '}DimensionProperties';\n\
    IF(CubeExists ( sCube ) = 1 );\n  sEleMapping = '}Dimensions' |'¦'|sSourceElement|'->'|sTargetElement;\n\
    \  ExecuteProcess( '}bedrock.cube.data.copy',\n  'pLogOutput', pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n  'pCube', sCube,\n  'pSrcView', '',\n  'pTgtView', '',\n  'pFilter',  '',\n\
    \  'pEleMapping', sEleMapping,\n  'pMappingDelim','->',\n  'pFactor', 1,\n  'pDimDelim', '&',\n  'pEleStartDelim',\
    \ '¦',\n  'pEleDelim', '+',\n  'pSuppressRules', 0 ,\n  'pCumulate', 0 ,\n  'pZeroSource', 0, \n \
    \ 'pZeroTarget', 1,\n  'pTemp', 1\n   );\nENDIF;\n  \nsCube = '}HierarchyProperties';\nIF(CubeExists\
    \ ( sCube ) = 1 );\n  sEleMapping = '}Dimensions' |'¦'|sSourceElement|'->'|sTargetElement;\n  ExecuteProcess(\
    \ '}bedrock.cube.data.copy',\n  'pLogOutput', pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\
    \  'pCube', sCube,\n  'pSrcView', '',\n  'pTgtView', '',\n  'pFilter',  '',\n  'pEleMapping', sEleMapping,\n\
    \  'pMappingDelim','->',\n  'pFactor', 1,\n  'pDimDelim', '&',\n  'pEleStartDelim', '¦',\n  'pEleDelim',\
    \ '+',\n  'pSuppressRules', 0 ,\n  'pCumulate', 0 ,\n  'pZeroSource', 0, \n  'pZeroTarget', 1,\n \
    \ 'pTemp', 1\n   );\nENDIF;\n\n\n### Set Descendent attribute value\nAttrDelete( pSrcDim, cHierAttr\
    \ );\nIf( pAttr = 1 );\n    AttrDelete( pTgtDim, cHierAttr );\nENDIF;\n\n### Return code & final error\
    \ message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully cloned dimension:hierarchy %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based on the\
    \ %pSubset% subset.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that makes a copy of an existing dimension subset
    and creates it as a new dimension hierarchy. The process is intended for development purposes but
    can also be used in production. Create a new hierarchy for testing or to reflect new business needs.
    Note that a valid source dimension name (pSrcDim) and source subset (pSubset) are mandatory; otherwise,
    the process will abort. If a source hierarchy name (pSrcHier) is specified, it must be valid; otherwise,
    the process will abort. Caution: The target hierarchy cannot be ''Leaves''. If the target hierarchy
    already exists, it will be overwritten.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will make a copy of an existing dimension subset, creating\
    \ it as a new dimension hierarchy.\n\n# Use case: Intended for Development but could be used in production\
    \ too.\n# 1. Create a new hierarchy for testing.\n# 2. Create a new hierarchy to reflect new business\
    \ needs.\n\n# Note:\n# Valid source dimension name (pSrcDim) and source subset (pSubset) are mandatory,\
    \ otherwise the process will abort.\n# If a source hierarchy name (pSrcHier) is specified, it needs\
    \ to be valid, otherwise the process will abort.\n\n# Caution:\n# - Target hierarchy cannot be Leaves.\n\
    # - If the target Hierarchy already exists, then it will be overwritten.\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode = 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName   \
    \      = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'|\
    \ cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%,\
    \ pSrcHier:%pSrcHier%, pSubset:%pSubset%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pAttr:%pAttr%, pUnwind:%pUnwind%,\
    \ pFlat:%pFlat%.';\ncHierAttr         = 'Bedrock.Descendant';\ncAttrVal          = 'Descendant';\n\
    \n## LogOutput parameters\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \n\
    ENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\nIf( Scan( ':', pSrcDim ) > 0 & pSrcHier @= ''\
    \ );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan( ':', pSrcDim ) + 1, Long(\
    \ pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim ) - 1 );\nEndIf;\n\nIf(\
    \ Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy has been passed as dimension. Handle\
    \ the input error by splitting dim:hier into dimension & hierarchy\n    pTgtHier       = SubSt( pTgtDim,\
    \ Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim        = SubSt( pTgtDim, 1, Scan( ':',\
    \ pTgtDim ) - 1 );\nEndIf;\n\n# Validate source dimension\nIF( Trim( pSrcDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIF( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \ source dimension: ' | pSrcDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n   If( pStrictErrorHandling = 1 );\
    \ \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Validate source Hierarchy\n\
    IF(pSrcHier @= '');\n    pSrcHier = pSrcDim;\nElseIf(HierarchyExists(pSrcDim, pSrcHier) = 0);\n  \
    \  nErrors = 1;\n    sMessage = 'Invalid source hierarchy: ' | pSrcHier;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;\n\n## Validate Source Subset\nIF(HierarchySubsetExists( pSrcDim,\
    \ pSrcHier, pSubset) = 0 );\n    sMessage = 'No valid source subset: ' | pSubset;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nELSE;\n    cSubset = pSubset;\n    nSubsetSize =\
    \ HierarchySubsetGetSize( pSrcDim, pSrcHier, pSubset );\nENDIF;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n## Validate target Dimension\nIf(pTgtDim @= '');\n    pTgtDim = pSrcDim;\nEndif;\n\
    \nIF( DimensionExists( pTgtDim ) = 0 );\n   DimensionCreate(pTgtDim);\nEndIf;\n\n### Create target\
    \ dimension Hierarchy ###\nIF(pTgtHier @= '');\n    pTgtHier = pTgtDim;\nEndIf;\n\n\nIf( HierarchyExists(pTgtDim,\
    \ pTgtHier) = 0 );\n    HierarchyCreate( pTgtDim, pTgtHier );\nElse;\n    IF(pUnwind = 1 );\n    \
    \    ExecuteProcess( '}bedrock.hier.unwind', 'pLogOutput', 0,\n            'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n            'pDim', pTgtDim, 'pHier', pTgtHier, 'pConsol', '*',\n       \
    \     'pRecursive', 1\n        );\n    ELSEIF(\n        pUnwind = 2 );\n        #Do nothing\n    ELSE;\n\
    \        HierarchyDeleteAllElements( pTgtDim, pTgtHier );\n    EndIf;\nEndIf;\n\n### Assign Data Source\
    \ ###\nDatasourceNameForServer = pSrcDim|':'|pSrcHier;\nDatasourceNameForClient = pSrcDim|':'|pSrcHier;\n\
    DataSourceType = 'SUBSET';\nDatasourceDimensionSubset = cSubset;\n\n### Set Descendent attribute value\n\
    AttrDelete( pSrcDim, cHierAttr );\nAttrInsert( pSrcDim, '', cHierAttr, 'S' );\n\n# Disable excessive\
    \ transaction logging of the attributes cube if it is logged\nsAttrCube = '}ElementAttributes_' |\
    \ pSrcDim;\nnAttrCubeLogChanges = CubeGetLogChanges(sAttrCube);\nIf( nAttrCubeLogChanges = 1 );\n\
    \   CubeSetLogChanges( sAttrCube, 0 );\nEndIf;\n\nnIndex = 1;\nnLimit = HierarchySubsetGetSize( pSrcDim,\
    \ pSrcHier, pSubset );\nWHILE( nIndex <= nLimit);\n    sElName = SubsetGetElementName( pSrcDim|':'|pSrcHier,\
    \ pSubset, nIndex );\n    ElementAttrPuts( cAttrVal, pSrcDim, pSrcHier, sElName, cHierAttr );\n  \
    \  sElType = ElementType( pSrcDim, pSrcHier, sElName );\n    HierarchyElementInsert(pTgtDim, pTgtHier,\
    \ '',sElName, sELType);\n    nIndex = nIndex + 1;\nEND;\n\n# Re-enable transaction logging setting\
    \ of the attributes cube if required\nIf( nAttrCubeLogChanges = 1 );\n   CubeSetLogChanges( sAttrCube,\
    \ 1 );\nEndIf;\n\n### Replicate Attributes ###\n# Note: DType on Attr dim returns 'AS', 'AN' or 'AA'\
    \ need to strip off leading 'A'\n \nsAttrDim = '}ElementAttributes_' | pSrcDim;\nsLastAttr = '';\n\
    If( pAttr = 1 & DimensionExists( sAttrDim ) = 1 );\n    nNumAttrs = DimSiz( sAttrDim );\n    nCount\
    \ = 1;\n    While( nCount <= nNumAttrs );\n        sAttrName = DimNm( sAttrDim, nCount );\n      \
    \  sAttrType = SubSt(DType( sAttrDim, sAttrName ), 2, 1 );\n        AttrInsert( pTgtDim, sLastAttr,\
    \ sAttrName, sAttrType );\n        sLastAttr = sAttrName;\n        nCount = nCount + 1;\n    End;\n\
    EndIf;\n \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Check for errors in prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nIf (pFlat = 1);\n\
    \    ##Creating the Flat hierarchy subset in the target dimension\n    sElType = ElementType(pSrcDim,\
    \ pSrcHier, vElement);\n    ## Add the element to the target dimension.\n    ## 'C' elements can't\
    \ be inserted as 'N' elements in the same dimension\n    IF(pTgtdim @= pSrcDim);\n        IF(sElType\
    \ @<> 'C' );\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement, sElType );\n  \
    \      Else;\n            If( pLogOutput = 1 );\n                sMessage = 'Name conflict! Cannot\
    \ create leaf element %vElement% in dimension %pTgtDim% as C element with same name already exists.';\n\
    \                LogOutput( 'WARN', Expand( cMsgErrorContent ) );\n            EndIf;\n        EndIf;\n\
    \    Else;\n        IF(sElType @= 'C' );\n            HierarchyElementInsert( pTgtDim, pTgtHier, '',\
    \ vElement, 'N' );\n        Else;\n            HierarchyElementInsert( pTgtDim, pTgtHier, '', vElement,\
    \ sElType );\n        EndIf;\n    EndIf;\nElse;\n    nIndex = 1;\n    nLimit = ElementComponentCount(\
    \ pSrcDim, pSrcHier, vElement );\n    WHILE( nIndex <= nLimit );\n        sElName = ElementComponent(\
    \ pSrcDim, pSrcHier, vElement, nIndex );\n        sDecendant = ElementAttrS(pSrcDim, pSrcHier, sElName,\
    \ cHierAttr);\n        IF(\n            sDecendant @= cAttrVal);\n            nElWeight = ElementWeight(\
    \ pSrcDim, pSrcHier, vElement, sElName );\n            HierarchyElementComponentAdd( pTgtDim, pTgtHier,\
    \ vElement, sElName, nElWeight );\n        ENDIF;\n        nIndex = nIndex + 1;\n    END;\nEndif;\n\
    \n### End MetaData ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n\n### Check for errors in prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n\n### Replicate\
    \ Attributes ###\n\n# Note: DTYPE on Attr dim returns 'AS', 'AN' or 'AA' need to strip off leading\
    \ 'A'\n\nIf( pAttr = 1 );\n\n    nCount = 1;\n    While( nCount <= nNumAttrs );\n        sAttrName\
    \ = DimNm( sAttrDim, nCount );\n        sAttrType = SubSt( DTYPE( sAttrDim, sAttrName ), 2, 1 );\n\
    \        If( sAttrType @= 'S' % sAttrType @= 'A' );\n            sAttrVal = ElementAttrS(pSrcDim,\
    \ pSrcHier, vElement, sAttrName);\n            If( sAttrVal @<> '' );\n                ElementAttrPutS(\
    \ sAttrVal, pTgtDim,pTgtHier, vElement, sAttrName,1 );\n            EndIf;\n        Else;\n      \
    \      nAttrVal = ElementAttrN(pSrcDim, pSrcHier, vElement, sAttrName);\n            If( nAttrVal\
    \ <> 0 );\n                ElementAttrPutN( nAttrVal, pTgtDim, pTgtHier, vElement, sAttrName );\n\
    \            EndIf;\n        EndIf;\n        nCount = nCount + 1;\n    End;\n\n  EndIf;\n\n### End\
    \ Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Set Target dimension sort order ###\n\nIf(pSrcDim @= pSrcHier);\n    sSourceElement = pSrcDim;\n\
    Else;\n    sSourceElement = pSrcDim|':'|pSrcHier;\nEndif;\nIf(pTgtDim @= pTgtHier);\n    sTargetElement\
    \ = pTgtDim;\nElse;\n    sTargetElement = pTgtDim|':'|pTgtHier;\nEndif;\n\nsCube = '}DimensionProperties';\n\
    IF(CubeExists ( sCube ) = 1 );\n  sEleMapping = '}Dimensions' |'¦'|sSourceElement|'->'|sTargetElement;\n\
    \  ExecuteProcess( '}bedrock.cube.data.copy',\n  'pLogOutput', pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n  'pCube', sCube,\n  'pSrcView', '',\n  'pTgtView', '',\n  'pFilter',  '',\n\
    \  'pEleMapping', sEleMapping,\n  'pMappingDelim','->',\n  'pFactor', 1,\n  'pDimDelim', '&',\n  'pEleStartDelim',\
    \ '¦',\n  'pEleDelim', '+',\n  'pSuppressRules', 0 ,\n  'pCumulate', 0 ,\n  'pZeroSource', 0, \n \
    \ 'pZeroTarget', 1,\n  'pTemp', 1\n   );\nENDIF;\n  \nsCube = '}HierarchyProperties';\nIF(CubeExists\
    \ ( sCube ) = 1 );\n  sEleMapping = '}Dimensions' |'¦'|sSourceElement|'->'|sTargetElement;\n  ExecuteProcess(\
    \ '}bedrock.cube.data.copy',\n  'pLogOutput', pLogOutput,\n  'pStrictErrorHandling', pStrictErrorHandling,\n\
    \  'pCube', sCube,\n  'pSrcView', '',\n  'pTgtView', '',\n  'pFilter',  '',\n  'pEleMapping', sEleMapping,\n\
    \  'pMappingDelim','->',\n  'pFactor', 1,\n  'pDimDelim', '&',\n  'pEleStartDelim', '¦',\n  'pEleDelim',\
    \ '+',\n  'pSuppressRules', 0 ,\n  'pCumulate', 0 ,\n  'pZeroSource', 0, \n  'pZeroTarget', 1,\n \
    \ 'pTemp', 1\n   );\nENDIF;\n\n\n### Set Descendent attribute value\nAttrDelete( pSrcDim, cHierAttr\
    \ );\nIf( pAttr = 1 );\n    AttrDelete( pTgtDim, cHierAttr );\nENDIF;\n\n### Return code & final error\
    \ message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully cloned dimension:hierarchy %pSrcDim%:%pSrcHier% to %pTgtDim%:%pTgtHier% based on the\
    \ %pSubset% subset.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine Dimension oder Hierarchie (oder eine
    Liste davon) löscht. Anwendungsfall: Gedacht für Entwicklung/Prototyping, um ungenutzte Dimensionen/Hierarchien
    nach dem Go-Live zu bereinigen. Hinweis: Ein gültiger Dimensionsname (pDim) ist zwingend erforderlich,
    sonst wird der Prozess abgebrochen. Wenn keine Hierarchie (pHier) angegeben ist, wird die Dimension
    gelöscht, sofern sie nicht von einem regulären Würfel verwendet wird. Bei Angabe einer Hierarchie
    muss diese gültig sein, andernfalls wird der Prozess abgebrochen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a dimension or hierarchy (or a list thereof).\n\
    \n# Use case: Intended for development/prototyping.\n# 1/ Clean up unused dimension/hierarchies after\
    \ Go Live.\n\n# Note:\n# Naturally, a valid dimension name (pDim) is mandatory otherwise the process\
    \ will abort.\n# If no hierarchy (pHier) is specified the dimension will be deleted if not in use\
    \ by a **regular** cube.\n# If a hierarchy is specified, it must be valid otherwise the process will\
    \ abort.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName    \
    \     = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo     \
    \     = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pDelim:%pDelim%.';\
    \ \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?',\
    \ pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No\
    \ dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( Scan(\
    \ '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & DimensionExists( pDim ) = 0\
    \ );\n    nErrors = 1;\n    sMessage = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  ## use same name as Dimension.\
    \ Since wildcards are allowed this is managed inside the code below\nElseIf( Trim( pHier ) @= 'Leaves'\
    \ );\n  nErrors = 1;\n  sMessage = 'Invalid hierarchy: 'Leaves'.';\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElseIf(  Scan( '*', pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim,\
    \ pHier ) = 0 & Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Trim( pHier\
    \ ) @= Trim( pDim ) );\n  nErrors = 1;\n  sMessage = 'Cannot delete same named hierarchy: '}bedrock.dim.delete'\
    \ process should be used for this purpose';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n  \
    \  pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n\nIF( Scan( '*',\
    \ pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pDim ) = 0 & Scan(\
    \ '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 );\n    If( HierarchyExists( pDim, pHier ) = 0 );\n \
    \       nError = 1;\n        sMessage = 'The Hierachy '' | pHier | '' is not available in '' | pDim\
    \ | '' dimension' ;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n\
    \        HierarchyDestroy( pDim  ,pHier );\n    Endif;\nElseIf( pHier @= 'Leaves');\n    nError =\
    \ 1;\n    sMessage = 'The Hierachy is Leaves and can not be destroyed';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElse;\n    # Loop through dimensions in pDim\n    sDims = pDim;\n\
    \    nDimDelimiterIndex = 1;\n    sMdx = '';\n    # Get 1st dimension\n    While( nDimDelimiterIndex\
    \ <> 0 );\n        # Extract 1st dimension > sDim\n        nDimDelimiterIndex = Scan( pDelim, sDims\
    \ );\n        If( nDimDelimiterIndex = 0 );\n            sDim = sDims;\n        Else;\n          \
    \  sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n            sDims = Trim( Subst( sDims,\
    \ nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n        EndIf;\n        \n          # Create\
    \ subset of dimensions using Wildcard to loop through dimensions in pDim with wildcard\n        sDimExp\
    \ = '''|sDim|''';\n        sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] )\
    \ , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n        IF(\
    \ sMdx @= ''); \n          sMdx = sMdxPart; \n        ELSE;\n          sMdx = sMdx | ' + ' | sMdxPart;\n\
    \        ENDIF;\n    End;\n    \n    If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n       \
    \ # If a delimited list of dim names includes wildcards then we may have to re-use the subset multiple\
    \ times\n        SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n    Else;\n        # temp subset,\
    \ therefore no need to destroy in epilog\n        SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions'\
    \ , 1 );\n    EndIf;\n    \n    # Loop through dimensions in subset created based on wildcard\n  \
    \  nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n    While( nCountDim >= 1 );\n        sDim\
    \ = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim );\n        # Validate dimension name\n\
    \        If( DimensionExists(sDim) = 0 );\n            nErrors = 1;\n            sMessage = Expand(\
    \ 'Dimension %sDim% does not exist.' );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n        Else;\n            If( pLogOutput = 1 );\n              sMessage = Expand( 'Dimension\
    \ %sDim% being processed....' );\n              LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n\
    \            EndIf;\n            # Loop through hierarchies in pHier\n            If( Trim( pHier\
    \ ) @= '' );\n              ### Use main hierarchy for each dimension if pHier is empty\n        \
    \      sHierarchies = sDim;\n            Else;\n              sHierarchies              = pHier;\n\
    \            EndIf;\n            nDelimiterIndexA    = 1;\n            sHierDim            = '}Hierarchies_'|sDim\
    \ ;\n            sMdxHier = '';\n            While( nDelimiterIndexA <> 0 );\n    \n             \
    \   nDelimiterIndexA = Scan( pDelim, sHierarchies );\n                If( nDelimiterIndexA = 0 );\n\
    \                    sHierarchy   = sHierarchies;\n                Else;\n                    sHierarchy\
    \   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n                    sHierarchies  =\
    \ Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n        \
    \        EndIf;\n                \n                # Create subset of Hierarchies using Wildcard\n\
    \                sHierExp = '''|sDim|':'|sHierarchy|''';\n                sMdxHierPart = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp | ')}';\n                IF( sMdxHier @= ''); \n \
    \                 sMdxHier = sMdxHierPart; \n                ELSE;\n                  sMdxHier = sMdxHier\
    \ | ' + ' | sMdxHierPart;\n                ENDIF;\n            End;\n    \n            If( SubsetExists(\
    \ sHierDim, cTempSub ) = 1 );\n                # If a delimited list of attr names includes wildcards\
    \ then we may have to re-use the subset multiple times\n                SubsetMDXSet( sHierDim, cTempSub,\
    \ sMdxHier );\n            Else;\n                # temp subset, therefore no need to destroy in epilog\n\
    \                SubsetCreatebyMDX( cTempSub, sMdxHier, sHierDim, 1 );\n            EndIf;\n     \
    \   \n            # Loop through subset of hierarchies created based on wildcard\n            nCountHier\
    \ = SubsetGetSize( sHierDim, cTempSub );\n            While( nCountHier >= 1 );\n                sCurrHier\
    \ = SubsetGetElementName( sHierDim, cTempSub, nCountHier );\n                sCurrHierName = Subst(\
    \ sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n                \n                # Validate\
    \ hierarchy name in dimension\n                If( Dimix( sHierDim , sCurrHier ) = 0 );\n        \
    \            sMessage = Expand('The %sCurrHier% hierarchy does NOT exist in the %sDim% dimension.');\n\
    \                    LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n                Else;\n   \
    \               If( pLogOutput = 1 );\n                    sMessage = Expand( 'Hierarchy %sCurrHierName%\
    \ in Dimension %sDim% being processed....' );\n                    LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n                  EndIf;\n                  If( Trim( sCurrHierName ) @= Trim( sDim ) );\n\
    \                      ## Do not remove main hierarchy\n                  ElseIf( sCurrHierName @=\
    \ 'Leaves');\n                      If( pLogOutput = 1 );\n                        sMessage = 'The\
    \ Hierachy is Leaves and can not be destroyed';\n                        LogOutput( 'INFO', Expand(\
    \ cMsgInfoContent ) );\n                      EndIf;\n                  Else;\n                  \
    \    HierarchyDestroy( sDim, sCurrHierName );\n                      If( pLogOutput = 1 );\n     \
    \                   sMessage = Expand( 'Destroying hierarchy %sCurrHierName% in Dimension %sDim%'\
    \ );\n                      LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n                  EndIf;\n\
    \                  Endif;\n                Endif;\n              \n                nCountHier = nCountHier\
    \ - 1;\n            End;\n                \n        EndIf;\n        \n        nCountDim = nCountDim\
    \ - 1;\n    End;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction     = Expand( 'Process:%cThisProcName% successfully deleted the dimension:hierarchy\
    \ %pDim%:%pHier%' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that deletes a dimension or hierarchy (or a list
    thereof). Use case: Intended for development/prototyping to clean up unused dimensions/hierarchies
    after Go-Live. Note: A valid dimension name (pDim) is mandatory; otherwise, the process will abort.
    If no hierarchy (pHier) is specified, the dimension will be deleted if not in use by a regular cube.
    If a hierarchy is specified, it must be valid; otherwise, the process will abort.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes a dimension or hierarchy (or a list thereof).\n\
    \n# Use case: Intended for development/prototyping.\n# 1/ Clean up unused dimension/hierarchies after\
    \ Go Live.\n\n# Note:\n# Naturally, a valid dimension name (pDim) is mandatory otherwise the process\
    \ will abort.\n# If no hierarchy (pHier) is specified the dimension will be deleted if not in use\
    \ by a **regular** cube.\n# If a hierarchy is specified, it must be valid otherwise the process will\
    \ abort.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName    \
    \     = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo     \
    \     = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pDelim:%pDelim%.';\
    \ \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?',\
    \ pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No\
    \ dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( Scan(\
    \ '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & DimensionExists( pDim ) = 0\
    \ );\n    nErrors = 1;\n    sMessage = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  ## use same name as Dimension.\
    \ Since wildcards are allowed this is managed inside the code below\nElseIf( Trim( pHier ) @= 'Leaves'\
    \ );\n  nErrors = 1;\n  sMessage = 'Invalid hierarchy: 'Leaves'.';\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElseIf(  Scan( '*', pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim,\
    \ pHier ) = 0 & Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Trim( pHier\
    \ ) @= Trim( pDim ) );\n  nErrors = 1;\n  sMessage = 'Cannot delete same named hierarchy: '}bedrock.dim.delete'\
    \ process should be used for this purpose';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n  \
    \  pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n\nIF( Scan( '*',\
    \ pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pDim ) = 0 & Scan(\
    \ '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 );\n    If( HierarchyExists( pDim, pHier ) = 0 );\n \
    \       nError = 1;\n        sMessage = 'The Hierachy '' | pHier | '' is not available in '' | pDim\
    \ | '' dimension' ;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Else;\n\
    \        HierarchyDestroy( pDim  ,pHier );\n    Endif;\nElseIf( pHier @= 'Leaves');\n    nError =\
    \ 1;\n    sMessage = 'The Hierachy is Leaves and can not be destroyed';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElse;\n    # Loop through dimensions in pDim\n    sDims = pDim;\n\
    \    nDimDelimiterIndex = 1;\n    sMdx = '';\n    # Get 1st dimension\n    While( nDimDelimiterIndex\
    \ <> 0 );\n        # Extract 1st dimension > sDim\n        nDimDelimiterIndex = Scan( pDelim, sDims\
    \ );\n        If( nDimDelimiterIndex = 0 );\n            sDim = sDims;\n        Else;\n          \
    \  sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n            sDims = Trim( Subst( sDims,\
    \ nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n        EndIf;\n        \n          # Create\
    \ subset of dimensions using Wildcard to loop through dimensions in pDim with wildcard\n        sDimExp\
    \ = '''|sDim|''';\n        sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] )\
    \ , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n        IF(\
    \ sMdx @= ''); \n          sMdx = sMdxPart; \n        ELSE;\n          sMdx = sMdx | ' + ' | sMdxPart;\n\
    \        ENDIF;\n    End;\n    \n    If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n       \
    \ # If a delimited list of dim names includes wildcards then we may have to re-use the subset multiple\
    \ times\n        SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n    Else;\n        # temp subset,\
    \ therefore no need to destroy in epilog\n        SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions'\
    \ , 1 );\n    EndIf;\n    \n    # Loop through dimensions in subset created based on wildcard\n  \
    \  nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n    While( nCountDim >= 1 );\n        sDim\
    \ = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim );\n        # Validate dimension name\n\
    \        If( DimensionExists(sDim) = 0 );\n            nErrors = 1;\n            sMessage = Expand(\
    \ 'Dimension %sDim% does not exist.' );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n        Else;\n            If( pLogOutput = 1 );\n              sMessage = Expand( 'Dimension\
    \ %sDim% being processed....' );\n              LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n\
    \            EndIf;\n            # Loop through hierarchies in pHier\n            If( Trim( pHier\
    \ ) @= '' );\n              ### Use main hierarchy for each dimension if pHier is empty\n        \
    \      sHierarchies = sDim;\n            Else;\n              sHierarchies              = pHier;\n\
    \            EndIf;\n            nDelimiterIndexA    = 1;\n            sHierDim            = '}Hierarchies_'|sDim\
    \ ;\n            sMdxHier = '';\n            While( nDelimiterIndexA <> 0 );\n    \n             \
    \   nDelimiterIndexA = Scan( pDelim, sHierarchies );\n                If( nDelimiterIndexA = 0 );\n\
    \                    sHierarchy   = sHierarchies;\n                Else;\n                    sHierarchy\
    \   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n                    sHierarchies  =\
    \ Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n        \
    \        EndIf;\n                \n                # Create subset of Hierarchies using Wildcard\n\
    \                sHierExp = '''|sDim|':'|sHierarchy|''';\n                sMdxHierPart = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp | ')}';\n                IF( sMdxHier @= ''); \n \
    \                 sMdxHier = sMdxHierPart; \n                ELSE;\n                  sMdxHier = sMdxHier\
    \ | ' + ' | sMdxHierPart;\n                ENDIF;\n            End;\n    \n            If( SubsetExists(\
    \ sHierDim, cTempSub ) = 1 );\n                # If a delimited list of attr names includes wildcards\
    \ then we may have to re-use the subset multiple times\n                SubsetMDXSet( sHierDim, cTempSub,\
    \ sMdxHier );\n            Else;\n                # temp subset, therefore no need to destroy in epilog\n\
    \                SubsetCreatebyMDX( cTempSub, sMdxHier, sHierDim, 1 );\n            EndIf;\n     \
    \   \n            # Loop through subset of hierarchies created based on wildcard\n            nCountHier\
    \ = SubsetGetSize( sHierDim, cTempSub );\n            While( nCountHier >= 1 );\n                sCurrHier\
    \ = SubsetGetElementName( sHierDim, cTempSub, nCountHier );\n                sCurrHierName = Subst(\
    \ sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n                \n                # Validate\
    \ hierarchy name in dimension\n                If( Dimix( sHierDim , sCurrHier ) = 0 );\n        \
    \            sMessage = Expand('The %sCurrHier% hierarchy does NOT exist in the %sDim% dimension.');\n\
    \                    LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n                Else;\n   \
    \               If( pLogOutput = 1 );\n                    sMessage = Expand( 'Hierarchy %sCurrHierName%\
    \ in Dimension %sDim% being processed....' );\n                    LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n                  EndIf;\n                  If( Trim( sCurrHierName ) @= Trim( sDim ) );\n\
    \                      ## Do not remove main hierarchy\n                  ElseIf( sCurrHierName @=\
    \ 'Leaves');\n                      If( pLogOutput = 1 );\n                        sMessage = 'The\
    \ Hierachy is Leaves and can not be destroyed';\n                        LogOutput( 'INFO', Expand(\
    \ cMsgInfoContent ) );\n                      EndIf;\n                  Else;\n                  \
    \    HierarchyDestroy( sDim, sCurrHierName );\n                      If( pLogOutput = 1 );\n     \
    \                   sMessage = Expand( 'Destroying hierarchy %sCurrHierName% in Dimension %sDim%'\
    \ );\n                      LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n                  EndIf;\n\
    \                  Endif;\n                Endif;\n              \n                nCountHier = nCountHier\
    \ - 1;\n            End;\n                \n        EndIf;\n        \n        nCountDim = nCountDim\
    \ - 1;\n    End;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction     = Expand( 'Process:%cThisProcName% successfully deleted the dimension:hierarchy\
    \ %pDim%:%pHier%' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der neue Elemente in einer Dimensionshierarchie
    erstellt. Wenn der Parameter pEle mit einer durch Trennzeichen getrennten Liste von Elementen gefüllt
    wird, werden mehrere Elemente erstellt. Beachte: Ein gültiger Dimensionsname (pDim) und eine Elementliste
    sind zwingend erforderlich, da der Prozess sonst abbricht. Vorsicht: Wenn die Zielhierarchie ''Leaves''
    ist, werden keine konsolidierten Elemente erstellt.'
  answer: "#Section Prolog\n \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create new element in a dimension Hierarchy. More\
    \ elements than one will be\n# created if pEle is supplied with a delimited list of elements.\n \n\
    # Note:\n# Valid dimension name (pDim) and element list are mandatory, otherwise the process will\
    \ abort.\n \n# Caution: When target hierarchy is `Leaves`, no consolidated elements will be created.\n\
    #EndRegion @DOC\n \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n \n### Constants ###\ncThisProcName     = GetProcessName();\ncTimeStamp  \
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSubDim       = cThisProcName |'_dims_'| cTimeStamp |'_'| cRandomInt;\ncTempSubHier   \
    \   = cThisProcName |'_hiers_'| cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo     \
    \     = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%, pEleType:%pEleType%,\
    \ pInsertionPoint:%pInsertionPoint%, pDelim:%pDelim%.'; \n \n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n \n### Validate Parameters ###\n\
    nErrors = 0;\n \nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan(\
    \ ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':',\
    \ pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\
    \ \n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension\
    \ specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n \n# Validate\
    \ Hierarchy\nIf( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed\
    \ this is managed inside the code below\nEndIf;\n \n# Validate element\nIf( Trim( pEle ) @= '' );\n\
    \    nErrors = 1;\n    sMessage = 'No element specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n \n# Validate element type\nIf( pEleType @= '' );\n    pEleType =\
    \ 'N';\nEndIf;\npEleType = Upper( pEleType );\nIf( pEleType @<> 'N' & pEleType @<> 'C' & pEleType\
    \ @<> 'S' );\n    nErrors = 1;\n    sMessage = 'Invalid element type: ' | pEleType;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n \n# If blank delimiter specified then convert\
    \ to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n \n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n \n \n# Loop through dimensions in pDim\nsDims = pDim;\nnDimDelimiterIndex = 1;\n\
    sMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension >\
    \ sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex = 0 );\n     \
    \   sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n\
    \        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n\
    \     \n      # Create subset of dimensions using Wildcard to loop through dimensions in pDim with\
    \ wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n\
    \    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n\
    \    ENDIF;\nEnd;\n \nIf( SubsetExists( '}Dimensions' , cTempSubDim ) = 1 );\n    # If a delimited\
    \ list of dim names includes wildcards then we may have to re-use the subset multiple times\n    SubsetMDXSet(\
    \ '}Dimensions' , cTempSubDim, sMDX );\nElse;\n    # temp subset, therefore no need to destroy in\
    \ epilog\n    SubsetCreatebyMDX( cTempSubDim, sMDX, '}Dimensions' , 1 );\nEndIf;\n \n# Loop through\
    \ dimensions in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions' , cTempSubDim\
    \ );\nWhile( nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSubDim, nCountDim\
    \ );\n    # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n        nErrors = 1;\n\
    \        sMessage = Expand( 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR', Expand(\
    \ cMsgErrorContent ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage = Expand( 'Dimension\
    \ %sDim% being processed....' );\n          LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n    \
    \    EndIf;\n        # Loop through hierarchies in pHier\n        If( Trim( pHier ) @= '' );\n   \
    \       ### Use main hierarchy for each dimension if pHier is empty\n          sHierarchies      =\
    \ sDim;\n        Else;\n          sHierarchies      = pHier;\n        EndIf;\n        nDelimiterIndexA\
    \    = 1;\n        sHierDim            = '}Dimensions';\n        sMdxHier            = '';\n     \
    \   While( nDelimiterIndexA <> 0 );\n \n            nDelimiterIndexA = Scan( pDelim, sHierarchies\
    \ );\n            If( nDelimiterIndexA = 0 );\n                sHierarchy   = sHierarchies;\n    \
    \        Else;\n                sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1\
    \ ) );\n                sHierarchies = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim),\
    \ Long( sHierarchies ) ) );\n            EndIf;\n             \n            ## If no wildcard specified\
    \ and current hierarchy does not exist in dimension, create it\n            If( Scan( '*', sHierarchy\
    \ ) = 0 & Scan( '?', sHierarchy ) = 0);\n              If( HierarchyExists( sDim, sHierarchy ) = 0\
    \ );\n                  HierarchyCreate( sDim, sHierarchy );\n              EndIf;\n            EndIf;\n\
    \ \n            # Create subset of Hierarchies using Wildcard\n            If( sHierarchy  @= sDim\
    \ );\n                sHierExp    = '''| sHierarchy |''';\n            Else;\n                sHierExp\
    \    = '''|sDim|':'|sHierarchy|''';\n            EndIf;\n            sMdxHierPart    = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp | ')}';\n            IF( sMdxHier    @= ''); \n  \
    \            sMdxHier      = sMdxHierPart; \n            ELSE;\n              sMdxHier      = sMdxHier\
    \ | ' + ' | sMdxHierPart;\n            ENDIF;\n        End;\n        If( Trim( pHier )   @= '*' );\n\
    \          sMdxHier          = '{ UNION ( ' | sMdxHier |' , {[}Dimensions].[' | sDim | ']} )}';\n\
    \        EndIf;\n         \n        If( SubsetExists( sHierDim, cTempSubHier ) = 1 );\n          \
    \  # If a delimited list of attr names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( sHierDim, cTempSubHier, sMdxHier );\n        Else;\n          \
    \  # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSubHier,\
    \ sMdxHier, sHierDim, 1 );\n        EndIf;\n     \n        # Loop through subset of hierarchies created\
    \ based on wildcard\n        nCountHier = SubsetGetSize( sHierDim, cTempSubHier );\n        While(\
    \ nCountHier >= 1 );\n            sCurrHier = SubsetGetElementName( sHierDim, cTempSubHier, nCountHier\
    \ );\n            sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n \
    \           # Validate hierarchy name in dimension\n            If( Dimix( sHierDim , sCurrHier )\
    \ = 0 );\n                sMessage = Expand('The %sCurrHier% hierarchy does NOT exist in the %sDim%\
    \ dimension.');\n                LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n            Else;\n\
    \              If( pLogOutput = 1 );\n                sMessage = Expand( 'Hierarchy %sCurrHierName%\
    \ in Dimension %sDim% being processed....' );\n                LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n              EndIf;\n               \n              # Extract, validate & add elements\n\
    \              sEles = pEle;\n              nDelimiterIndexB = 1;\n              While( nDelimiterIndexB\
    \ <> 0 );\n                   \n                  nDelimiterIndexB = Scan( pDelim, sEles );\n    \
    \              If( nDelimiterIndexB = 0 );\n                      sEle = sEles;\n                \
    \  Else;\n                      sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB - 1 ) );\n        \
    \              sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim), Long( sEles ) ) );\n \
    \                 EndIf;\n                   \n                  # Add elements that don't already\
    \ exist\n                  If( ElementIndex( sDim, sCurrHierName, sEle ) <> 0 );\n               \
    \       If( pLogOutput = 1 );\n                        sMessage = Expand( 'Element ' | sEle | ' already\
    \ exist in hierarchy ' | sCurrHier);\n                        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n                      EndIf;\n                  Else;\n                      # Validate Insertion\
    \ point\n                      IF( pInsertionPoint @<> '' );\n                          If( ElementIndex(\
    \ sDim, sCurrHierName, pInsertionPoint ) = 0 );\n                              If( pLogOutput = 1\
    \ );\n                                sMessage = Expand( 'Element insertion point ' | pInsertionPoint\
    \ | ' does NOT exist in dimension:hierarchy ' | sCurrHier | '. Using '' '' as insertion point.' );\n\
    \                                LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n               \
    \               EndIf;\n                              sInsertionPoint = '';\n                    \
    \      Else;\n                              sInsertionPoint = pInsertionPoint;\n                 \
    \         EndIf;\n                      Else;\n                          sInsertionPoint = pInsertionPoint;\n\
    \                      EndIf;\n                      # Leaves hier\n                      If( sCurrHierName\
    \ @= 'Leaves' & pEleType @= 'C' );\n                          If( pLogOutput = 1 );\n            \
    \                sMessage = Expand( 'Invalid element type for Leaves hierarchy in dimension %sDim%:\
    \ ' | pEleType );\n                            LogOutput( cMsgErrorLevel, Expand( cMsgInfoContent\
    \ ) );\n                          EndIf;\n                      Else;\n                          HierarchyElementInsert(\
    \ sDim, sCurrHierName, sInsertionPoint , sEle , pEleType );    \n                          If( pLogOutput\
    \ = 1 );\n                            sMessage = Expand( 'Element %sEle% created in hierarchy %sCurrHier%\
    \ having type ' | pEleType );\n                            LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n                          EndIf;\n                      EndIf;\n                  Endif;\n\
    \              End;\n          Endif;\n           \n            nCountHier = nCountHier - 1;\n   \
    \     End;\n             \n    EndIf;\n     \n    nCountDim = nCountDim - 1;\nEnd;\n \n \n### End\
    \ Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \     = Expand( 'Process:%cThisProcName% inserted element(s) %pEle% with type %pEleType% into %pDim%:%pHier%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n\n### End Epilog ###"
- question: 'Create an IBM Turbo Integrator process that creates new elements in a dimension hierarchy.
    More than one element will be created if the parameter pEle is supplied with a delimited list of elements.
    Note: A valid dimension name (pDim) and element list are mandatory, otherwise the process will abort.
    Caution: When the target hierarchy is ''Leaves'', no consolidated elements will be created.'
  answer: "#Section Prolog\n \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create new element in a dimension Hierarchy. More\
    \ elements than one will be\n# created if pEle is supplied with a delimited list of elements.\n \n\
    # Note:\n# Valid dimension name (pDim) and element list are mandatory, otherwise the process will\
    \ abort.\n \n# Caution: When target hierarchy is `Leaves`, no consolidated elements will be created.\n\
    #EndRegion @DOC\n \n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n \n### Constants ###\ncThisProcName     = GetProcessName();\ncTimeStamp  \
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSubDim       = cThisProcName |'_dims_'| cTimeStamp |'_'| cRandomInt;\ncTempSubHier   \
    \   = cThisProcName |'_hiers_'| cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo     \
    \     = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%, pEleType:%pEleType%,\
    \ pInsertionPoint:%pInsertionPoint%, pDelim:%pDelim%.'; \n \n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n \n### Validate Parameters ###\n\
    nErrors = 0;\n \nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan(\
    \ ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':',\
    \ pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\
    \ \n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension\
    \ specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n \n# Validate\
    \ Hierarchy\nIf( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed\
    \ this is managed inside the code below\nEndIf;\n \n# Validate element\nIf( Trim( pEle ) @= '' );\n\
    \    nErrors = 1;\n    sMessage = 'No element specified.';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n \n# Validate element type\nIf( pEleType @= '' );\n    pEleType =\
    \ 'N';\nEndIf;\npEleType = Upper( pEleType );\nIf( pEleType @<> 'N' & pEleType @<> 'C' & pEleType\
    \ @<> 'S' );\n    nErrors = 1;\n    sMessage = 'Invalid element type: ' | pEleType;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n \n# If blank delimiter specified then convert\
    \ to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n \n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n \n \n# Loop through dimensions in pDim\nsDims = pDim;\nnDimDelimiterIndex = 1;\n\
    sMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension >\
    \ sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex = 0 );\n     \
    \   sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n\
    \        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n\
    \     \n      # Create subset of dimensions using Wildcard to loop through dimensions in pDim with\
    \ wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n\
    \    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n\
    \    ENDIF;\nEnd;\n \nIf( SubsetExists( '}Dimensions' , cTempSubDim ) = 1 );\n    # If a delimited\
    \ list of dim names includes wildcards then we may have to re-use the subset multiple times\n    SubsetMDXSet(\
    \ '}Dimensions' , cTempSubDim, sMDX );\nElse;\n    # temp subset, therefore no need to destroy in\
    \ epilog\n    SubsetCreatebyMDX( cTempSubDim, sMDX, '}Dimensions' , 1 );\nEndIf;\n \n# Loop through\
    \ dimensions in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions' , cTempSubDim\
    \ );\nWhile( nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSubDim, nCountDim\
    \ );\n    # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n        nErrors = 1;\n\
    \        sMessage = Expand( 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR', Expand(\
    \ cMsgErrorContent ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage = Expand( 'Dimension\
    \ %sDim% being processed....' );\n          LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n    \
    \    EndIf;\n        # Loop through hierarchies in pHier\n        If( Trim( pHier ) @= '' );\n   \
    \       ### Use main hierarchy for each dimension if pHier is empty\n          sHierarchies      =\
    \ sDim;\n        Else;\n          sHierarchies      = pHier;\n        EndIf;\n        nDelimiterIndexA\
    \    = 1;\n        sHierDim            = '}Dimensions';\n        sMdxHier            = '';\n     \
    \   While( nDelimiterIndexA <> 0 );\n \n            nDelimiterIndexA = Scan( pDelim, sHierarchies\
    \ );\n            If( nDelimiterIndexA = 0 );\n                sHierarchy   = sHierarchies;\n    \
    \        Else;\n                sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1\
    \ ) );\n                sHierarchies = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim),\
    \ Long( sHierarchies ) ) );\n            EndIf;\n             \n            ## If no wildcard specified\
    \ and current hierarchy does not exist in dimension, create it\n            If( Scan( '*', sHierarchy\
    \ ) = 0 & Scan( '?', sHierarchy ) = 0);\n              If( HierarchyExists( sDim, sHierarchy ) = 0\
    \ );\n                  HierarchyCreate( sDim, sHierarchy );\n              EndIf;\n            EndIf;\n\
    \ \n            # Create subset of Hierarchies using Wildcard\n            If( sHierarchy  @= sDim\
    \ );\n                sHierExp    = '''| sHierarchy |''';\n            Else;\n                sHierExp\
    \    = '''|sDim|':'|sHierarchy|''';\n            EndIf;\n            sMdxHierPart    = '{TM1FILTERBYPATTERN(\
    \ {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp | ')}';\n            IF( sMdxHier    @= ''); \n  \
    \            sMdxHier      = sMdxHierPart; \n            ELSE;\n              sMdxHier      = sMdxHier\
    \ | ' + ' | sMdxHierPart;\n            ENDIF;\n        End;\n        If( Trim( pHier )   @= '*' );\n\
    \          sMdxHier          = '{ UNION ( ' | sMdxHier |' , {[}Dimensions].[' | sDim | ']} )}';\n\
    \        EndIf;\n         \n        If( SubsetExists( sHierDim, cTempSubHier ) = 1 );\n          \
    \  # If a delimited list of attr names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( sHierDim, cTempSubHier, sMdxHier );\n        Else;\n          \
    \  # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSubHier,\
    \ sMdxHier, sHierDim, 1 );\n        EndIf;\n     \n        # Loop through subset of hierarchies created\
    \ based on wildcard\n        nCountHier = SubsetGetSize( sHierDim, cTempSubHier );\n        While(\
    \ nCountHier >= 1 );\n            sCurrHier = SubsetGetElementName( sHierDim, cTempSubHier, nCountHier\
    \ );\n            sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n \
    \           # Validate hierarchy name in dimension\n            If( Dimix( sHierDim , sCurrHier )\
    \ = 0 );\n                sMessage = Expand('The %sCurrHier% hierarchy does NOT exist in the %sDim%\
    \ dimension.');\n                LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n            Else;\n\
    \              If( pLogOutput = 1 );\n                sMessage = Expand( 'Hierarchy %sCurrHierName%\
    \ in Dimension %sDim% being processed....' );\n                LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n              EndIf;\n               \n              # Extract, validate & add elements\n\
    \              sEles = pEle;\n              nDelimiterIndexB = 1;\n              While( nDelimiterIndexB\
    \ <> 0 );\n                   \n                  nDelimiterIndexB = Scan( pDelim, sEles );\n    \
    \              If( nDelimiterIndexB = 0 );\n                      sEle = sEles;\n                \
    \  Else;\n                      sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB - 1 ) );\n        \
    \              sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim), Long( sEles ) ) );\n \
    \                 EndIf;\n                   \n                  # Add elements that don't already\
    \ exist\n                  If( ElementIndex( sDim, sCurrHierName, sEle ) <> 0 );\n               \
    \       If( pLogOutput = 1 );\n                        sMessage = Expand( 'Element ' | sEle | ' already\
    \ exist in hierarchy ' | sCurrHier);\n                        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n                      EndIf;\n                  Else;\n                      # Validate Insertion\
    \ point\n                      IF( pInsertionPoint @<> '' );\n                          If( ElementIndex(\
    \ sDim, sCurrHierName, pInsertionPoint ) = 0 );\n                              If( pLogOutput = 1\
    \ );\n                                sMessage = Expand( 'Element insertion point ' | pInsertionPoint\
    \ | ' does NOT exist in dimension:hierarchy ' | sCurrHier | '. Using '' '' as insertion point.' );\n\
    \                                LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n               \
    \               EndIf;\n                              sInsertionPoint = '';\n                    \
    \      Else;\n                              sInsertionPoint = pInsertionPoint;\n                 \
    \         EndIf;\n                      Else;\n                          sInsertionPoint = pInsertionPoint;\n\
    \                      EndIf;\n                      # Leaves hier\n                      If( sCurrHierName\
    \ @= 'Leaves' & pEleType @= 'C' );\n                          If( pLogOutput = 1 );\n            \
    \                sMessage = Expand( 'Invalid element type for Leaves hierarchy in dimension %sDim%:\
    \ ' | pEleType );\n                            LogOutput( cMsgErrorLevel, Expand( cMsgInfoContent\
    \ ) );\n                          EndIf;\n                      Else;\n                          HierarchyElementInsert(\
    \ sDim, sCurrHierName, sInsertionPoint , sEle , pEleType );    \n                          If( pLogOutput\
    \ = 1 );\n                            sMessage = Expand( 'Element %sEle% created in hierarchy %sCurrHier%\
    \ having type ' | pEleType );\n                            LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n                          EndIf;\n                      EndIf;\n                  Endif;\n\
    \              End;\n          Endif;\n           \n            nCountHier = nCountHier - 1;\n   \
    \     End;\n             \n    EndIf;\n     \n    nCountDim = nCountDim - 1;\nEnd;\n \n \n### End\
    \ Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \     = Expand( 'Process:%cThisProcName% inserted element(s) %pEle% with type %pEleType% into %pDim%:%pHier%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n\n### End Epilog ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der das Löschen von bestimmten oder allen Elementen
    aus einer Dimension Hierarchie ermöglicht. Elemente können über eine durch Trennzeichen getrennte
    Liste von Elementen spezifiziert werden. Jedes Mitglied der Liste kann genau oder durch ein Wildcard-Muster
    angegeben werden. Wildcards ''*'' und ''?'' sind erlaubt. Achtung: Wenn pEle auf ''*'' gesetzt ist,
    werden __alle__ Elemente in pHier gelöscht!'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete specified or all elements from a dimension\
    \ Hierarchy. Elements might be\n# specified as a delimited list of elements. Each member in the list\
    \ might be specified exactly or\n# by a wildcard pattern. Wildcards '\\*' and '?' are accepted.\n\
    #\n# Caution: When pEle is set to \\*, __all__ elements in pHier will be deleted!\n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncTimeStamp   \
    \     = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSubDim       = cThisProcName |'_dims_'| cTimeStamp |'_'| cRandomInt;\ncTempSubHier   \
    \   = cThisProcName |'_hiers_'| cTimeStamp |'_'| cRandomInt;\ncTempSubEle       = cThisProcName |'_eles_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgInfoLevel\
    \     = 'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo     \
    \     = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%, pDelim:%pDelim%.';\
    \ \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?',\
    \ pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate Dimension\nIf( Trim( pDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n  \
    \  pDelim = '&';\nEndIf;\n\n# Validate Hierarchy\nIf( Trim( pHier ) @= '' );\n    ## use same name\
    \ as Dimension. Since wildcards are allowed this is managed inside the code below\nEndIf;\n\n### Check\
    \ for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\n\
    nDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    #\
    \ Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex\
    \ = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) )\
    \ );\n    EndIf;\n    \n      # Create subset of dimensions using Wildcard to loop through dimensions\
    \ in pDim with wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT(\
    \ TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'|\
    \ sDimExp | ')}';\n    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx |\
    \ ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n\nIf( SubsetExists( '}Dimensions' , cTempSubDim ) = 1 );\n\
    \    # If a delimited list of dim names includes wildcards then we may have to re-use the subset multiple\
    \ times\n    SubsetMDXSet( '}Dimensions' , cTempSubDim, sMDX );\nElse;\n    # temp subset, therefore\
    \ no need to destroy in epilog\n    SubsetCreatebyMDX( cTempSubDim, sMDX, '}Dimensions' , 1 );\nEndIf;\n\
    \n# Loop through dimensions in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions'\
    \ , cTempSubDim );\nWhile( nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSubDim,\
    \ nCountDim );\n    # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n        nErrors\
    \ = 1;\n        sMessage = Expand( 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR',\
    \ Expand( cMsgErrorContent ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage = Expand(\
    \ 'Dimension %sDim% being processed....' );\n          LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n        EndIf;\n        # Loop through hierarchies in pHier\n        If( Trim( pHier ) @=\
    \ '' );\n          ### Use main hierarchy for each dimension if pHier is empty\n          sHierarchies\
    \      = sDim;\n        Else;\n          sHierarchies      = pHier;\n        EndIf;\n        nDelimiterIndexA\
    \    = 1;\n        sHierDim            = '}Dimensions' ;\n        sMdxHier            = '';\n    \
    \    While( nDelimiterIndexA <> 0 );\n\n            nDelimiterIndexA = Scan( pDelim, sHierarchies\
    \ );\n            If( nDelimiterIndexA = 0 );\n                sHierarchy   = sHierarchies;\n    \
    \        Else;\n                sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1\
    \ ) );\n                sHierarchies = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim),\
    \ Long( sHierarchies ) ) );\n            EndIf;\n\n            # Create subset of Hierarchies using\
    \ Wildcard\n            If( sHierarchy  @= sDim );\n                sHierExp    = '''|sDim|''';\n\
    \            Else;\n                sHierExp    = '''|sDim|':'|sHierarchy|''';\n            EndIf;\n\
    \            sMdxHierPart    = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp\
    \ | ')}';\n            IF( sMdxHier    @= ''); \n              sMdxHier      = sMdxHierPart; \n  \
    \          ELSE;\n              sMdxHier      = sMdxHier | ' + ' | sMdxHierPart;\n            ENDIF;\n\
    \        End;\n        If( Trim( pHier )   @= '*' );\n          sMdxHier          = '{ UNION ( ' |\
    \ sMdxHier |' , {[}Dimensions].[' | sDim | ']} )}';\n        EndIf;\n\n        If( SubsetExists( sHierDim,\
    \ cTempSubHier ) = 1 );\n            # If a delimited list of hier names includes wildcards then we\
    \ may have to re-use the subset multiple times\n            SubsetMDXSet( sHierDim, cTempSubHier,\
    \ sMdxHier );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSubHier, sMdxHier, sHierDim, 1 );\n        EndIf;\n    \n   \
    \     # Loop through subset of hierarchies created based on wildcard\n        nCountHier = SubsetGetSize(\
    \ sHierDim, cTempSubHier );\n        While( nCountHier >= 1 );\n            sCurrHier = SubsetGetElementName(\
    \ sHierDim, cTempSubHier, nCountHier );\n            sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1,\
    \ Long(sCurrHier) );\n            # Validate hierarchy name in sHierDim\n            If( Dimix( sHierDim\
    \ , sCurrHier ) = 0 );\n                sMessage = Expand('The %sCurrHier% hierarchy does NOT exist\
    \ in the %sDim% dimension.');\n                LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n\
    \            Else;\n              If( pLogOutput = 1 );\n                sMessage = Expand( 'Hierarchy\
    \ %sCurrHierName% in Dimension %sDim% being processed....' );\n                LogOutput( 'INFO',\
    \ Expand( cMsgInfoContent ) );\n              EndIf;\n              # Loop through hierarchy elements\
    \ in pEle\n              sEles = pEle;\n               nDelimiterIndexB = 1;\n              While(\
    \ nDelimiterIndexB <> 0 );\n                  \n                  nDelimiterIndexB = Scan( pDelim,\
    \ sEles );\n                  If( nDelimiterIndexB = 0 );\n                      sEle = sEles;\n \
    \                 Else;\n                      sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB - 1\
    \ ) );\n                      sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim), Long( sEles\
    \ ) ) );\n                  EndIf;\n                  \n                  # Check if a wildcard has\
    \ been used to specify the Element name.\n                  # If it hasn't then just delete the Element\
    \ if it exists\n                  If(sEle @= '*');\n                          HierarchyDeleteAllElements(sDim,\
    \ sCurrHierName);\n                  ElseIf( Scan( '*', sEle ) = 0 & Scan( '?', sEle ) = 0);\n   \
    \                   If( HierarchyElementExists( sDim,sCurrHierName, sEle ) = 1 );\n              \
    \            HierarchyElementDelete( sDim, sCurrHierName,sEle );\n                          If( sCurrHierName\
    \ @= 'Leaves' );\n                              sMessage = Expand('Element %sEle% deleted from LEAVES\
    \ hierarchy in dimension %sDim%. This action removes the element from all hierarchies!');\n      \
    \                        LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n                \
    \          ElseIf( pLogOutput = 1 );\n                              sMessage = Expand( 'Element %sEle%\
    \ deleted from hierarchy %sCurrHierName% in dimension %sDim%.' );\n                              LogOutput(\
    \ cMsgInfoLevel, Expand( cMsgInfoContent ) );\n                          EndIf;\n                \
    \      Else;\n                          If( pLogOutput >= 1 );\n                              sMessage\
    \ = Expand('The Hierarchy %sCurrHier% does not contain element %sEle%.');\n                      \
    \        LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n                          EndIf;\n\
    \                      Endif;\n                  Else;\n                      # Wildcard search string\n\
    \                      sEle = '''|sEle|''';\n                      sProc = '}bedrock.hier.sub.create.bymdx';\n\
    \                      sMdxEle = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' | sCurrHier |' ])},'| sEle|\
    \ ')}';\n\n                      If( HierarchySubsetExists( sDim, sCurrHierName, cTempSubEle ) = 1\
    \ );\n                          # If a delimited list of ele names includes wildcards then we may\
    \ have to re-use the subset multiple times\n                          HierarchySubsetMDXSet( sDim,\
    \ sCurrHierName, cTempSubEle, sMDXEle );\n                      Else;\n                          #\
    \ temp subset, therefore no need to destroy in epilog\n                          SubsetCreatebyMDX(\
    \ cTempSubEle, sMDXEle, sCurrHier, 1 );\n                      EndIf;\n\n                      # Loop\
    \ through subset of hierarchy elements created based on wildcard\n                      nCountElems\
    \ = HierarchySubsetGetSize(sDim, sCurrHierName, cTempSubEle);\n                      While( nCountElems\
    \ >= 1 );\n                          sElement = HierarchySubsetGetElementName(sDim, sCurrHierName,\
    \ cTempSubEle, nCountElems);\n                          HierarchyElementDelete( sDim, sCurrHierName,sElement\
    \ );\n                          If( pLogOutput = 1 );\n                              sMessage = Expand(\
    \ 'Element %sElement% deleted from hierarchy %sCurrHierName% in dimension %sDim%.' );\n          \
    \                    LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n                    \
    \      EndIf;\n                          nCountElems = nCountElems - 1;\n                      End;\n\
    \                  EndIf;\n              \n              End;\n          Endif;\n          \n    \
    \        nCountHier = nCountHier - 1;\n        End;\n            \n    EndIf;\n    \n    nCountDim\
    \ = nCountDim - 1;\nEnd;\n\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction      = Expand( 'Process:%cThisProcName% successfully deleted the appropriate elements\
    \ in hierarchy %pDim%:%pHier%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that allows for the deletion of specified or all
    elements from a dimension hierarchy. Elements can be specified as a delimited list of elements. Each
    member in the list may be specified exactly or by a wildcard pattern. Wildcards ''*'' and ''?'' are
    accepted. Caution: When pEle is set to ''*'', __all__ elements in pHier will be deleted!'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete specified or all elements from a dimension\
    \ Hierarchy. Elements might be\n# specified as a delimited list of elements. Each member in the list\
    \ might be specified exactly or\n# by a wildcard pattern. Wildcards '\\*' and '?' are accepted.\n\
    #\n# Caution: When pEle is set to \\*, __all__ elements in pHier will be deleted!\n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncTimeStamp   \
    \     = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSubDim       = cThisProcName |'_dims_'| cTimeStamp |'_'| cRandomInt;\ncTempSubHier   \
    \   = cThisProcName |'_hiers_'| cTimeStamp |'_'| cRandomInt;\ncTempSubEle       = cThisProcName |'_eles_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgInfoLevel\
    \     = 'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cMsgInfoContent   = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo     \
    \     = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%, pDelim:%pDelim%.';\
    \ \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?',\
    \ pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate Dimension\nIf( Trim( pDim ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n  \
    \  pDelim = '&';\nEndIf;\n\n# Validate Hierarchy\nIf( Trim( pHier ) @= '' );\n    ## use same name\
    \ as Dimension. Since wildcards are allowed this is managed inside the code below\nEndIf;\n\n### Check\
    \ for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\n\
    nDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    #\
    \ Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex\
    \ = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) )\
    \ );\n    EndIf;\n    \n      # Create subset of dimensions using Wildcard to loop through dimensions\
    \ in pDim with wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT(\
    \ TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'|\
    \ sDimExp | ')}';\n    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx |\
    \ ' + ' | sMdxPart;\n    ENDIF;\nEnd;\n\nIf( SubsetExists( '}Dimensions' , cTempSubDim ) = 1 );\n\
    \    # If a delimited list of dim names includes wildcards then we may have to re-use the subset multiple\
    \ times\n    SubsetMDXSet( '}Dimensions' , cTempSubDim, sMDX );\nElse;\n    # temp subset, therefore\
    \ no need to destroy in epilog\n    SubsetCreatebyMDX( cTempSubDim, sMDX, '}Dimensions' , 1 );\nEndIf;\n\
    \n# Loop through dimensions in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions'\
    \ , cTempSubDim );\nWhile( nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSubDim,\
    \ nCountDim );\n    # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n        nErrors\
    \ = 1;\n        sMessage = Expand( 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR',\
    \ Expand( cMsgErrorContent ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage = Expand(\
    \ 'Dimension %sDim% being processed....' );\n          LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n        EndIf;\n        # Loop through hierarchies in pHier\n        If( Trim( pHier ) @=\
    \ '' );\n          ### Use main hierarchy for each dimension if pHier is empty\n          sHierarchies\
    \      = sDim;\n        Else;\n          sHierarchies      = pHier;\n        EndIf;\n        nDelimiterIndexA\
    \    = 1;\n        sHierDim            = '}Dimensions' ;\n        sMdxHier            = '';\n    \
    \    While( nDelimiterIndexA <> 0 );\n\n            nDelimiterIndexA = Scan( pDelim, sHierarchies\
    \ );\n            If( nDelimiterIndexA = 0 );\n                sHierarchy   = sHierarchies;\n    \
    \        Else;\n                sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1\
    \ ) );\n                sHierarchies = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim),\
    \ Long( sHierarchies ) ) );\n            EndIf;\n\n            # Create subset of Hierarchies using\
    \ Wildcard\n            If( sHierarchy  @= sDim );\n                sHierExp    = '''|sDim|''';\n\
    \            Else;\n                sHierExp    = '''|sDim|':'|sHierarchy|''';\n            EndIf;\n\
    \            sMdxHierPart    = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp\
    \ | ')}';\n            IF( sMdxHier    @= ''); \n              sMdxHier      = sMdxHierPart; \n  \
    \          ELSE;\n              sMdxHier      = sMdxHier | ' + ' | sMdxHierPart;\n            ENDIF;\n\
    \        End;\n        If( Trim( pHier )   @= '*' );\n          sMdxHier          = '{ UNION ( ' |\
    \ sMdxHier |' , {[}Dimensions].[' | sDim | ']} )}';\n        EndIf;\n\n        If( SubsetExists( sHierDim,\
    \ cTempSubHier ) = 1 );\n            # If a delimited list of hier names includes wildcards then we\
    \ may have to re-use the subset multiple times\n            SubsetMDXSet( sHierDim, cTempSubHier,\
    \ sMdxHier );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSubHier, sMdxHier, sHierDim, 1 );\n        EndIf;\n    \n   \
    \     # Loop through subset of hierarchies created based on wildcard\n        nCountHier = SubsetGetSize(\
    \ sHierDim, cTempSubHier );\n        While( nCountHier >= 1 );\n            sCurrHier = SubsetGetElementName(\
    \ sHierDim, cTempSubHier, nCountHier );\n            sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1,\
    \ Long(sCurrHier) );\n            # Validate hierarchy name in sHierDim\n            If( Dimix( sHierDim\
    \ , sCurrHier ) = 0 );\n                sMessage = Expand('The %sCurrHier% hierarchy does NOT exist\
    \ in the %sDim% dimension.');\n                LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n\
    \            Else;\n              If( pLogOutput = 1 );\n                sMessage = Expand( 'Hierarchy\
    \ %sCurrHierName% in Dimension %sDim% being processed....' );\n                LogOutput( 'INFO',\
    \ Expand( cMsgInfoContent ) );\n              EndIf;\n              # Loop through hierarchy elements\
    \ in pEle\n              sEles = pEle;\n               nDelimiterIndexB = 1;\n              While(\
    \ nDelimiterIndexB <> 0 );\n                  \n                  nDelimiterIndexB = Scan( pDelim,\
    \ sEles );\n                  If( nDelimiterIndexB = 0 );\n                      sEle = sEles;\n \
    \                 Else;\n                      sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB - 1\
    \ ) );\n                      sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim), Long( sEles\
    \ ) ) );\n                  EndIf;\n                  \n                  # Check if a wildcard has\
    \ been used to specify the Element name.\n                  # If it hasn't then just delete the Element\
    \ if it exists\n                  If(sEle @= '*');\n                          HierarchyDeleteAllElements(sDim,\
    \ sCurrHierName);\n                  ElseIf( Scan( '*', sEle ) = 0 & Scan( '?', sEle ) = 0);\n   \
    \                   If( HierarchyElementExists( sDim,sCurrHierName, sEle ) = 1 );\n              \
    \            HierarchyElementDelete( sDim, sCurrHierName,sEle );\n                          If( sCurrHierName\
    \ @= 'Leaves' );\n                              sMessage = Expand('Element %sEle% deleted from LEAVES\
    \ hierarchy in dimension %sDim%. This action removes the element from all hierarchies!');\n      \
    \                        LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n                \
    \          ElseIf( pLogOutput = 1 );\n                              sMessage = Expand( 'Element %sEle%\
    \ deleted from hierarchy %sCurrHierName% in dimension %sDim%.' );\n                              LogOutput(\
    \ cMsgInfoLevel, Expand( cMsgInfoContent ) );\n                          EndIf;\n                \
    \      Else;\n                          If( pLogOutput >= 1 );\n                              sMessage\
    \ = Expand('The Hierarchy %sCurrHier% does not contain element %sEle%.');\n                      \
    \        LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n                          EndIf;\n\
    \                      Endif;\n                  Else;\n                      # Wildcard search string\n\
    \                      sEle = '''|sEle|''';\n                      sProc = '}bedrock.hier.sub.create.bymdx';\n\
    \                      sMdxEle = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' | sCurrHier |' ])},'| sEle|\
    \ ')}';\n\n                      If( HierarchySubsetExists( sDim, sCurrHierName, cTempSubEle ) = 1\
    \ );\n                          # If a delimited list of ele names includes wildcards then we may\
    \ have to re-use the subset multiple times\n                          HierarchySubsetMDXSet( sDim,\
    \ sCurrHierName, cTempSubEle, sMDXEle );\n                      Else;\n                          #\
    \ temp subset, therefore no need to destroy in epilog\n                          SubsetCreatebyMDX(\
    \ cTempSubEle, sMDXEle, sCurrHier, 1 );\n                      EndIf;\n\n                      # Loop\
    \ through subset of hierarchy elements created based on wildcard\n                      nCountElems\
    \ = HierarchySubsetGetSize(sDim, sCurrHierName, cTempSubEle);\n                      While( nCountElems\
    \ >= 1 );\n                          sElement = HierarchySubsetGetElementName(sDim, sCurrHierName,\
    \ cTempSubEle, nCountElems);\n                          HierarchyElementDelete( sDim, sCurrHierName,sElement\
    \ );\n                          If( pLogOutput = 1 );\n                              sMessage = Expand(\
    \ 'Element %sElement% deleted from hierarchy %sCurrHierName% in dimension %sDim%.' );\n          \
    \                    LogOutput( cMsgInfoLevel, Expand( cMsgInfoContent ) );\n                    \
    \      EndIf;\n                          nCountElems = nCountElems - 1;\n                      End;\n\
    \                  EndIf;\n              \n              End;\n          Endif;\n          \n    \
    \        nCountHier = nCountHier - 1;\n        End;\n            \n    EndIf;\n    \n    nCountDim\
    \ = nCountDim - 1;\nEnd;\n\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction      = Expand( 'Process:%cThisProcName% successfully deleted the appropriate elements\
    \ in hierarchy %pDim%:%pHier%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der es ermöglicht, ein Element entweder zu
    einer Konsolidierung hinzuzufügen oder daraus zu entfernen. Der Prozess sollte folgende Eingabeparameter
    akzeptieren: gültiger Dimensionsname (pDim), Konsolidierungselementname (pTgtConsol) und Elementname
    (pEle). Der Prozess muss einen Modus (Add oder Remove) nutzen, um das Element entsprechend zu verwalten.
    Beachte, dass die Zielhierarchie nicht ''Leaves'' sein darf und der Prozess bei ungültigen Eingaben
    abbricht.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Add or Remove Element from a Consolidation in\
    \ a Hierarchy.\n\n# Note:\n# Valid dimension name (pDim), consolidated element name (pTgtConsol) and\
    \ element name (pEle)\n# otherwise the process will abort. Mode can be either Add to add or Remove\
    \ to remove the element\n# from a consolidation. \n\n# Caution: Target hierarchy cannot be `Leaves`.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo        = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%,\
    \ pTgtConsol:%pTgtConsol%, pMode:%pMode%, pWeight:%pWeight%.';\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt(\
    \ pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension ' | pDim | ' does not\
    \ exist on server.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ Hierarchy\nIf( Trim( pHier ) @= '' );\n    sHier = Trim( pDim );\nElse;\n    sHier = Trim( pHier\
    \ );\nEndIf;\nIf( sHier @= 'Leaves' );\n    nErrors = 1;\n    sMessage = 'Invalid  Hierarchy: ' |\
    \ pDim |':'|sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( HierarchyExists(\
    \ pDim, sHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'The Hierachy ' | sHier | ' does not exist\
    \ in dimension ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate Element\nIf( Trim( pEle ) @= '' );\n    nErrors = 1;\n    sMessage = 'No element specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( ElementIndex ( pDim, sHier,\
    \ pEle ) = 0 );\n    nErrors = 1;\n    sMessage = 'Element: ' | pEle | ' does not exist in dimension:\
    \ ' | pDim|':'| sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n#\
    \ Validate target consol\nIf( ElementIndex ( pDim, sHier, pTgtConsol ) = 0  );\n    nErrors = 1;\n\
    \    sMessage = 'Consolidated Element: ' | pTgtConsol | ' does not exist in dimension: ' | pDim|':'|\
    \ sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( ElementType( pDim,\
    \ sHier, pTgtConsol ) @<> 'C' );\n    nErrors = 1;\n    sMessage = 'Target Consolidation: ' | pTgtConsol\
    \ | ' has incorrect element type.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\nIf( ElementIsAncestor( pDim, sHier, pEle, pTgtConsol ) = 1 );\n    nErrors = 1;\n    sMessage\
    \ = 'Cannot add element: ' | pEle | ' to consolidation: ' | pTgtConsol | ' due to circular reference.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate action\nIf( pMode\
    \ @<> 'Add' & pMode @<> 'Remove' );\n    nErrors = 1;\n    sMessage = 'Invalid action: ' | pMode |\
    \ '. Valid actions are Add or Remove';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Insert Element\
    \ into consolidation ###\nIf( pMode @= 'Add' );\n    HierarchyElementComponentAdd( pDim, sHier, pTgtConsol,\
    \ pEle, pWeight );\nEndIf;\n\n### Remove Element from consolidation ###\nIf( pMode @= 'Remove' );\n\
    \    # Check that element is actually a child of target consol\n    If( ElementIsComponent ( pDim,\
    \ sHier, pEle, pTgtConsol ) = 1 );\n        HierarchyElementComponentDelete( pDim, sHier, pTgtConsol,\
    \ pEle );\n    Else;\n        nErrors = 1;\n        sMessage = 'Element: ' | pEle | ' is not a child\
    \ of consolidation: ' | pTgtConsol;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    EndIf;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### If errors occurred terminate process with a major error status ###\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 major error and consequently aborted. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nEndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName%\
    \ successfully %pMode%ed element %pEle% to/from %pTgtConsol% in the %pDim%:%pHier% dimension:hierarchy.'\
    \ );\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode\
    \  = 1;\nIf( pLogoutput = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \nEndIf;\n\n\n\
    ### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that allows adding or removing an element from a
    consolidation within a hierarchy. The process should accept the following input parameters: valid
    dimension name (pDim), consolidated element name (pTgtConsol), and element name (pEle). The process
    must utilize a mode (Add or Remove) to manage the element accordingly. Note that the target hierarchy
    cannot be ''Leaves'' and the process should abort on invalid inputs.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Add or Remove Element from a Consolidation in\
    \ a Hierarchy.\n\n# Note:\n# Valid dimension name (pDim), consolidated element name (pTgtConsol) and\
    \ element name (pEle)\n# otherwise the process will abort. Mode can be either Add to add or Remove\
    \ to remove the element\n# from a consolidation. \n\n# Caution: Target hierarchy cannot be `Leaves`.\n\
    #EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo        = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pEle:%pEle%,\
    \ pTgtConsol:%pTgtConsol%, pMode:%pMode%, pWeight:%pWeight%.';\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt(\
    \ pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension ' | pDim | ' does not\
    \ exist on server.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ Hierarchy\nIf( Trim( pHier ) @= '' );\n    sHier = Trim( pDim );\nElse;\n    sHier = Trim( pHier\
    \ );\nEndIf;\nIf( sHier @= 'Leaves' );\n    nErrors = 1;\n    sMessage = 'Invalid  Hierarchy: ' |\
    \ pDim |':'|sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( HierarchyExists(\
    \ pDim, sHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'The Hierachy ' | sHier | ' does not exist\
    \ in dimension ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate Element\nIf( Trim( pEle ) @= '' );\n    nErrors = 1;\n    sMessage = 'No element specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( ElementIndex ( pDim, sHier,\
    \ pEle ) = 0 );\n    nErrors = 1;\n    sMessage = 'Element: ' | pEle | ' does not exist in dimension:\
    \ ' | pDim|':'| sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n#\
    \ Validate target consol\nIf( ElementIndex ( pDim, sHier, pTgtConsol ) = 0  );\n    nErrors = 1;\n\
    \    sMessage = 'Consolidated Element: ' | pTgtConsol | ' does not exist in dimension: ' | pDim|':'|\
    \ sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( ElementType( pDim,\
    \ sHier, pTgtConsol ) @<> 'C' );\n    nErrors = 1;\n    sMessage = 'Target Consolidation: ' | pTgtConsol\
    \ | ' has incorrect element type.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\nIf( ElementIsAncestor( pDim, sHier, pEle, pTgtConsol ) = 1 );\n    nErrors = 1;\n    sMessage\
    \ = 'Cannot add element: ' | pEle | ' to consolidation: ' | pTgtConsol | ' due to circular reference.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate action\nIf( pMode\
    \ @<> 'Add' & pMode @<> 'Remove' );\n    nErrors = 1;\n    sMessage = 'Invalid action: ' | pMode |\
    \ '. Valid actions are Add or Remove';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Insert Element\
    \ into consolidation ###\nIf( pMode @= 'Add' );\n    HierarchyElementComponentAdd( pDim, sHier, pTgtConsol,\
    \ pEle, pWeight );\nEndIf;\n\n### Remove Element from consolidation ###\nIf( pMode @= 'Remove' );\n\
    \    # Check that element is actually a child of target consol\n    If( ElementIsComponent ( pDim,\
    \ sHier, pEle, pTgtConsol ) = 1 );\n        HierarchyElementComponentDelete( pDim, sHier, pTgtConsol,\
    \ pEle );\n    Else;\n        nErrors = 1;\n        sMessage = 'Element: ' | pEle | ' is not a child\
    \ of consolidation: ' | pTgtConsol;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    EndIf;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### If errors occurred terminate process with a major error status ###\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 major error and consequently aborted. Please\
    \ see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nEndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName%\
    \ successfully %pMode%ed element %pEle% to/from %pTgtConsol% in the %pDim%:%pHier% dimension:hierarchy.'\
    \ );\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode\
    \  = 1;\nIf( pLogoutput = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \nEndIf;\n\n\n\
    ### End Epilog ###"
- question: "Entwickle einen IBM Turbo Integrator Prozess, der alle Elemente in ausgewählten Dimensionen\
    \ und Hierarchien überprüft und eine CSV-Datei erstellt, die alle Elemente mit ungewöhnlichen Zeichen\
    \ auflistet. Beachte, dass Steuerdimensionen ignoriert werden. Die Parameter des Prozesses sind: \n\
    \n- pDim: Gib an, welche Dimensionen validiert werden sollen. Verwende Wildcards wie `*` und `?` für\
    \ Muster oder eine Liste von Dimensionen mit einem Trennzeichen. Der Stern `*` verarbeitet alle Dimensionen.\
    \ \n- pHier: Gib an, welche Hierarchien validiert werden sollen. Verwende `*` für alle Hierarchien\
    \ oder spezifische Muster. Beachte, dass bei Angabe von Hierarchien pDim nicht als Liste oder mit\
    \ Wildcards verwendet werden sollte. \n- pDelim: Bestimme das Trennzeichen, um mehrere Dimensionen\
    \ oder Hierarchien zu trennen. Der Standard ist `&`, aber dies kann angepasst werden. \n- pFirst:\
    \ Wenn `1`, werden alle Anforderungen für alle Zeichen überprüft, sonst werden strenge Anforderungen\
    \ für das erste Zeichen ignoriert.'"
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will review all elements in selected dimensions (you\
    \ can specify a single dimension,\n# multiple dimensions or wildcards to match dimensions) and hierarchies\
    \ and will generate a `csv` \n# file listing all elements with unusual characters.\n# Control dimensions\
    \ are ignored.\n\n# Note:\n# - pDim: Specify which dimensions to validate. When specifying a dimension\
    \ name, wildcards can\n#   be specified by using the `*` and `?` characters. A list of dimensions\
    \ can also be entered with\n#   a delimiter (e.g. `v*&plan*` will process all dimensions starting\
    \ with `v` and `plan`). If \n#   * is entered then it ignores anything entered for hierarchy (pHier)\
    \ and processes all dimensions\n# - pHier: Specify which hierarchies to validate. To validate ALL\
    \ hierachies, enter *. \n#   When specifying a hierarchy name, wildcards can be specified by using\
    \ the\n#   `*` and `?` characters. A list of hierachies can also be entered with a delimiter. If pHier\n\
    #   has a value then it does not make sense that pDim can be set up as a list or with wildcards.\n\
    # - pDelim: The delimiter is used when specifying multiple dimensions or multiple hierachies. The\n\
    #   default delimiter is `&`. Any delimiter can be used by specifying a value for pDelim. Choose\n\
    #   a delimiter that won't be used in either the wildcard search strings or dimension names.\n# -\
    \ pFirst:\n#   - When set to `1`: all requirements for all characters are validated.\n#   - ELSE:\
    \ ignores stringent requirements for 1st character.\n#EndRegion @DOC\n\n\n### Global Variables\nStringGlobalVariable\
    \ ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode = 0;\n\
    \n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp\
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) *\
    \ 1000 ));\ncSubset           = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel \
    \   = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\ncLogInfo      \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pFirst:%pFirst%, pDelim:%pDelim%';\n\
    cDim              = '}Dimensions';\ncFile             = GetProcessErrorFileDirectory | 'Element Issues.csv';\n\
    \n# Variables\nnMeta             = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*',\
    \ pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @=\
    \ '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n\
    \    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified. Use * to process all\
    \ dimensions';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ hierarchy\nIf( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed,\
    \ this is managed inside the code below\nEndIf;\n\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\
    \n## Validate dimension\nIF( Trim( pDim ) @= '*' );\n    sMDX                = Expand('{ TM1SUBSETALL(\
    \ [}Dimensions] ) }');\nElseIf( Trim( pHier ) @= '*' );\n    IF( Scan( pDelim , pDim )>0 );\n    \
    \    # delimiter in pDim. Seperate and add MDX for each part separately\n        sMDX            =\
    \ '{ ';\n        sDims           = Trim( pDim );\n        nDelimiterIndex = 1;\n        While( nDelimiterIndex\
    \ <> 0 );    \n            nDelimiterIndex = Scan( pDelim, sDims );\n            If( nDelimiterIndex\
    \ = 0 );\n                sDim            = sDims;\n            ELSE;\n                sDim      \
    \      = Trim( SubSt( sDims, 1, nDelimiterIndex - 1 ) );\n                sDims           = Trim(\
    \ Subst( sDims, nDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n            ENDIF;\n         \
    \   IF(DimensionExists(sDim)=1 );\n                sMDX            = Expand('{TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%sDim%*')}');\n            ELSEIF(Scan( '*', sDim )=0 & Scan( '?',\
    \ sDim )=0 );\n                #nErrors = 1;\n                sMessage= Expand('Dimension %sDim% does\
    \ not exist.');\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      \
    \      ELSE;\n                sMDX            = sMDX | IF(Long(sMDX)>4,\n                        \
    \                    Expand(',TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%sDim%')'),\n  \
    \                                          Expand(' TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%sDim%')')); \n            ENDIF;\n        END;\n        sMDX                    = sMDX | '\
    \ }';\n    ELSE;\n        IF(DimensionExists(pDim)=1 );\n            sMDX                = Expand('{TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%pDim%*')}');\n        ELSEIF(Scan( '*', pDim )=0 & Scan( '?', pDim\
    \ )=0 );\n            nErrors = 1;\n            sMessage= Expand('Dimension %pDim% does not exist.');\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ELSE;\n           \
    \ sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%')}');\n\
    \        ENDIF;\n    ENDIF;\n    \nElseIf( HierarchyExists( pDim , pHier ) = 1 & Trim( pHier ) @<>''\
    \ );\n    sMDX = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%pHier%')}');\n\
    \    \nElseIf( Scan( pDelim  , pHier )>0 % Scan( '*'     , pHier )>0 % Scan( '?'     , pHier )>0);\n\
    \    sMDX            = '{ ';\n    IF( Scan( pDelim  , pHier )>0 );\n        # delimiter in pHier.\
    \ Seperate and add MDX for each part separately\n        sHiers           = Trim( pHier );\n     \
    \   nDelimiterIndex = 1;\n        While( nDelimiterIndex <> 0 );    \n            nDelimiterIndex\
    \ = Scan( pDelim, sHiers );\n            If( nDelimiterIndex = 0 );\n                sHier       \
    \     = sHiers;\n            ELSE;\n                sHier            = Trim( SubSt( sHiers, 1, nDelimiterIndex\
    \ - 1 ) );\n                sHiers           = Trim( Subst( sHiers, nDelimiterIndex + Long(pDelim),\
    \ Long( sHiers ) ) );\n            ENDIF;\n            IF(HierarchyExists( pDim, sHier )=1 );\n  \
    \              sMDX            = sMDX | IF(Long(sMDX)>4,\n                                       \
    \     Expand(',TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')'),\n         \
    \                                   Expand(' TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')'));\
    \ \n            ELSEIF(Scan( '*', sHier )=0 & Scan( '?', sHier )=0 );\n                nErrors = 1;\n\
    \                sMessage= Expand('Dimension:Hierarchy %pDim%:%sHier% does not exist.');\n       \
    \         LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            ELSE;\n          \
    \      sMDX            = sMDX | IF(Long(sMDX)>4,\n                                            Expand(',TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')'),\n                                          \
    \  Expand(' TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')')); \n          \
    \  ENDIF;\n                \n        END;\n        sMDX                    = sMDX | ' }';\n    ELSE;\n\
    \        # No delimiters but with wildcards in hierachy\n        IF(HierarchyExists( pDim, pHier )=1\
    \ );\n            sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] )\
    \ ,'%pDim%:%pHier%')}');\n        ELSEIF(Scan( '*', pHier )=0 & Scan( '?', pHier )=0 );\n        \
    \    nErrors = 1;\n            sMessage= Expand('Dimension:Hierarchy %pDim%:%pHier% does not exist.');\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ELSE;\n           \
    \ sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%pHier%')}');\n\
    \        ENDIF;\n        \n    ENDIF;\n\nElseIf( Trim( pHier ) @='' );\n    ## Use main hierarchy\
    \ for each dimension processed\n    pHier = Trim( pDim );\n    sMDX            = '{ ';\n    IF( Scan(\
    \ pDelim  , pHier )>0 );\n        # delimiter in pHier. Seperate and add MDX for each part separately\n\
    \        sHiers           = Trim( pHier );\n        nDelimiterIndex = 1;\n        While( nDelimiterIndex\
    \ <> 0 );    \n            nDelimiterIndex = Scan( pDelim, sHiers );\n            If( nDelimiterIndex\
    \ = 0 );\n                sHier            = sHiers;\n            ELSE;\n                sHier   \
    \         = Trim( SubSt( sHiers, 1, nDelimiterIndex - 1 ) );\n                sHiers           = Trim(\
    \ Subst( sHiers, nDelimiterIndex + Long(pDelim), Long( sHiers ) ) );\n            ENDIF;\n       \
    \     IF(HierarchyExists( sHier, sHier )=1 );\n                sMDX            = sMDX | IF(Long(sMDX)>4,\n\
    \                                            Expand(',TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions]\
    \ ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')'),\n              \
    \                              Expand(' TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] )\
    \ , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')')); \n            ELSEIF(Scan(\
    \ '*', sHier )=0 & Scan( '?', sHier )=0 );\n                nErrors = 1;\n                sMessage=\
    \ Expand('Dimension:Hierarchy %sHier%:%sHier% does not exist.');\n                LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n            ELSE;\n                sMDX            = sMDX | IF(Long(sMDX)>4,\n\
    \                                            Expand(',TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions]\
    \ ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')'),\n              \
    \                              Expand(' TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] )\
    \ , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')')); \n            ENDIF;\n\
    \                \n        END;\n        sMDX                    = sMDX | ' }';\n    ELSE;\n     \
    \   # No delimiters but with wildcards in hierachy\n        IF(HierarchyExists( pDim, pHier )=1 );\n\
    \            sMDX                = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions]\
    \ ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%pDim%')}');\n        ELSEIF(Scan(\
    \ '*', pHier )=0 & Scan( '?', pHier )=0 );\n            nErrors = 1;\n            sMessage= Expand('Dimension:Hierarchy\
    \ %pDim%:%pHier% does not exist.');\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        ELSE;\n            sMDX                = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%pDim%')}');\n\
    \        ENDIF;\n        \n    ENDIF;\n    \nELSE;\n    nErrors = 1;\n    sMessage= Expand('Dimension:Hierarchy\
    \ %pDim%:%pHier% does not exist.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n    DatasourceType = 'NULL';\n\
    \    ProcessBreak;\nEndIf;\n\n# Create temporary subset\nSubsetCreatebyMDX(cSubset, sMDX , 1 );\n\n\
    ### Set data source for process ### \nDatasourceType              = 'SUBSET';\nDatasourceNameForServer\
    \     = cDim; \nDatasourceNameForClient     = cDim;\nDatasourceDimensionSubset   = cSubset;\n\n###\
    \ End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n# Validates characters in elements\n\n# Increment nMeta\nnMeta           = nMeta + 1;\n\n# Output\
    \ 1st line\nIF( nMeta = 1 );\n    sOutput     = 'Dimension:Hierarchy'' |','| ''Element''  |','| ''Type''\
    \ |','| ''Comments';\n    TextOutput ( cFile , sOutput );\nEndIf;\n\n### Skip Control dimensions###\n\
    IF(Subst(vDim , 1 , 1 ) @= '}' );\n    ItemSkip;\nENDIF;\n\n# Set Dim name & hierachy name\nIF( SCAN(\
    \ ':' , vDim )=0 );\n    sDim        = vDim ;\n    sHier       = sDim ;\nELSE;\n    sDim        =\
    \ SUBST( vDim, 1 , SCAN( ':' , vDim ) -1 );\n    sHier       = SUBST( vDim, SCAN( ':' , vDim ) +1,\
    \ 99 );\nENDIF;\n\nnDimSize        = ElementCount( sDim , sHier );\nnCount          = 1;\nWhile( nCount\
    \ <= nDimSize );\n    sEle        = ElementName( sDim , sHier , nCount );\n    sEleType    = ElementType(\
    \ sDim , sHier , sEle );\n    sEleNew     = '';\n    nEleSiz     = Long(sEle);\n    nChar       =\
    \ 1;\n    While( nChar <= nEleSiz & ElementIndex( sDim , sHier , sEle ) > 0 );\n        sChar    \
    \   = NumberToString( nChar );\n        sEleChar    = Subst( sEle , nChar , 1 );\n        nCode  \
    \     = CODE( sEle , nChar );\n        sCode       = NumberToString( nCode );\n        IF( vDim @=\
    \ sDim );\n            IF( nChar=1 & pFirst=1 & (nCode=39 % nCode=45 % nCode=91 % nCode=34 % nCode=64\
    \ % nCode=33 % nCode=43 % nCode=123 % nCode=37));\n                sOutput = Expand('%vDim%' , %sEle%\
    \ , %sEleType% ,Has an illegal 1st character '%sEleChar%' with an AscII code of %sCode%.');\n    \
    \            TextOutput ( cFile , sOutput );\n            EndIf;\n            IF( sEleChar@='/' %\
    \ sEleChar@='|' % sEleChar@=''' % sEleChar@='' % sEleChar@='>' % \n                sEleChar@='<' %\
    \ sEleChar@=':' % sEleChar@='?' % sEleChar@='*');     \n                sOutput = Expand('%vDim%'\
    \ , %sEle% , %sEleType% ,Has a forbidden character #%sChar% '%sEleChar%' with an AscII code of %sCode%.');\n\
    \                TextOutput ( cFile , sOutput );\n            ENDIF;\n        ELSEIF( ElementType(\
    \ sDim, sHier, sEle)@='C' % pHier@<>'' );\n            IF( nChar=1 & pFirst=1 & (nCode=39 % nCode=45\
    \ % nCode=91 % nCode=34 % nCode=64 % nCode=33 % nCode=43 % nCode=123 % nCode=37));\n             \
    \   sOutput = Expand('%vDim%' , %sEle% , %sEleType% ,Has an illegal 1st character '%sEleChar%' with\
    \ an AscII code of %sCode%.');\n                TextOutput ( cFile , sOutput );\n            EndIf;\n\
    \            IF( sEleChar@='/' % sEleChar@='|' % sEleChar@=''' % sEleChar@='' % sEleChar@='>' % \n\
    \                sEleChar@='<' % sEleChar@=':' % sEleChar@='?' % sEleChar@='*');     \n          \
    \      sOutput = Expand('%vDim%' , %sEle% , %sEleType% ,Has a forbidden character #%sChar% '%sEleChar%'\
    \ with an AscII code of %sCode%.');\n                TextOutput ( cFile , sOutput );\n           \
    \ ENDIF;\n        ENDIF;\n\n        nChar       = nChar + 1;\n    End;\n    \n    nCount      = nCount\
    \ + 1;\nEnd;\n\n### End MetaData ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### If errors occurred terminate process with a major error status ###\nIf( nErrors\
    \ <> 0 );\n  sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% incurred at\
    \ least 1 major error and consequently aborted.' );\n  nProcessReturnCode = 0;\n  LogOutput( 'ERROR',\
    \ Expand( sProcessReturnCode | ' Please see above lines in this file for more details.' ) );\n  If(\
    \ pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  EndIf;\nEndIf;\n\n#Return Code\nsProcessAction\
    \      = Expand( 'Process:%cThisProcName% has validated all the elements for %pDim% dimension and\
    \ generated a csv report: %cFile%.' );\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\nnProcessReturnCode  = 1;\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', sProcessAction );   \n\
    ENDIF;\n\n### End Epilog ###"
- question: "Develop an IBM Turbo Integrator process that reviews all elements in selected dimensions\
    \ and hierarchies, generating a CSV file listing all elements with unusual characters. Note that control\
    \ dimensions are ignored. The parameters of the process are: \n\n- pDim: Specify which dimensions\
    \ to validate. Use wildcards like `*` and `?` for patterns or a list of dimensions with a delimiter.\
    \ A `*` processes all dimensions. \n- pHier: Specify which hierarchies to validate. Use `*` for all\
    \ hierarchies or specific patterns. Note that if hierarchies are specified, pDim should not be set\
    \ up as a list or with wildcards. \n- pDelim: Determine the delimiter to separate multiple dimensions\
    \ or hierarchies. The default is `&`, but this can be customized. \n- pFirst: When `1`, all requirements\
    \ for all characters are validated, otherwise stringent requirements for the first character are ignored.'"
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will review all elements in selected dimensions (you\
    \ can specify a single dimension,\n# multiple dimensions or wildcards to match dimensions) and hierarchies\
    \ and will generate a `csv` \n# file listing all elements with unusual characters.\n# Control dimensions\
    \ are ignored.\n\n# Note:\n# - pDim: Specify which dimensions to validate. When specifying a dimension\
    \ name, wildcards can\n#   be specified by using the `*` and `?` characters. A list of dimensions\
    \ can also be entered with\n#   a delimiter (e.g. `v*&plan*` will process all dimensions starting\
    \ with `v` and `plan`). If \n#   * is entered then it ignores anything entered for hierarchy (pHier)\
    \ and processes all dimensions\n# - pHier: Specify which hierarchies to validate. To validate ALL\
    \ hierachies, enter *. \n#   When specifying a hierarchy name, wildcards can be specified by using\
    \ the\n#   `*` and `?` characters. A list of hierachies can also be entered with a delimiter. If pHier\n\
    #   has a value then it does not make sense that pDim can be set up as a list or with wildcards.\n\
    # - pDelim: The delimiter is used when specifying multiple dimensions or multiple hierachies. The\n\
    #   default delimiter is `&`. Any delimiter can be used by specifying a value for pDelim. Choose\n\
    #   a delimiter that won't be used in either the wildcard search strings or dimension names.\n# -\
    \ pFirst:\n#   - When set to `1`: all requirements for all characters are validated.\n#   - ELSE:\
    \ ignores stringent requirements for 1st character.\n#EndRegion @DOC\n\n\n### Global Variables\nStringGlobalVariable\
    \ ('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode = 0;\n\
    \n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp\
    \        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) *\
    \ 1000 ));\ncSubset           = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel \
    \   = 'ERROR';\ncMsgErrorContent  = '%cThisProcName% : %sMessage% : %cUserName%';\ncLogInfo      \
    \    = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pFirst:%pFirst%, pDelim:%pDelim%';\n\
    cDim              = '}Dimensions';\ncFile             = GetProcessErrorFileDirectory | 'Element Issues.csv';\n\
    \n# Variables\nnMeta             = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*',\
    \ pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @=\
    \ '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n\
    \    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified. Use * to process all\
    \ dimensions';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ hierarchy\nIf( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed,\
    \ this is managed inside the code below\nEndIf;\n\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\
    \n## Validate dimension\nIF( Trim( pDim ) @= '*' );\n    sMDX                = Expand('{ TM1SUBSETALL(\
    \ [}Dimensions] ) }');\nElseIf( Trim( pHier ) @= '*' );\n    IF( Scan( pDelim , pDim )>0 );\n    \
    \    # delimiter in pDim. Seperate and add MDX for each part separately\n        sMDX            =\
    \ '{ ';\n        sDims           = Trim( pDim );\n        nDelimiterIndex = 1;\n        While( nDelimiterIndex\
    \ <> 0 );    \n            nDelimiterIndex = Scan( pDelim, sDims );\n            If( nDelimiterIndex\
    \ = 0 );\n                sDim            = sDims;\n            ELSE;\n                sDim      \
    \      = Trim( SubSt( sDims, 1, nDelimiterIndex - 1 ) );\n                sDims           = Trim(\
    \ Subst( sDims, nDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n            ENDIF;\n         \
    \   IF(DimensionExists(sDim)=1 );\n                sMDX            = Expand('{TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%sDim%*')}');\n            ELSEIF(Scan( '*', sDim )=0 & Scan( '?',\
    \ sDim )=0 );\n                #nErrors = 1;\n                sMessage= Expand('Dimension %sDim% does\
    \ not exist.');\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      \
    \      ELSE;\n                sMDX            = sMDX | IF(Long(sMDX)>4,\n                        \
    \                    Expand(',TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%sDim%')'),\n  \
    \                                          Expand(' TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions]\
    \ ) ,'%sDim%')')); \n            ENDIF;\n        END;\n        sMDX                    = sMDX | '\
    \ }';\n    ELSE;\n        IF(DimensionExists(pDim)=1 );\n            sMDX                = Expand('{TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%pDim%*')}');\n        ELSEIF(Scan( '*', pDim )=0 & Scan( '?', pDim\
    \ )=0 );\n            nErrors = 1;\n            sMessage= Expand('Dimension %pDim% does not exist.');\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ELSE;\n           \
    \ sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%')}');\n\
    \        ENDIF;\n    ENDIF;\n    \nElseIf( HierarchyExists( pDim , pHier ) = 1 & Trim( pHier ) @<>''\
    \ );\n    sMDX = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%pHier%')}');\n\
    \    \nElseIf( Scan( pDelim  , pHier )>0 % Scan( '*'     , pHier )>0 % Scan( '?'     , pHier )>0);\n\
    \    sMDX            = '{ ';\n    IF( Scan( pDelim  , pHier )>0 );\n        # delimiter in pHier.\
    \ Seperate and add MDX for each part separately\n        sHiers           = Trim( pHier );\n     \
    \   nDelimiterIndex = 1;\n        While( nDelimiterIndex <> 0 );    \n            nDelimiterIndex\
    \ = Scan( pDelim, sHiers );\n            If( nDelimiterIndex = 0 );\n                sHier       \
    \     = sHiers;\n            ELSE;\n                sHier            = Trim( SubSt( sHiers, 1, nDelimiterIndex\
    \ - 1 ) );\n                sHiers           = Trim( Subst( sHiers, nDelimiterIndex + Long(pDelim),\
    \ Long( sHiers ) ) );\n            ENDIF;\n            IF(HierarchyExists( pDim, sHier )=1 );\n  \
    \              sMDX            = sMDX | IF(Long(sMDX)>4,\n                                       \
    \     Expand(',TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')'),\n         \
    \                                   Expand(' TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')'));\
    \ \n            ELSEIF(Scan( '*', sHier )=0 & Scan( '?', sHier )=0 );\n                nErrors = 1;\n\
    \                sMessage= Expand('Dimension:Hierarchy %pDim%:%sHier% does not exist.');\n       \
    \         LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n            ELSE;\n          \
    \      sMDX            = sMDX | IF(Long(sMDX)>4,\n                                            Expand(',TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')'),\n                                          \
    \  Expand(' TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%sHier%')')); \n          \
    \  ENDIF;\n                \n        END;\n        sMDX                    = sMDX | ' }';\n    ELSE;\n\
    \        # No delimiters but with wildcards in hierachy\n        IF(HierarchyExists( pDim, pHier )=1\
    \ );\n            sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] )\
    \ ,'%pDim%:%pHier%')}');\n        ELSEIF(Scan( '*', pHier )=0 & Scan( '?', pHier )=0 );\n        \
    \    nErrors = 1;\n            sMessage= Expand('Dimension:Hierarchy %pDim%:%pHier% does not exist.');\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ELSE;\n           \
    \ sMDX                = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) ,'%pDim%:%pHier%')}');\n\
    \        ENDIF;\n        \n    ENDIF;\n\nElseIf( Trim( pHier ) @='' );\n    ## Use main hierarchy\
    \ for each dimension processed\n    pHier = Trim( pDim );\n    sMDX            = '{ ';\n    IF( Scan(\
    \ pDelim  , pHier )>0 );\n        # delimiter in pHier. Seperate and add MDX for each part separately\n\
    \        sHiers           = Trim( pHier );\n        nDelimiterIndex = 1;\n        While( nDelimiterIndex\
    \ <> 0 );    \n            nDelimiterIndex = Scan( pDelim, sHiers );\n            If( nDelimiterIndex\
    \ = 0 );\n                sHier            = sHiers;\n            ELSE;\n                sHier   \
    \         = Trim( SubSt( sHiers, 1, nDelimiterIndex - 1 ) );\n                sHiers           = Trim(\
    \ Subst( sHiers, nDelimiterIndex + Long(pDelim), Long( sHiers ) ) );\n            ENDIF;\n       \
    \     IF(HierarchyExists( sHier, sHier )=1 );\n                sMDX            = sMDX | IF(Long(sMDX)>4,\n\
    \                                            Expand(',TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions]\
    \ ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')'),\n              \
    \                              Expand(' TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] )\
    \ , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')')); \n            ELSEIF(Scan(\
    \ '*', sHier )=0 & Scan( '?', sHier )=0 );\n                nErrors = 1;\n                sMessage=\
    \ Expand('Dimension:Hierarchy %sHier%:%sHier% does not exist.');\n                LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n            ELSE;\n                sMDX            = sMDX | IF(Long(sMDX)>4,\n\
    \                                            Expand(',TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions]\
    \ ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')'),\n              \
    \                              Expand(' TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions] )\
    \ , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%sHier%')')); \n            ENDIF;\n\
    \                \n        END;\n        sMDX                    = sMDX | ' }';\n    ELSE;\n     \
    \   # No delimiters but with wildcards in hierachy\n        IF(HierarchyExists( pDim, pHier )=1 );\n\
    \            sMDX                = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL( [}Dimensions]\
    \ ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%pDim%')}');\n        ELSEIF(Scan(\
    \ '*', pHier )=0 & Scan( '?', pHier )=0 );\n            nErrors = 1;\n            sMessage= Expand('Dimension:Hierarchy\
    \ %pDim%:%pHier% does not exist.');\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n        ELSE;\n            sMDX                = Expand('{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'%pDim%')}');\n\
    \        ENDIF;\n        \n    ENDIF;\n    \nELSE;\n    nErrors = 1;\n    sMessage= Expand('Dimension:Hierarchy\
    \ %pDim%:%pHier% does not exist.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n    DatasourceType = 'NULL';\n\
    \    ProcessBreak;\nEndIf;\n\n# Create temporary subset\nSubsetCreatebyMDX(cSubset, sMDX , 1 );\n\n\
    ### Set data source for process ### \nDatasourceType              = 'SUBSET';\nDatasourceNameForServer\
    \     = cDim; \nDatasourceNameForClient     = cDim;\nDatasourceDimensionSubset   = cSubset;\n\n###\
    \ End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n# Validates characters in elements\n\n# Increment nMeta\nnMeta           = nMeta + 1;\n\n# Output\
    \ 1st line\nIF( nMeta = 1 );\n    sOutput     = 'Dimension:Hierarchy'' |','| ''Element''  |','| ''Type''\
    \ |','| ''Comments';\n    TextOutput ( cFile , sOutput );\nEndIf;\n\n### Skip Control dimensions###\n\
    IF(Subst(vDim , 1 , 1 ) @= '}' );\n    ItemSkip;\nENDIF;\n\n# Set Dim name & hierachy name\nIF( SCAN(\
    \ ':' , vDim )=0 );\n    sDim        = vDim ;\n    sHier       = sDim ;\nELSE;\n    sDim        =\
    \ SUBST( vDim, 1 , SCAN( ':' , vDim ) -1 );\n    sHier       = SUBST( vDim, SCAN( ':' , vDim ) +1,\
    \ 99 );\nENDIF;\n\nnDimSize        = ElementCount( sDim , sHier );\nnCount          = 1;\nWhile( nCount\
    \ <= nDimSize );\n    sEle        = ElementName( sDim , sHier , nCount );\n    sEleType    = ElementType(\
    \ sDim , sHier , sEle );\n    sEleNew     = '';\n    nEleSiz     = Long(sEle);\n    nChar       =\
    \ 1;\n    While( nChar <= nEleSiz & ElementIndex( sDim , sHier , sEle ) > 0 );\n        sChar    \
    \   = NumberToString( nChar );\n        sEleChar    = Subst( sEle , nChar , 1 );\n        nCode  \
    \     = CODE( sEle , nChar );\n        sCode       = NumberToString( nCode );\n        IF( vDim @=\
    \ sDim );\n            IF( nChar=1 & pFirst=1 & (nCode=39 % nCode=45 % nCode=91 % nCode=34 % nCode=64\
    \ % nCode=33 % nCode=43 % nCode=123 % nCode=37));\n                sOutput = Expand('%vDim%' , %sEle%\
    \ , %sEleType% ,Has an illegal 1st character '%sEleChar%' with an AscII code of %sCode%.');\n    \
    \            TextOutput ( cFile , sOutput );\n            EndIf;\n            IF( sEleChar@='/' %\
    \ sEleChar@='|' % sEleChar@=''' % sEleChar@='' % sEleChar@='>' % \n                sEleChar@='<' %\
    \ sEleChar@=':' % sEleChar@='?' % sEleChar@='*');     \n                sOutput = Expand('%vDim%'\
    \ , %sEle% , %sEleType% ,Has a forbidden character #%sChar% '%sEleChar%' with an AscII code of %sCode%.');\n\
    \                TextOutput ( cFile , sOutput );\n            ENDIF;\n        ELSEIF( ElementType(\
    \ sDim, sHier, sEle)@='C' % pHier@<>'' );\n            IF( nChar=1 & pFirst=1 & (nCode=39 % nCode=45\
    \ % nCode=91 % nCode=34 % nCode=64 % nCode=33 % nCode=43 % nCode=123 % nCode=37));\n             \
    \   sOutput = Expand('%vDim%' , %sEle% , %sEleType% ,Has an illegal 1st character '%sEleChar%' with\
    \ an AscII code of %sCode%.');\n                TextOutput ( cFile , sOutput );\n            EndIf;\n\
    \            IF( sEleChar@='/' % sEleChar@='|' % sEleChar@=''' % sEleChar@='' % sEleChar@='>' % \n\
    \                sEleChar@='<' % sEleChar@=':' % sEleChar@='?' % sEleChar@='*');     \n          \
    \      sOutput = Expand('%vDim%' , %sEle% , %sEleType% ,Has a forbidden character #%sChar% '%sEleChar%'\
    \ with an AscII code of %sCode%.');\n                TextOutput ( cFile , sOutput );\n           \
    \ ENDIF;\n        ENDIF;\n\n        nChar       = nChar + 1;\n    End;\n    \n    nCount      = nCount\
    \ + 1;\nEnd;\n\n### End MetaData ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### If errors occurred terminate process with a major error status ###\nIf( nErrors\
    \ <> 0 );\n  sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% incurred at\
    \ least 1 major error and consequently aborted.' );\n  nProcessReturnCode = 0;\n  LogOutput( 'ERROR',\
    \ Expand( sProcessReturnCode | ' Please see above lines in this file for more details.' ) );\n  If(\
    \ pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  EndIf;\nEndIf;\n\n#Return Code\nsProcessAction\
    \      = Expand( 'Process:%cThisProcName% has validated all the elements for %pDim% dimension and\
    \ generated a csv report: %cFile%.' );\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\nnProcessReturnCode  = 1;\nIF ( pLogoutput = 1 );\n  LogOutput('INFO', sProcessAction );   \n\
    ENDIF;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der alle konsolidierten Elemente ohne untergeordnete
    Elemente in der Zielhierarchie löscht. Verwende diesen Prozess, um Konsolidierungen nach Änderungen
    in der Dimension aufzuräumen. Wichtig: Eine gültige Zieldimension (pDim) muss angegeben werden, sonst
    wird der Prozess abgebrochen. Achtung: Die Zielhierarchie (pHier) darf nicht ''Leaves'' sein.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete all consolidated elements with no children\
    \ in the target Hierarchy.\n\n# Use case:\n# - Service process to clean-up consolidations after dimension\
    \ changes.\n\n# Note:\n# Valid target dimension (pDim) must be supplied otherwise the process will\
    \ terminate.\n\n# Caution: Target hierarchy (pHier) cannot be `Leaves`.\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        =\
    \ 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%.' ;  \ncMsgInfoContent =\
    \ 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan(\
    \ ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':',\
    \ pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\
    \n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension\
    \ specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ Hierarchy\nIf( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed\
    \ this is managed inside the code below\nEndIf;\n\n# If blank delimiter specified then convert to\
    \ default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\nnDimDelimiterIndex = 1;\nsMdx\
    \ = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension > sDim\n\
    \    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex = 0 );\n        sDim\
    \ = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n       \
    \ sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n\
    \    \n      # Create subset of dimensions using Wildcard to loop through dimensions in pDim with\
    \ wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n\
    \    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n\
    \    ENDIF;\nEnd;\n\nIf( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n    # If a delimited list\
    \ of dim names includes wildcards then we may have to re-use the subset multiple times\n    SubsetMDXSet(\
    \ '}Dimensions' , cTempSub, sMDX );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n\
    \    SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\nEndIf;\n\n# Loop through dimensions\
    \ in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\nWhile(\
    \ nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim );\n   \
    \ # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n        nErrors = 1;\n        sMessage\
    \ = Expand( 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage = Expand( 'Dimension %sDim% being\
    \ processed....' );\n          LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n        EndIf;\n \
    \       # Loop through hierarchies in pHier\n        If( Trim( pHier ) @= '' );\n          ### Use\
    \ main hierarchy for each dimension if pHier is empty\n          sHierarchies = sDim;\n        Else;\n\
    \          sHierarchies              = pHier;\n        EndIf;\n        nDelimiterIndexA    = 1;\n\
    \        sHierDim            = '}Dimensions';\n        \n        sMdxHier = '';\n        While( nDelimiterIndexA\
    \ <> 0 );\n\n            nDelimiterIndexA = Scan( pDelim, sHierarchies );\n            If( nDelimiterIndexA\
    \ = 0 );\n                sHierarchy   = sHierarchies;\n            Else;\n                sHierarchy\
    \   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n                sHierarchies  = Trim(\
    \ Subst( sHierarchies, nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n            EndIf;\n\
    \            \n            ## If no wildcard specified and current hierarchy does not exist in dimension,\
    \ create it\n            If( Scan( '*', sHierarchy ) = 0 & Scan( '?', sHierarchy ) = 0);\n       \
    \       If( HierarchyExists( sDim, sHierarchy ) = 0 );\n                  HierarchyCreate( sDim, sHierarchy\
    \ );\n              EndIf;\n            EndIf;\n\n            # Create subset of Hierarchies using\
    \ Wildcard\n            If( sHierarchy @= sDim );\n                sHierExp = '''| sHierarchy |''';\n\
    \            Else;\n                sHierExp = '''|sDim|':'|sHierarchy|''';\n            EndIf;\n\
    \            sMdxHierPart = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp |\
    \ ')}';\n            IF( sMdxHier @= ''); \n              sMdxHier = sMdxHierPart; \n            ELSE;\n\
    \              sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n            ENDIF;\n        End;\n   \
    \     IF(Trim(pHier) @= '*');\n          sMdxHier = '{ UNION ( ' | sMdxHier |' , {[}Dimensions].['\
    \ | sDim | ']} )}';\n        ENDIF;\n        \n        If( SubsetExists( sHierDim, cTempSub ) = 1\
    \ );\n            # If a delimited list of attr names includes wildcards then we may have to re-use\
    \ the subset multiple times\n            SubsetMDXSet( sHierDim, cTempSub, sMdxHier );\n        Else;\n\
    \            # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMdxHier, sHierDim, 1 );\n        EndIf;\n    \n        # Loop through subset of hierarchies\
    \ created based on wildcard\n        nCountHier = SubsetGetSize( sHierDim, cTempSub );\n        While(\
    \ nCountHier >= 1 );\n            sCurrHier = SubsetGetElementName( sHierDim, cTempSub, nCountHier\
    \ );\n            sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n \
    \           # Validate hierarchy name in dimension\n            If( Dimix( sHierDim , sCurrHier )\
    \ = 0 );\n                sMessage = Expand('The %sCurrHier% hierarchy does NOT exist in the %sDim%\
    \ dimension.');\n                LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n            Else;\n\
    \              If( pLogOutput = 1 );\n                sMessage = Expand( 'Hierarchy %sCurrHierName%\
    \ in Dimension %sDim% being processed....' );\n                LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n              EndIf;\n              \n              ### Go through dimension and delete consols\
    \ with no children ###\n              nElementCount       = ElementCount( sDim, sCurrHierName );\n\
    \              While( nElementCount >= 1 );\n                  sElement        = ElementName( sDim,\
    \ sCurrHierName, nElementCount );\n                  sElementType    = ElementType( sDim, sCurrHierName,\
    \ sElement );\n                  If( sElementType @= 'C' );\n                      nChildCount = ElementComponentCount(\
    \ sDim, sCurrHierName, sElement );\n                      If( nChildCount = 0 );\n               \
    \           HierarchyElementDelete( sDim, sCurrHierName, sElement );\n                      EndIf;\n\
    \                  EndIf;\n                  nElementCount = nElementCount - 1;\n              End;\n\
    \n          Endif;\n          \n            nCountHier = nCountHier - 1;\n        End;\n         \
    \   \n    EndIf;\n    \n    nCountDim = nCountDim - 1;\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see\
    \ above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted all C level items that did not have children.' );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that deletes all consolidated elements with no children
    in the target hierarchy. Use this process to clean up consolidations after dimension changes. Note:
    A valid target dimension (pDim) must be supplied, otherwise the process will terminate. Caution: The
    target hierarchy (pHier) cannot be ''Leaves''.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete all consolidated elements with no children\
    \ in the target Hierarchy.\n\n# Use case:\n# - Service process to clean-up consolidations after dimension\
    \ changes.\n\n# Note:\n# Valid target dimension (pDim) must be supplied otherwise the process will\
    \ terminate.\n\n# Caution: Target hierarchy (pHier) cannot be `Leaves`.\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        =\
    \ 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%.' ;  \ncMsgInfoContent =\
    \ 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan(\
    \ ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':',\
    \ pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\
    \n# Validate dimension\nIf( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension\
    \ specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ Hierarchy\nIf( Trim( pHier ) @= '' );\n    ## use same name as Dimension. Since wildcards are allowed\
    \ this is managed inside the code below\nEndIf;\n\n# If blank delimiter specified then convert to\
    \ default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\nnDimDelimiterIndex = 1;\nsMdx\
    \ = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    # Extract 1st dimension > sDim\n\
    \    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex = 0 );\n        sDim\
    \ = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n       \
    \ sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n\
    \    \n      # Create subset of dimensions using Wildcard to loop through dimensions in pDim with\
    \ wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart = '{TM1FILTERBYPATTERN( EXCEPT( TM1SUBSETALL(\
    \ [}Dimensions] ) , TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '*:*') ) ,'| sDimExp | ')}';\n\
    \    IF( sMdx @= ''); \n      sMdx = sMdxPart; \n    ELSE;\n      sMdx = sMdx | ' + ' | sMdxPart;\n\
    \    ENDIF;\nEnd;\n\nIf( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n    # If a delimited list\
    \ of dim names includes wildcards then we may have to re-use the subset multiple times\n    SubsetMDXSet(\
    \ '}Dimensions' , cTempSub, sMDX );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n\
    \    SubsetCreatebyMDX( cTempSub, sMDX, '}Dimensions' , 1 );\nEndIf;\n\n# Loop through dimensions\
    \ in subset created based on wildcard\nnCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\nWhile(\
    \ nCountDim >= 1 );\n    sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim );\n   \
    \ # Validate dimension name\n    If( DimensionExists(sDim) = 0 );\n        nErrors = 1;\n        sMessage\
    \ = Expand( 'Dimension %sDim% does not exist.' );\n        LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        If( pLogOutput = 1 );\n          sMessage = Expand( 'Dimension %sDim% being\
    \ processed....' );\n          LogOutput( 'INFO', Expand( cMsgInfoContent ) );\n        EndIf;\n \
    \       # Loop through hierarchies in pHier\n        If( Trim( pHier ) @= '' );\n          ### Use\
    \ main hierarchy for each dimension if pHier is empty\n          sHierarchies = sDim;\n        Else;\n\
    \          sHierarchies              = pHier;\n        EndIf;\n        nDelimiterIndexA    = 1;\n\
    \        sHierDim            = '}Dimensions';\n        \n        sMdxHier = '';\n        While( nDelimiterIndexA\
    \ <> 0 );\n\n            nDelimiterIndexA = Scan( pDelim, sHierarchies );\n            If( nDelimiterIndexA\
    \ = 0 );\n                sHierarchy   = sHierarchies;\n            Else;\n                sHierarchy\
    \   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA - 1 ) );\n                sHierarchies  = Trim(\
    \ Subst( sHierarchies, nDelimiterIndexA + Long(pDelim), Long( sHierarchies ) ) );\n            EndIf;\n\
    \            \n            ## If no wildcard specified and current hierarchy does not exist in dimension,\
    \ create it\n            If( Scan( '*', sHierarchy ) = 0 & Scan( '?', sHierarchy ) = 0);\n       \
    \       If( HierarchyExists( sDim, sHierarchy ) = 0 );\n                  HierarchyCreate( sDim, sHierarchy\
    \ );\n              EndIf;\n            EndIf;\n\n            # Create subset of Hierarchies using\
    \ Wildcard\n            If( sHierarchy @= sDim );\n                sHierExp = '''| sHierarchy |''';\n\
    \            Else;\n                sHierExp = '''|sDim|':'|sHierarchy|''';\n            EndIf;\n\
    \            sMdxHierPart = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sHierDim| '])},'| sHierExp |\
    \ ')}';\n            IF( sMdxHier @= ''); \n              sMdxHier = sMdxHierPart; \n            ELSE;\n\
    \              sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n            ENDIF;\n        End;\n   \
    \     IF(Trim(pHier) @= '*');\n          sMdxHier = '{ UNION ( ' | sMdxHier |' , {[}Dimensions].['\
    \ | sDim | ']} )}';\n        ENDIF;\n        \n        If( SubsetExists( sHierDim, cTempSub ) = 1\
    \ );\n            # If a delimited list of attr names includes wildcards then we may have to re-use\
    \ the subset multiple times\n            SubsetMDXSet( sHierDim, cTempSub, sMdxHier );\n        Else;\n\
    \            # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMdxHier, sHierDim, 1 );\n        EndIf;\n    \n        # Loop through subset of hierarchies\
    \ created based on wildcard\n        nCountHier = SubsetGetSize( sHierDim, cTempSub );\n        While(\
    \ nCountHier >= 1 );\n            sCurrHier = SubsetGetElementName( sHierDim, cTempSub, nCountHier\
    \ );\n            sCurrHierName = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n \
    \           # Validate hierarchy name in dimension\n            If( Dimix( sHierDim , sCurrHier )\
    \ = 0 );\n                sMessage = Expand('The %sCurrHier% hierarchy does NOT exist in the %sDim%\
    \ dimension.');\n                LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n            Else;\n\
    \              If( pLogOutput = 1 );\n                sMessage = Expand( 'Hierarchy %sCurrHierName%\
    \ in Dimension %sDim% being processed....' );\n                LogOutput( 'INFO', Expand( cMsgInfoContent\
    \ ) );\n              EndIf;\n              \n              ### Go through dimension and delete consols\
    \ with no children ###\n              nElementCount       = ElementCount( sDim, sCurrHierName );\n\
    \              While( nElementCount >= 1 );\n                  sElement        = ElementName( sDim,\
    \ sCurrHierName, nElementCount );\n                  sElementType    = ElementType( sDim, sCurrHierName,\
    \ sElement );\n                  If( sElementType @= 'C' );\n                      nChildCount = ElementComponentCount(\
    \ sDim, sCurrHierName, sElement );\n                      If( nChildCount = 0 );\n               \
    \           HierarchyElementDelete( sDim, sCurrHierName, sElement );\n                      EndIf;\n\
    \                  EndIf;\n                  nElementCount = nElementCount - 1;\n              End;\n\
    \n          Endif;\n          \n            nCountHier = nCountHier - 1;\n        End;\n         \
    \   \n    EndIf;\n    \n    nCountDim = nCountDim - 1;\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\n#Section Daten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see\
    \ above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted all C level items that did not have children.' );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der alle Dimensionselemente in einer Hierarchie
    in eine Datei exportiert. Die Exportdatei soll alle Daten enthalten, die zur vollständigen Rekonstruktion
    der Dimension benötigt werden. Ein benutzerdefiniertes Trennzeichen (angegeben durch ein Zeichen oder
    dessen ASCII-Code) kann verwendet werden. Das Dateiformat ist wie folgt: Die erste Zeile enthält Metadaten
    der Datei mit einer Zusammenfassung der Dimension, der Hierarchie, der Anzahl der Elemente und dem
    Datum/Zeitpunkt der Dateierstellung. Die zweite Zeile gibt die Quelldimension und Hierarchie an. Die
    dritte Zeile zeigt die Sortierreihenfolge der Dimension. Die vierte und fünfte Zeile sind für zukünftige
    Entwicklungen reserviert. Die sechste Zeile ist die Kopfzeile für den Elementexport. Ab der siebten
    Zeile folgen die Elementeexportdaten. Dieser Prozess sollte dazu verwendet werden, ein Backup der
    Dimension vor Veränderungen in der produktiven Umgebung zu erstellen oder eine schnelle Replikation
    einer großen Dimension zu ermöglichen. Dabei sind ein gültiger Dimensionsname (pDim), die Einhaltung
    einer Kopfzeile (pTitleRecord) und das Legacy-Exportformat (pLegacy) zwingend erforderlich, andernfalls
    wird der Prozess abgebrochen. Falls erforderlich, kann ein benutzerdefiniertes Trennzeichen durch
    Angabe des Parameters pDelim als einzelnes Zeichen oder als 3-stellige (dezimal) ASCII-Code verwendet
    werden. Zum Beispiel, um TAB als Trennzeichen zu verwenden, verwende 009. Achtung: Der Prozess wurde
    in Bedrock4 neu gestaltet, kann jedoch Dimensionsexporte aus früheren Versionen von Bedrock im Legacy-Modus
    (pLegacy = 1) verarbeiten.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Export all Dimension elements in a Hierarchy to\
    \ a File. Export file maintains\n# all data that can be used to completely reconstruct the dimension.\
    \ Custom record delimiter\n# (specified by a character or its ASCII code) can be used.\n# __Format\
    \ of the file:__  \n# - 1st line: File metadata contains summary information about the dimension,\
    \ hierarchy, number of\n#   elements and date/time when file was generated.\n# - 2nd line: Source\
    \ dimension and hierarchy.\n# - 3rd line: Dimension sort order.\n# - 4th and 5th line: Reserved for\
    \ future development.\n# - 6th line: Header for elements export.\n# - 7th line and forth: Elements\
    \ export data.\n\n# Use case:\n# 1. Backup of dimension before changes in productive environment.\n\
    # 2. Quick replication of a large dimension.\n\n# Note:\n# Valid dimension name (pDim), inclusion\
    \ of header (pTitleRecord) and legacy export format (pLegacy)\n# are mandatory otherwise the process\
    \ will abort.\n# If needed, custom delimiter might be used by specifying parameter pDelim value as\
    \ either exactly one\n# character or as a 3-digit (decimal) ASCII code. For example to use TAB as\
    \ a delimiter, use 009.\n\n# Caution: Process was redesigned in Bedrock4 but is able to process dimension\
    \ extracts from prior\n# versions of Bedrock in legacy mode (pLegacy = 1).\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        =\
    \ 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%,\
    \ pTitleRecord:%pTitleRecord%, pDelim:%pDelim%, pQuote:%pQuote%, pLegacy:%pLegacy%.';\ncCubeS1   \
    \      = '}DimensionProperties';\ncType           = 'Type-';\ncParent         = 'Parent-';\ncIndex\
    \          = 'Index-';\ncWeight         = 'Weight-';\ncAttrName       = 'Attr Name-';\ncAttrValue\
    \      = 'Attr Value-';\ncLenASCIICode = 3;\n\npDelim  = TRIM(pDelim);\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Initialise ###\n\
    nRecordCount = 0;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier\
    \ @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n\
    \    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'Dimension: ' | pDim | ' does not exist.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate Hierarchy\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\nElse;\n  sHier\
    \ = pHier;\nEndIf;\n\nIf( HierarchyExists( pDim, sHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'The\
    \ Hierachy ' | sHier | ' does not exist.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':'\
    \ );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0\
    \ );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n\
    # Validate export path\nIf( Trim( pTgtDir ) @= '' );\n    pTgtDir     = GetProcessErrorFileDirectory;\n\
    \    sMessage    = 'Target folder defaulted to error file directory.';\n    LogOutput( 'INFO', Expand(\
    \ cMsgErrorContent ) );\nEndIf;\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n    pTgtDir\
    \ = SubSt( pTgtDir, 1, Long( pTgtDir ) -1 );\nEndIf;\nIf( FileExists( pTgtDir ) = 0 );\n    nErrors\
    \     = 1;\n    sMessage    = 'Invalid export path specified. Folder does not exist.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npTgtDir         = pTgtDir | sOSDelim;\n\n\
    # Validate export filename\nIf( pTgtFile @= '' );\n    pTgtFile        = pDim | If( pLegacy = 1,'','\
    \ '|sHier ) | '_Export.csv';\nElseIf( Scan( '.', pTgtFile ) = 0 );\n    # No file extension specified\n\
    \    pTgtFile        = pTgtFile | '.csv';\nEndIf;\n\n# Validate file delimiter & quote character\n\
    If( pDelim @= '' );\n    pDelim = ',';\nElse;\n    # If length of pDelim is exactly 3 chars and each\
    \ of them is decimal digit, then the pDelim is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim)\
    \ = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE(\
    \ pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim, nChar )<=CODE( '9', 1 ) );\n          nValid = 1;\n\
    \        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n  \
    \  EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber( pDelim ));\n    Else;\n      pDelim\
    \ = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote character\
    \ \nElse;\n    # If length of pQuote is exactly 3 chars and each of them is decimal digit, then the\
    \ pQuote is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n   \
    \   nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n  \
    \        nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If (\
    \ nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote = SubSt( Trim(\
    \ pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate Character Set\nIf(Trim( pCharacterSet ) @= ''\
    \ );\n  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n# Construct full export filename including path\n\
    sFilename       = pTgtDir | pTgtFile;\nsAttrDimName    = '}ElementAttributes_' | pDim ;\n\n### Check\
    \ for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Data Source ###\nDatasourceNameForServer\
    \     = pDim | IF(pHier@='','',':'|pHier) ;\nDatasourceNameForClient     = DatasourceNameForServer\
    \ ;\nDataSourceType              = 'SUBSET';\nDatasourceDimensionSubset   = 'ALL';\nDatasourceAsciiDelimiter=\
    \ pDelim;\nDatasourceAsciiQuoteCharacter = pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n# Set the output character set\nSetOutputCharacterSet(\
    \ sFileName, pCharacterSet );\n\n### Record Count\nnRecordCount = nRecordCount + 1;\n\n### Export\
    \ Header Information\n## Line 1: File Metadata information\nIf( nRecordCount = 1 & pTitleRecord =\
    \ 1 );\n    TextOutput( sFilename, 'Export from dimension Hierarchy: ' | pDim|':'|sHier | ', all elements\
    \ in index order. Total elements=' |\n                 NumberToString( ElementCount( pDim, sHier )\
    \ ) | '. On ' | Date( Now, 1 ) | ' at ' | Time );\n\n## Line 2: Source Dimension\n    TextOutput(\
    \ sFilename, pDim, sHier  );\n\n## Line 3: Sort Order Information\n    sSortElementType    = CELLGETS(\
    \ cCubeS1, pDim, 'SORTELEMENTSTYPE' );\n    sSortComponentType  = CELLGETS( cCubeS1, pDim, 'SORTCOMPONENTSTYPE'\
    \ );\n    sSortElementSense   = CELLGETS( cCubeS1, pDim, 'SORTELEMENTSSENSE' );\n    sSortComponentSense\
    \ = CELLGETS( cCubeS1, pDim, 'SORTCOMPONENTSSENSE' );\n    If( pLegacy = 1 );\n        TextOutput(\
    \ sFilename, sSortElementType , sSortComponentType , sSortElementSense , sSortComponentSense  );\n\
    \    Else;\n        TextOutput( sFilename, 'Sort parameters :', sSortElementType , sSortComponentType\
    \ , sSortElementSense , sSortComponentSense  );\n    EndIf;\n    \n## Line 4 (and 5?): Header Information\n\
    \    If( pLegacy = 1 );\n            TextOutput( sFilename, 'Reserved' );\n    EndIf;\n    TextOutput(\
    \ sFilename, 'Reserved' );\n    \n## Line 5 or 6: Header Information\n    TextOutput( sFilename, 'Line_Type',\
    \ 'Element', 'Value_1', 'Value_2', 'Value_3' );\n\n### Attribute Information \n    If( DimensionExists(\
    \ sAttrDimName ) = 1 );\n        nIndex = 1;\n        nLimit = DIMSIZ ( sAttrDimName );\n        WHILE(\
    \ nIndex <= nLimit );\n            sElName   = DIMNM( sAttrDimName, nIndex );\n            sElType\
    \   = DTYPE( sAttrDimName, sElName);\n            TextOutput( sFilename, 'A', sElName, sElType );\n\
    \            nIndex = nIndex + 1;\n        END; \n    EndIf;\n#    TextOutput( sFilename, '' );\n\
    EndIf;\n\n### Element Information\nnElIndex        = ElementIndex( pDim, sHier, vEle );\nsElType \
    \        = ElementTYPE(  pDim, sHier, vEle );\nTextOutput( sFilename,'E', vEle, If( pLegacy = 1,'',\
    \ cType ) | sElType, If( pLegacy = 1,'', cIndex ) | NumberToString( nElIndex ) );\n\n### Element Parents\n\
    nElPar          = ElementParentCount( pDim, sHier, vEle );\nIF( nElPar > 0 );\n    nIndex = 1;\n \
    \   nLimit = nElPar;\n    WHILE( nIndex <= nLimit );\n        sElPar  = ElementParent( pDim, sHier,\
    \ vEle, nIndex );\n        sElType = ElementTYPE( pDim, sHier, sElPar );\n        nElWgt  = ElementWeight(\
    \ pDim, sHier, sElPar, vEle );\n        TextOutput( sFilename, 'P', vEle, If( pLegacy = 1,'', cParent\
    \ ) | sElPar, If( pLegacy = 1,'', cType ) | sElType, If( pLegacy = 1,'', cWeight ) | NumberToString(\
    \ nElWgt ) );\n        nIndex = nIndex + 1;\n    END;\nENDIF;\n\n### Attribute Value \nIF( DimensionExists(\
    \ sAttrDimName ) = 1 );\n    nIndex = 1;\n    nLimit = DIMSIZ ( sAttrDimName );\n    WHILE( nIndex\
    \ <= nLimit );\n        sElName   = DIMNM( sAttrDimName, nIndex );\n        sElType   = DTYPE( sAttrDimName,\
    \ sElName);\n        IF( sElType @= 'AN' );\n            sAttrValue = NumberToString( ElementAttrN(\
    \ pDim , sHier , vEle , sElName ) );\n        ELSE;\n            sAttrValue = ElementAttrS( pDim ,\
    \ sHier , vEle , sElName );\n        ENDIF;\n        IF( sAttrValue @<>'' & sAttrValue @<>'0' );\n\
    \            TextOutput( sFilename, 'V', vEle, If( pLegacy = 1,'', cAttrName ) | sElName, If( pLegacy\
    \ = 1,'', cAttrValue ) | sAttrValue );\n        EndIf;\n        nIndex = nIndex + 1;\n    END;\nENDIF;\n\
    \n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    ### If errors occurred terminate process with a major error status ###\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 major error and consequently aborted. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nEndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName%\
    \ successfully exported the %pDim%:%pHier% dimension:hierarchy to %sFileName%.' );\nsProcessReturnCode\
    \  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode  = 1;\nIf ( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \nEndIf;\n\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that exports all dimension elements in a hierarchy
    to a file. The export file should maintain all data necessary to completely reconstruct the dimension.
    A custom record delimiter (specified by a character or its ASCII code) can be used. The file format
    is as follows: The first line contains file metadata with a summary of the dimension, hierarchy, number
    of elements, and the date/time the file was generated. The second line indicates the source dimension
    and hierarchy. The third line shows the dimension sort order. The fourth and fifth lines are reserved
    for future development. The sixth line is the header for elements export. From the seventh line onwards,
    element export data follows. This process should be used to create a backup of the dimension before
    changes in the production environment or to quickly replicate a large dimension. A valid dimension
    name (pDim), inclusion of a header (pTitleRecord), and legacy export format (pLegacy) are mandatory,
    otherwise the process will abort. If needed, a custom delimiter can be used by specifying the parameter
    pDelim as either exactly one character or as a 3-digit (decimal) ASCII code. For example, to use TAB
    as a delimiter, use 009. Caution: The process was redesigned in Bedrock4 but is able to process dimension
    extracts from prior versions of Bedrock in legacy mode (pLegacy = 1).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Export all Dimension elements in a Hierarchy to\
    \ a File. Export file maintains\n# all data that can be used to completely reconstruct the dimension.\
    \ Custom record delimiter\n# (specified by a character or its ASCII code) can be used.\n# __Format\
    \ of the file:__  \n# - 1st line: File metadata contains summary information about the dimension,\
    \ hierarchy, number of\n#   elements and date/time when file was generated.\n# - 2nd line: Source\
    \ dimension and hierarchy.\n# - 3rd line: Dimension sort order.\n# - 4th and 5th line: Reserved for\
    \ future development.\n# - 6th line: Header for elements export.\n# - 7th line and forth: Elements\
    \ export data.\n\n# Use case:\n# 1. Backup of dimension before changes in productive environment.\n\
    # 2. Quick replication of a large dimension.\n\n# Note:\n# Valid dimension name (pDim), inclusion\
    \ of header (pTitleRecord) and legacy export format (pLegacy)\n# are mandatory otherwise the process\
    \ will abort.\n# If needed, custom delimiter might be used by specifying parameter pDelim value as\
    \ either exactly one\n# character or as a 3-digit (decimal) ASCII code. For example to use TAB as\
    \ a delimiter, use 009.\n\n# Caution: Process was redesigned in Bedrock4 but is able to process dimension\
    \ extracts from prior\n# versions of Bedrock in legacy mode (pLegacy = 1).\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName      \
    \ = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel\
    \  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo        =\
    \ 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%,\
    \ pTitleRecord:%pTitleRecord%, pDelim:%pDelim%, pQuote:%pQuote%, pLegacy:%pLegacy%.';\ncCubeS1   \
    \      = '}DimensionProperties';\ncType           = 'Type-';\ncParent         = 'Parent-';\ncIndex\
    \          = 'Index-';\ncWeight         = 'Weight-';\ncAttrName       = 'Attr Name-';\ncAttrValue\
    \      = 'Attr Value-';\ncLenASCIICode = 3;\n\npDelim  = TRIM(pDelim);\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Initialise ###\n\
    nRecordCount = 0;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier\
    \ @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n\
    \    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'Dimension: ' | pDim | ' does not exist.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate Hierarchy\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\nElse;\n  sHier\
    \ = pHier;\nEndIf;\n\nIf( HierarchyExists( pDim, sHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'The\
    \ Hierachy ' | sHier | ' does not exist.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':'\
    \ );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0\
    \ );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n\
    # Validate export path\nIf( Trim( pTgtDir ) @= '' );\n    pTgtDir     = GetProcessErrorFileDirectory;\n\
    \    sMessage    = 'Target folder defaulted to error file directory.';\n    LogOutput( 'INFO', Expand(\
    \ cMsgErrorContent ) );\nEndIf;\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n    pTgtDir\
    \ = SubSt( pTgtDir, 1, Long( pTgtDir ) -1 );\nEndIf;\nIf( FileExists( pTgtDir ) = 0 );\n    nErrors\
    \     = 1;\n    sMessage    = 'Invalid export path specified. Folder does not exist.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npTgtDir         = pTgtDir | sOSDelim;\n\n\
    # Validate export filename\nIf( pTgtFile @= '' );\n    pTgtFile        = pDim | If( pLegacy = 1,'','\
    \ '|sHier ) | '_Export.csv';\nElseIf( Scan( '.', pTgtFile ) = 0 );\n    # No file extension specified\n\
    \    pTgtFile        = pTgtFile | '.csv';\nEndIf;\n\n# Validate file delimiter & quote character\n\
    If( pDelim @= '' );\n    pDelim = ',';\nElse;\n    # If length of pDelim is exactly 3 chars and each\
    \ of them is decimal digit, then the pDelim is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim)\
    \ = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE(\
    \ pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim, nChar )<=CODE( '9', 1 ) );\n          nValid = 1;\n\
    \        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n  \
    \  EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber( pDelim ));\n    Else;\n      pDelim\
    \ = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote character\
    \ \nElse;\n    # If length of pQuote is exactly 3 chars and each of them is decimal digit, then the\
    \ pQuote is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n   \
    \   nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n  \
    \        nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If (\
    \ nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote = SubSt( Trim(\
    \ pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate Character Set\nIf(Trim( pCharacterSet ) @= ''\
    \ );\n  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n# Construct full export filename including path\n\
    sFilename       = pTgtDir | pTgtFile;\nsAttrDimName    = '}ElementAttributes_' | pDim ;\n\n### Check\
    \ for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Data Source ###\nDatasourceNameForServer\
    \     = pDim | IF(pHier@='','',':'|pHier) ;\nDatasourceNameForClient     = DatasourceNameForServer\
    \ ;\nDataSourceType              = 'SUBSET';\nDatasourceDimensionSubset   = 'ALL';\nDatasourceAsciiDelimiter=\
    \ pDelim;\nDatasourceAsciiQuoteCharacter = pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n# Set the output character set\nSetOutputCharacterSet(\
    \ sFileName, pCharacterSet );\n\n### Record Count\nnRecordCount = nRecordCount + 1;\n\n### Export\
    \ Header Information\n## Line 1: File Metadata information\nIf( nRecordCount = 1 & pTitleRecord =\
    \ 1 );\n    TextOutput( sFilename, 'Export from dimension Hierarchy: ' | pDim|':'|sHier | ', all elements\
    \ in index order. Total elements=' |\n                 NumberToString( ElementCount( pDim, sHier )\
    \ ) | '. On ' | Date( Now, 1 ) | ' at ' | Time );\n\n## Line 2: Source Dimension\n    TextOutput(\
    \ sFilename, pDim, sHier  );\n\n## Line 3: Sort Order Information\n    sSortElementType    = CELLGETS(\
    \ cCubeS1, pDim, 'SORTELEMENTSTYPE' );\n    sSortComponentType  = CELLGETS( cCubeS1, pDim, 'SORTCOMPONENTSTYPE'\
    \ );\n    sSortElementSense   = CELLGETS( cCubeS1, pDim, 'SORTELEMENTSSENSE' );\n    sSortComponentSense\
    \ = CELLGETS( cCubeS1, pDim, 'SORTCOMPONENTSSENSE' );\n    If( pLegacy = 1 );\n        TextOutput(\
    \ sFilename, sSortElementType , sSortComponentType , sSortElementSense , sSortComponentSense  );\n\
    \    Else;\n        TextOutput( sFilename, 'Sort parameters :', sSortElementType , sSortComponentType\
    \ , sSortElementSense , sSortComponentSense  );\n    EndIf;\n    \n## Line 4 (and 5?): Header Information\n\
    \    If( pLegacy = 1 );\n            TextOutput( sFilename, 'Reserved' );\n    EndIf;\n    TextOutput(\
    \ sFilename, 'Reserved' );\n    \n## Line 5 or 6: Header Information\n    TextOutput( sFilename, 'Line_Type',\
    \ 'Element', 'Value_1', 'Value_2', 'Value_3' );\n\n### Attribute Information \n    If( DimensionExists(\
    \ sAttrDimName ) = 1 );\n        nIndex = 1;\n        nLimit = DIMSIZ ( sAttrDimName );\n        WHILE(\
    \ nIndex <= nLimit );\n            sElName   = DIMNM( sAttrDimName, nIndex );\n            sElType\
    \   = DTYPE( sAttrDimName, sElName);\n            TextOutput( sFilename, 'A', sElName, sElType );\n\
    \            nIndex = nIndex + 1;\n        END; \n    EndIf;\n#    TextOutput( sFilename, '' );\n\
    EndIf;\n\n### Element Information\nnElIndex        = ElementIndex( pDim, sHier, vEle );\nsElType \
    \        = ElementTYPE(  pDim, sHier, vEle );\nTextOutput( sFilename,'E', vEle, If( pLegacy = 1,'',\
    \ cType ) | sElType, If( pLegacy = 1,'', cIndex ) | NumberToString( nElIndex ) );\n\n### Element Parents\n\
    nElPar          = ElementParentCount( pDim, sHier, vEle );\nIF( nElPar > 0 );\n    nIndex = 1;\n \
    \   nLimit = nElPar;\n    WHILE( nIndex <= nLimit );\n        sElPar  = ElementParent( pDim, sHier,\
    \ vEle, nIndex );\n        sElType = ElementTYPE( pDim, sHier, sElPar );\n        nElWgt  = ElementWeight(\
    \ pDim, sHier, sElPar, vEle );\n        TextOutput( sFilename, 'P', vEle, If( pLegacy = 1,'', cParent\
    \ ) | sElPar, If( pLegacy = 1,'', cType ) | sElType, If( pLegacy = 1,'', cWeight ) | NumberToString(\
    \ nElWgt ) );\n        nIndex = nIndex + 1;\n    END;\nENDIF;\n\n### Attribute Value \nIF( DimensionExists(\
    \ sAttrDimName ) = 1 );\n    nIndex = 1;\n    nLimit = DIMSIZ ( sAttrDimName );\n    WHILE( nIndex\
    \ <= nLimit );\n        sElName   = DIMNM( sAttrDimName, nIndex );\n        sElType   = DTYPE( sAttrDimName,\
    \ sElName);\n        IF( sElType @= 'AN' );\n            sAttrValue = NumberToString( ElementAttrN(\
    \ pDim , sHier , vEle , sElName ) );\n        ELSE;\n            sAttrValue = ElementAttrS( pDim ,\
    \ sHier , vEle , sElName );\n        ENDIF;\n        IF( sAttrValue @<>'' & sAttrValue @<>'0' );\n\
    \            TextOutput( sFilename, 'V', vEle, If( pLegacy = 1,'', cAttrName ) | sElName, If( pLegacy\
    \ = 1,'', cAttrValue ) | sAttrValue );\n        EndIf;\n        nIndex = nIndex + 1;\n    END;\nENDIF;\n\
    \n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    ### If errors occurred terminate process with a major error status ###\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 major error and consequently aborted. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nEndIf;\n\n### Return Code\nsProcessAction      = Expand( 'Process:%cThisProcName%\
    \ successfully exported the %pDim%:%pHier% dimension:hierarchy to %sFileName%.' );\nsProcessReturnCode\
    \  = Expand( '%sProcessReturnCode% %sProcessAction%' );\nnProcessReturnCode  = 1;\nIf ( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );   \nEndIf;\n\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine Dimension mit ihren Hierarchien in
    einem TurboIntegrator-Skript exportiert. Dies sollte keinen CSV-Export beinhalten, sondern ein fest
    codiertes TurboIntegrator-Skript erstellen, das die Dimension/Hierarchie mit kompletten Rollup-Strukturen,
    Attributwerten, Teilmengen und Metadateninformationen wie Sortierreihenfolge, MDX-Hierarchienamen,
    Ebenen und Bezeichnungen wiedergibt. Der Prozess sollte für die automatische Skripterstellung zu Migrationszwecken
    dienlich sein, ohne dass eine Datenquelle oder andere Prozessparameter benötigt werden. Dies ist besonders
    nützlich in Umgebungen ohne Dateisystemzugriff und für manuell definierte Dimensionen. Berücksichtige
    die folgenden Parameter: pDim zur Filterung der zu exportierenden Dimensionen/Hierarchien, pEle zur
    Einschränkung der Elemente für den Export, pDimInfo zur Einbeziehung von Metadaten, pAttr und pAttrVal
    für die Attributerstellung und -werte sowie pSub für Teilmengen-Definitionen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process exports a dimension hierarchies as _TurboIntegrator\
    \ script_. This is rather than creating a CSV which can be read by a generic \n# TurboIntegrator process\
    \ this process creates a _**hardcoded**_ TurboIntegrator process to create a dimension/hierarchy complete\
    \ with rollup \n# structure, attribute values, subsets and metadata information such as sort order,\
    \ MDX hierarchy names and levels and captions.\n#\n# Use case:\n# The specific use case where this\
    \ process will be useful is to automate the creation of TurboIntegrator script for promotion/migration\
    \ purposes\n# as 100% stand-alone without need for data source o any parameters for the process. This\
    \ can be useful in situations where DevOps has no file system access\n# to an environment and for\
    \ manually defined dimensions such as measures.\n#\n# Note:\n# Several parameters control the scope\
    \ of what is exported.\n# * pDim accepts wildcard and lists of dimensions and/or hierarchies to filter\
    \ the **}Dimensions** dimension. There is no separate **pHier** parameter for this process\n# * pEle\
    \ accepts wildcard and lists of _elements_. This can be used to limit the scope of the export of dimension\
    \ structure and attribute values to a subset of elements\n# * pDimInfo 1/0 numeric Boolean whether\
    \ to include metadata relevant to the dimensions/hierarchies defined in pDim from }DimensionProperties,\
    \ }HierarchyProperties and }DimensionAttributes\n# * pAttr 1/0 numeric Boolean whether to include\
    \ attribute creation\n# * pAttrVal 1/0 numeric Boolean whether to include attribute values (for the\
    \ elements defined in pEle )\n# * pSub 1/0 numeric Boolean whether to include subset definitions for\
    \ dynamic and static subsets\n# * There is no Boolean for exporting dimension structure, this is determined\
    \ by pEle. To export all elements use pEle='*'. To suppress export of rollup structure (and attribute\
    \ values) use pEle=''\n# * 2 scripts are produced. One to copy/paste into prolog and one for epilog\
    \ as Direct functions are not used for creation of elements and parent-child relationships\n#\n# Caution:\
    \ \n# This process is designed for _**smaller (typically manually defined) dimensions**_. No check\
    \ is implemented for upper limit of the set of elements defined by pEle if run on a large \n# dimension\
    \ then the export script will be correspondingly large. \n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp\
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncTimeStampPrint = TimSt( Now, '\\Y-\\m-\\d \\h:\\i:\\\
    s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pEle:%pEle%, pDelim:%pDelim%, pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%, pTitleRecord:%pTitleRecord%,\
    \ pDimInfo:%pDimInfo%, pAttr:%pAttr%, pAttrVal:%pAttrVal%, pSub:%pSub%';\ncCubeS1         = '}DimensionProperties';\n\
    pDelim          = Trim( pDelim );\ncLenASCIICode   = 3;\ncHashLine       = '#################################################################################################';\n\
    sAttrDone       = '';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Initialise ###\nnRecordCount = 0;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\n## Validate Source dimension\nIF( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF(\
    \ Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & DimensionExists( pDim\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate element\nIf( pEle @<> '');\n    If( Scan( '*',\
    \ pEle ) = 0 & Scan( '?', pEle ) = 0 & Scan( pDelim, pEle ) = 0 & DimIx( pDim, pEle ) = 0 );\n   \
    \     nErrors = 1;\n        sMessage = 'Item ' | pEle | ' does NOT exist. Please enter a valid element\
    \ in the ' |pDim| ' dimension.';  \n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    Endif;\nEndif;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2,\
    \ 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n# Validate export path\nIf( Trim( pTgtDir ) @= '' );\n    pTgtDir     = GetProcessErrorFileDirectory;\n\
    \    sMessage    = 'Target folder defaulted to error file directory.';\n    LogOutput( 'INFO', Expand(\
    \ cMsgErrorContent ) );\nEndIf;\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n    pTgtDir\
    \     = SubSt( pTgtDir, 1, Long( pTgtDir ) -1 );\nEndIf;\nIf( FileExists( pTgtDir ) = 0 );\n    nErrors\
    \     = 1;\n    sMessage    = 'Invalid export path specified. Folder does not exist.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npTgtDir         = pTgtDir | sOSDelim;\n\n\
    # Validate export filename\nIf( pTgtFile    @= '' );\n    pTgtFile1   = 'bedrock_dimension_script_prolog.txt';\n\
    \    pTgtFile2   = 'bedrock_dimension_script_epilog.txt';\nElse;\n    If( SubSt( pTgtFile, Long( pTgtFile\
    \ ) - 4, 1 ) @= '.' );\n        pTgtFile = SubSt( pTgtFile, 1, Long( pTgtFile ) - 5 );\n    EndIf;\n\
    \    If( SubSt( pTgtFile, Long( pTgtFile ), 1 ) @= '_' );\n        pTgtFile = SubSt( pTgtFile, 1,\
    \ Long( pTgtFile ) - 1 );\n    EndIf;\n    pTgtFile1   = pTgtFile | '_prolog.txt';\n    pTgtFile2\
    \   = pTgtFile | '_epilog.txt';\n\nEndIf;\n\n# Validate file delimiter & quote character\nIf( pDelim\
    \ @= '' );\n    pDelim      = '&';\nElse;\n    # If length of pDelim is exactly 3 chars and each of\
    \ them is decimal digit, then the pDelim is entered as ASCII code\n    nValid      = 0;\n    If (\
    \ LONG(pDelim) = cLenASCIICode );\n      nChar     = 1;\n      While ( nChar <= cLenASCIICode );\n\
    \        If( CODE( pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim, nChar )<=CODE( '9', 1 ) );\n  \
    \        nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar   = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim    = Char( StringToNumber( pDelim\
    \ ) );\n    Else;\n      pDelim    = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate\
    \ Character Set\nIf(Trim( pCharacterSet ) @= '' );\n  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n# Use\
    \ no quote character \npQuote          = '';\n\n# Construct full export filename including path\n\
    sFileName       = pTgtDir | pTgtFile1;\nsFileName2      = pTgtDir | pTgtFile2;\n\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\n\
    nDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    #\
    \ Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex\
    \ = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) )\
    \ );\n    EndIf;\n    \n    # Create subset of dimensions using Wildcard to loop through dimensions\
    \ in pDim with wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart = Expand('{TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions].[}Dimensions] ), %sDimExp% )}');\n    If( sMdx @= ''); \n        sMdx\
    \ = sMdxPart; \n    Else;\n        sMdx = sMdx | ' + ' | sMdxPart;\n    EndIf;\nEnd;\n\nIf( SubsetExists(\
    \ '}Dimensions' , cTempSub ) = 1 );\n    # If a delimited list of dim names includes wildcards then\
    \ we may have to re-use the subset multiple times\n    SubsetMDXSet( '}Dimensions' , cTempSub, sMDX\
    \ );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n    SubsetCreatebyMDX( cTempSub,\
    \ sMDX, '}Dimensions' , 1 );\nEndIf;\n\n# Assign Data Source\nDataSourceType                  = 'SUBSET';\n\
    DatasourceNameForServer         = '}Dimensions';\nDatasourceDimensionSubset       = cTempSub;\nDatasourceASCIIQuoteCharacter\
    \   = pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n \n\n# Set the output character set\nSetOutputCharacterSet( sFileName, pCharacterSet\
    \ );\n\n### Record Count\nnRecordCount = nRecordCount + 1;\n\n### Set dimension & hierarchy variables\n\
    If( Scan( ':', vDim ) = 0 );\n    sDim    = vDim;\n    sHier   = vDim;\nElse;\n    sDim    = SubSt(\
    \ vDim, 1, Scan( ':', vDim ) - 1 );\n    sHier   = SubSt( vDim, Scan( ':', vDim ) + 1, Long( vDim\
    \ ) - ( Long( sDim ) + 1 ) );\nEndIf;\nsDimAttr    = '}ElementAttributes_' | sDim;\nsDimSub     =\
    \ '}Subsets_' | sDim;\n\n### Export Header Information\nIf( nRecordCount = 1 & pTitleRecord = 1 );\n\
    \    sHeader = Expand('# Export dimensions as script pDim=%pDim% pEle=%pEle% On %cTimeStampPrint%');\n\
    \    TextOutput( sFileName, sHeader );\n    If( ( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 &\
    \ pEle @<> '' ) % ( pSub = 1 & DimensionExists( sDimSub ) = 1 ) );\n        sHeader = Expand('# Export\
    \ dimensions as script pDim=%pDim% pEle=%pEle% On %cTimeStampPrint%');\n        TextOutput( sFileName2,\
    \ sHeader );\n    EndIf;\nEndIf;\n\n### Dimension write open\nTextOutput( sFileName, '' );\nTextOutput(\
    \ sFileName, cHashLine );\nTextOutput( sFileName, Expand('#Region Dimension/Hierarchy: %vDim%') );\n\
    If( ( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists(\
    \ sDimSub ) = 1 ) );\n    TextOutput( sFileName2, '' );\n    TextOutput( sFileName2, cHashLine );\n\
    \    TextOutput( sFileName2, Expand('#Region Dimension/Hierarchy: %vDim% (EPILOG)') );\nEndIf;\n\n\
    #################################################################################################\n\
    #Region Create Dimension (PROLOG)\nTextOutput( sFileName, '' );\nTextOutput( sFileName, Expand('sDimHier\
    \ = ''%vDim%'';') );\nTextOutput( sFileName, Expand('sDim     = ''%sDim%'';') );\nTextOutput( sFileName,\
    \ Expand('sHier    = ''%sHier%'';') );\nTextOutput( sFileName, Expand('sDimAttr = ''%sDimAttr%'';')\
    \ );\nTextOutput( sFileName, 'If( DimensionExists( sDim ) = 0 );');\nTextOutput( sFileName, '    DimensionCreate(\
    \ sDim );');\nTextOutput( sFileName, '    If( sDim @<> sHier );');\nTextOutput( sFileName, '     \
    \   HierarchyCreate( sDim, sHier );');\nTextOutput( sFileName, '    EndIf;' );\nTextOutput( sFileName,\
    \ 'ElseIf( sDim @<> sHier );');\nTextOutput( sFileName, '    If( HierarchyExists( sDim, sHier ) =\
    \ 0 );');\nTextOutput( sFileName, '        HierarchyCreate( sDim, sHier );');\nTextOutput( sFileName,\
    \ '    EndIf;' );\nTextOutput( sFileName, 'EndIf;' );\n#EndRegion Create Dimension\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Dimension Info (PROLOG)\nIf( pDimInfo = 1 );\n    TextOutput( sFileName, '' );\n    TextOutput(\
    \ sFileName, cHashLine );\n    TextOutput( sFileName, Expand('#Region Dimension Info: %vDim%') );\n\
    \    sSORTELEMENTSTYPE   = CellGetS( '}DimensionProperties', vDim, 'SORTELEMENTSTYPE' );\n    sSORTCOMPONENTSTYPE\
    \ = CellGetS( '}DimensionProperties', vDim, 'SORTCOMPONENTSTYPE' );\n    sSORTELEMENTSSENSE  = CellGetS(\
    \ '}DimensionProperties', vDim, 'SORTELEMENTSSENSE' );\n    sSORTCOMPONENTSSENSE= CellGetS( '}DimensionProperties',\
    \ vDim, 'SORTCOMPONENTSSENSE' );\n    sDefHier            = CellGetS( '}DimensionProperties', vDim,\
    \ 'DEFAULT_HIERARCHY' );\n    sDefMember          = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0',\
    \ 'defaultMember' );\n    sHierLevels         = NumberToString( CellGetN( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'LevelsToHierarchize' ) );\n    sLevel000           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level000' );\n    sLevel001           = CellGetS( '}HierarchyProperties', vDim,\
    \ 'hierarchy0', 'level001' );\n    sLevel002           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0',\
    \ 'level002' );\n    sLevel003           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level003'\
    \ );\n    sLevel004           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level004' );\n\
    \    sLevel005           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level005' );\n \
    \   sLevel006           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level006' );\n  \
    \  sLevel007           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level007' );\n   \
    \ sLevel008           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level008' );\n    sLevel009\
    \           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level009' );\n    sLevel010 \
    \          = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level010' );\n    sLevel011  \
    \         = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level011' );\n    sLevel012   \
    \        = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level012' );\n    sLevel013    \
    \       = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level013' );\n    sLevel014     \
    \      = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level014' );\n    sLevel015      \
    \     = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level015' );\n    sLevel016       \
    \    = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level016' );\n    sLevel017        \
    \   = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level017' );\n    sLevel018         \
    \  = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level018' );\n    sLevel019          \
    \ = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level019' );\n    sLevel020           =\
    \ CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level020' );\n    TextOutput( sFileName,\
    \ Expand('DimensionSortOrder( sDimHier, ''%sSORTCOMPONENTSTYPE%'', ''%sSORTCOMPONENTSSENSE%'', ''%sSORTELEMENTSTYPE%'',\
    \ ''%sSORTELEMENTSSENSE%'' );') );\n    TextOutput( sFileName, Expand('CellPutS( ''%sDefHier%'', ''}DimensionProperties'',\
    \ sDimHier, ''DEFAULT_HIERARCHY'' );') );\n    TextOutput( sFileName, Expand('CellPutS( ''%sDefMember%'',\
    \ ''}HierarchyProperties'', sDimHier, ''hierarchy0'', ''defaultMember'' );') );\n    TextOutput( sFileName,\
    \ Expand('CellPutN( %sHierLevels%, ''}HierarchyProperties'', sDimHier, ''hierarchy0'', ''LevelsToHierarchize''\
    \ );') );\n    nCtr                = 0;\n    While( nCtr         <= 20 );\n        sLvl          \
    \  = 'Level0' | If( nCtr < 10, '0', '' ) | NumberToString( nCtr ); \n        sLvlVal         = Expand('%'|\
    \ Expand('s%sLvl%') |'%');\n        If( sLvlVal     @<> '' );\n            TextOutput( sFileName,\
    \ Expand('CellPutS( ''%sLvlVal%'', ''}HierarchyProperties'', sDimHier, ''hierarchy0'', ''%sLvl%''\
    \ );') );\n        EndIf;\n        nCtr            = nCtr + 1;\n    End;\n    If( CubeExists( '}DimensionAttributes'\
    \ ) = 1 );\n        nCtr            = 1;\n        While( nCtr     <= DimSiz( '}DimensionAttributes'\
    \ ) );\n            sAttr       = DimNm( '}DimensionAttributes', nCtr );\n            sAttrTyp   \
    \ = SubSt( DType( '}DimensionAttributes', sAttr ), 2, 1 );\n            sAttrVal    = If( sAttrTyp\
    \ @= 'N', NumberToString( DimensionAttrN( vDim, sAttr ) ), DimensionAttrS( vDim, sAttr ) );\n    \
    \        TextOutput( sFileName, Expand('DimensionAttrInsert( '''', ''%sAttr%'', ''%sAttrTyp%'' );')\
    \ );\n            If( sAttrTyp @= 'N' );\n                TextOutput( sFileName, Expand('DimensionAttrPutN(\
    \ %sAttrVal%, sDimHier, ''%sAttr%'' );') );\n            Else;\n                TextOutput( sFileName,\
    \ Expand('DimensionAttrPutS( ''%sAttrVal%'', sDimHier, ''%sAttr%'' );') );\n            EndIf;\n \
    \           nCtr        = nCtr + 1;\n        End;\n    EndIf;\n    TextOutput( sFileName, Expand('#EndRegion\
    \ Dimension Info: %vDim%') );\n    TextOutput( sFileName, cHashLine );\nEndIf;\n#EndRegion Dimension\
    \ Info\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Create Attributes (PROLOG)\nIf( pAttr = 1 & DimensionExists( sDimAttr ) = 1 & Scan( sDim|pDelim,\
    \ sAttrDone ) = 0 );\n    sAttrDone       = sAttrDone | sDim | pDelim;\n    TextOutput( sFileName,\
    \ '' );\n    TextOutput( sFileName, cHashLine );\n    TextOutput( sFileName, Expand('#Region Create\
    \ Attributes: %sDim%') );\n    nCtr            = 1;\n    While( nCtr     <= DimSiz( sDimAttr ) );\n\
    \        sAttr       = DimNm( sDimAttr, nCtr );\n        sAttrTyp    = SubSt( DType( sDimAttr, sAttr\
    \ ), 2, 1 );\n        # Escape potential single apostrophes to avoid parsing errors in attribute names\n\
    \        nChar = 1;\n        nCount = 0;\n        sAttrStrOut = '';\n        While( nChar <= LONG(\
    \ sAttr ) + 1 );\n            If( nChar <= LONG( sAttr ) );\n                sChar = SUBST( sAttr,\
    \ nChar, 1 );\n            Else;\n                sChar = '';\n            EndIf;\n            If(\
    \ sChar @= '''' );\n                nCount = nCount + 1;\n            ElseIf( nCount > 0 );\n    \
    \            If( MOD( nCount, 2 ) <> 0 );\n                    sAttrStrOut = sAttrStrOut | '''';\n\
    \                EndIf;\n                nCount = 0;\n            EndIf;\n            sAttrStrOut\
    \ = sAttrStrOut | sChar;\n            nChar = nChar + 1;\n        End;\n        If( nCtr = 1 );\n\
    \            TextOutput( sFileName, 'If( DimensionExists( sDimAttr ) = 0 % CubeExists( sDimAttr )\
    \ = 0 );');\n            TextOutput( sFileName, Expand('    AttrInsert( sDim, '''', ''%sAttrStrOut%'',\
    \ ''%sAttrTyp%'' );') );\n            TextOutput( sFileName, 'EndIf;' );\n        EndIf;\n       \
    \ TextOutput( sFileName, Expand('If( DimIx( sDimAttr, ''%sAttrStrOut%'' ) = 0 );') );\n        TextOutput(\
    \ sFileName, Expand('    AttrInsert( sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\n     \
    \   TextOutput( sFileName, 'Else;' );\n        TextOutput( sFileName, Expand('    If( DType( sDimAttr,\
    \ ''%sAttrStrOut%'' ) @<> ''A%sAttrTyp%'' );') );\n        TextOutput( sFileName, Expand('       \
    \ AttrDelete( sDim, ''%sAttrStrOut%'' );') );\n        TextOutput( sFileName, Expand('        AttrInsert(\
    \ sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\n        TextOutput( sFileName, '    EndIf;'\
    \ );\n        TextOutput( sFileName, 'EndIf;' );\n        nCtr        = nCtr + 1;\n    End;\n    TextOutput(\
    \ sFileName, Expand('#EndRegion Create Attributes: %sDim%') );\n    TextOutput( sFileName, cHashLine\
    \ );\nEndIf;\n#EndRegion Create Attributes\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Create Dimension/Hierarchy Structure (PROLOG)\nIf( pEle @<> '' );\n    sMDX = '';\n    If(\
    \ pEle @= '*' );\n        sMDX = Expand('{TM1SubsetAll([%sDim%].[%sHier%])}');\n    Else;\n      \
    \  # Loop through elements (inc. wildcard expressions) in pEle\n        sEles = pEle;\n        nEleDelimiterIndex\
    \ = 1;\n        # Get 1st ele\n        While( nEleDelimiterIndex <> 0 );\n            # Extract 1st\
    \ ele in sEles\n            nEleDelimiterIndex = Scan( pDelim, sEles );\n            If( nEleDelimiterIndex\
    \ = 0 );\n                sEle = sEles;\n            Else;\n                sEle = Trim( SubSt( sEles,\
    \ 1, nEleDelimiterIndex - 1 ) );\n                sEles = Trim( Subst( sEles, nEleDelimiterIndex +\
    \ Long( pDelim ), Long( sEles ) ) );\n            EndIf;\n            If( Scan( '*', sEle ) > 0 %\
    \ Scan( '?', sEle ) > 0 );\n                # Create MDX for subset of eles using Wildcard Pattern\
    \ filter (means pEle entry MUST use principal name)\n                sEleExp = '''|sEle|''';\n   \
    \             sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [%sDim%].[%sHier%] ), %sEleExp%\
    \ )}');\n            Else;\n                # Create MDX of single element and all descendants\n \
    \               sMDXPart = Expand('{TM1DRILLDOWNMEMBER( {[%sDim%].[%sHier%].[%sEle%]}, ALL, RECURSIVE\
    \ )}');\n            EndIf;\n            If( sMDX @= ''); \n                sMDX = sMdxPart; \n  \
    \          Else;\n                sMDX = sMDX | ' + ' | sMdxPart;\n            EndIf;\n        End;\n\
    \    EndIf;\n    If( SubsetExists( vDim, cTempSub ) = 1 );\n        SubsetMDXSet( vDim, cTempSub,\
    \ sMDX );\n    Else;\n        SubsetCreatebyMDX( cTempSub, sMDX, vDim, 1 );\n    EndIf;\n    nMax\
    \ = SubsetGetSize( vDim, cTempSub );\n    If( nMax >= 1 );\n        TextOutput( sFileName, '' );\n\
    \        TextOutput( sFileName, cHashLine );\n        TextOutput( sFileName, Expand('#Region Create\
    \ Elements: %vDim%') );\n        nCtr = 1;\n        While( nCtr <= nMax );\n            # 1st insert\
    \ all elements to get correct order\n            sEle = SubsetGetElementName( vDim, cTempSub, nCtr\
    \ );\n            # Escape potential single apostrophes to avoid parsing errors in element names\n\
    \            nChar = 1;\n            nCount = 0;\n            sEleStrOut = '';\n            While(\
    \ nChar <= LONG( sEle ) + 1 );\n                If( nChar <= LONG( sEle ) );\n                   \
    \ sChar = SUBST( sEle, nChar, 1 );\n                Else;\n                    sChar = '';\n     \
    \           EndIf;\n                If( sChar @= '''' );\n                    nCount = nCount + 1;\n\
    \                ElseIf( nCount > 0 );\n                    If( MOD( nCount, 2 ) <> 0 );\n       \
    \                 sEleStrOut = sEleStrOut | '''';\n                    EndIf;\n                  \
    \  nCount = 0;\n                EndIf;\n                sEleStrOut = sEleStrOut | sChar;\n       \
    \         nChar = nChar + 1;\n            End;\n            sEleTyp = DType( vDim, sEle );\n     \
    \       TextOutput( sFileName, Expand('DimensionElementInsert( sDimHier, '''', ''%sEleStrOut%'', ''%sEleTyp%''\
    \ );') );\n            nCtr    = nCtr + 1;\n        End;\n        nCtr = 1;\n        While( nCtr <=\
    \ nMax );\n            # 2nd loop again and create parent linkages\n            sEle    = SubsetGetElementName(\
    \ vDim, cTempSub, nCtr );\n            # Escape potential single apostrophes to avoid parsing errors\
    \ in element names\n            nChar = 1;\n            nCount = 0;\n            sEleStrOut = '';\n\
    \            While( nChar <= LONG( sEle ) + 1 );\n                If( nChar <= LONG( sEle ) );\n \
    \                   sChar = SUBST( sEle, nChar, 1 );\n                Else;\n                    sChar\
    \ = '';\n                EndIf;\n                If( sChar @= '''' );\n                    nCount\
    \ = nCount + 1;\n                ElseIf( nCount > 0 );\n                    If( MOD( nCount, 2 ) <>\
    \ 0 );\n                        sEleStrOut = sEleStrOut | '''';\n                    EndIf;\n    \
    \                nCount = 0;\n                EndIf;\n                sEleStrOut = sEleStrOut | sChar;\n\
    \                nChar = nChar + 1;\n            End;\n            nPar    = 1;\n            While(\
    \ nPar <= ElParN( vDim, sEle ) );\n                sPar = ElPar( vDim, sEle, nPar );\n           \
    \     # Escape potential single apostrophes to avoid parsing errors in parent element names\n    \
    \            nChar = 1;\n                nCount = 0;\n                sParStrOut = '';\n         \
    \       While( nChar <= LONG( sPar ) + 1 );\n                    If( nChar <= LONG( sPar ) );\n  \
    \                      sChar = SUBST( sPar, nChar, 1 );\n                    Else;\n             \
    \           sChar = '';\n                    EndIf;\n                    If( sChar @= '''' );\n  \
    \                      nCount = nCount + 1;\n                    ElseIf( nCount > 0 );\n         \
    \               If( MOD( nCount, 2 ) <> 0 );\n                            sParStrOut = sParStrOut\
    \ | '''';\n                        EndIf;\n                        nCount = 0;\n                 \
    \   EndIf;\n                    sParStrOut = sParStrOut | sChar;\n                    nChar = nChar\
    \ + 1;\n                End;\n                sWht = NumberToString( ElWeight( vDim, sPar, sEle )\
    \ );\n                If( pEle @<> '*' );\n                    TextOutput( sFileName, Expand('DimensionElementInsert(\
    \ sDimHier, '''', ''%sParStrOut%'', ''C'' );') );\n                EndIf;\n                TextOutput(\
    \ sFileName, Expand('DimensionElementComponentAdd( sDimHier, ''%sParStrOut%'', ''%sEleStrOut%'', %sWht%\
    \ );') );\n                nPar = nPar + 1;\n            End;\n            nCtr     = nCtr + 1;\n\
    \        End;\n        TextOutput( sFileName, Expand('#EndRegion Create Elements: %vDim%') );\n  \
    \      TextOutput( sFileName, cHashLine );\n    EndIf;\nEndIf;\n#EndRegion Create Structure\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Attribute Values (EPILOG)\nIf( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & nMax >=1 );\n\
    \    TextOutput( sFileName2, '' );\n    TextOutput( sFileName2, cHashLine );\n    TextOutput( sFileName2,\
    \ Expand('#Region Attribute Values: %vDim%') );\n    TextOutput( sFileName2, Expand('sDimHier = ''%vDim%'';')\
    \ );\n    TextOutput( sFileName2, Expand('sDim     = ''%sDim%'';') );\n    TextOutput( sFileName2,\
    \ Expand('sHier    = ''%sHier%'';') );\n    TextOutput( sFileName2, Expand('sDimAttr = ''%sDimAttr%'';')\
    \ );\n    nCtr = 1;\n    While( nCtr <= nMax );\n        # loop elements again and internally loop\
    \ attributes\n        sEle = SubsetGetElementName( vDim, cTempSub, nCtr );\n        # Escape potential\
    \ single apostrophes to avoid parsing errors in element names\n        nChar = 1;\n        nCount\
    \ = 0;\n        sEleStrOut = '';\n        While( nChar <= LONG( sEle ) + 1 );\n            If( nChar\
    \ <= LONG( sEle ) );\n                sChar = SUBST( sEle, nChar, 1 );\n            Else;\n      \
    \          sChar = '';\n            EndIf;\n            If( sChar @= '''' );\n                nCount\
    \ = nCount + 1;\n            ElseIf( nCount > 0 );\n                If( MOD( nCount, 2 ) <> 0 );\n\
    \                    sEleStrOut = sEleStrOut | '''';\n                EndIf;\n                nCount\
    \ = 0;\n            EndIf;\n            sEleStrOut = sEleStrOut | sChar;\n            nChar = nChar\
    \ + 1;\n        End;\n        sEleTyp = DType( vDim, sEle );\n        nAttr   = 1;\n        While(\
    \ nAttr <= DimSiz( sDimAttr ) );\n            sAttr       = DimNm( sDimAttr, nAttr );\n          \
    \  # Escape potential single apostrophes to avoid parsing errors in attribute names\n            nChar\
    \ = 1;\n            nCount = 0;\n            sAttrStrOut = '';\n            While( nChar <= LONG(\
    \ sAttr ) + 1 );\n                If( nChar <= LONG( sAttr ) );\n                    sChar = SUBST(\
    \ sAttr, nChar, 1 );\n                Else;\n                    sChar = '';\n                EndIf;\n\
    \                If( sChar @= '''' );\n                    nCount = nCount + 1;\n                ElseIf(\
    \ nCount > 0 );\n                    If( MOD( nCount, 2 ) <> 0 );\n                        sAttrStrOut\
    \ = sAttrStrOut | '''';\n                    EndIf;\n                    nCount = 0;\n           \
    \     EndIf;\n                sAttrStrOut = sAttrStrOut | sChar;\n                nChar = nChar +\
    \ 1;\n            End;\n            sAttrTyp    = SubSt( DType( sDimAttr, sAttr ), 2, 1 );\n     \
    \       sAttrVal    = '';\n            If( ( sDim @<> sHier & sEleTyp @<> 'N' ) & sAttrTyp @= 'N'\
    \ );\n                sAttrVal= NumberToString( ElementAttrN( sDim, sHier, sEle, sAttr ) );\n    \
    \        ElseIf( sDim @<> sHier & sEleTyp @<> 'N' );\n                sAttrVal= ElementAttrS( sDim,\
    \ sHier, sEle, sAttr );\n            ElseIf( sEleTyp @= 'N' & sAttrTyp @= 'N' & DimIx( sDim, sEle\
    \ ) = 0 );\n                sAttrVal= NumberToString( ElementAttrN( sDim, sHier, sEle, sAttr ) );\n\
    \            ElseIf( sEleTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\n                sAttrVal= ElementAttrS(\
    \ sDim, sHier, sEle, sAttr );\n            ElseIf( sAttrTyp @= 'N' );\n                sAttrVal= NumberToString(\
    \ AttrN( sDim, sEle, sAttr ) );\n            Else;\n                sAttrVal= AttrS( sDim, sEle, sAttr\
    \ );\n            EndIf;\n            sAttrValStrOut = '';\n            If( sAttrVal @<> '' );\n \
    \               If( sAttrTyp @<> 'N' );\n                    # Escape potential single apostrophes\
    \ to avoid parsing errors in attribute values\n                    nChar = 1;\n                  \
    \  nCount = 0;\n                    While( nChar <= LONG( sAttrVal ) + 1 );\n                    \
    \    If( nChar <= LONG( sAttrVal ) );\n                            sChar = SUBST( sAttrVal, nChar,\
    \ 1 );\n                        Else;\n                            sChar = '';\n                 \
    \       EndIf;\n                        If( sChar @= '''' );\n                            nCount =\
    \ nCount + 1;\n                        ElseIf( nCount > 0 );\n                            If( MOD(\
    \ nCount, 2 ) <> 0 );\n                                sAttrValStrOut = sAttrValStrOut | '''';\n \
    \                           EndIf;\n                            nCount = 0;\n                    \
    \    EndIf;\n                        sAttrValStrOut = sAttrValStrOut | sChar;\n                  \
    \      nChar = nChar + 1;\n                    End;\n                Else;\n                    #\
    \ we won't need any tratment for non-string attributes\n                    sAttrValStrOut = sAttrVal;\n\
    \                EndIf;\n                If( ( sDim @<> sHier & sEleTyp @<> 'N' ) & sAttrTyp @= 'N'\
    \ );\n                    TextOutput( sFileName2, Expand('ElementAttrPutN( %sAttrValStrOut%, sDim,\
    \ sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                ElseIf( sDim @<> sHier & sEleTyp\
    \ @<> 'N' );\n                    TextOutput( sFileName2, Expand('ElementAttrPutS( ''%sAttrValStrOut%'',\
    \ sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                ElseIf( sEleTyp @= 'N'\
    \ & sAttrTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\n                    TextOutput( sFileName2, Expand('ElementAttrPutN(\
    \ %sAttrValStrOut%, sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                ElseIf(\
    \ sEleTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\n                    TextOutput( sFileName2, Expand('ElementAttrPutS(\
    \ ''%sAttrValStrOut%'', sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n               \
    \ ElseIf( sAttrTyp @= 'N' );\n                    TextOutput( sFileName2, Expand('AttrPutN( %sAttrValStrOut%,\
    \ sDim, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                Else;\n                    TextOutput(\
    \ sFileName2, Expand('AttrPutS( ''%sAttrValStrOut%'', sDim, ''%sEleStrOut%'', ''%sAttrStrOut%'' );')\
    \ );\n                EndIf;\n            EndIf;\n            nAttr = nAttr + 1;\n        End;\n \
    \       nCtr    = nCtr + 1;\n    End;\n    TextOutput( sFileName2, Expand('#EndRegion Attribute Values:\
    \ %vDim%') );\n    TextOutput( sFileName2, cHashLine );\nEndIf;\n#EndRegion Attribute Values\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Subsets (EPILOG)\nIf( pSub = 1 & DimensionExists( sDimSub ) = 1 );\n    If( sDim @= vDim );\n\
    \        sMDX = Expand('{Except( {TM1SubsetAll( [%sDimSub%] )}, {TM1FilterByPattern( {TM1SubsetAll(\
    \ [%sDimSub%] )}, '*:*' )} )}');\n    Else;\n        sMDX = Expand('{TM1FilterByPattern( {TM1SubsetAll(\
    \ [%sDimSub%] )}, '%sHier%:*' )}');\n    EndIf;\n    If( SubsetExists( sDimSub, cTempSub ) = 1 );\n\
    \        SubsetMDXSet( sDimSub, cTempSub, sMDX );\n    Else;\n        SubsetCreatebyMDX( cTempSub,\
    \ sMDX, sDimSub, 1 );\n    EndIf;\n    nMax = SubsetGetSize( sDimSub, cTempSub );\n    If( nMax >=\
    \ 1 );\n        TextOutput( sFileName2, '' );\n        TextOutput( sFileName2, cHashLine );\n    \
    \    TextOutput( sFileName2, Expand('#Region Subsets: %vDim%') );\n        If( pAttrVal <> 1 % DimensionExists(\
    \ sDimAttr ) = 0 % pEle @= '' );\n            TextOutput( sFileName2, Expand('sDimHier = ''%vDim%'';')\
    \ );\n            TextOutput( sFileName2, Expand('sDim     = ''%sDim%'';') );\n            TextOutput(\
    \ sFileName2, Expand('sHier    = ''%sHier%'';') );\n            TextOutput( sFileName2, Expand('sDimAttr\
    \ = ''%sDimAttr%'';') );\n        EndIf;\n        nCtr = 1;\n        While( nCtr <= nMax );\n    \
    \        sSub        = SubsetGetElementName( sDimSub, cTempSub, nCtr );\n            If( Scan( ':',\
    \ sSub ) > 0 );\n                sSub    = SubSt( sSub, Scan( ':', sSub ) + 1, Long( sSub ) );\n \
    \           EndIf;\n            sMDX        = SubsetMDXGet( vDim, sSub );\n            # If MDX expression\
    \ contains TM1SubsetBasis function then treat it as a static subset\n            If( sMDX @<> '' &\
    \ Scan( 'TM1SUBSETBASIS()', Upper( sMDX ) ) = 0 );\n                # create by MDX\n            \
    \    TextOutput( sFileName2, Expand('If( SubsetExists( sDimHier, ''%sSub%'' ) = 0 );') );\n      \
    \          TextOutput( sFileName2, Expand('    SubsetCreatebyMDX( ''%sSub%'', ''%sMDX%'', sDimHier,\
    \ 0 );') );\n                TextOutput( sFileName2, 'Else;' );\n                TextOutput( sFileName2,\
    \ Expand('    SubsetMDXSet( sDimHier, ''%sSub%'', ''%sMDX%'' );') );\n                TextOutput(\
    \ sFileName2, 'EndIf;' );\n            Else;\n                # loop members\n                TextOutput(\
    \ sFileName2, Expand('If( SubsetExists( sDimHier, ''%sSub%'' ) = 0 );') );\n                TextOutput(\
    \ sFileName2, Expand('    SubsetCreate( sDimHier, ''%sSub%'' );') );\n                TextOutput(\
    \ sFileName2, 'Else;' );\n                TextOutput( sFileName2, Expand('    SubsetDeleteAllElements(\
    \ sDimHier, ''%sSub%'' );') );\n                TextOutput( sFileName2, 'EndIf;' );\n            \
    \    nEles   = SubsetGetSize( vDim, sSub );\n                nEle    = 1;\n                While(\
    \ nEle <= nEles );\n                    sEle = SubsetGetElementName( vDim, sSub, nEle );\n       \
    \             # Escape potential single apostrophes to avoid parsing errors in element names\n   \
    \                 nChar = 1;\n                    nCount = 0;\n                    sEleStrOut = '';\n\
    \                    While( nChar <= LONG( sEle ) + 1 );\n                        If( nChar <= LONG(\
    \ sEle ) );\n                            sChar = SUBST( sEle, nChar, 1 );\n                      \
    \  Else;\n                            sChar = '';\n                        EndIf;\n              \
    \          If( sChar @= '''' );\n                            nCount = nCount + 1;\n              \
    \          ElseIf( nCount > 0 );\n                            If( MOD( nCount, 2 ) <> 0 );\n     \
    \                           sEleStrOut = sEleStrOut | '''';\n                            EndIf;\n\
    \                            nCount = 0;\n                        EndIf;\n                       \
    \ sEleStrOut = sEleStrOut | sChar;\n                        nChar = nChar + 1;\n                 \
    \   End;\n                    TextOutput( sFileName2, Expand('SubsetElementInsert( sDimHier, ''%sSub%'',\
    \ ''%sEleStrOut%'', 0 );') );\n                    nEle = nEle + 1;\n                End;\n      \
    \      EndIf;\n            nCtr        = nCtr + 1;\n        End;\n        TextOutput( sFileName2,\
    \ Expand('#EndRegion Subsets: %vDim%') );\n        TextOutput( sFileName2, cHashLine );\n    EndIf;\n\
    EndIf;\n#EndRegion Subsets\n#################################################################################################\n\
    \n### Dimension write close\nTextOutput( sFileName, '' );\nTextOutput( sFileName, Expand('#EndRegion\
    \ Dimension/Hierarchy: %vDim%') );\nTextOutput( sFileName, cHashLine );\nIf( ( pAttrVal = 1 & DimensionExists(\
    \ sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists( sDimSub ) = 1 ) );\n    TextOutput(\
    \ sFileName2, '' );\n    TextOutput( sFileName2, Expand('#EndRegion Dimension/Hierarchy: %vDim%')\
    \ );\n    TextOutput( sFileName2, cHashLine );\nEndIf;\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### If errors occurred terminate process with a major error\
    \ status ###\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 major error and\
    \ consequently aborted. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for details.' );\n  \
    \  If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nEndIf;\n\n### Return Code\n\
    sProcessAction      = Expand( 'Process:%cThisProcName% successfully exported %pDim% dimension:hierarchy\
    \ to %sFileName%.' );\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    nProcessReturnCode  = 1;\nIf ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );\
    \   \nEndIf;\n\n### End"
- question: 'Develop an IBM Turbo Integrator process that exports a dimension with its hierarchies as
    a TurboIntegrator script. Instead of creating a CSV file, the process should generate a hardcoded
    TurboIntegrator script for creating the dimension/hierarchy, including complete rollup structure,
    attribute values, subsets, and metadata information like sort order, MDX hierarchy names, levels,
    and captions. This process should be useful for automating script creation for migration purposes
    without requiring a data source or any parameters for the process. It''s particularly helpful in environments
    without file system access and for manually defined dimensions. Consider the following parameters:
    pDim for filtering dimensions/hierarchies to export, pEle for limiting elements to be exported, pDimInfo
    for including metadata, pAttr and pAttrVal for attribute creation and values, and pSub for subset
    definitions.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process exports a dimension hierarchies as _TurboIntegrator\
    \ script_. This is rather than creating a CSV which can be read by a generic \n# TurboIntegrator process\
    \ this process creates a _**hardcoded**_ TurboIntegrator process to create a dimension/hierarchy complete\
    \ with rollup \n# structure, attribute values, subsets and metadata information such as sort order,\
    \ MDX hierarchy names and levels and captions.\n#\n# Use case:\n# The specific use case where this\
    \ process will be useful is to automate the creation of TurboIntegrator script for promotion/migration\
    \ purposes\n# as 100% stand-alone without need for data source o any parameters for the process. This\
    \ can be useful in situations where DevOps has no file system access\n# to an environment and for\
    \ manually defined dimensions such as measures.\n#\n# Note:\n# Several parameters control the scope\
    \ of what is exported.\n# * pDim accepts wildcard and lists of dimensions and/or hierarchies to filter\
    \ the **}Dimensions** dimension. There is no separate **pHier** parameter for this process\n# * pEle\
    \ accepts wildcard and lists of _elements_. This can be used to limit the scope of the export of dimension\
    \ structure and attribute values to a subset of elements\n# * pDimInfo 1/0 numeric Boolean whether\
    \ to include metadata relevant to the dimensions/hierarchies defined in pDim from }DimensionProperties,\
    \ }HierarchyProperties and }DimensionAttributes\n# * pAttr 1/0 numeric Boolean whether to include\
    \ attribute creation\n# * pAttrVal 1/0 numeric Boolean whether to include attribute values (for the\
    \ elements defined in pEle )\n# * pSub 1/0 numeric Boolean whether to include subset definitions for\
    \ dynamic and static subsets\n# * There is no Boolean for exporting dimension structure, this is determined\
    \ by pEle. To export all elements use pEle='*'. To suppress export of rollup structure (and attribute\
    \ values) use pEle=''\n# * 2 scripts are produced. One to copy/paste into prolog and one for epilog\
    \ as Direct functions are not used for creation of elements and parent-child relationships\n#\n# Caution:\
    \ \n# This process is designed for _**smaller (typically manually defined) dimensions**_. No check\
    \ is implemented for upper limit of the set of elements defined by pEle if run on a large \n# dimension\
    \ then the export script will be correspondingly large. \n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp\
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncTimeStampPrint = TimSt( Now, '\\Y-\\m-\\d \\h:\\i:\\\
    s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pEle:%pEle%, pDelim:%pDelim%, pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%, pTitleRecord:%pTitleRecord%,\
    \ pDimInfo:%pDimInfo%, pAttr:%pAttr%, pAttrVal:%pAttrVal%, pSub:%pSub%';\ncCubeS1         = '}DimensionProperties';\n\
    pDelim          = Trim( pDelim );\ncLenASCIICode   = 3;\ncHashLine       = '#################################################################################################';\n\
    sAttrDone       = '';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Initialise ###\nnRecordCount = 0;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\n## Validate Source dimension\nIF( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF(\
    \ Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & DimensionExists( pDim\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate element\nIf( pEle @<> '');\n    If( Scan( '*',\
    \ pEle ) = 0 & Scan( '?', pEle ) = 0 & Scan( pDelim, pEle ) = 0 & DimIx( pDim, pEle ) = 0 );\n   \
    \     nErrors = 1;\n        sMessage = 'Item ' | pEle | ' does NOT exist. Please enter a valid element\
    \ in the ' |pDim| ' dimension.';  \n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\n    Endif;\nEndif;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2,\
    \ 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n# Validate export path\nIf( Trim( pTgtDir ) @= '' );\n    pTgtDir     = GetProcessErrorFileDirectory;\n\
    \    sMessage    = 'Target folder defaulted to error file directory.';\n    LogOutput( 'INFO', Expand(\
    \ cMsgErrorContent ) );\nEndIf;\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n    pTgtDir\
    \     = SubSt( pTgtDir, 1, Long( pTgtDir ) -1 );\nEndIf;\nIf( FileExists( pTgtDir ) = 0 );\n    nErrors\
    \     = 1;\n    sMessage    = 'Invalid export path specified. Folder does not exist.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npTgtDir         = pTgtDir | sOSDelim;\n\n\
    # Validate export filename\nIf( pTgtFile    @= '' );\n    pTgtFile1   = 'bedrock_dimension_script_prolog.txt';\n\
    \    pTgtFile2   = 'bedrock_dimension_script_epilog.txt';\nElse;\n    If( SubSt( pTgtFile, Long( pTgtFile\
    \ ) - 4, 1 ) @= '.' );\n        pTgtFile = SubSt( pTgtFile, 1, Long( pTgtFile ) - 5 );\n    EndIf;\n\
    \    If( SubSt( pTgtFile, Long( pTgtFile ), 1 ) @= '_' );\n        pTgtFile = SubSt( pTgtFile, 1,\
    \ Long( pTgtFile ) - 1 );\n    EndIf;\n    pTgtFile1   = pTgtFile | '_prolog.txt';\n    pTgtFile2\
    \   = pTgtFile | '_epilog.txt';\n\nEndIf;\n\n# Validate file delimiter & quote character\nIf( pDelim\
    \ @= '' );\n    pDelim      = '&';\nElse;\n    # If length of pDelim is exactly 3 chars and each of\
    \ them is decimal digit, then the pDelim is entered as ASCII code\n    nValid      = 0;\n    If (\
    \ LONG(pDelim) = cLenASCIICode );\n      nChar     = 1;\n      While ( nChar <= cLenASCIICode );\n\
    \        If( CODE( pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim, nChar )<=CODE( '9', 1 ) );\n  \
    \        nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar   = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim    = Char( StringToNumber( pDelim\
    \ ) );\n    Else;\n      pDelim    = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate\
    \ Character Set\nIf(Trim( pCharacterSet ) @= '' );\n  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n# Use\
    \ no quote character \npQuote          = '';\n\n# Construct full export filename including path\n\
    sFileName       = pTgtDir | pTgtFile1;\nsFileName2      = pTgtDir | pTgtFile2;\n\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for\
    \ errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Loop through dimensions in pDim\nsDims = pDim;\n\
    nDimDelimiterIndex = 1;\nsMdx = '';\n# Get 1st dimension\nWhile( nDimDelimiterIndex <> 0 );\n    #\
    \ Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim, sDims );\n    If( nDimDelimiterIndex\
    \ = 0 );\n        sDim = sDims;\n    Else;\n        sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n        sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) )\
    \ );\n    EndIf;\n    \n    # Create subset of dimensions using Wildcard to loop through dimensions\
    \ in pDim with wildcard\n    sDimExp = '''|sDim|''';\n    sMdxPart = Expand('{TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions].[}Dimensions] ), %sDimExp% )}');\n    If( sMdx @= ''); \n        sMdx\
    \ = sMdxPart; \n    Else;\n        sMdx = sMdx | ' + ' | sMdxPart;\n    EndIf;\nEnd;\n\nIf( SubsetExists(\
    \ '}Dimensions' , cTempSub ) = 1 );\n    # If a delimited list of dim names includes wildcards then\
    \ we may have to re-use the subset multiple times\n    SubsetMDXSet( '}Dimensions' , cTempSub, sMDX\
    \ );\nElse;\n    # temp subset, therefore no need to destroy in epilog\n    SubsetCreatebyMDX( cTempSub,\
    \ sMDX, '}Dimensions' , 1 );\nEndIf;\n\n# Assign Data Source\nDataSourceType                  = 'SUBSET';\n\
    DatasourceNameForServer         = '}Dimensions';\nDatasourceDimensionSubset       = cTempSub;\nDatasourceASCIIQuoteCharacter\
    \   = pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n \n\n# Set the output character set\nSetOutputCharacterSet( sFileName, pCharacterSet\
    \ );\n\n### Record Count\nnRecordCount = nRecordCount + 1;\n\n### Set dimension & hierarchy variables\n\
    If( Scan( ':', vDim ) = 0 );\n    sDim    = vDim;\n    sHier   = vDim;\nElse;\n    sDim    = SubSt(\
    \ vDim, 1, Scan( ':', vDim ) - 1 );\n    sHier   = SubSt( vDim, Scan( ':', vDim ) + 1, Long( vDim\
    \ ) - ( Long( sDim ) + 1 ) );\nEndIf;\nsDimAttr    = '}ElementAttributes_' | sDim;\nsDimSub     =\
    \ '}Subsets_' | sDim;\n\n### Export Header Information\nIf( nRecordCount = 1 & pTitleRecord = 1 );\n\
    \    sHeader = Expand('# Export dimensions as script pDim=%pDim% pEle=%pEle% On %cTimeStampPrint%');\n\
    \    TextOutput( sFileName, sHeader );\n    If( ( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 &\
    \ pEle @<> '' ) % ( pSub = 1 & DimensionExists( sDimSub ) = 1 ) );\n        sHeader = Expand('# Export\
    \ dimensions as script pDim=%pDim% pEle=%pEle% On %cTimeStampPrint%');\n        TextOutput( sFileName2,\
    \ sHeader );\n    EndIf;\nEndIf;\n\n### Dimension write open\nTextOutput( sFileName, '' );\nTextOutput(\
    \ sFileName, cHashLine );\nTextOutput( sFileName, Expand('#Region Dimension/Hierarchy: %vDim%') );\n\
    If( ( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists(\
    \ sDimSub ) = 1 ) );\n    TextOutput( sFileName2, '' );\n    TextOutput( sFileName2, cHashLine );\n\
    \    TextOutput( sFileName2, Expand('#Region Dimension/Hierarchy: %vDim% (EPILOG)') );\nEndIf;\n\n\
    #################################################################################################\n\
    #Region Create Dimension (PROLOG)\nTextOutput( sFileName, '' );\nTextOutput( sFileName, Expand('sDimHier\
    \ = ''%vDim%'';') );\nTextOutput( sFileName, Expand('sDim     = ''%sDim%'';') );\nTextOutput( sFileName,\
    \ Expand('sHier    = ''%sHier%'';') );\nTextOutput( sFileName, Expand('sDimAttr = ''%sDimAttr%'';')\
    \ );\nTextOutput( sFileName, 'If( DimensionExists( sDim ) = 0 );');\nTextOutput( sFileName, '    DimensionCreate(\
    \ sDim );');\nTextOutput( sFileName, '    If( sDim @<> sHier );');\nTextOutput( sFileName, '     \
    \   HierarchyCreate( sDim, sHier );');\nTextOutput( sFileName, '    EndIf;' );\nTextOutput( sFileName,\
    \ 'ElseIf( sDim @<> sHier );');\nTextOutput( sFileName, '    If( HierarchyExists( sDim, sHier ) =\
    \ 0 );');\nTextOutput( sFileName, '        HierarchyCreate( sDim, sHier );');\nTextOutput( sFileName,\
    \ '    EndIf;' );\nTextOutput( sFileName, 'EndIf;' );\n#EndRegion Create Dimension\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Dimension Info (PROLOG)\nIf( pDimInfo = 1 );\n    TextOutput( sFileName, '' );\n    TextOutput(\
    \ sFileName, cHashLine );\n    TextOutput( sFileName, Expand('#Region Dimension Info: %vDim%') );\n\
    \    sSORTELEMENTSTYPE   = CellGetS( '}DimensionProperties', vDim, 'SORTELEMENTSTYPE' );\n    sSORTCOMPONENTSTYPE\
    \ = CellGetS( '}DimensionProperties', vDim, 'SORTCOMPONENTSTYPE' );\n    sSORTELEMENTSSENSE  = CellGetS(\
    \ '}DimensionProperties', vDim, 'SORTELEMENTSSENSE' );\n    sSORTCOMPONENTSSENSE= CellGetS( '}DimensionProperties',\
    \ vDim, 'SORTCOMPONENTSSENSE' );\n    sDefHier            = CellGetS( '}DimensionProperties', vDim,\
    \ 'DEFAULT_HIERARCHY' );\n    sDefMember          = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0',\
    \ 'defaultMember' );\n    sHierLevels         = NumberToString( CellGetN( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'LevelsToHierarchize' ) );\n    sLevel000           = CellGetS( '}HierarchyProperties',\
    \ vDim, 'hierarchy0', 'level000' );\n    sLevel001           = CellGetS( '}HierarchyProperties', vDim,\
    \ 'hierarchy0', 'level001' );\n    sLevel002           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0',\
    \ 'level002' );\n    sLevel003           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level003'\
    \ );\n    sLevel004           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level004' );\n\
    \    sLevel005           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level005' );\n \
    \   sLevel006           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level006' );\n  \
    \  sLevel007           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level007' );\n   \
    \ sLevel008           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level008' );\n    sLevel009\
    \           = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level009' );\n    sLevel010 \
    \          = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level010' );\n    sLevel011  \
    \         = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level011' );\n    sLevel012   \
    \        = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level012' );\n    sLevel013    \
    \       = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level013' );\n    sLevel014     \
    \      = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level014' );\n    sLevel015      \
    \     = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level015' );\n    sLevel016       \
    \    = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level016' );\n    sLevel017        \
    \   = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level017' );\n    sLevel018         \
    \  = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level018' );\n    sLevel019          \
    \ = CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level019' );\n    sLevel020           =\
    \ CellGetS( '}HierarchyProperties', vDim, 'hierarchy0', 'level020' );\n    TextOutput( sFileName,\
    \ Expand('DimensionSortOrder( sDimHier, ''%sSORTCOMPONENTSTYPE%'', ''%sSORTCOMPONENTSSENSE%'', ''%sSORTELEMENTSTYPE%'',\
    \ ''%sSORTELEMENTSSENSE%'' );') );\n    TextOutput( sFileName, Expand('CellPutS( ''%sDefHier%'', ''}DimensionProperties'',\
    \ sDimHier, ''DEFAULT_HIERARCHY'' );') );\n    TextOutput( sFileName, Expand('CellPutS( ''%sDefMember%'',\
    \ ''}HierarchyProperties'', sDimHier, ''hierarchy0'', ''defaultMember'' );') );\n    TextOutput( sFileName,\
    \ Expand('CellPutN( %sHierLevels%, ''}HierarchyProperties'', sDimHier, ''hierarchy0'', ''LevelsToHierarchize''\
    \ );') );\n    nCtr                = 0;\n    While( nCtr         <= 20 );\n        sLvl          \
    \  = 'Level0' | If( nCtr < 10, '0', '' ) | NumberToString( nCtr ); \n        sLvlVal         = Expand('%'|\
    \ Expand('s%sLvl%') |'%');\n        If( sLvlVal     @<> '' );\n            TextOutput( sFileName,\
    \ Expand('CellPutS( ''%sLvlVal%'', ''}HierarchyProperties'', sDimHier, ''hierarchy0'', ''%sLvl%''\
    \ );') );\n        EndIf;\n        nCtr            = nCtr + 1;\n    End;\n    If( CubeExists( '}DimensionAttributes'\
    \ ) = 1 );\n        nCtr            = 1;\n        While( nCtr     <= DimSiz( '}DimensionAttributes'\
    \ ) );\n            sAttr       = DimNm( '}DimensionAttributes', nCtr );\n            sAttrTyp   \
    \ = SubSt( DType( '}DimensionAttributes', sAttr ), 2, 1 );\n            sAttrVal    = If( sAttrTyp\
    \ @= 'N', NumberToString( DimensionAttrN( vDim, sAttr ) ), DimensionAttrS( vDim, sAttr ) );\n    \
    \        TextOutput( sFileName, Expand('DimensionAttrInsert( '''', ''%sAttr%'', ''%sAttrTyp%'' );')\
    \ );\n            If( sAttrTyp @= 'N' );\n                TextOutput( sFileName, Expand('DimensionAttrPutN(\
    \ %sAttrVal%, sDimHier, ''%sAttr%'' );') );\n            Else;\n                TextOutput( sFileName,\
    \ Expand('DimensionAttrPutS( ''%sAttrVal%'', sDimHier, ''%sAttr%'' );') );\n            EndIf;\n \
    \           nCtr        = nCtr + 1;\n        End;\n    EndIf;\n    TextOutput( sFileName, Expand('#EndRegion\
    \ Dimension Info: %vDim%') );\n    TextOutput( sFileName, cHashLine );\nEndIf;\n#EndRegion Dimension\
    \ Info\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Create Attributes (PROLOG)\nIf( pAttr = 1 & DimensionExists( sDimAttr ) = 1 & Scan( sDim|pDelim,\
    \ sAttrDone ) = 0 );\n    sAttrDone       = sAttrDone | sDim | pDelim;\n    TextOutput( sFileName,\
    \ '' );\n    TextOutput( sFileName, cHashLine );\n    TextOutput( sFileName, Expand('#Region Create\
    \ Attributes: %sDim%') );\n    nCtr            = 1;\n    While( nCtr     <= DimSiz( sDimAttr ) );\n\
    \        sAttr       = DimNm( sDimAttr, nCtr );\n        sAttrTyp    = SubSt( DType( sDimAttr, sAttr\
    \ ), 2, 1 );\n        # Escape potential single apostrophes to avoid parsing errors in attribute names\n\
    \        nChar = 1;\n        nCount = 0;\n        sAttrStrOut = '';\n        While( nChar <= LONG(\
    \ sAttr ) + 1 );\n            If( nChar <= LONG( sAttr ) );\n                sChar = SUBST( sAttr,\
    \ nChar, 1 );\n            Else;\n                sChar = '';\n            EndIf;\n            If(\
    \ sChar @= '''' );\n                nCount = nCount + 1;\n            ElseIf( nCount > 0 );\n    \
    \            If( MOD( nCount, 2 ) <> 0 );\n                    sAttrStrOut = sAttrStrOut | '''';\n\
    \                EndIf;\n                nCount = 0;\n            EndIf;\n            sAttrStrOut\
    \ = sAttrStrOut | sChar;\n            nChar = nChar + 1;\n        End;\n        If( nCtr = 1 );\n\
    \            TextOutput( sFileName, 'If( DimensionExists( sDimAttr ) = 0 % CubeExists( sDimAttr )\
    \ = 0 );');\n            TextOutput( sFileName, Expand('    AttrInsert( sDim, '''', ''%sAttrStrOut%'',\
    \ ''%sAttrTyp%'' );') );\n            TextOutput( sFileName, 'EndIf;' );\n        EndIf;\n       \
    \ TextOutput( sFileName, Expand('If( DimIx( sDimAttr, ''%sAttrStrOut%'' ) = 0 );') );\n        TextOutput(\
    \ sFileName, Expand('    AttrInsert( sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\n     \
    \   TextOutput( sFileName, 'Else;' );\n        TextOutput( sFileName, Expand('    If( DType( sDimAttr,\
    \ ''%sAttrStrOut%'' ) @<> ''A%sAttrTyp%'' );') );\n        TextOutput( sFileName, Expand('       \
    \ AttrDelete( sDim, ''%sAttrStrOut%'' );') );\n        TextOutput( sFileName, Expand('        AttrInsert(\
    \ sDim, '''', ''%sAttrStrOut%'', ''%sAttrTyp%'' );') );\n        TextOutput( sFileName, '    EndIf;'\
    \ );\n        TextOutput( sFileName, 'EndIf;' );\n        nCtr        = nCtr + 1;\n    End;\n    TextOutput(\
    \ sFileName, Expand('#EndRegion Create Attributes: %sDim%') );\n    TextOutput( sFileName, cHashLine\
    \ );\nEndIf;\n#EndRegion Create Attributes\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Create Dimension/Hierarchy Structure (PROLOG)\nIf( pEle @<> '' );\n    sMDX = '';\n    If(\
    \ pEle @= '*' );\n        sMDX = Expand('{TM1SubsetAll([%sDim%].[%sHier%])}');\n    Else;\n      \
    \  # Loop through elements (inc. wildcard expressions) in pEle\n        sEles = pEle;\n        nEleDelimiterIndex\
    \ = 1;\n        # Get 1st ele\n        While( nEleDelimiterIndex <> 0 );\n            # Extract 1st\
    \ ele in sEles\n            nEleDelimiterIndex = Scan( pDelim, sEles );\n            If( nEleDelimiterIndex\
    \ = 0 );\n                sEle = sEles;\n            Else;\n                sEle = Trim( SubSt( sEles,\
    \ 1, nEleDelimiterIndex - 1 ) );\n                sEles = Trim( Subst( sEles, nEleDelimiterIndex +\
    \ Long( pDelim ), Long( sEles ) ) );\n            EndIf;\n            If( Scan( '*', sEle ) > 0 %\
    \ Scan( '?', sEle ) > 0 );\n                # Create MDX for subset of eles using Wildcard Pattern\
    \ filter (means pEle entry MUST use principal name)\n                sEleExp = '''|sEle|''';\n   \
    \             sMdxPart = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [%sDim%].[%sHier%] ), %sEleExp%\
    \ )}');\n            Else;\n                # Create MDX of single element and all descendants\n \
    \               sMDXPart = Expand('{TM1DRILLDOWNMEMBER( {[%sDim%].[%sHier%].[%sEle%]}, ALL, RECURSIVE\
    \ )}');\n            EndIf;\n            If( sMDX @= ''); \n                sMDX = sMdxPart; \n  \
    \          Else;\n                sMDX = sMDX | ' + ' | sMdxPart;\n            EndIf;\n        End;\n\
    \    EndIf;\n    If( SubsetExists( vDim, cTempSub ) = 1 );\n        SubsetMDXSet( vDim, cTempSub,\
    \ sMDX );\n    Else;\n        SubsetCreatebyMDX( cTempSub, sMDX, vDim, 1 );\n    EndIf;\n    nMax\
    \ = SubsetGetSize( vDim, cTempSub );\n    If( nMax >= 1 );\n        TextOutput( sFileName, '' );\n\
    \        TextOutput( sFileName, cHashLine );\n        TextOutput( sFileName, Expand('#Region Create\
    \ Elements: %vDim%') );\n        nCtr = 1;\n        While( nCtr <= nMax );\n            # 1st insert\
    \ all elements to get correct order\n            sEle = SubsetGetElementName( vDim, cTempSub, nCtr\
    \ );\n            # Escape potential single apostrophes to avoid parsing errors in element names\n\
    \            nChar = 1;\n            nCount = 0;\n            sEleStrOut = '';\n            While(\
    \ nChar <= LONG( sEle ) + 1 );\n                If( nChar <= LONG( sEle ) );\n                   \
    \ sChar = SUBST( sEle, nChar, 1 );\n                Else;\n                    sChar = '';\n     \
    \           EndIf;\n                If( sChar @= '''' );\n                    nCount = nCount + 1;\n\
    \                ElseIf( nCount > 0 );\n                    If( MOD( nCount, 2 ) <> 0 );\n       \
    \                 sEleStrOut = sEleStrOut | '''';\n                    EndIf;\n                  \
    \  nCount = 0;\n                EndIf;\n                sEleStrOut = sEleStrOut | sChar;\n       \
    \         nChar = nChar + 1;\n            End;\n            sEleTyp = DType( vDim, sEle );\n     \
    \       TextOutput( sFileName, Expand('DimensionElementInsert( sDimHier, '''', ''%sEleStrOut%'', ''%sEleTyp%''\
    \ );') );\n            nCtr    = nCtr + 1;\n        End;\n        nCtr = 1;\n        While( nCtr <=\
    \ nMax );\n            # 2nd loop again and create parent linkages\n            sEle    = SubsetGetElementName(\
    \ vDim, cTempSub, nCtr );\n            # Escape potential single apostrophes to avoid parsing errors\
    \ in element names\n            nChar = 1;\n            nCount = 0;\n            sEleStrOut = '';\n\
    \            While( nChar <= LONG( sEle ) + 1 );\n                If( nChar <= LONG( sEle ) );\n \
    \                   sChar = SUBST( sEle, nChar, 1 );\n                Else;\n                    sChar\
    \ = '';\n                EndIf;\n                If( sChar @= '''' );\n                    nCount\
    \ = nCount + 1;\n                ElseIf( nCount > 0 );\n                    If( MOD( nCount, 2 ) <>\
    \ 0 );\n                        sEleStrOut = sEleStrOut | '''';\n                    EndIf;\n    \
    \                nCount = 0;\n                EndIf;\n                sEleStrOut = sEleStrOut | sChar;\n\
    \                nChar = nChar + 1;\n            End;\n            nPar    = 1;\n            While(\
    \ nPar <= ElParN( vDim, sEle ) );\n                sPar = ElPar( vDim, sEle, nPar );\n           \
    \     # Escape potential single apostrophes to avoid parsing errors in parent element names\n    \
    \            nChar = 1;\n                nCount = 0;\n                sParStrOut = '';\n         \
    \       While( nChar <= LONG( sPar ) + 1 );\n                    If( nChar <= LONG( sPar ) );\n  \
    \                      sChar = SUBST( sPar, nChar, 1 );\n                    Else;\n             \
    \           sChar = '';\n                    EndIf;\n                    If( sChar @= '''' );\n  \
    \                      nCount = nCount + 1;\n                    ElseIf( nCount > 0 );\n         \
    \               If( MOD( nCount, 2 ) <> 0 );\n                            sParStrOut = sParStrOut\
    \ | '''';\n                        EndIf;\n                        nCount = 0;\n                 \
    \   EndIf;\n                    sParStrOut = sParStrOut | sChar;\n                    nChar = nChar\
    \ + 1;\n                End;\n                sWht = NumberToString( ElWeight( vDim, sPar, sEle )\
    \ );\n                If( pEle @<> '*' );\n                    TextOutput( sFileName, Expand('DimensionElementInsert(\
    \ sDimHier, '''', ''%sParStrOut%'', ''C'' );') );\n                EndIf;\n                TextOutput(\
    \ sFileName, Expand('DimensionElementComponentAdd( sDimHier, ''%sParStrOut%'', ''%sEleStrOut%'', %sWht%\
    \ );') );\n                nPar = nPar + 1;\n            End;\n            nCtr     = nCtr + 1;\n\
    \        End;\n        TextOutput( sFileName, Expand('#EndRegion Create Elements: %vDim%') );\n  \
    \      TextOutput( sFileName, cHashLine );\n    EndIf;\nEndIf;\n#EndRegion Create Structure\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Attribute Values (EPILOG)\nIf( pAttrVal = 1 & DimensionExists( sDimAttr ) = 1 & nMax >=1 );\n\
    \    TextOutput( sFileName2, '' );\n    TextOutput( sFileName2, cHashLine );\n    TextOutput( sFileName2,\
    \ Expand('#Region Attribute Values: %vDim%') );\n    TextOutput( sFileName2, Expand('sDimHier = ''%vDim%'';')\
    \ );\n    TextOutput( sFileName2, Expand('sDim     = ''%sDim%'';') );\n    TextOutput( sFileName2,\
    \ Expand('sHier    = ''%sHier%'';') );\n    TextOutput( sFileName2, Expand('sDimAttr = ''%sDimAttr%'';')\
    \ );\n    nCtr = 1;\n    While( nCtr <= nMax );\n        # loop elements again and internally loop\
    \ attributes\n        sEle = SubsetGetElementName( vDim, cTempSub, nCtr );\n        # Escape potential\
    \ single apostrophes to avoid parsing errors in element names\n        nChar = 1;\n        nCount\
    \ = 0;\n        sEleStrOut = '';\n        While( nChar <= LONG( sEle ) + 1 );\n            If( nChar\
    \ <= LONG( sEle ) );\n                sChar = SUBST( sEle, nChar, 1 );\n            Else;\n      \
    \          sChar = '';\n            EndIf;\n            If( sChar @= '''' );\n                nCount\
    \ = nCount + 1;\n            ElseIf( nCount > 0 );\n                If( MOD( nCount, 2 ) <> 0 );\n\
    \                    sEleStrOut = sEleStrOut | '''';\n                EndIf;\n                nCount\
    \ = 0;\n            EndIf;\n            sEleStrOut = sEleStrOut | sChar;\n            nChar = nChar\
    \ + 1;\n        End;\n        sEleTyp = DType( vDim, sEle );\n        nAttr   = 1;\n        While(\
    \ nAttr <= DimSiz( sDimAttr ) );\n            sAttr       = DimNm( sDimAttr, nAttr );\n          \
    \  # Escape potential single apostrophes to avoid parsing errors in attribute names\n            nChar\
    \ = 1;\n            nCount = 0;\n            sAttrStrOut = '';\n            While( nChar <= LONG(\
    \ sAttr ) + 1 );\n                If( nChar <= LONG( sAttr ) );\n                    sChar = SUBST(\
    \ sAttr, nChar, 1 );\n                Else;\n                    sChar = '';\n                EndIf;\n\
    \                If( sChar @= '''' );\n                    nCount = nCount + 1;\n                ElseIf(\
    \ nCount > 0 );\n                    If( MOD( nCount, 2 ) <> 0 );\n                        sAttrStrOut\
    \ = sAttrStrOut | '''';\n                    EndIf;\n                    nCount = 0;\n           \
    \     EndIf;\n                sAttrStrOut = sAttrStrOut | sChar;\n                nChar = nChar +\
    \ 1;\n            End;\n            sAttrTyp    = SubSt( DType( sDimAttr, sAttr ), 2, 1 );\n     \
    \       sAttrVal    = '';\n            If( ( sDim @<> sHier & sEleTyp @<> 'N' ) & sAttrTyp @= 'N'\
    \ );\n                sAttrVal= NumberToString( ElementAttrN( sDim, sHier, sEle, sAttr ) );\n    \
    \        ElseIf( sDim @<> sHier & sEleTyp @<> 'N' );\n                sAttrVal= ElementAttrS( sDim,\
    \ sHier, sEle, sAttr );\n            ElseIf( sEleTyp @= 'N' & sAttrTyp @= 'N' & DimIx( sDim, sEle\
    \ ) = 0 );\n                sAttrVal= NumberToString( ElementAttrN( sDim, sHier, sEle, sAttr ) );\n\
    \            ElseIf( sEleTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\n                sAttrVal= ElementAttrS(\
    \ sDim, sHier, sEle, sAttr );\n            ElseIf( sAttrTyp @= 'N' );\n                sAttrVal= NumberToString(\
    \ AttrN( sDim, sEle, sAttr ) );\n            Else;\n                sAttrVal= AttrS( sDim, sEle, sAttr\
    \ );\n            EndIf;\n            sAttrValStrOut = '';\n            If( sAttrVal @<> '' );\n \
    \               If( sAttrTyp @<> 'N' );\n                    # Escape potential single apostrophes\
    \ to avoid parsing errors in attribute values\n                    nChar = 1;\n                  \
    \  nCount = 0;\n                    While( nChar <= LONG( sAttrVal ) + 1 );\n                    \
    \    If( nChar <= LONG( sAttrVal ) );\n                            sChar = SUBST( sAttrVal, nChar,\
    \ 1 );\n                        Else;\n                            sChar = '';\n                 \
    \       EndIf;\n                        If( sChar @= '''' );\n                            nCount =\
    \ nCount + 1;\n                        ElseIf( nCount > 0 );\n                            If( MOD(\
    \ nCount, 2 ) <> 0 );\n                                sAttrValStrOut = sAttrValStrOut | '''';\n \
    \                           EndIf;\n                            nCount = 0;\n                    \
    \    EndIf;\n                        sAttrValStrOut = sAttrValStrOut | sChar;\n                  \
    \      nChar = nChar + 1;\n                    End;\n                Else;\n                    #\
    \ we won't need any tratment for non-string attributes\n                    sAttrValStrOut = sAttrVal;\n\
    \                EndIf;\n                If( ( sDim @<> sHier & sEleTyp @<> 'N' ) & sAttrTyp @= 'N'\
    \ );\n                    TextOutput( sFileName2, Expand('ElementAttrPutN( %sAttrValStrOut%, sDim,\
    \ sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                ElseIf( sDim @<> sHier & sEleTyp\
    \ @<> 'N' );\n                    TextOutput( sFileName2, Expand('ElementAttrPutS( ''%sAttrValStrOut%'',\
    \ sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                ElseIf( sEleTyp @= 'N'\
    \ & sAttrTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\n                    TextOutput( sFileName2, Expand('ElementAttrPutN(\
    \ %sAttrValStrOut%, sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                ElseIf(\
    \ sEleTyp @= 'N' & DimIx( sDim, sEle ) = 0 );\n                    TextOutput( sFileName2, Expand('ElementAttrPutS(\
    \ ''%sAttrValStrOut%'', sDim, sHier, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n               \
    \ ElseIf( sAttrTyp @= 'N' );\n                    TextOutput( sFileName2, Expand('AttrPutN( %sAttrValStrOut%,\
    \ sDim, ''%sEleStrOut%'', ''%sAttrStrOut%'' );') );\n                Else;\n                    TextOutput(\
    \ sFileName2, Expand('AttrPutS( ''%sAttrValStrOut%'', sDim, ''%sEleStrOut%'', ''%sAttrStrOut%'' );')\
    \ );\n                EndIf;\n            EndIf;\n            nAttr = nAttr + 1;\n        End;\n \
    \       nCtr    = nCtr + 1;\n    End;\n    TextOutput( sFileName2, Expand('#EndRegion Attribute Values:\
    \ %vDim%') );\n    TextOutput( sFileName2, cHashLine );\nEndIf;\n#EndRegion Attribute Values\n#################################################################################################\n\
    \n#################################################################################################\n\
    #Region Subsets (EPILOG)\nIf( pSub = 1 & DimensionExists( sDimSub ) = 1 );\n    If( sDim @= vDim );\n\
    \        sMDX = Expand('{Except( {TM1SubsetAll( [%sDimSub%] )}, {TM1FilterByPattern( {TM1SubsetAll(\
    \ [%sDimSub%] )}, '*:*' )} )}');\n    Else;\n        sMDX = Expand('{TM1FilterByPattern( {TM1SubsetAll(\
    \ [%sDimSub%] )}, '%sHier%:*' )}');\n    EndIf;\n    If( SubsetExists( sDimSub, cTempSub ) = 1 );\n\
    \        SubsetMDXSet( sDimSub, cTempSub, sMDX );\n    Else;\n        SubsetCreatebyMDX( cTempSub,\
    \ sMDX, sDimSub, 1 );\n    EndIf;\n    nMax = SubsetGetSize( sDimSub, cTempSub );\n    If( nMax >=\
    \ 1 );\n        TextOutput( sFileName2, '' );\n        TextOutput( sFileName2, cHashLine );\n    \
    \    TextOutput( sFileName2, Expand('#Region Subsets: %vDim%') );\n        If( pAttrVal <> 1 % DimensionExists(\
    \ sDimAttr ) = 0 % pEle @= '' );\n            TextOutput( sFileName2, Expand('sDimHier = ''%vDim%'';')\
    \ );\n            TextOutput( sFileName2, Expand('sDim     = ''%sDim%'';') );\n            TextOutput(\
    \ sFileName2, Expand('sHier    = ''%sHier%'';') );\n            TextOutput( sFileName2, Expand('sDimAttr\
    \ = ''%sDimAttr%'';') );\n        EndIf;\n        nCtr = 1;\n        While( nCtr <= nMax );\n    \
    \        sSub        = SubsetGetElementName( sDimSub, cTempSub, nCtr );\n            If( Scan( ':',\
    \ sSub ) > 0 );\n                sSub    = SubSt( sSub, Scan( ':', sSub ) + 1, Long( sSub ) );\n \
    \           EndIf;\n            sMDX        = SubsetMDXGet( vDim, sSub );\n            # If MDX expression\
    \ contains TM1SubsetBasis function then treat it as a static subset\n            If( sMDX @<> '' &\
    \ Scan( 'TM1SUBSETBASIS()', Upper( sMDX ) ) = 0 );\n                # create by MDX\n            \
    \    TextOutput( sFileName2, Expand('If( SubsetExists( sDimHier, ''%sSub%'' ) = 0 );') );\n      \
    \          TextOutput( sFileName2, Expand('    SubsetCreatebyMDX( ''%sSub%'', ''%sMDX%'', sDimHier,\
    \ 0 );') );\n                TextOutput( sFileName2, 'Else;' );\n                TextOutput( sFileName2,\
    \ Expand('    SubsetMDXSet( sDimHier, ''%sSub%'', ''%sMDX%'' );') );\n                TextOutput(\
    \ sFileName2, 'EndIf;' );\n            Else;\n                # loop members\n                TextOutput(\
    \ sFileName2, Expand('If( SubsetExists( sDimHier, ''%sSub%'' ) = 0 );') );\n                TextOutput(\
    \ sFileName2, Expand('    SubsetCreate( sDimHier, ''%sSub%'' );') );\n                TextOutput(\
    \ sFileName2, 'Else;' );\n                TextOutput( sFileName2, Expand('    SubsetDeleteAllElements(\
    \ sDimHier, ''%sSub%'' );') );\n                TextOutput( sFileName2, 'EndIf;' );\n            \
    \    nEles   = SubsetGetSize( vDim, sSub );\n                nEle    = 1;\n                While(\
    \ nEle <= nEles );\n                    sEle = SubsetGetElementName( vDim, sSub, nEle );\n       \
    \             # Escape potential single apostrophes to avoid parsing errors in element names\n   \
    \                 nChar = 1;\n                    nCount = 0;\n                    sEleStrOut = '';\n\
    \                    While( nChar <= LONG( sEle ) + 1 );\n                        If( nChar <= LONG(\
    \ sEle ) );\n                            sChar = SUBST( sEle, nChar, 1 );\n                      \
    \  Else;\n                            sChar = '';\n                        EndIf;\n              \
    \          If( sChar @= '''' );\n                            nCount = nCount + 1;\n              \
    \          ElseIf( nCount > 0 );\n                            If( MOD( nCount, 2 ) <> 0 );\n     \
    \                           sEleStrOut = sEleStrOut | '''';\n                            EndIf;\n\
    \                            nCount = 0;\n                        EndIf;\n                       \
    \ sEleStrOut = sEleStrOut | sChar;\n                        nChar = nChar + 1;\n                 \
    \   End;\n                    TextOutput( sFileName2, Expand('SubsetElementInsert( sDimHier, ''%sSub%'',\
    \ ''%sEleStrOut%'', 0 );') );\n                    nEle = nEle + 1;\n                End;\n      \
    \      EndIf;\n            nCtr        = nCtr + 1;\n        End;\n        TextOutput( sFileName2,\
    \ Expand('#EndRegion Subsets: %vDim%') );\n        TextOutput( sFileName2, cHashLine );\n    EndIf;\n\
    EndIf;\n#EndRegion Subsets\n#################################################################################################\n\
    \n### Dimension write close\nTextOutput( sFileName, '' );\nTextOutput( sFileName, Expand('#EndRegion\
    \ Dimension/Hierarchy: %vDim%') );\nTextOutput( sFileName, cHashLine );\nIf( ( pAttrVal = 1 & DimensionExists(\
    \ sDimAttr ) = 1 & pEle @<> '' ) % ( pSub = 1 & DimensionExists( sDimSub ) = 1 ) );\n    TextOutput(\
    \ sFileName2, '' );\n    TextOutput( sFileName2, Expand('#EndRegion Dimension/Hierarchy: %vDim%')\
    \ );\n    TextOutput( sFileName2, cHashLine );\nEndIf;\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### If errors occurred terminate process with a major error\
    \ status ###\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 major error and\
    \ consequently aborted. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for details.' );\n  \
    \  If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nEndIf;\n\n### Return Code\n\
    sProcessAction      = Expand( 'Process:%cThisProcName% successfully exported %pDim% dimension:hierarchy\
    \ to %sFileName%.' );\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    nProcessReturnCode  = 1;\nIf ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( sProcessAction ) );\
    \   \nEndIf;\n\n### End"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, um Dimensionselemente aus einer Datei in eine
    angegebene Hierarchie zu importieren. Dieser Prozess soll in der Lage sein, eine von `}ti.hier.export`
    generierte Datei zu lesen. Das Dateiformat umfasst verschiedene Linien: Die erste Zeile enthält Metadaten
    der Datei mit zusammenfassenden Informationen über die Dimension, Hierarchie, Anzahl der Elemente
    und das Datum/Uhrzeit der Dateierstellung. Die zweite Zeile weist die Quellendimension und -hierarchie
    aus. Die dritte Zeile beschreibt die Sortierreihenfolge der Dimension. Die vierte und fünfte Zeile
    sind für zukünftige Entwicklungen reserviert. Die sechste Zeile beinhaltet den Header für den Elementeexport,
    während die siebte Zeile und folgende die exportierten Elementdaten darstellen. Anwendungsfälle für
    diesen Prozess beinhalten die Wiederherstellung einer Dimension aus einem Backup und die schnelle
    Replikation einer großen Dimension. Beachten Sie, dass ein gültiger Dimensionsname (pDim) zwingend
    erforderlich ist, andernfalls wird der Prozess abgebrochen. Falls nötig, kann ein benutzerdefiniertes
    Trennzeichen verwendet werden, indem der Parameter pDelim entsprechend einem einzigen Zeichen oder
    einem dreistelligen ASCII-Code angegeben wird. Außerdem bietet der pUnwind Parameter die Option, Elemente
    in der Zieldimension zu 2 (nichts tun oder nur hinzufügen), 1 (entwirren) oder 0 (löschen) festzulegen.
    Standardmäßig wird entwirrt, es sollte jedoch Vorsicht walten gelassen werden, wenn Option 0 verwendet
    wird, um Datenverlust zu vermeiden. Beachten Sie, dass der Prozess in Bedrock4 neu gestaltet wurde,
    aber auch Dimensionsextrakte aus früheren Bedrock-Versionen im Legacy-Modus (pLegacy = 1) verarbeiten
    kann.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will import Dimension elements into a specified Hierarchy\
    \ from a File. The process\n# is able to read a file generated by `}bedrock.hier.export`.\n# __Format\
    \ of the file:__  \n# - 1st line: File metadata contains summary information about the dimension,\
    \ hierarchy, number of\n#   elements and date/time when file was generated.\n# - 2nd line: Source\
    \ dimension and hierarchy.\n# - 3rd line: Dimension sort order.\n# - 4th and 5th line: Reserved for\
    \ future development.\n# - 6th line: Header for elements export.\n# - 7th line and forth: Elements\
    \ export data.\n\n# Use case:\n# 1. Restore a dimension from a backup.\n# 2. Quick replication of\
    \ a large dimension.\n\n# Note:\n# Valid dimension name (pDim) is mandatory otherwise the process\
    \ will abort.\n# If needed, custom delimiter might be used by specifying parameter pDelim value as\
    \ either exactly one\n# character or as a 3-digit (decimal) ASCII code. For example to use TAB as\
    \ a delimiter, use 009.\n# pUnwind provides the option to 1 (unwind) or 0 (delete) elements in the\
    \ target dimension. Default is to unwind,\n# care should be taken when using option 0 otherwise data\
    \ loss may occur.\n\n# Caution: Process was redesigned in Bedrock4 but is able to process dimension\
    \ extracts from prior\n# versions of Bedrock in legacy mode (pLegacy = 1).\n#EndRegion @DOC\n\n# This\
    \ process will Create Dimension hierarchy from File.\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\\
    h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSrcDir:%pSrcDir%, pSrcFile:%pSrcFile%, pDelim:%pDelim%, pQuote:%pQuote%, pLegacy:%pLegacy%,\
    \ pUnwind:%pUnwind%, pConsol:%pConsol%';\ncLenASCIICode = 3;\n\npDelim  = TRIM(pDelim);\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnMetaCount\
    \ = 0;\nnDataCount = 0;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0\
    \ & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting\
    \ dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long(\
    \ pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    sMessage\
    \ = 'Dimension: ' | pDim | ' does not exist and will be created.';\n    LogOutput( 'INFO', Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate Hierarchy\nsHier       = Trim( pHier );\nIf( sHier @=\
    \ '' );\n    sHier     = pDim;\nElseIf( sHier @= 'Leaves' );\n    nErrors   = 1;\n    sMessage  =\
    \ 'Invalid  Hierarchy: ' | pDim |':'|sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':'\
    \ );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0\
    \ );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n\
    ## Validate source dir\nIf( Trim( pSrcDir ) @= '' );\n    pSrcDir     = GetProcessErrorFileDirectory;\n\
    \    sMessage    = 'Source folder defaulted to error file directory.';\n    LogOutput( 'INFO', Expand(\
    \ cMsgErrorContent ) );\nEndIf;\nIf( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @= sOSDelim );\n    pSrcDir\
    \ = SubSt( pSrcDir, 1, Long( pSrcDir ) -1 );\nEndIf;\nIf( FileExists( pSrcDir ) = 0 );\n    nErrors\
    \     = 1;\n    sMessage    = 'Invalid source path specified. Folder does not exist.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npSrcDir         = pSrcDir | sOSDelim;\n\n\
    # Validate legacy file format\nIf( pLegacy <> 1 );\n    pLegacy = 0;\nEndIf;\n\n# Validate export\
    \ filename\nIf( pSrcFile @= '' );\n  pSrcFile      = pDim | If( pLegacy = 1, '', ' ' | sHier ) | '_Export.csv';\n\
    ElseIf( Scan( '.', pSrcFile ) = 0 );\n    # No file extension specified\n    pSrcFile    = pSrcFile\
    \ | '.csv';\nEndIf;\n\n# Construct full export filename including path\nsFilename       = pSrcDir\
    \ | pSrcFile;\nsAttrDimName    = '}ElementAttributes_' | pDim ;\n\nIf( FileExists( sFilename ) = 0\
    \ );\n    nErrors     = 1;\n    sMessage    = 'Invalid path or file name specified. It does not exist.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate unwind\nIf( pUnwind\
    \ <> 0 );\n    pUnwind = 1;\nEndIf;\n\n# Validate consolidation to unwind\nIf( pConsol @= '' );\n\
    \    # Only check if parameter is passed as empty as this is invalid. Validation in case of element\
    \ not existng in dimension will be evaluated in the unwind sub-process\n    pConsol = '*';\nEndIf;\n\
    \n# Validate file delimiter & quote character\nIf( pDelim @= '' );\n    pDelim = ',';\nElse;\n   \
    \ # If length of pDelim is exactly 3 chars and each of them is decimal digit, then the pDelim is entered\
    \ as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim) = cLenASCIICode );\n      nChar = 1;\n   \
    \   While ( nChar <= cLenASCIICode );\n        If( CODE( pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim,\
    \ nChar )<=CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n      \
    \  EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber(\
    \ pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf( pQuote\
    \ @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is exactly 3 chars and\
    \ each of them is decimal digit, then the pQuote is entered as ASCII code\n    nValid = 0;\n    If\
    \ ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n \
    \       If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n\
    \          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n\
    \    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n\
    \  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Prepare target dimension ###\nIf( HierarchyExists(\
    \ pDim, sHier ) = 1 );\n    If( pUnwind = 1 );\n    ExecuteProcess('}bedrock.hier.unwind', 'pLogOutput',\
    \ pLogOutput,\n      'pStrictErrorHandling', pStrictErrorHandling,\n    \t'pDim', pDim,\n    \t'pHier',\
    \ sHier,\n    \t'pConsol', pConsol,\n    \t'pRecursive', 1\n    );\n    ElseIf( pUnwind = 0 );\n \
    \       If( pDim @= pHier );\n            DimensionDeleteAllElements( pDim );\n        Else;\n   \
    \         HierarchyDeleteAllElements( pDim, pHier );\n        EndIf;\n    EndIf;\nElse;\n    ExecuteProcess('}bedrock.hier.create',\n\
    \t'pLogOutput',pLogOutput,\n\t'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pDim,\n\t'pHier',sHier);\n\
    EndIf;\n\nIf( nErrors = 0 );\n    If( HierarchyExists( pDim, pHier ) = 1 );\n        IF ( pUnwind\
    \ = 1 ) ;\n            sMessage = 'Dimension unwound: ' | pDim|':'|sHier;\n        ELSEIF ( pUnwind\
    \ = 0 ) ;\n            sMessage = 'Dimension rebuilt: ' | pDim|':'|sHier;\n        ENDIF ;\n    Else;\n\
    \        sMessage = 'Dimension created: ' | pDim|':'|sHier;\n    EndIf;\nElse;\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\nEndIf;\n\n### CONSTANTS\
    \ ###\nsAttrDimName    = '}ElementAttributes_' | pDim ;\ncCubeS1         = '}DimensionProperties';\n\
    \n#Processbreak;\n\n### Assign Datasource ###\nDataSourceType          = 'CHARACTERDELIMITED';\nDatasourceNameForServer\
    \ = sFilename;\nDatasourceNameForClient = sFilename;\nDatasourceAsciiDelimiter= pDelim;\nDatasourceAsciiQuoteCharacter\
    \ = pQuote;\n\n\n##### End Prolog #####\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n\
    \  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\nIf( pDim @= sHier);\n    sDim = pDim;\nElse;\n    sDim = pDim|':'|sHier;\nEndif;\n\n###\
    \ Metadata Count\nnMetaCount = nMetaCount + 1;\n\nsVar1 = v1;\nsVar2 = v2;\nsVar3 = If( pLegacy <>\
    \ 1, Subst( v3 , Scan( '-' , v3 ) + 1 , Long( v3 ) ), v3 );\nsVar4 = If( pLegacy <> 1, Subst( v4 ,\
    \ Scan( '-' , v4 ) + 1 , Long( v4 ) ), v4 );\nsVar5 = If( pLegacy <> 1, Subst( v5 , Scan( '-' , v5\
    \ ) + 1 , Long( v5 ) ), v5 );\n\n## Set Dimension Sort Order\nIF( v1 @= 'Sort parameters :' );\n \
    \   CELLPUTS( sVar2, cCubeS1 , sDim, 'SORTELEMENTSTYPE' );\n    CELLPUTS( sVar3, cCubeS1 , sDim, 'SORTCOMPONENTSTYPE'\
    \ );\n    CELLPUTS( sVar4, cCubeS1 , sDim, 'SORTELEMENTSSENSE' );\n    CELLPUTS( sVar5, cCubeS1 ,\
    \ sDim, 'SORTCOMPONENTSSENSE' );\n    DimensionSortOrder( sDim, sVar3, sVar5, sVar2, sVar4 );\nElseIF(\
    \ pLegacy = 1 & nDataCount = 3 & ( sVar1 @= 'BYINPUT' % sVar1 @= 'BYNAME' % sVar1 @= 'BYHIERARCHY'\
    \ % sVar1 @= 'BYLEVEL' ) );\n    CELLPUTS( sVar1, cCubeS1 , sDim, 'SORTELEMENTSTYPE' );\n    CELLPUTS(\
    \ sVar2, cCubeS1 , sDim, 'SORTCOMPONENTSTYPE' );\n    CELLPUTS( sVar3, cCubeS1 , sDim, 'SORTELEMENTSSENSE'\
    \ );\n    CELLPUTS( sVar4, cCubeS1 , sDim, 'SORTCOMPONENTSSENSE' );\n    DimensionSortOrder( sDim,\
    \ sVar2, sVar4, sVar1, sVar3 );\nENDIF;\n\n### Build dimension\nIF( V1 @= 'A' );\n    # insert attributes\n\
    \    ATTRINSERT( pDim, '', sVar2 , SUBST( sVar3, 2, 1 ) );\n    IF( pLogOutput = 1 );\n        sMessage\
    \    = Expand('Attribute %sVar2% created in %sDim% as type %sVar3%.');\n        LogOutput( 'INFO',\
    \ Expand( cMsgErrorContent ) );  \n    ENDIF;\nELSEIF( V1 @= 'E' );\n    # insert elements\n    HierarchyElementInsert(\
    \ pDim, sHier, '', sVar2 , sVar3 );\n    IF( pLogOutput = 1 );\n        sMessage    = Expand('Inserted\
    \ element %sVar2% into %sDim% as type %sVar3%.');\n        LogOutput( 'INFO', Expand( cMsgErrorContent\
    \ ) );  \n    ENDIF;\nELSEIF( V1 @= 'P' );\n    # create rollups\n    HierarchyElementInsert( pDim,\
    \ sHier, '', sVar3 , sVar4 );\n    HierarchyElementComponentAdd( pDim, sHier, sVar3 , sVar2 , StringToNumber(\
    \ sVar5 ) );\n    IF( pLogOutput = 1 );\n        sMessage    = Expand('Inserted parent %sVar3% into\
    \ %sDim% as type %sVar4%. Then added %sVar2% to %sVar3% with a weight of %sVar5%.');\n        sMessage\
    \    = Expand('Added %sVar2% to %sVar3% with a weight of %sVar5%.');\n        LogOutput( 'INFO', Expand(\
    \ cMsgErrorContent ) );  \n    ENDIF;\n\nENDIF;\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n\
    \  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n### Data Count\nnDataCount = nDataCount + 1;\n\nsVar1 = v1;\nsVar2 = v2;\nsVar3 = If( pLegacy\
    \ <> 1, Subst( v3 , Scan( '-' , v3 ) + 1 , Long( v3 ) ), v3 );\nsVar4 = If( pLegacy <> 1, Subst( v4\
    \ , Scan( '-' , v4 ) + 1 , Long( v4 ) ), v4 );\nsVar5 = If( pLegacy <> 1, Subst( v5 , Scan( '-' ,\
    \ v5 ) + 1 , Long( v5 ) ), v5 );\n\nIf( pDim @= sHier);\n    sDim = pDim;\nElse;\n    sDim = pDim|':'|sHier;\n\
    Endif;\n\n### Load Attribute Values ###\nIF( V1 @= 'V' );\n    sAttrType = DTYPE( sAttrDimName , sVar3\
    \ );\n    IF ( pDim @<> sHier );\n        IF ( CellIsUpdateable ( '}ElementAttributes_' | pDim, sVar2,\
    \ sVar3 ) = 0 ) ;\n            ItemSkip ;\n        ENDIF ;\n        IF( sAttrType @= 'AN' );\n   \
    \         ElementAttrPUTN( StringToNumber( sVar4 ), pDim, sHier, sVar2, sVar3 );\n        ELSEIF(\
    \ sAttrType @= 'AA' );\n            ElementATTRPUTS( sVar4, pDim, sHier, sVar2, sVar3, 1 );\n    \
    \    ELSE;\n            ElementATTRPUTS( sVar4, pDim, sHier, sVar2, sVar3 );\n        ENDIF;\n   \
    \ ELSE;\n        IF ( CellIsUpdateable ( '}ElementAttributes_' | pDim , sVar2, sVar3 ) = 0 ) ;\n \
    \           ItemSkip ;\n        ENDIF ;\n        IF( sAttrType @= 'AN' );\n            AttrPUTN( StringToNumber(\
    \ sVar4 ), pDim, sVar2, sVar3 );\n        ELSEIF( sAttrType @= 'AA' );\n            ATTRPUTS( sVar4,\
    \ pDim, sVar2, sVar3, 1 );\n        ELSE;\n            ATTRPUTS( sVar4, pDim, sVar2, sVar3 );\n  \
    \      ENDIF;        \n    ENDIF;\nENDIF;\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### If errors occurred terminate process with a major error\
    \ status ###\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 major error and\
    \ consequently aborted. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for details.' );\n  \
    \  If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nEndIf;\n\n### Return Code\n\
    sProcessAction      = Expand( 'Process:%cThisProcName% successfully imported data from %sFileName%\
    \ and updated the %pDim%:%pHier% dimension:hierarchy.' );\nsProcessReturnCode  = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\nnProcessReturnCode  = 1;\nIf ( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ sProcessAction ) );   \nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process to import dimension elements into a specified hierarchy
    from a file. This process should be capable of reading a file generated by `}ti.hier.export`. The
    file format includes several lines: the first line contains file metadata with summary information
    about the dimension, hierarchy, number of elements, and the date/time the file was generated. The
    second line specifies the source dimension and hierarchy. The third line describes the dimension''s
    sort order. The fourth and fifth lines are reserved for future development. The sixth line contains
    the header for elements export, while the seventh line onwards represents the elements export data.
    Use cases for this process include restoring a dimension from a backup and quickly replicating a large
    dimension. Note that a valid dimension name (pDim) is mandatory; otherwise, the process will abort.
    If needed, a custom delimiter can be used by specifying the pDelim parameter as either exactly one
    character or a three-digit ASCII code. Additionally, the pUnwind parameter provides the option to
    set elements in the target dimension to 2 (do nothing or add only), 1 (unwind), or 0 (delete). By
    default, it unwinds, but caution should be taken when using option 0 to prevent data loss. Note that
    the process was redesigned in Bedrock4 but can also handle dimension extracts from previous Bedrock
    versions in legacy mode (pLegacy = 1).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will import Dimension elements into a specified Hierarchy\
    \ from a File. The process\n# is able to read a file generated by `}bedrock.hier.export`.\n# __Format\
    \ of the file:__  \n# - 1st line: File metadata contains summary information about the dimension,\
    \ hierarchy, number of\n#   elements and date/time when file was generated.\n# - 2nd line: Source\
    \ dimension and hierarchy.\n# - 3rd line: Dimension sort order.\n# - 4th and 5th line: Reserved for\
    \ future development.\n# - 6th line: Header for elements export.\n# - 7th line and forth: Elements\
    \ export data.\n\n# Use case:\n# 1. Restore a dimension from a backup.\n# 2. Quick replication of\
    \ a large dimension.\n\n# Note:\n# Valid dimension name (pDim) is mandatory otherwise the process\
    \ will abort.\n# If needed, custom delimiter might be used by specifying parameter pDelim value as\
    \ either exactly one\n# character or as a 3-digit (decimal) ASCII code. For example to use TAB as\
    \ a delimiter, use 009.\n# pUnwind provides the option to 1 (unwind) or 0 (delete) elements in the\
    \ target dimension. Default is to unwind,\n# care should be taken when using option 0 otherwise data\
    \ loss may occur.\n\n# Caution: Process was redesigned in Bedrock4 but is able to process dimension\
    \ extracts from prior\n# versions of Bedrock in legacy mode (pLegacy = 1).\n#EndRegion @DOC\n\n# This\
    \ process will Create Dimension hierarchy from File.\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\\
    h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSrcDir:%pSrcDir%, pSrcFile:%pSrcFile%, pDelim:%pDelim%, pQuote:%pQuote%, pLegacy:%pLegacy%,\
    \ pUnwind:%pUnwind%, pConsol:%pConsol%';\ncLenASCIICode = 3;\n\npDelim  = TRIM(pDelim);\n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnMetaCount\
    \ = 0;\nnDataCount = 0;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0\
    \ & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting\
    \ dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long(\
    \ pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\
    If( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimensionExists( pDim ) = 0 );\n    sMessage\
    \ = 'Dimension: ' | pDim | ' does not exist and will be created.';\n    LogOutput( 'INFO', Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate Hierarchy\nsHier       = Trim( pHier );\nIf( sHier @=\
    \ '' );\n    sHier     = pDim;\nElseIf( sHier @= 'Leaves' );\n    nErrors   = 1;\n    sMessage  =\
    \ 'Invalid  Hierarchy: ' | pDim |':'|sHier;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':'\
    \ );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0\
    \ );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n\
    ## Validate source dir\nIf( Trim( pSrcDir ) @= '' );\n    pSrcDir     = GetProcessErrorFileDirectory;\n\
    \    sMessage    = 'Source folder defaulted to error file directory.';\n    LogOutput( 'INFO', Expand(\
    \ cMsgErrorContent ) );\nEndIf;\nIf( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @= sOSDelim );\n    pSrcDir\
    \ = SubSt( pSrcDir, 1, Long( pSrcDir ) -1 );\nEndIf;\nIf( FileExists( pSrcDir ) = 0 );\n    nErrors\
    \     = 1;\n    sMessage    = 'Invalid source path specified. Folder does not exist.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npSrcDir         = pSrcDir | sOSDelim;\n\n\
    # Validate legacy file format\nIf( pLegacy <> 1 );\n    pLegacy = 0;\nEndIf;\n\n# Validate export\
    \ filename\nIf( pSrcFile @= '' );\n  pSrcFile      = pDim | If( pLegacy = 1, '', ' ' | sHier ) | '_Export.csv';\n\
    ElseIf( Scan( '.', pSrcFile ) = 0 );\n    # No file extension specified\n    pSrcFile    = pSrcFile\
    \ | '.csv';\nEndIf;\n\n# Construct full export filename including path\nsFilename       = pSrcDir\
    \ | pSrcFile;\nsAttrDimName    = '}ElementAttributes_' | pDim ;\n\nIf( FileExists( sFilename ) = 0\
    \ );\n    nErrors     = 1;\n    sMessage    = 'Invalid path or file name specified. It does not exist.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate unwind\nIf( pUnwind\
    \ <> 0 );\n    pUnwind = 1;\nEndIf;\n\n# Validate consolidation to unwind\nIf( pConsol @= '' );\n\
    \    # Only check if parameter is passed as empty as this is invalid. Validation in case of element\
    \ not existng in dimension will be evaluated in the unwind sub-process\n    pConsol = '*';\nEndIf;\n\
    \n# Validate file delimiter & quote character\nIf( pDelim @= '' );\n    pDelim = ',';\nElse;\n   \
    \ # If length of pDelim is exactly 3 chars and each of them is decimal digit, then the pDelim is entered\
    \ as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim) = cLenASCIICode );\n      nChar = 1;\n   \
    \   While ( nChar <= cLenASCIICode );\n        If( CODE( pDelim, nChar )>=CODE( '0', 1 ) & CODE( pDelim,\
    \ nChar )<=CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n      \
    \  EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pDelim=CHAR(StringToNumber(\
    \ pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf( pQuote\
    \ @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is exactly 3 chars and\
    \ each of them is decimal digit, then the pQuote is entered as ASCII code\n    nValid = 0;\n    If\
    \ ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n \
    \       If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n\
    \          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n\
    \    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n\
    \  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Prepare target dimension ###\nIf( HierarchyExists(\
    \ pDim, sHier ) = 1 );\n    If( pUnwind = 1 );\n    ExecuteProcess('}bedrock.hier.unwind', 'pLogOutput',\
    \ pLogOutput,\n      'pStrictErrorHandling', pStrictErrorHandling,\n    \t'pDim', pDim,\n    \t'pHier',\
    \ sHier,\n    \t'pConsol', pConsol,\n    \t'pRecursive', 1\n    );\n    ElseIf( pUnwind = 0 );\n \
    \       If( pDim @= pHier );\n            DimensionDeleteAllElements( pDim );\n        Else;\n   \
    \         HierarchyDeleteAllElements( pDim, pHier );\n        EndIf;\n    EndIf;\nElse;\n    ExecuteProcess('}bedrock.hier.create',\n\
    \t'pLogOutput',pLogOutput,\n\t'pStrictErrorHandling', pStrictErrorHandling,\n\t'pDim',pDim,\n\t'pHier',sHier);\n\
    EndIf;\n\nIf( nErrors = 0 );\n    If( HierarchyExists( pDim, pHier ) = 1 );\n        IF ( pUnwind\
    \ = 1 ) ;\n            sMessage = 'Dimension unwound: ' | pDim|':'|sHier;\n        ELSEIF ( pUnwind\
    \ = 0 ) ;\n            sMessage = 'Dimension rebuilt: ' | pDim|':'|sHier;\n        ENDIF ;\n    Else;\n\
    \        sMessage = 'Dimension created: ' | pDim|':'|sHier;\n    EndIf;\nElse;\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\nEndIf;\n\n### CONSTANTS\
    \ ###\nsAttrDimName    = '}ElementAttributes_' | pDim ;\ncCubeS1         = '}DimensionProperties';\n\
    \n#Processbreak;\n\n### Assign Datasource ###\nDataSourceType          = 'CHARACTERDELIMITED';\nDatasourceNameForServer\
    \ = sFilename;\nDatasourceNameForClient = sFilename;\nDatasourceAsciiDelimiter= pDelim;\nDatasourceAsciiQuoteCharacter\
    \ = pQuote;\n\n\n##### End Prolog #####\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n\
    \  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\nIf( pDim @= sHier);\n    sDim = pDim;\nElse;\n    sDim = pDim|':'|sHier;\nEndif;\n\n###\
    \ Metadata Count\nnMetaCount = nMetaCount + 1;\n\nsVar1 = v1;\nsVar2 = v2;\nsVar3 = If( pLegacy <>\
    \ 1, Subst( v3 , Scan( '-' , v3 ) + 1 , Long( v3 ) ), v3 );\nsVar4 = If( pLegacy <> 1, Subst( v4 ,\
    \ Scan( '-' , v4 ) + 1 , Long( v4 ) ), v4 );\nsVar5 = If( pLegacy <> 1, Subst( v5 , Scan( '-' , v5\
    \ ) + 1 , Long( v5 ) ), v5 );\n\n## Set Dimension Sort Order\nIF( v1 @= 'Sort parameters :' );\n \
    \   CELLPUTS( sVar2, cCubeS1 , sDim, 'SORTELEMENTSTYPE' );\n    CELLPUTS( sVar3, cCubeS1 , sDim, 'SORTCOMPONENTSTYPE'\
    \ );\n    CELLPUTS( sVar4, cCubeS1 , sDim, 'SORTELEMENTSSENSE' );\n    CELLPUTS( sVar5, cCubeS1 ,\
    \ sDim, 'SORTCOMPONENTSSENSE' );\n    DimensionSortOrder( sDim, sVar3, sVar5, sVar2, sVar4 );\nElseIF(\
    \ pLegacy = 1 & nDataCount = 3 & ( sVar1 @= 'BYINPUT' % sVar1 @= 'BYNAME' % sVar1 @= 'BYHIERARCHY'\
    \ % sVar1 @= 'BYLEVEL' ) );\n    CELLPUTS( sVar1, cCubeS1 , sDim, 'SORTELEMENTSTYPE' );\n    CELLPUTS(\
    \ sVar2, cCubeS1 , sDim, 'SORTCOMPONENTSTYPE' );\n    CELLPUTS( sVar3, cCubeS1 , sDim, 'SORTELEMENTSSENSE'\
    \ );\n    CELLPUTS( sVar4, cCubeS1 , sDim, 'SORTCOMPONENTSSENSE' );\n    DimensionSortOrder( sDim,\
    \ sVar2, sVar4, sVar1, sVar3 );\nENDIF;\n\n### Build dimension\nIF( V1 @= 'A' );\n    # insert attributes\n\
    \    ATTRINSERT( pDim, '', sVar2 , SUBST( sVar3, 2, 1 ) );\n    IF( pLogOutput = 1 );\n        sMessage\
    \    = Expand('Attribute %sVar2% created in %sDim% as type %sVar3%.');\n        LogOutput( 'INFO',\
    \ Expand( cMsgErrorContent ) );  \n    ENDIF;\nELSEIF( V1 @= 'E' );\n    # insert elements\n    HierarchyElementInsert(\
    \ pDim, sHier, '', sVar2 , sVar3 );\n    IF( pLogOutput = 1 );\n        sMessage    = Expand('Inserted\
    \ element %sVar2% into %sDim% as type %sVar3%.');\n        LogOutput( 'INFO', Expand( cMsgErrorContent\
    \ ) );  \n    ENDIF;\nELSEIF( V1 @= 'P' );\n    # create rollups\n    HierarchyElementInsert( pDim,\
    \ sHier, '', sVar3 , sVar4 );\n    HierarchyElementComponentAdd( pDim, sHier, sVar3 , sVar2 , StringToNumber(\
    \ sVar5 ) );\n    IF( pLogOutput = 1 );\n        sMessage    = Expand('Inserted parent %sVar3% into\
    \ %sDim% as type %sVar4%. Then added %sVar2% to %sVar3% with a weight of %sVar5%.');\n        sMessage\
    \    = Expand('Added %sVar2% to %sVar3% with a weight of %sVar5%.');\n        LogOutput( 'INFO', Expand(\
    \ cMsgErrorContent ) );  \n    ENDIF;\n\nENDIF;\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n\
    \  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n### Data Count\nnDataCount = nDataCount + 1;\n\nsVar1 = v1;\nsVar2 = v2;\nsVar3 = If( pLegacy\
    \ <> 1, Subst( v3 , Scan( '-' , v3 ) + 1 , Long( v3 ) ), v3 );\nsVar4 = If( pLegacy <> 1, Subst( v4\
    \ , Scan( '-' , v4 ) + 1 , Long( v4 ) ), v4 );\nsVar5 = If( pLegacy <> 1, Subst( v5 , Scan( '-' ,\
    \ v5 ) + 1 , Long( v5 ) ), v5 );\n\nIf( pDim @= sHier);\n    sDim = pDim;\nElse;\n    sDim = pDim|':'|sHier;\n\
    Endif;\n\n### Load Attribute Values ###\nIF( V1 @= 'V' );\n    sAttrType = DTYPE( sAttrDimName , sVar3\
    \ );\n    IF ( pDim @<> sHier );\n        IF ( CellIsUpdateable ( '}ElementAttributes_' | pDim, sVar2,\
    \ sVar3 ) = 0 ) ;\n            ItemSkip ;\n        ENDIF ;\n        IF( sAttrType @= 'AN' );\n   \
    \         ElementAttrPUTN( StringToNumber( sVar4 ), pDim, sHier, sVar2, sVar3 );\n        ELSEIF(\
    \ sAttrType @= 'AA' );\n            ElementATTRPUTS( sVar4, pDim, sHier, sVar2, sVar3, 1 );\n    \
    \    ELSE;\n            ElementATTRPUTS( sVar4, pDim, sHier, sVar2, sVar3 );\n        ENDIF;\n   \
    \ ELSE;\n        IF ( CellIsUpdateable ( '}ElementAttributes_' | pDim , sVar2, sVar3 ) = 0 ) ;\n \
    \           ItemSkip ;\n        ENDIF ;\n        IF( sAttrType @= 'AN' );\n            AttrPUTN( StringToNumber(\
    \ sVar4 ), pDim, sVar2, sVar3 );\n        ELSEIF( sAttrType @= 'AA' );\n            ATTRPUTS( sVar4,\
    \ pDim, sVar2, sVar3, 1 );\n        ELSE;\n            ATTRPUTS( sVar4, pDim, sVar2, sVar3 );\n  \
    \      ENDIF;        \n    ENDIF;\nENDIF;\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### If errors occurred terminate process with a major error\
    \ status ###\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 major error and\
    \ consequently aborted. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% aborted. Check tm1server.log for details.' );\n  \
    \  If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nEndIf;\n\n### Return Code\n\
    sProcessAction      = Expand( 'Process:%cThisProcName% successfully imported data from %sFileName%\
    \ and updated the %pDim%:%pHier% dimension:hierarchy.' );\nsProcessReturnCode  = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\nnProcessReturnCode  = 1;\nIf ( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ sProcessAction ) );   \nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der alle Blattelemente (in der ''Leaves''-Hierarchie)
    der angegebenen Dimension(en) überprüft. Innerhalb der ''Leaves''-Hierarchie wird für jedes Element
    *alle Hierarchien* auf das Vorhandensein des Blattelements gescannt. Wenn das Blattelement in allen
    Hierarchien außer ''Leaves'' nicht existiert, wird das Element als Waise klassifiziert und der Teilmenge
    ''Verwaiste Blattelemente'' hinzugefügt. Zusätzlich, wenn der Parameter pIncludeNoParentElems gesetzt
    ist, werden Elemente ohne übergeordnete Elemente in der Teilmenge ''Keine Eltern'' der entsprechenden
    Hierarchie (außer ''Leaves'') innerhalb von ''Leaves'' gespeichert. Der Name der Teilmenge kann angepasst
    werden und wird mit Bindestrich- und dem Namen der entsprechenden Hierarchie versehen. Der Hauptanwendungsbereich:
    1. Primär zur Identifizierung von Dimensionen mit Wartungsproblemen während der Entwicklung/Prototyping
    gedacht. 2. Kann auch zur Fehlersuche in produktiven Instanzen verwendet werden.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process checks all leaf elements (in the Leaves hierarchy)\
    \ of the specified dimension(s).\n# Within the Leaves hierarchy for each element *all hierarchies*\
    \ are scanned for the existance of the leaf element.\n# If the leaf element does not exist in all\
    \ hierarchies except for Leaves then the element is classified as an orphan and added to the \n# 'Orphan\
    \ Leaf Elements' subset.\n# Additionally when running with pIncludeNoParentElems parameter set, elements\
    \ that have no parent will be stored in No Parents subset\n# of matching hierarchy (except `Leaves`)\
    \ within Leaves. The subset name might be accomodated and will be suffixed by dash and name of the\
    \ matching hierarchy.\n#\n# Use case: \n# 1. Primarily intended to identify dimensions with maintenance\
    \ issues during development/prototyping.\n# 2. Can also be used for trouble-shooting in productive\
    \ instances.\n#\n#EndRegion @DOC\n\n### Global Variables\n\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants\ncThisProcName\
    \     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt   \
    \     = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub1          = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncTempSub2         = cTempSub1 | '_2';\ncTempSubDim       = cThisProcName |'_Dim_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgInfoLevel\
    \     = 'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%.';\ncAll            \
    \  = '*';\ncDimDimensions    = '}Dimensions';\ncHierLeaves       = 'Leaves';\ncSubMissing       =\
    \ 'Bedrock - Orphan Elements - Leaves';\ncSubNoParents     = 'Bedrock - No Parents - %sHier%';\n\n\
    ### LogOutput parameters\nIF( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \n### Validate Parameters\nnErrors = 0;\nnDims = 0;\nnDimsWithOrphans = 0;\nnDimsWithoutParents =\
    \ 0;\nnElems = 0;\nnElemsMissing = 0;\nnElemsMissingParent = 0;\nsDimPrev = '';\n\nIf( Scan( '*',\
    \ pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @=\
    \ '' );\n  # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n  pHier = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n  pDim\
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate delimiter\nIf( Trim( pDelim )\
    \ @= '' );\n  pDelim = '&';\nEndIf;\n\nIf( Trim( pTgtSubLeaves ) @= '' );\n  pTgtSubLeaves = cSubMissing;\n\
    EndIf;\n\nIf( Trim( pTgtSubNoParents ) @= '' );\n  pTgtSubNoParents = cSubNoParents;\nElse;\n  pTgtSubNoParents\
    \ = pTgtSubNoParents | ' - %sHier%';\nEndIf;\n\n### Validate dimension\nIf( Trim( pDim ) @= '' );\n\
    \  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### If errors occurred terminate process with a major error status ###\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Handle All dimensions or a dimension list\n### We will exclude hierarchies\
    \ in this step and will filter them in connection with subsets in later steps\nIf ( TRIM( pDim ) @=\
    \ cAll );\n  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}' );\nElse;\n  sDimTokenizer = TRIM( pDim );\n  sMDX = '';\n  ### Loop and tokenize\
    \ dimension list\n  While ( sDimTokenizer @<> '' );\n    nPos = SCAN( pDelim, sDimTokenizer );\n \
    \   If ( nPos = 0 );\n      nPos = LONG( sDimTokenizer ) + 1;\n    EndIf;\n    sSearchDim = TRIM(\
    \ SUBST( sDimTokenizer, 1, nPos - 1 ) );\n    If( sMDX @= '' );\n      sMDX = Expand( '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n    Else;\n \
    \     sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}, '%sSearchDim%')}' );\n    EndIf;\n    ### Consume dimension and delimiter\n    sDimTokenizer\
    \ = TRIM( DELET( sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX = Expand( '{%sMDX%}'\
    \ );\nEndIf;\n\n### Create dimensions subset\nIf ( SubsetExists( cDimDimensions, cTempSub1 ) = 0 );\n\
    \  SubsetCreate( cDimDimensions, cTempSub1, 1 );\nEndIf;\nSubsetMDXSet( cDimDimensions, cTempSub1,\
    \ sMDX );\nSubsetMDXSet( cDimDimensions, cTempSub1, '' );\n\n### Create hierachies working subset\n\
    If ( SubsetExists( cDimDimensions, cTempSub2 ) = 0 );\n  SubsetCreate( cDimDimensions, cTempSub2,\
    \ 1 );\nEndIf;\n\nDatasourceNameForServer = cDimDimensions;\nDatasourceNameForClient = cDimDimensions;\n\
    DataSourceType = 'SUBSET';\nDatasourceDimensionSubset = cTempSub1;\n#Section Metadaten\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n# Skip processing if there is no\
    \ Leaves hierarchy defined for the dimension or we are processing Leaves\nIf ( HierarchyExists( vDim,\
    \ cHierLeaves ) = 0 );\n  ItemSkip;\nEndIf;\n\n# Summary information printout\nIf ( sDimPrev @<> vDim\
    \ );\n  If ( sDimPrev @<> '' & nElemsMissing <> 0 );\n    sElemsMissing = NumberToString( nElemsMissing\
    \ );\n    If ( pLogOutput <> 0 );\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%]\
    \ is missing [%sElemsMissing%] elements from [%cHierLeaves%] hierarchy in all of matching hierarchies\
    \ [%pHier%]. List of elements is available in subset [%pTgtSub%] of [%cHierLeaves%] hierarchy.' )\
    \ );\n    EndIf;\n    nDimsWithOrphans = nDimsWithOrphans + 1;\n  EndIf;\n  If ( sDimPrev @<> '' &\
    \ nElemsMissingParent <> 0 );\n    sElemsMissingParent = NumberToString( nElemsMissingParent );\n\
    \    If ( pLogOutput <> 0 );\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] contains\
    \ [%sElemsMissingParent%] elements that are missing parent in matching hierarchies [%pHier%].' ) );\n\
    \    EndIf;\n    nDimsWithoutParents = nDimsWithoutParents + 1;\n  EndIf;\n  nDims = nDims + 1;\n\
    \  nElemsMissing = 0;\n  nElemsMissingParent = 0;\n  sDimPrev = vDim;\nEndIf;\n\nIf( pHier @= '' );\n\
    \  sHier = vDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIf( sHier @= cAll );\n  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ [%cDimDimensions%].CurrentMember.Name = ''%vDim%'' OR INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ ''%vDim%:'' ) = 1 )}' );\n  SubsetMDXSet( cDimDimensions, cTempSub2, sMDX );\n  # Exclude Leaves\
    \ from the count\n  nMaxHier = SubsetGetSize( cDimDimensions, cTempSub2 ) - 1;\nElse;\n  sMDX = Expand(\
    \ '{TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimDimensions%])}, ''%vDim%:%sHier%'')}' );\n  SubsetMDXSet(\
    \ cDimDimensions, cTempSub2, sMDX );\n  nMaxHier = SubsetGetSize( cDimDimensions, cTempSub2 );\nEndIf;\
    \  \n\nIf ( nMaxHier <> 0 );\n  nElem = 1;\n  nMaxElem = ElementCount( vDim, cHierLeaves );\n  While\
    \ ( nElem <= nMaxElem );\n    sElem = ElementName( vDim, cHierLeaves, nElem );\n    nElems = 0;\n\
    \    nHier = 1;\n    While ( nHier <= nMaxHier );\n      sDimHier = SubsetGetElementName( cDimDimensions,\
    \ cTempSub2, nHier );\n      nDelimHier = SCAN( ':', sDimHier );\n      If ( nDelimHier <> 0 );\n\
    \        sDim = SUBST( sDimHier, 1, nDelimHier - 1);\n        sHier = SUBST( sDimHier, nDelimHier\
    \ + 1, LONG( sDimHier ) - nDelimHier );\n      Else;\n        sDim = sDimHier;\n        sHier = sDimHier;\n\
    \      EndIf;\n      If ( sHier @<> cHierLeaves );\n        If ( pIncludeNoParentElems <> 0 );\n \
    \         If(ElementIndex( sDim, sHier, sElem ) <> 0 & ElementParentCount( sDim, sHier, sElem ) =\
    \ 0 & ElementLevel(sDim, sHier, sElem) = 0);\n            sTgtSubNoParents = Expand(pTgtSubNoParents);\n\
    \            If ( HierarchySubsetExists( sDim, cHierLeaves, sTgtSubNoParents ) = 0 );\n          \
    \    HierarchySubsetCreate( sDim, cHierLeaves, sTgtSubNoParents );\n            ElseIf ( nElemsMissingParent\
    \ = 0 );\n              HierarchySubsetDeleteAllElements( sDim, cHierLeaves, sTgtSubNoParents );\n\
    \            EndIf;\n            If ( HierarchySubsetElementExists( sDim, cHierLeaves, sTgtSubNoParents,\
    \ sElem ) = 0 );\n              HierarchySubsetElementInsert( sDim, cHierLeaves, sTgtSubNoParents,\
    \ sElem, 0 );\n            EndIf;\n            If ( pLogOutput > 1 );\n              LogOutput( cMsgInfoLevel,\
    \ Expand( 'Element [%sElem%] is missing parent in [%sHier%] of dimension [%vDim%].' ) );\n       \
    \     EndIf;\n            nElemsMissingParent = nElemsMissingParent + 1;\n          EndIf;\n     \
    \   EndIf;\n        If ( ElementIndex( sDim, sHier, sElem ) = 0 );\n          nElems = nElems + 1;\n\
    \        EndIf;\n      EndIf;\n      nHier = nHier + 1;\n    End;\n    # We have scanned all hierarchies\
    \ and if number of elements missing equals number of hierarchies (excl. Leaves) then the element is\
    \ orphan in Leaves\n    If ( nElems = nMaxHier );\n      If ( HierarchySubsetExists( sDim, cHierLeaves,\
    \ pTgtSubLeaves ) = 0 );\n        HierarchySubsetCreate( sDim, cHierLeaves, pTgtSubLeaves );\n   \
    \   ElseIf ( nElemsMissing = 0 );\n        HierarchySubsetDeleteAllElements( sDim, cHierLeaves, pTgtSubLeaves\
    \ );\n      EndIf;\n      If ( HierarchySubsetElementExists( sDim, cHierLeaves, pTgtSubLeaves, sElem\
    \ ) = 0 );\n        HierarchySubsetElementInsert( sDim, cHierLeaves, pTgtSubLeaves, sElem, 0 );\n\
    \      EndIf;\n      If ( pLogOutput > 1 );\n        LogOutput( cMsgInfoLevel, Expand( 'Element [%sElem%]\
    \ is missing in all matching hierarchies [%pHier%] of dimension [%vDim%] except [%cHierLeaves%].'\
    \ ) );\n      EndIf;\n      nElemsMissing = nElemsMissing + 1;\n    EndIf;\n    nElem = nElem + 1;\n\
    \  End;\nEndIf;\n\n#Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ If errors occurred terminate process with a major error status ###\nIf( nErrors <> 0 );\n    sMessage\
    \ = 'the process incurred at least 1 major error and consequently aborted. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nEndIf;\n\n### Return Code\nIf ( nDims <> 0 );\n  sDims = NumberToString( nDims );\n\
    \  ### Regular function - Leaves orphans\n  If ( nDimsWithOrphans = 0 & nElemsMissing <> 0 );\n  \
    \  nDimsWithOrphans = 1;\n    If ( pLogOutput <> 0 );\n      sElemsMissing = NumberToString( nElemsMissing\
    \ );\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] is missing [%sElemsMissing%]\
    \ elements from [%cHierLeaves%] hierarchy in all of matching hierarchies [%pHier%]. List of elements\
    \ is available in subset [%pTgtSub%] of [%cHierLeaves%] hierarchy.' ) );\n    EndIf;\n  EndIf;\n \
    \ sDimsWithOrphans = NumberToString( nDimsWithOrphans );\n  If ( nDimsWithOrphans <> 0 );\n    sProcessAction\
    \ = Expand( 'There are orphan elements in [%sDimsWithOrphans%] dimensions out of [%sDims%] matching.'\
    \ );\n  Else;\n    sProcessAction = Expand( 'Scanned [%sDims%] dimensions, all are OK and contain\
    \ no Leaves orphans.' );\n  EndIf;\n  ### Optional function - elements missing parents\n  If ( nDimsWithoutParents\
    \ = 0 & nElemsMissingParent <> 0 );\n    nDimsWithoutParents = 1;\n    If ( pLogOutput <> 0 );\n \
    \     sElemsMissingParents = NumberToString( nElemsMissingParent );\n      LogOutput( cMsgInfoLevel,\
    \ Expand( 'Dimension [%sDimPrev%] contains [%sElemsMissingParents%] elements that are missing parent\
    \ in matching hierarchies [%pHier%].' ) );\n    EndIf;\n  EndIf;\n  sDimsWithoutParents = NumberToString(\
    \ nDimsWithoutParents );\n  If ( nDimsWithoutParents <> 0 );\n    sProcessAction = Expand( '%sProcessAction%\
    \ There are elements having no parent in [%sDimsWithoutParents%] dimensions out of [%sDims%] matching.'\
    \ );\n  Else;\n    sProcessAction = Expand( '%sProcessAction% All scanned dimensions are OK and contain\
    \ no elements without parents.' );\n  EndIf;\nElse;\n  sProcessAction = 'No dimensions/hierarchies\
    \ are matching supplied parameters.';\nEndIf;\nsProcessReturnCode  = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\nnProcessReturnCode  = 1;\nIf( pLogoutput <> 0 );\n    LogOutput( cMsgInfoLevel,\
    \ Expand( sProcessAction ) );   \nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that checks all leaf elements (in the ''Leaves''
    hierarchy) of the specified dimension(s). Within the ''Leaves'' hierarchy, for each element, *all
    hierarchies* are scanned for the existence of the leaf element. If the leaf element does not exist
    in all hierarchies except for ''Leaves'', the element is classified as an orphan and added to the
    ''Orphan Leaf Elements'' subset. Additionally, when running with the pIncludeNoParentElems parameter
    set, elements that have no parent will be stored in the ''No Parents'' subset of the matching hierarchy
    (except ''Leaves'') within Leaves. The subset name might be adapted and suffixed with a dash and the
    name of the matching hierarchy. Use case: 1. Primarily intended to identify dimensions with maintenance
    issues during development/prototyping. 2. Can also be used for troubleshooting in productive instances.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process checks all leaf elements (in the Leaves hierarchy)\
    \ of the specified dimension(s).\n# Within the Leaves hierarchy for each element *all hierarchies*\
    \ are scanned for the existance of the leaf element.\n# If the leaf element does not exist in all\
    \ hierarchies except for Leaves then the element is classified as an orphan and added to the \n# 'Orphan\
    \ Leaf Elements' subset.\n# Additionally when running with pIncludeNoParentElems parameter set, elements\
    \ that have no parent will be stored in No Parents subset\n# of matching hierarchy (except `Leaves`)\
    \ within Leaves. The subset name might be accomodated and will be suffixed by dash and name of the\
    \ matching hierarchy.\n#\n# Use case: \n# 1. Primarily intended to identify dimensions with maintenance\
    \ issues during development/prototyping.\n# 2. Can also be used for trouble-shooting in productive\
    \ instances.\n#\n#EndRegion @DOC\n\n### Global Variables\n\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants\ncThisProcName\
    \     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt   \
    \     = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub1          = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncTempSub2         = cTempSub1 | '_2';\ncTempSubDim       = cThisProcName |'_Dim_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgInfoLevel\
    \     = 'INFO';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%.';\ncAll            \
    \  = '*';\ncDimDimensions    = '}Dimensions';\ncHierLeaves       = 'Leaves';\ncSubMissing       =\
    \ 'Bedrock - Orphan Elements - Leaves';\ncSubNoParents     = 'Bedrock - No Parents - %sHier%';\n\n\
    ### LogOutput parameters\nIF( pLogoutput = 1 );\n  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \n### Validate Parameters\nnErrors = 0;\nnDims = 0;\nnDimsWithOrphans = 0;\nnDimsWithoutParents =\
    \ 0;\nnElems = 0;\nnElemsMissing = 0;\nnElemsMissingParent = 0;\nsDimPrev = '';\n\nIf( Scan( '*',\
    \ pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @=\
    \ '' );\n  # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n  pHier = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n  pDim\
    \ = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate delimiter\nIf( Trim( pDelim )\
    \ @= '' );\n  pDelim = '&';\nEndIf;\n\nIf( Trim( pTgtSubLeaves ) @= '' );\n  pTgtSubLeaves = cSubMissing;\n\
    EndIf;\n\nIf( Trim( pTgtSubNoParents ) @= '' );\n  pTgtSubNoParents = cSubNoParents;\nElse;\n  pTgtSubNoParents\
    \ = pTgtSubNoParents | ' - %sHier%';\nEndIf;\n\n### Validate dimension\nIf( Trim( pDim ) @= '' );\n\
    \  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### If errors occurred terminate process with a major error status ###\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Handle All dimensions or a dimension list\n### We will exclude hierarchies\
    \ in this step and will filter them in connection with subsets in later steps\nIf ( TRIM( pDim ) @=\
    \ cAll );\n  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}' );\nElse;\n  sDimTokenizer = TRIM( pDim );\n  sMDX = '';\n  ### Loop and tokenize\
    \ dimension list\n  While ( sDimTokenizer @<> '' );\n    nPos = SCAN( pDelim, sDimTokenizer );\n \
    \   If ( nPos = 0 );\n      nPos = LONG( sDimTokenizer ) + 1;\n    EndIf;\n    sSearchDim = TRIM(\
    \ SUBST( sDimTokenizer, 1, nPos - 1 ) );\n    If( sMDX @= '' );\n      sMDX = Expand( '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n    Else;\n \
    \     sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}, '%sSearchDim%')}' );\n    EndIf;\n    ### Consume dimension and delimiter\n    sDimTokenizer\
    \ = TRIM( DELET( sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX = Expand( '{%sMDX%}'\
    \ );\nEndIf;\n\n### Create dimensions subset\nIf ( SubsetExists( cDimDimensions, cTempSub1 ) = 0 );\n\
    \  SubsetCreate( cDimDimensions, cTempSub1, 1 );\nEndIf;\nSubsetMDXSet( cDimDimensions, cTempSub1,\
    \ sMDX );\nSubsetMDXSet( cDimDimensions, cTempSub1, '' );\n\n### Create hierachies working subset\n\
    If ( SubsetExists( cDimDimensions, cTempSub2 ) = 0 );\n  SubsetCreate( cDimDimensions, cTempSub2,\
    \ 1 );\nEndIf;\n\nDatasourceNameForServer = cDimDimensions;\nDatasourceNameForClient = cDimDimensions;\n\
    DataSourceType = 'SUBSET';\nDatasourceDimensionSubset = cTempSub1;\n#Section Metadaten\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n# Skip processing if there is no\
    \ Leaves hierarchy defined for the dimension or we are processing Leaves\nIf ( HierarchyExists( vDim,\
    \ cHierLeaves ) = 0 );\n  ItemSkip;\nEndIf;\n\n# Summary information printout\nIf ( sDimPrev @<> vDim\
    \ );\n  If ( sDimPrev @<> '' & nElemsMissing <> 0 );\n    sElemsMissing = NumberToString( nElemsMissing\
    \ );\n    If ( pLogOutput <> 0 );\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%]\
    \ is missing [%sElemsMissing%] elements from [%cHierLeaves%] hierarchy in all of matching hierarchies\
    \ [%pHier%]. List of elements is available in subset [%pTgtSub%] of [%cHierLeaves%] hierarchy.' )\
    \ );\n    EndIf;\n    nDimsWithOrphans = nDimsWithOrphans + 1;\n  EndIf;\n  If ( sDimPrev @<> '' &\
    \ nElemsMissingParent <> 0 );\n    sElemsMissingParent = NumberToString( nElemsMissingParent );\n\
    \    If ( pLogOutput <> 0 );\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] contains\
    \ [%sElemsMissingParent%] elements that are missing parent in matching hierarchies [%pHier%].' ) );\n\
    \    EndIf;\n    nDimsWithoutParents = nDimsWithoutParents + 1;\n  EndIf;\n  nDims = nDims + 1;\n\
    \  nElemsMissing = 0;\n  nElemsMissingParent = 0;\n  sDimPrev = vDim;\nEndIf;\n\nIf( pHier @= '' );\n\
    \  sHier = vDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIf( sHier @= cAll );\n  sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ [%cDimDimensions%].CurrentMember.Name = ''%vDim%'' OR INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ ''%vDim%:'' ) = 1 )}' );\n  SubsetMDXSet( cDimDimensions, cTempSub2, sMDX );\n  # Exclude Leaves\
    \ from the count\n  nMaxHier = SubsetGetSize( cDimDimensions, cTempSub2 ) - 1;\nElse;\n  sMDX = Expand(\
    \ '{TM1FILTERBYPATTERN({TM1SUBSETALL([%cDimDimensions%])}, ''%vDim%:%sHier%'')}' );\n  SubsetMDXSet(\
    \ cDimDimensions, cTempSub2, sMDX );\n  nMaxHier = SubsetGetSize( cDimDimensions, cTempSub2 );\nEndIf;\
    \  \n\nIf ( nMaxHier <> 0 );\n  nElem = 1;\n  nMaxElem = ElementCount( vDim, cHierLeaves );\n  While\
    \ ( nElem <= nMaxElem );\n    sElem = ElementName( vDim, cHierLeaves, nElem );\n    nElems = 0;\n\
    \    nHier = 1;\n    While ( nHier <= nMaxHier );\n      sDimHier = SubsetGetElementName( cDimDimensions,\
    \ cTempSub2, nHier );\n      nDelimHier = SCAN( ':', sDimHier );\n      If ( nDelimHier <> 0 );\n\
    \        sDim = SUBST( sDimHier, 1, nDelimHier - 1);\n        sHier = SUBST( sDimHier, nDelimHier\
    \ + 1, LONG( sDimHier ) - nDelimHier );\n      Else;\n        sDim = sDimHier;\n        sHier = sDimHier;\n\
    \      EndIf;\n      If ( sHier @<> cHierLeaves );\n        If ( pIncludeNoParentElems <> 0 );\n \
    \         If(ElementIndex( sDim, sHier, sElem ) <> 0 & ElementParentCount( sDim, sHier, sElem ) =\
    \ 0 & ElementLevel(sDim, sHier, sElem) = 0);\n            sTgtSubNoParents = Expand(pTgtSubNoParents);\n\
    \            If ( HierarchySubsetExists( sDim, cHierLeaves, sTgtSubNoParents ) = 0 );\n          \
    \    HierarchySubsetCreate( sDim, cHierLeaves, sTgtSubNoParents );\n            ElseIf ( nElemsMissingParent\
    \ = 0 );\n              HierarchySubsetDeleteAllElements( sDim, cHierLeaves, sTgtSubNoParents );\n\
    \            EndIf;\n            If ( HierarchySubsetElementExists( sDim, cHierLeaves, sTgtSubNoParents,\
    \ sElem ) = 0 );\n              HierarchySubsetElementInsert( sDim, cHierLeaves, sTgtSubNoParents,\
    \ sElem, 0 );\n            EndIf;\n            If ( pLogOutput > 1 );\n              LogOutput( cMsgInfoLevel,\
    \ Expand( 'Element [%sElem%] is missing parent in [%sHier%] of dimension [%vDim%].' ) );\n       \
    \     EndIf;\n            nElemsMissingParent = nElemsMissingParent + 1;\n          EndIf;\n     \
    \   EndIf;\n        If ( ElementIndex( sDim, sHier, sElem ) = 0 );\n          nElems = nElems + 1;\n\
    \        EndIf;\n      EndIf;\n      nHier = nHier + 1;\n    End;\n    # We have scanned all hierarchies\
    \ and if number of elements missing equals number of hierarchies (excl. Leaves) then the element is\
    \ orphan in Leaves\n    If ( nElems = nMaxHier );\n      If ( HierarchySubsetExists( sDim, cHierLeaves,\
    \ pTgtSubLeaves ) = 0 );\n        HierarchySubsetCreate( sDim, cHierLeaves, pTgtSubLeaves );\n   \
    \   ElseIf ( nElemsMissing = 0 );\n        HierarchySubsetDeleteAllElements( sDim, cHierLeaves, pTgtSubLeaves\
    \ );\n      EndIf;\n      If ( HierarchySubsetElementExists( sDim, cHierLeaves, pTgtSubLeaves, sElem\
    \ ) = 0 );\n        HierarchySubsetElementInsert( sDim, cHierLeaves, pTgtSubLeaves, sElem, 0 );\n\
    \      EndIf;\n      If ( pLogOutput > 1 );\n        LogOutput( cMsgInfoLevel, Expand( 'Element [%sElem%]\
    \ is missing in all matching hierarchies [%pHier%] of dimension [%vDim%] except [%cHierLeaves%].'\
    \ ) );\n      EndIf;\n      nElemsMissing = nElemsMissing + 1;\n    EndIf;\n    nElem = nElem + 1;\n\
    \  End;\nEndIf;\n\n#Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ If errors occurred terminate process with a major error status ###\nIf( nErrors <> 0 );\n    sMessage\
    \ = 'the process incurred at least 1 major error and consequently aborted. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nEndIf;\n\n### Return Code\nIf ( nDims <> 0 );\n  sDims = NumberToString( nDims );\n\
    \  ### Regular function - Leaves orphans\n  If ( nDimsWithOrphans = 0 & nElemsMissing <> 0 );\n  \
    \  nDimsWithOrphans = 1;\n    If ( pLogOutput <> 0 );\n      sElemsMissing = NumberToString( nElemsMissing\
    \ );\n      LogOutput( cMsgInfoLevel, Expand( 'Dimension [%sDimPrev%] is missing [%sElemsMissing%]\
    \ elements from [%cHierLeaves%] hierarchy in all of matching hierarchies [%pHier%]. List of elements\
    \ is available in subset [%pTgtSub%] of [%cHierLeaves%] hierarchy.' ) );\n    EndIf;\n  EndIf;\n \
    \ sDimsWithOrphans = NumberToString( nDimsWithOrphans );\n  If ( nDimsWithOrphans <> 0 );\n    sProcessAction\
    \ = Expand( 'There are orphan elements in [%sDimsWithOrphans%] dimensions out of [%sDims%] matching.'\
    \ );\n  Else;\n    sProcessAction = Expand( 'Scanned [%sDims%] dimensions, all are OK and contain\
    \ no Leaves orphans.' );\n  EndIf;\n  ### Optional function - elements missing parents\n  If ( nDimsWithoutParents\
    \ = 0 & nElemsMissingParent <> 0 );\n    nDimsWithoutParents = 1;\n    If ( pLogOutput <> 0 );\n \
    \     sElemsMissingParents = NumberToString( nElemsMissingParent );\n      LogOutput( cMsgInfoLevel,\
    \ Expand( 'Dimension [%sDimPrev%] contains [%sElemsMissingParents%] elements that are missing parent\
    \ in matching hierarchies [%pHier%].' ) );\n    EndIf;\n  EndIf;\n  sDimsWithoutParents = NumberToString(\
    \ nDimsWithoutParents );\n  If ( nDimsWithoutParents <> 0 );\n    sProcessAction = Expand( '%sProcessAction%\
    \ There are elements having no parent in [%sDimsWithoutParents%] dimensions out of [%sDims%] matching.'\
    \ );\n  Else;\n    sProcessAction = Expand( '%sProcessAction% All scanned dimensions are OK and contain\
    \ no elements without parents.' );\n  EndIf;\nElse;\n  sProcessAction = 'No dimensions/hierarchies\
    \ are matching supplied parameters.';\nEndIf;\nsProcessReturnCode  = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\nnProcessReturnCode  = 1;\nIf( pLogoutput <> 0 );\n    LogOutput( cMsgInfoLevel,\
    \ Expand( sProcessAction ) );   \nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der die Synchronität der Leaves-Hierarchie in
    Bezug auf die Haupt- und Alternativhierarchien einer Dimension überprüft und wiederherstellt. Der
    Prozess sollte sicherstellen, dass alle Blattelemente in der Leaves-Hierarchie vorhanden sind, wenn
    diese mit den in den Parametern pDim und pHier angegebenen Dimensionen und Hierarchien verglichen
    werden. Der Vorgang sollte automatisch fehlende Blattelemente zur Leaves-Hierarchie hinzufügen. Nutze
    diesen Prozess, um während der Entwicklung oder Fehlersuche in produktiven Instanzen Dimensionsprobleme
    zu identifizieren und zu beheben.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# In certain circumstances the Leaves hierarchy can become *out of\
    \ sync* with the same named hierarchy and other alternate hierarchies\n# and *not contain all leaf\
    \ elements*. Should this happen this process will heal such dimensions and restore the synced state\
    \ where\n# the Leaves hierarchy contains the collection of all leaf elements from all hiearchies of\
    \ a dimension.  \n# For the set of dimensions and hierarchies defined by the pDim & pHier parameters\
    \ this process checks that all leaf elements from each\n# hierarchy also exists in the Leaves hierarchy\
    \ of the specified dimension(s).\n#\n# If the leaf element does not exist in the Leaves hierarchy\
    \ then the element is inserted into Leaves.\n#\n# Use case: \n# 1. Primarily intended to identify\
    \ dimensions with maintenance issues during development/prototyping.\n# 2. Can also be used for trouble-shooting\
    \ in productive instances.\n#\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants\ncThisProcName\
    \     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt   \
    \     = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncTempSubDim       = cThisProcName |'_Dim_'| cTimeStamp |'_'| cRandomInt;\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgInfoLevel     = 'INFO';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%.';\ncAll              = '*';\ncDimDimensions    =\
    \ '}Dimensions';\ncCharAny          = '?';\ncStringAny        = '*';\ncHierLeaves       = 'Leaves';\n\
    cRollupOrphan     = 'ORPHAN LEAVES';\n\n### LogOutput parameters\nIF( pLogoutput >= 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\nsDimPrev          = '';\nnErrors  \
    \         = 0;\nnDims             = 0;\nnDimsChanged      = 0;\nnElems            = 0;\nnLeaves  \
    \         = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan(\
    \ ':', pDim ) > 0 & pHier @= '' );\n  # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n  pHier = SubSt( pDim, Scan( ':', pDim )\
    \ + 1, Long( pDim ) );\n  pDim = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate\
    \ delimiter\nIf( Trim( pDelim ) @= '' );\n  pDelim = '&';\nEndIf;\n\n### Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### Validate reverse sync option\nIf( pReverse <> 1 );\n\
    \  pReverse = 0;\nEndIf;\n\n### If errors occurred terminate process with a major error status ###\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Handle All dimensions or a dimension list, including all available hierarchies\n\
    If ( TRIM( pDim ) @= cAll );\n  sMDX1 = Expand( '{TM1SUBSETALL([%cDimDimensions%])}' );\nElse;\n \
    \ sDimTokenizer = TRIM( pDim );\n  sMDX = '';\n  ### Loop and tokenize dimension list\n  While ( sDimTokenizer\
    \ @<> '' );\n    nPos = SCAN( pDelim, sDimTokenizer );\n    If ( nPos = 0 );\n      nPos = LONG( sDimTokenizer\
    \ ) + 1;\n    EndIf;\n    sSearchDim = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n    If( sMDX\
    \ @= '' );\n      sMDX = Expand( '{TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])}, '%sSearchDim%*'\
    \ )}' );\n    Else;\n      sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])},\
    \ '%sSearchDim%' )}' );\n    EndIf;\n    ### Consume dimension and delimiter\n    sDimTokenizer =\
    \ TRIM( DELET( sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX1 = Expand( '{%sMDX%}'\
    \ );\nEndIf;\n\n### Handle All hierarchies or a hierarchy list\n### We will filter hierarchies in\
    \ this step from base set created previously\nIf ( TRIM( pHier ) @= cAll );\n  sMDX = sMDX1;\nElse;\n\
    \  sHierTokenizer = TRIM( pHier );\n  If( sHierTokenizer @= '' );\n    # if pHier blank then we need\
    \ only same named hierarchies - that means to exclude elements that have : in their names\n    sMDX\
    \ = Expand( '{FILTER( %sMDX1%, INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}' );\n \
    \ Else;\n    sMDX = '';\n    ### Loop and tokenize hierarchy list\n    While ( sHierTokenizer @<>\
    \ '' );\n      nPos = SCAN( pDelim, sHierTokenizer );\n      If ( nPos = 0 );\n        nPos = LONG(\
    \ sHierTokenizer ) + 1;\n      EndIf;\n      sSearchHier = TRIM( SUBST( sHierTokenizer, 1, nPos -\
    \ 1 ) );\n      If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN( %sMDX1%, '*:%sSearchHier%'\
    \ )}' );\n      Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN( %sMDX1%, '*:%sSearchHier%'\
    \ )}' );\n      EndIf;\n      ### Consume hierarchy and delimiter\n      sHierTokenizer = TRIM( DELET(\
    \ sHierTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n    End;\n    sMDX = Expand( '{%sMDX%}' );\n\
    \  EndIf;\nEndIf;\n\nsMDX = Expand(' {EXCEPT( %sMDX%, {TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])},\
    \ '*:Leaves' )} )}');\nsMDXF = Expand( '{ORDER( %sMDX%, [%cDimDimensions%].CurrentMember.Name, ASC\
    \ )}' );\n\n### Create dimension:hierarchy subset\nIf ( SubsetExists( cDimDimensions, cTempSub ) =\
    \ 0 );\n    SubsetCreatebyMDX( cTempSub, sMDXF, cDimDimensions, 1 );\nElse;\n    SubsetMDXSet( cDimDimensions,\
    \ cTempSub, sMDXF );\nEndIf;\n\nDatasourceNameForServer = cDimDimensions;\nDatasourceNameForClient\
    \ = cDimDimensions;\nDataSourceType = 'SUBSET';\nDatasourceDimensionSubset = cTempSub;\n\n### END\
    \ PROLOG\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n# Get dimension & hierarchy from vDimHier\nnDelimHier  = SCAN( ':', vDimHier );\nIf ( nDelimHier\
    \ <> 0 );\n    sDim    = SUBST( vDimHier, 1, nDelimHier - 1);\n    sHier   = SUBST( vDimHier, nDelimHier\
    \ + 1, LONG( vDimHier ) - nDelimHier );\nElse;\n    sDim    = vDimHier;\n    sHier   = vDimHier;\n\
    EndIf;\n\nIf ( sHier  @= cHierLeaves );\n    ItemSkip;\nEndIf;\n\n# Set check counters\nIf( sDim @<>\
    \ sDimPrev );\n    nDims   = nDims + 1;\nEndIf;\nnElems      = 0;\nnLeaves     = 0;\n\n# Add leaves\
    \ which exist in hierarchy but (somehow) don't exist in Leaves hierarchy to Leaves\nnElem = 1;\nnMaxElem\
    \ = ElementCount( sDim, sHier );\nWhile ( nElem <= nMaxElem );\n    sElem = ElementName( sDim, sHier,\
    \ nElem );\n    sType = ElementType( sDim, sHier, sElem );\n    If ( ElementLevel( sDim, sHier, sElem\
    \ ) = 0 & HierarchyExists( sDim, cHierLeaves ) = 1 );\n        If ( ElementIndex( sDim, cHierLeaves,\
    \ sElem ) = 0 & ( sType @= 'N' % sType @= 'S' ) );\n            HierarchyElementInsert( sDim, cHierLeaves,\
    \ '', sElem, sType );\n            nElems = nElems + 1;\n            If ( pLogOutput <> 0 );\n   \
    \             LogOutput( cMsgInfoLevel, Expand( 'Adding element [%sElem%] of [%sType%] type into [%cHierLeaves%],\
    \ element was found in hierarchy [%sHier%].' ) );\n            EndIf;\n        EndIf;\n    EndIf;\n\
    \    nElem = nElem + 1;\nEnd;\n\n# Add leaves not existing in hierarchy to the 'ORPHAN LEAVES' consolidation\n\
    If( pReverse = 1 & HierarchyExists( sDim, cHierLeaves ) = 1 );\n    nLeaf = 1;\n    nMaxLeaves = ElementCount(\
    \ sDim, cHierLeaves );\n    While ( nLeaf <= nMaxLeaves );\n        sLeaf = ElementName( sDim, cHierLeaves,\
    \ nLeaf );\n        sType = ElementType( sDim, cHierLeaves, sLeaf );\n        If ( ElementIndex( sDim,\
    \ sHier, sLeaf ) = 0 );\n            HierarchyElementInsert( sDim, sHier, '', cRollupOrphan, 'C' );\n\
    \            HierarchyElementInsert( sDim, sHier, '', sLeaf, sType );\n            If( sType @= 'N'\
    \ );\n                HierarchyElementComponentAdd( sDim, sHier, cRollupOrphan, sLeaf, 1 );\n    \
    \        EndIf;\n            nLeaves = nLeaves + 1;\n            If ( pLogOutput <> 0 );\n       \
    \         LogOutput( cMsgInfoLevel, Expand( 'Adding leaf [%sLeaf%] into hierarchy [%sHier%].' ) );\n\
    \            EndIf;\n        EndIf;\n        nLeaf = nLeaf + 1;\n    End;\nEndIf;\n\n# Summary information\
    \ printout\nIf( nElems  > 0 );\n    sElems  = NumberToString( nElems );\n    If ( pLogOutput <> 0\
    \ );\n        LogOutput( cMsgInfoLevel, Expand( 'Added [%sElems%] elements from hierarchy [%sHier%]\
    \ into [%cHierLeaves%] hierarchy of [%sDim%] dimension.' ) );\n    EndIf;\nEndIf;\nIf( nLeaves > 0\
    \ );\n    sLeaves = NumberToString( nLeaves );\n    If ( pLogOutput <> 0 );\n        LogOutput( cMsgInfoLevel,\
    \ Expand( 'Added [%sLeaves%] leaves into hierarchy [%sHier%] of [%sDim%] dimension.' ) );\n    EndIf;\n\
    EndIf;\nIf( sDim @<> sDimPrev & (nElems + nLeaves) > 0 );\n    nDimsChanged = nDimsChanged + 1;\n\
    EndIf;\nsDimPrev    = sDim;\n\n### END METADATA\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### If errors occurred terminate process with a major error status ###\n\
    If( nErrors <> 0 );\n    sMessage = 'the process incurred at least 1 major error and consequently\
    \ aborted. Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nEndIf;\n\n### Return Code\nIf ( nDims <> 0 );\n  sDims\
    \ = NumberToString( nDims );\n  sDimsChanged = NumberToString( nDimsChanged );\n  If ( nDimsChanged\
    \ > 0 );\n    sProcessAction = Expand( 'Modified [%sDimsChanged%] dimensions out of [%sDims%] matching\
    \ the filter.' );\n  Else;\n    sProcessAction = Expand( 'Scanned [%sDims%] dimensions, all are ok.'\
    \ );\n  EndIf;\nElse;\n  sProcessAction = 'No dimensions/hierarchies are matching supplied parameters.\
    \ Nothing modified.';\nEndIf;\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\nnProcessReturnCode  = 1;\nIf( pLogoutput <> 0 );\n    LogOutput( cMsgInfoLevel, Expand( sProcessAction\
    \ ) );   \nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that verifies and restores the synchronization of
    the Leaves hierarchy concerning the main and alternate hierarchies of a dimension. The process should
    ensure that all leaf elements are present in the Leaves hierarchy when compared with the dimensions
    and hierarchies specified in the pDim and pHier parameters. The operation should automatically insert
    any missing leaf elements into the Leaves hierarchy. Use this process to identify and resolve dimension
    issues during development or troubleshooting in productive instances.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# In certain circumstances the Leaves hierarchy can become *out of\
    \ sync* with the same named hierarchy and other alternate hierarchies\n# and *not contain all leaf\
    \ elements*. Should this happen this process will heal such dimensions and restore the synced state\
    \ where\n# the Leaves hierarchy contains the collection of all leaf elements from all hiearchies of\
    \ a dimension.  \n# For the set of dimensions and hierarchies defined by the pDim & pHier parameters\
    \ this process checks that all leaf elements from each\n# hierarchy also exists in the Leaves hierarchy\
    \ of the specified dimension(s).\n#\n# If the leaf element does not exist in the Leaves hierarchy\
    \ then the element is inserted into Leaves.\n#\n# Use case: \n# 1. Primarily intended to identify\
    \ dimensions with maintenance issues during development/prototyping.\n# 2. Can also be used for trouble-shooting\
    \ in productive instances.\n#\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants\ncThisProcName\
    \     = GetProcessName();\ncTimeStamp        = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt   \
    \     = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub          = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncTempSubDim       = cThisProcName |'_Dim_'| cTimeStamp |'_'| cRandomInt;\ncUserName\
    \         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgInfoLevel     = 'INFO';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%.';\ncAll              = '*';\ncDimDimensions    =\
    \ '}Dimensions';\ncCharAny          = '?';\ncStringAny        = '*';\ncHierLeaves       = 'Leaves';\n\
    cRollupOrphan     = 'ORPHAN LEAVES';\n\n### LogOutput parameters\nIF( pLogoutput >= 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\nsDimPrev          = '';\nnErrors  \
    \         = 0;\nnDims             = 0;\nnDimsChanged      = 0;\nnElems            = 0;\nnLeaves  \
    \         = 0;\n\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan(\
    \ ':', pDim ) > 0 & pHier @= '' );\n  # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n  pHier = SubSt( pDim, Scan( ':', pDim )\
    \ + 1, Long( pDim ) );\n  pDim = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate\
    \ delimiter\nIf( Trim( pDelim ) @= '' );\n  pDelim = '&';\nEndIf;\n\n### Validate dimension\nIf( Trim(\
    \ pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified.';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### Validate reverse sync option\nIf( pReverse <> 1 );\n\
    \  pReverse = 0;\nEndIf;\n\n### If errors occurred terminate process with a major error status ###\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Handle All dimensions or a dimension list, including all available hierarchies\n\
    If ( TRIM( pDim ) @= cAll );\n  sMDX1 = Expand( '{TM1SUBSETALL([%cDimDimensions%])}' );\nElse;\n \
    \ sDimTokenizer = TRIM( pDim );\n  sMDX = '';\n  ### Loop and tokenize dimension list\n  While ( sDimTokenizer\
    \ @<> '' );\n    nPos = SCAN( pDelim, sDimTokenizer );\n    If ( nPos = 0 );\n      nPos = LONG( sDimTokenizer\
    \ ) + 1;\n    EndIf;\n    sSearchDim = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n    If( sMDX\
    \ @= '' );\n      sMDX = Expand( '{TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])}, '%sSearchDim%*'\
    \ )}' );\n    Else;\n      sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])},\
    \ '%sSearchDim%' )}' );\n    EndIf;\n    ### Consume dimension and delimiter\n    sDimTokenizer =\
    \ TRIM( DELET( sDimTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n  End;\n  sMDX1 = Expand( '{%sMDX%}'\
    \ );\nEndIf;\n\n### Handle All hierarchies or a hierarchy list\n### We will filter hierarchies in\
    \ this step from base set created previously\nIf ( TRIM( pHier ) @= cAll );\n  sMDX = sMDX1;\nElse;\n\
    \  sHierTokenizer = TRIM( pHier );\n  If( sHierTokenizer @= '' );\n    # if pHier blank then we need\
    \ only same named hierarchies - that means to exclude elements that have : in their names\n    sMDX\
    \ = Expand( '{FILTER( %sMDX1%, INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}' );\n \
    \ Else;\n    sMDX = '';\n    ### Loop and tokenize hierarchy list\n    While ( sHierTokenizer @<>\
    \ '' );\n      nPos = SCAN( pDelim, sHierTokenizer );\n      If ( nPos = 0 );\n        nPos = LONG(\
    \ sHierTokenizer ) + 1;\n      EndIf;\n      sSearchHier = TRIM( SUBST( sHierTokenizer, 1, nPos -\
    \ 1 ) );\n      If( sMDX @= '' );\n        sMDX = Expand( '{TM1FILTERBYPATTERN( %sMDX1%, '*:%sSearchHier%'\
    \ )}' );\n      Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN( %sMDX1%, '*:%sSearchHier%'\
    \ )}' );\n      EndIf;\n      ### Consume hierarchy and delimiter\n      sHierTokenizer = TRIM( DELET(\
    \ sHierTokenizer, 1, nPos + LONG( pDelim ) - 1 ) );\n    End;\n    sMDX = Expand( '{%sMDX%}' );\n\
    \  EndIf;\nEndIf;\n\nsMDX = Expand(' {EXCEPT( %sMDX%, {TM1FILTERBYPATTERN( {TM1SUBSETALL([%cDimDimensions%])},\
    \ '*:Leaves' )} )}');\nsMDXF = Expand( '{ORDER( %sMDX%, [%cDimDimensions%].CurrentMember.Name, ASC\
    \ )}' );\n\n### Create dimension:hierarchy subset\nIf ( SubsetExists( cDimDimensions, cTempSub ) =\
    \ 0 );\n    SubsetCreatebyMDX( cTempSub, sMDXF, cDimDimensions, 1 );\nElse;\n    SubsetMDXSet( cDimDimensions,\
    \ cTempSub, sMDXF );\nEndIf;\n\nDatasourceNameForServer = cDimDimensions;\nDatasourceNameForClient\
    \ = cDimDimensions;\nDataSourceType = 'SUBSET';\nDatasourceDimensionSubset = cTempSub;\n\n### END\
    \ PROLOG\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n# Get dimension & hierarchy from vDimHier\nnDelimHier  = SCAN( ':', vDimHier );\nIf ( nDelimHier\
    \ <> 0 );\n    sDim    = SUBST( vDimHier, 1, nDelimHier - 1);\n    sHier   = SUBST( vDimHier, nDelimHier\
    \ + 1, LONG( vDimHier ) - nDelimHier );\nElse;\n    sDim    = vDimHier;\n    sHier   = vDimHier;\n\
    EndIf;\n\nIf ( sHier  @= cHierLeaves );\n    ItemSkip;\nEndIf;\n\n# Set check counters\nIf( sDim @<>\
    \ sDimPrev );\n    nDims   = nDims + 1;\nEndIf;\nnElems      = 0;\nnLeaves     = 0;\n\n# Add leaves\
    \ which exist in hierarchy but (somehow) don't exist in Leaves hierarchy to Leaves\nnElem = 1;\nnMaxElem\
    \ = ElementCount( sDim, sHier );\nWhile ( nElem <= nMaxElem );\n    sElem = ElementName( sDim, sHier,\
    \ nElem );\n    sType = ElementType( sDim, sHier, sElem );\n    If ( ElementLevel( sDim, sHier, sElem\
    \ ) = 0 & HierarchyExists( sDim, cHierLeaves ) = 1 );\n        If ( ElementIndex( sDim, cHierLeaves,\
    \ sElem ) = 0 & ( sType @= 'N' % sType @= 'S' ) );\n            HierarchyElementInsert( sDim, cHierLeaves,\
    \ '', sElem, sType );\n            nElems = nElems + 1;\n            If ( pLogOutput <> 0 );\n   \
    \             LogOutput( cMsgInfoLevel, Expand( 'Adding element [%sElem%] of [%sType%] type into [%cHierLeaves%],\
    \ element was found in hierarchy [%sHier%].' ) );\n            EndIf;\n        EndIf;\n    EndIf;\n\
    \    nElem = nElem + 1;\nEnd;\n\n# Add leaves not existing in hierarchy to the 'ORPHAN LEAVES' consolidation\n\
    If( pReverse = 1 & HierarchyExists( sDim, cHierLeaves ) = 1 );\n    nLeaf = 1;\n    nMaxLeaves = ElementCount(\
    \ sDim, cHierLeaves );\n    While ( nLeaf <= nMaxLeaves );\n        sLeaf = ElementName( sDim, cHierLeaves,\
    \ nLeaf );\n        sType = ElementType( sDim, cHierLeaves, sLeaf );\n        If ( ElementIndex( sDim,\
    \ sHier, sLeaf ) = 0 );\n            HierarchyElementInsert( sDim, sHier, '', cRollupOrphan, 'C' );\n\
    \            HierarchyElementInsert( sDim, sHier, '', sLeaf, sType );\n            If( sType @= 'N'\
    \ );\n                HierarchyElementComponentAdd( sDim, sHier, cRollupOrphan, sLeaf, 1 );\n    \
    \        EndIf;\n            nLeaves = nLeaves + 1;\n            If ( pLogOutput <> 0 );\n       \
    \         LogOutput( cMsgInfoLevel, Expand( 'Adding leaf [%sLeaf%] into hierarchy [%sHier%].' ) );\n\
    \            EndIf;\n        EndIf;\n        nLeaf = nLeaf + 1;\n    End;\nEndIf;\n\n# Summary information\
    \ printout\nIf( nElems  > 0 );\n    sElems  = NumberToString( nElems );\n    If ( pLogOutput <> 0\
    \ );\n        LogOutput( cMsgInfoLevel, Expand( 'Added [%sElems%] elements from hierarchy [%sHier%]\
    \ into [%cHierLeaves%] hierarchy of [%sDim%] dimension.' ) );\n    EndIf;\nEndIf;\nIf( nLeaves > 0\
    \ );\n    sLeaves = NumberToString( nLeaves );\n    If ( pLogOutput <> 0 );\n        LogOutput( cMsgInfoLevel,\
    \ Expand( 'Added [%sLeaves%] leaves into hierarchy [%sHier%] of [%sDim%] dimension.' ) );\n    EndIf;\n\
    EndIf;\nIf( sDim @<> sDimPrev & (nElems + nLeaves) > 0 );\n    nDimsChanged = nDimsChanged + 1;\n\
    EndIf;\nsDimPrev    = sDim;\n\n### END METADATA\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### If errors occurred terminate process with a major error status ###\n\
    If( nErrors <> 0 );\n    sMessage = 'the process incurred at least 1 major error and consequently\
    \ aborted. Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% aborted. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nEndIf;\n\n### Return Code\nIf ( nDims <> 0 );\n  sDims\
    \ = NumberToString( nDims );\n  sDimsChanged = NumberToString( nDimsChanged );\n  If ( nDimsChanged\
    \ > 0 );\n    sProcessAction = Expand( 'Modified [%sDimsChanged%] dimensions out of [%sDims%] matching\
    \ the filter.' );\n  Else;\n    sProcessAction = Expand( 'Scanned [%sDims%] dimensions, all are ok.'\
    \ );\n  EndIf;\nElse;\n  sProcessAction = 'No dimensions/hierarchies are matching supplied parameters.\
    \ Nothing modified.';\nEndIf;\nsProcessReturnCode  = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\nnProcessReturnCode  = 1;\nIf( pLogoutput <> 0 );\n    LogOutput( cMsgInfoLevel, Expand( sProcessAction\
    \ ) );   \nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der ein Teilmengen-Set von einer Hierarchie
    in einer Quell-Dimension zu einer Hierarchie in einer Ziel-Dimension kopiert. Beachte dabei, dass
    gültige Quell-Dimensionsnamen (pSrcDim), Quell- (pSrcSub) und Ziel-Teilmengen (pTgtSub) zwingend erforderlich
    sind, da der Prozess ansonsten abgebrochen wird. Achte darauf, dass die Ziel-Hierarchie nicht `Leaves`
    sein darf. Falls die Ziel-Dimensionen-Hierarchie bereits existiert, wird sie überschrieben.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will copy a subset from a Hierarchy in source Dimension\
    \ to a Hierarchy in target\n# Dimension.\n\n# Note:\n# Valid source dimension name (pSrcDim), source\
    \ (pSrcSub) and target subset (pTgtSub) are \n# mandatory otherwise the process will abort.\n\n# Caution:\n\
    # - Target hierarchy cannot be `Leaves`.\n# - If the target dimension Hierarchy exists then it will\
    \ be overwritten.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\\
    h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%,\
    \ pSrcHier:%pSrcHier%, pSrcSub:%pSrcSub%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pTgtSub:%pTgtSub%,\
    \ pTemp:%pTemp%, pAlias:%pAlias%.' ; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':',\
    \ pSrcDim ) > 0 & pSrcHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan(\
    \ ':', pSrcDim ) + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim\
    \ ) - 1 );\nEndIf;\n\n# Validate Source dimension\nIf( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n\
    \    sMessage = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension ' |\
    \ pSrcDim | ' does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate Source Hierarchy\nIf( Trim( pSrcHier ) @= '' );\n    pSrcHier = Trim( pSrcDim );\nEndIf;\n\
    \nIf( HierarchyExists( pSrcDim , pSrcHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'The Hierachy\
    \ ' | pSrcHier | ' does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate Source subset\nIf( Trim( pSrcsub ) @= '' );\n    nErrors = 1;\n    sMessage =\
    \ 'No source subset specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ HierarchySubsetExists( pSrcDim , pSrcHier, pSrcsub ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \ source subset : ' | pSrcDim |':'| pSrcHier |':'| pSrcSub;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim  \
    \      = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n# Validate target dimension\nIf(\
    \ Trim( pTgtDim ) @= '' );\n    pTgtDim = Trim( pSrcDim );\nElseIf( DimensionExists( pTgtDim ) = 0\
    \ );\n    nErrors = 1;\n    sMessage = 'Invalid target dimension: ' | pTgtDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n\n# Validate Target Hierarchy\nIf( Trim( pTgtHier ) @=\
    \ '' );\n    pTgtHier = pTgtDim;\nElseIf( HierarchyExists( pTgtDim, pTgtHier ) = 0 );\n    nErrors\
    \ = 1;\n    sMessage = 'The target Hierachy ' | pTgtHier | ' does not exist.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pTgtSub ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No target subset specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage\
    \ = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate Alias exists\nIf ( pAlias @<> '' & \n    DimIx ( Expand\
    \ ( '}ElementAttributes_%pTgtDim%' ), pAlias ) = 0\n);\n  nErrors = 1;\n  sMessage = 'Alias does not\
    \ exist in dimension %pTgtDim%.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\
    \  \n\n# Validate alias attribute name is actually an alias\nIf ( pAlias @<> '' & \n    Dtype ( Expand\
    \ ( '}ElementAttributes_%pTgtDim%' ), pAlias ) @<> 'AA'\n);\n  nErrors = 1;\n  sMessage = 'Attribute\
    \ %pAlias% is not an alias in dimension %pTgtDim%.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;  \n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create Target\
    \ Subset ###\nIf( HierarchySubsetExists( pTgtDim, pTgtHier, pTgtsub ) = 1 );\n    HierarchySubsetDeleteAllElements(\
    \ pTgtDim, pTgtHier, pTgtsub );\nElse;\n    HierarchySubsetCreate( pTgtDim, pTgtHier, pTgtsub, pTemp\
    \ );\nEndIf;\n\n### Set Alias ###\nIf ( pAlias @<> '' );\n    If ( pTgtDim @= pTgtHier );\n      \
    \  SubsetAliasSet( pTgtDim, pTgtsub, pAlias);\n    Else;\n        SubsetAliasSet( pTgtDim | ':' |\
    \ pTgtHier, pTgtsub, pAlias);\n    EndIf;\nEndIf;\n\n# HierarchySubsetMDXGet not returning anything.\
    \ Thought it might also return alias used in source subset\nsMDX = HierarchySubsetMDXGet(pSrcDim,\
    \ pSrcHier, pSrcSub);\n\nnElementPosition = 0;\n\n### Set data source for process ###\nDatasourceType\
    \              = 'SUBSET';\nDatasourceNameForServer     = pSrcDim | ':' | pSrcHier;\nDatasourceDimensionSubset\
    \   = pSrcsub;\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \nIF( pTgtDim @= pSrcDim & pTgtHier @= pSrcHier);\n    nElementPosition = nElementPosition + 1;\n\
    ElseIF( ElementIndex( pTgtDim, pTgtHier,vEle ) > 0 );\n    nElementPosition = nElementPosition + 1;\n\
    Else;\n    ItemReject( Expand( 'Cannot insert into subset. Element  %vEle% does not exist in target\
    \ dimension:Hierarchy %pTgtDim%:%pTgtHier%.' ) );\nEndIF;\n\nHierarchySubsetElementInsert( pTgtDim\
    \ , pTgtHier, pTgtSub , vEle , nElementPosition );\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned the\
    \ %pTgtDim%:%pTgtHier%:%pTgtSub% subset from %pSrcDim%:%pSrcHier%:%pSrcSub%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Develop an IBM Turbo Integrator process that copies a subset from a hierarchy in a source
    dimension to a hierarchy in a target dimension. Note that valid source dimension names (pSrcDim),
    source (pSrcSub), and target subsets (pTgtSub) are mandatory; otherwise, the process will abort. Make
    sure the target hierarchy cannot be `Leaves`. If the target dimension hierarchy exists, it will be
    overwritten.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will copy a subset from a Hierarchy in source Dimension\
    \ to a Hierarchy in target\n# Dimension.\n\n# Note:\n# Valid source dimension name (pSrcDim), source\
    \ (pSrcSub) and target subset (pTgtSub) are \n# mandatory otherwise the process will abort.\n\n# Caution:\n\
    # - Target hierarchy cannot be `Leaves`.\n# - If the target dimension Hierarchy exists then it will\
    \ be overwritten.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\\
    h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters pSrcDim:%pSrcDim%,\
    \ pSrcHier:%pSrcHier%, pSrcSub:%pSrcSub%, pTgtDim:%pTgtDim%, pTgtHier:%pTgtHier%, pTgtSub:%pTgtSub%,\
    \ pTemp:%pTemp%, pAlias:%pAlias%.' ; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':',\
    \ pSrcDim ) > 0 & pSrcHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input\
    \ error by splitting dim:hier into dimension & hierarchy\n    pSrcHier       = SubSt( pSrcDim, Scan(\
    \ ':', pSrcDim ) + 1, Long( pSrcDim ) );\n    pSrcDim        = SubSt( pSrcDim, 1, Scan( ':', pSrcDim\
    \ ) - 1 );\nEndIf;\n\n# Validate Source dimension\nIf( Trim( pSrcDim ) @= '' );\n    nErrors = 1;\n\
    \    sMessage = 'No source dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIf( DimensionExists( pSrcDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Dimension ' |\
    \ pSrcDim | ' does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# Validate Source Hierarchy\nIf( Trim( pSrcHier ) @= '' );\n    pSrcHier = Trim( pSrcDim );\nEndIf;\n\
    \nIf( HierarchyExists( pSrcDim , pSrcHier ) = 0 );\n    nErrors = 1;\n    sMessage = 'The Hierachy\
    \ ' | pSrcHier | ' does not exist.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate Source subset\nIf( Trim( pSrcsub ) @= '' );\n    nErrors = 1;\n    sMessage =\
    \ 'No source subset specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf(\
    \ HierarchySubsetExists( pSrcDim , pSrcHier, pSrcsub ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid\
    \ source subset : ' | pSrcDim |':'| pSrcHier |':'| pSrcSub;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\nIf( Scan( ':', pTgtDim ) > 0 & pTgtHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pTgtHier       = SubSt( pTgtDim, Scan( ':', pTgtDim ) + 1, Long( pTgtDim ) );\n    pTgtDim  \
    \      = SubSt( pTgtDim, 1, Scan( ':', pTgtDim ) - 1 );\nEndIf;\n\n# Validate target dimension\nIf(\
    \ Trim( pTgtDim ) @= '' );\n    pTgtDim = Trim( pSrcDim );\nElseIf( DimensionExists( pTgtDim ) = 0\
    \ );\n    nErrors = 1;\n    sMessage = 'Invalid target dimension: ' | pTgtDim;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n\n# Validate Target Hierarchy\nIf( Trim( pTgtHier ) @=\
    \ '' );\n    pTgtHier = pTgtDim;\nElseIf( HierarchyExists( pTgtDim, pTgtHier ) = 0 );\n    nErrors\
    \ = 1;\n    sMessage = 'The target Hierachy ' | pTgtHier | ' does not exist.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pTgtSub ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No target subset specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage\
    \ = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n# Validate Alias exists\nIf ( pAlias @<> '' & \n    DimIx ( Expand\
    \ ( '}ElementAttributes_%pTgtDim%' ), pAlias ) = 0\n);\n  nErrors = 1;\n  sMessage = 'Alias does not\
    \ exist in dimension %pTgtDim%.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\
    \  \n\n# Validate alias attribute name is actually an alias\nIf ( pAlias @<> '' & \n    Dtype ( Expand\
    \ ( '}ElementAttributes_%pTgtDim%' ), pAlias ) @<> 'AA'\n);\n  nErrors = 1;\n  sMessage = 'Attribute\
    \ %pAlias% is not an alias in dimension %pTgtDim%.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;  \n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Create Target\
    \ Subset ###\nIf( HierarchySubsetExists( pTgtDim, pTgtHier, pTgtsub ) = 1 );\n    HierarchySubsetDeleteAllElements(\
    \ pTgtDim, pTgtHier, pTgtsub );\nElse;\n    HierarchySubsetCreate( pTgtDim, pTgtHier, pTgtsub, pTemp\
    \ );\nEndIf;\n\n### Set Alias ###\nIf ( pAlias @<> '' );\n    If ( pTgtDim @= pTgtHier );\n      \
    \  SubsetAliasSet( pTgtDim, pTgtsub, pAlias);\n    Else;\n        SubsetAliasSet( pTgtDim | ':' |\
    \ pTgtHier, pTgtsub, pAlias);\n    EndIf;\nEndIf;\n\n# HierarchySubsetMDXGet not returning anything.\
    \ Thought it might also return alias used in source subset\nsMDX = HierarchySubsetMDXGet(pSrcDim,\
    \ pSrcHier, pSrcSub);\n\nnElementPosition = 0;\n\n### Set data source for process ###\nDatasourceType\
    \              = 'SUBSET';\nDatasourceNameForServer     = pSrcDim | ':' | pSrcHier;\nDatasourceDimensionSubset\
    \   = pSrcsub;\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \nIF( pTgtDim @= pSrcDim & pTgtHier @= pSrcHier);\n    nElementPosition = nElementPosition + 1;\n\
    ElseIF( ElementIndex( pTgtDim, pTgtHier,vEle ) > 0 );\n    nElementPosition = nElementPosition + 1;\n\
    Else;\n    ItemReject( Expand( 'Cannot insert into subset. Element  %vEle% does not exist in target\
    \ dimension:Hierarchy %pTgtDim%:%pTgtHier%.' ) );\nEndIF;\n\nHierarchySubsetElementInsert( pTgtDim\
    \ , pTgtHier, pTgtSub , vEle , nElementPosition );\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned the\
    \ %pTgtDim%:%pTgtHier%:%pTgtSub% subset from %pSrcDim%:%pSrcHier%:%pSrcSub%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der einen statischen Teilmenge in einer Hierarchie
    einer Ziel-Dimension erstellt. Der Prozess sollte mehrere Parameter verwenden, um festzulegen, welche
    Elemente in die Teilmenge aufgenommen werden: - pConsol: Wenn angegeben, werden nur Elemente, die
    Nachkommen des Consol sind, in die Teilmenge aufgenommen. Wenn nicht, wird dieser Filter ignoriert.
    - pAttr: Wenn angegeben, werden nur Elemente mit einem Wert, der pAttrValue entspricht, in die Teilmenge
    aufgenommen. Wenn nicht, wird dieser Filter ignoriert. - pLevelFrom: Nur Elemente mit einem Level
    größer oder gleich pLevelFrom werden in die Teilmenge aufgenommen. - pLevelTo: Nur Elemente mit einem
    Level kleiner oder gleich pLevelTo werden in die Teilmenge aufgenommen. - pExclusions: Wenn pExclusions
    angegeben ist, werden die Elemente (getrennt durch einen Trennzeichensatz) von der Teilmenge ausgeschlossen.
    Wildcard-Zeichen ''*'' und ''?'' werden akzeptiert. - pAddToSubset: Wenn die angegebene Teilmenge
    bereits existiert, wird dieser Parameter steuern, ob Elemente der bestehenden Teilmenge hinzugefügt
    werden (Wert 1) oder eine neue Teilmenge erstellt wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Start Prolog ###\n\n#Region @DOC\n# Description:\n# This process will create a static subset\
    \ in a Hierarchy of target Dimension.\n\n# Note:\n# This process uses a number of parameters to determine\
    \ what to include in the subset:\n# - pConsol: If specified, only elements that are descendants of\
    \ the consol will be included in\n#   the subset. If blank, then this filter will be ignored.\n# -\
    \ pAttr: If specified, only elements that have a value equivalent to pAttrValue will be included\n\
    #   in the subset. If blank, this filter will be ignored.\n# - pLevelFrom: Only elements with a level\
    \ greater than or equal to pLevelFrom will be included in\n#   the subset.\n# - pLevelTo: Only elements\
    \ with a level less than or equal to pLevelFrom will be included in the\n#   subset.\n# - pExclusions:\
    \ If pExclusions is specified then the elements (separated by a delimiter) will be\n#   excluded from\
    \ the subset. Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset : If the specified\
    \ subset already exists then this parameter will control whether\n#   elements will be added to the\
    \ existing subset (value 1) or a new subset will be created\n#   (value 0).\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pConsol:%pConsol%, pAttr:%pAttr%, pAttrValue:%pAttrValue%, pLevelFrom:%pLevelFrom%,\
    \ pLevelTo:%pLevelTo%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%, pAlias:%pAlias%,\
    \ pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier\
    \       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan(\
    \ ':', pDim ) - 1 );\nEndIf;\n\n## Validate dimension\nIF( Trim( pDim ) @= '' );\n    nErrors = 1;\n\
    \    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIF( DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension:\
    \ ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\n\
    If( Trim( pHier ) @= '' );\n    sHier = pDim;\nElse;\n    sHier = pHier;\nEndIf;\nIF( sHier @= 'Leaves'\
    \ );\n    nErrors = 1;\n    sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIF(HierarchyExists(pDim, sHier ) = 0 );\n    nErrors = 1;\n \
    \   sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate subset\nIF(Trim( pSub ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No subset specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate consolidation\npConsol = Trim( pConsol );\nIf( pConsol @<> '' & pConsol\
    \ @<> '*' );\n    If( ElementIndex ( pDim, sHier, pConsol ) = 0 );\n        nErrors = 1;\n       \
    \ sMessage = 'The ' | pConsol | ' consolidation does not exist in the '| pDim |' dimension:Hierarchy\
    \ ' | pDim |':'| sHier;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\n\
    EndIf;\n\n## Validate attribute\npAttr = Trim( pAttr );\nIF(pAttr @<> '' );\n\n    If( DimensionExists(\
    \ cAttributeDim ) = 0 );\n        nErrors = 1;\n        sMessage = 'Dimension: ' | pDim | ' does not\
    \ have any attributes.';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\n\
    \    \n    IF(DIMIX( cAttributeDim, pAttr ) = 0 );\n        nErrors = 1;\n        sMessage = 'The\
    \ ' | pAttr |' attribute does not exist in the ' | pDim | ' dimension.';\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    EndIf;\n    \n    sAttributeType = DType( cAttributeDim, pAttr\
    \ );\n    If(sAttributeType @= 'AN' % sAttributeType @= 'N' );\n        If(pAttrValue @= '' );\n \
    \           nAttributeValue = 0;\n        Else;\n            nAttributeValue = StringToNumber( pAttrValue\
    \ );\n        EndIf;\n    EndIf;\n    \nEndIf;\n\n## Validate element level parameters\nIf(pLevelFrom\
    \ < 0 % pLevelTo < 0 % pLevelTo < pLevelFrom );\n    nErrors = 1;\n    sMessage = 'Element levels\
    \ must be greater than or equal to zero and level to must be greater than or equal to level from';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate delimiter\nIF(\
    \ pExclusions @<> '' & pDelim @= '' );\n    ## Set to default parameter.\n    pDelimiter = '&';\n\
    EndIf;\n\n## Validate add to subset\nIF( pAddToSubset <> 0 & pAddToSubset <> 1 );\n    nErrors = 1;\n\
    \    sMessage = 'Invalid value for pAddToSubset: ' | NumberToString( pAddToSubset ) | '. Valid values\
    \ are 0 and 1';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate\
    \ Alias\nsDimAttr = '}ElementAttributes_' | pDim;\nIF( pAlias @<> '' );\n    \n    IF(DimensionExists(\
    \ sDimAttr ) = 0 );\n        sMessage = 'No attributes exist for the dimension: ' | pDim;\n      \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        pAlias = '';\n    ElseIf(DIMIX(\
    \ sDimAttr, pAlias ) = 0 );\n        sMessage = 'The alias: ' | pAlias | ' does not exist as an attribute\
    \ in the dimension: ' | pDim;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \        pAlias = '';\n    ElseIf(DTYPE( sDimAttr, pAlias ) @<> 'AA' );\n        sMessage = 'The alias:\
    \ ' | pAlias | ' is not an Alias type of attribute in the dimension: ' | sDimAttr;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        pAlias = '';\n    EndIf;\n\nENDIF;\n\n##\
    \ Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter\
    \ pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndIf;\n\n### Check for errors before preparing subset\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Prepare subset\
    \ ###\nIF( HierarchySubsetExists( pDim,sHier, pSub ) = 1 );\n    If( pAddtoSubset <> 1 );\n      \
    \  HierarchySubsetDeleteAllElements( pDim, sHier, pSub );\n        nSubsetSize = 0;\n    Else;\n \
    \       nSubsetSize = HierarchySubsetGetSize(pDim, sHier, pSub );\n    EndIf;\nElse;\n    HierarchySubsetCreate(\
    \ pDim, sHier, pSub, pTemp );\n    nSubsetSize = 0;\nEndIf;\n\n### Set Alias ###\nIF(pAlias @<> ''\
    \ );\n      HierarchySubsetAliasSet( pDim, pHier, pSub, pAlias);\nENDIF;\n\n### Assign Datasource\
    \ ###\n\nDatasourceNameForServer     = pDim|':'|sHier;\nDataSourceDimensionSubset   = 'All';\n\n\n\
    ### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Check for errors in prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n\n### Add elements\
    \ to subset ###\n\n## Check that element is a descendant of specified consolidation\nIf( pConsol @<>\
    \ '' & pConsol @<> '*' );\n  If(ElementIsAncestor(pDim, pHier, pConsol, vEle) = 0 & vEle @<> pConsol\
    \ );\n    ItemSkip;\n  EndIf;\nEndIf;\n\n## Check that element has a matching attribute value\nIf(\
    \ pAttr @<> ''  );\n  If( sAttributeType @= 'AN' % sAttributeType @= 'N' );\n    If( ElementAttrN(\
    \ pDim, pHier, vEle, pAttr ) <> nAttributeValue );\n      ItemSkip;\n    EndIf;\n  Else;\n    If(\
    \ ElementAttrS( pDim, pHier, vEle, pAttr ) @<> pAttrValue );\n      ItemSkip;\n    EndIf;\n  EndIf;\n\
    EndIf;\n\n## Check that element has an appropriate element level\nnElementLevel = ElementLevel( pDim,\
    \ pHier, vEle );\nIf( nElementLevel < pLevelFrom % nElementLevel > pLevelTo );\n  ItemSkip;\nEndIf;\n\
    \n## Add element to subset\nnSubsetSize = nSubsetSize + 1;\n\nHierarchySubsetElementInsert( pDim,\
    \ pHier, pSub, vEle, nSubsetSize );\n\n### End Metadata ###\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n\n    ### Process Exclusions ###\n    IF( nErrors = 0 & Trim( pExclusions )\
    \ @<> '' );\n        ExecuteProcess( '}bedrock.hier.sub.exclude',\n            'pLogOutput', pLogOutput,\n\
    \            'pStrictErrorHandling', pStrictErrorHandling,\n            'pDim', pDim,\n          \
    \  'pHier', pHier,\n            'pSub', pSub,\n            'pExclusions', pExclusions,\n         \
    \   'pDelim', pDelim\n            );\n    EndIf;\n    \n    ### Get subset size ###\n    nSubSiz =\
    \ SubsetGetSize( pDim|':'|sHier, pSub );\n    sSubSiz = NumberToString( nSubSiz );\n    If( nSubSiz\
    \ = 0 );\n        nErrors = 1;\n        sMessage= 'Subset contains no elements.';\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n    \n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ created subset %pDim%:%pHier%:%pSub% with %sSubSiz% elements. ' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in a hierarchy of a
    target dimension. The process should use several parameters to determine what elements to include
    in the subset: - pConsol: If specified, only elements that are descendants of the consol will be included
    in the subset. If blank, this filter will be ignored. - pAttr: If specified, only elements that have
    a value equivalent to pAttrValue will be included in the subset. If blank, this filter will be ignored.
    - pLevelFrom: Only elements with a level greater than or equal to pLevelFrom will be included in the
    subset. - pLevelTo: Only elements with a level less than or equal to pLevelTo will be included in
    the subset. - pExclusions: If pExclusions is specified, the elements (separated by a delimiter) will
    be excluded from the subset. Wildcards characters ''*'' and ''?'' are accepted. - pAddToSubset: If
    the specified subset already exists, this parameter will control whether elements are added to the
    existing subset (value 1) or a new subset is created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Start Prolog ###\n\n#Region @DOC\n# Description:\n# This process will create a static subset\
    \ in a Hierarchy of target Dimension.\n\n# Note:\n# This process uses a number of parameters to determine\
    \ what to include in the subset:\n# - pConsol: If specified, only elements that are descendants of\
    \ the consol will be included in\n#   the subset. If blank, then this filter will be ignored.\n# -\
    \ pAttr: If specified, only elements that have a value equivalent to pAttrValue will be included\n\
    #   in the subset. If blank, this filter will be ignored.\n# - pLevelFrom: Only elements with a level\
    \ greater than or equal to pLevelFrom will be included in\n#   the subset.\n# - pLevelTo: Only elements\
    \ with a level less than or equal to pLevelFrom will be included in the\n#   subset.\n# - pExclusions:\
    \ If pExclusions is specified then the elements (separated by a delimiter) will be\n#   excluded from\
    \ the subset. Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset : If the specified\
    \ subset already exists then this parameter will control whether\n#   elements will be added to the\
    \ existing subset (value 1) or a new subset will be created\n#   (value 0).\n#EndRegion @DOC\n\n###\
    \ Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pConsol:%pConsol%, pAttr:%pAttr%, pAttrValue:%pAttrValue%, pLevelFrom:%pLevelFrom%,\
    \ pLevelTo:%pLevelTo%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%, pAlias:%pAlias%,\
    \ pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier\
    \       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan(\
    \ ':', pDim ) - 1 );\nEndIf;\n\n## Validate dimension\nIF( Trim( pDim ) @= '' );\n    nErrors = 1;\n\
    \    sMessage = 'No dimension specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nElseIF( DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension:\
    \ ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\n\
    If( Trim( pHier ) @= '' );\n    sHier = pDim;\nElse;\n    sHier = pHier;\nEndIf;\nIF( sHier @= 'Leaves'\
    \ );\n    nErrors = 1;\n    sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIF(HierarchyExists(pDim, sHier ) = 0 );\n    nErrors = 1;\n \
    \   sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate subset\nIF(Trim( pSub ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No subset specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate consolidation\npConsol = Trim( pConsol );\nIf( pConsol @<> '' & pConsol\
    \ @<> '*' );\n    If( ElementIndex ( pDim, sHier, pConsol ) = 0 );\n        nErrors = 1;\n       \
    \ sMessage = 'The ' | pConsol | ' consolidation does not exist in the '| pDim |' dimension:Hierarchy\
    \ ' | pDim |':'| sHier;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\n\
    EndIf;\n\n## Validate attribute\npAttr = Trim( pAttr );\nIF(pAttr @<> '' );\n\n    If( DimensionExists(\
    \ cAttributeDim ) = 0 );\n        nErrors = 1;\n        sMessage = 'Dimension: ' | pDim | ' does not\
    \ have any attributes.';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\n\
    \    \n    IF(DIMIX( cAttributeDim, pAttr ) = 0 );\n        nErrors = 1;\n        sMessage = 'The\
    \ ' | pAttr |' attribute does not exist in the ' | pDim | ' dimension.';\n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    EndIf;\n    \n    sAttributeType = DType( cAttributeDim, pAttr\
    \ );\n    If(sAttributeType @= 'AN' % sAttributeType @= 'N' );\n        If(pAttrValue @= '' );\n \
    \           nAttributeValue = 0;\n        Else;\n            nAttributeValue = StringToNumber( pAttrValue\
    \ );\n        EndIf;\n    EndIf;\n    \nEndIf;\n\n## Validate element level parameters\nIf(pLevelFrom\
    \ < 0 % pLevelTo < 0 % pLevelTo < pLevelFrom );\n    nErrors = 1;\n    sMessage = 'Element levels\
    \ must be greater than or equal to zero and level to must be greater than or equal to level from';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate delimiter\nIF(\
    \ pExclusions @<> '' & pDelim @= '' );\n    ## Set to default parameter.\n    pDelimiter = '&';\n\
    EndIf;\n\n## Validate add to subset\nIF( pAddToSubset <> 0 & pAddToSubset <> 1 );\n    nErrors = 1;\n\
    \    sMessage = 'Invalid value for pAddToSubset: ' | NumberToString( pAddToSubset ) | '. Valid values\
    \ are 0 and 1';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate\
    \ Alias\nsDimAttr = '}ElementAttributes_' | pDim;\nIF( pAlias @<> '' );\n    \n    IF(DimensionExists(\
    \ sDimAttr ) = 0 );\n        sMessage = 'No attributes exist for the dimension: ' | pDim;\n      \
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        pAlias = '';\n    ElseIf(DIMIX(\
    \ sDimAttr, pAlias ) = 0 );\n        sMessage = 'The alias: ' | pAlias | ' does not exist as an attribute\
    \ in the dimension: ' | pDim;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    \        pAlias = '';\n    ElseIf(DTYPE( sDimAttr, pAlias ) @<> 'AA' );\n        sMessage = 'The alias:\
    \ ' | pAlias | ' is not an Alias type of attribute in the dimension: ' | sDimAttr;\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        pAlias = '';\n    EndIf;\n\nENDIF;\n\n##\
    \ Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter\
    \ pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndIf;\n\n### Check for errors before preparing subset\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Prepare subset\
    \ ###\nIF( HierarchySubsetExists( pDim,sHier, pSub ) = 1 );\n    If( pAddtoSubset <> 1 );\n      \
    \  HierarchySubsetDeleteAllElements( pDim, sHier, pSub );\n        nSubsetSize = 0;\n    Else;\n \
    \       nSubsetSize = HierarchySubsetGetSize(pDim, sHier, pSub );\n    EndIf;\nElse;\n    HierarchySubsetCreate(\
    \ pDim, sHier, pSub, pTemp );\n    nSubsetSize = 0;\nEndIf;\n\n### Set Alias ###\nIF(pAlias @<> ''\
    \ );\n      HierarchySubsetAliasSet( pDim, pHier, pSub, pAlias);\nENDIF;\n\n### Assign Datasource\
    \ ###\n\nDatasourceNameForServer     = pDim|':'|sHier;\nDataSourceDimensionSubset   = 'All';\n\n\n\
    ### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Check for errors in prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n\n### Add elements\
    \ to subset ###\n\n## Check that element is a descendant of specified consolidation\nIf( pConsol @<>\
    \ '' & pConsol @<> '*' );\n  If(ElementIsAncestor(pDim, pHier, pConsol, vEle) = 0 & vEle @<> pConsol\
    \ );\n    ItemSkip;\n  EndIf;\nEndIf;\n\n## Check that element has a matching attribute value\nIf(\
    \ pAttr @<> ''  );\n  If( sAttributeType @= 'AN' % sAttributeType @= 'N' );\n    If( ElementAttrN(\
    \ pDim, pHier, vEle, pAttr ) <> nAttributeValue );\n      ItemSkip;\n    EndIf;\n  Else;\n    If(\
    \ ElementAttrS( pDim, pHier, vEle, pAttr ) @<> pAttrValue );\n      ItemSkip;\n    EndIf;\n  EndIf;\n\
    EndIf;\n\n## Check that element has an appropriate element level\nnElementLevel = ElementLevel( pDim,\
    \ pHier, vEle );\nIf( nElementLevel < pLevelFrom % nElementLevel > pLevelTo );\n  ItemSkip;\nEndIf;\n\
    \n## Add element to subset\nnSubsetSize = nSubsetSize + 1;\n\nHierarchySubsetElementInsert( pDim,\
    \ pHier, pSub, vEle, nSubsetSize );\n\n### End Metadata ###\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n\n    ### Process Exclusions ###\n    IF( nErrors = 0 & Trim( pExclusions )\
    \ @<> '' );\n        ExecuteProcess( '}bedrock.hier.sub.exclude',\n            'pLogOutput', pLogOutput,\n\
    \            'pStrictErrorHandling', pStrictErrorHandling,\n            'pDim', pDim,\n          \
    \  'pHier', pHier,\n            'pSub', pSub,\n            'pExclusions', pExclusions,\n         \
    \   'pDelim', pDelim\n            );\n    EndIf;\n    \n    ### Get subset size ###\n    nSubSiz =\
    \ SubsetGetSize( pDim|':'|sHier, pSub );\n    sSubSiz = NumberToString( nSubSiz );\n    If( nSubSiz\
    \ = 0 );\n        nErrors = 1;\n        sMessage= 'Subset contains no elements.';\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    EndIf;\nEndIf;\n    \n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ created subset %pDim%:%pHier%:%pSub% with %sSubSiz% elements. ' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, um eine statische Untergruppe in der Hierarchie
    einer Dimension zu erstellen, die aus allen Elementen besteht. Verwenden Sie die folgenden Änderungsparameter,
    um zu bestimmen, was in die Untergruppe aufgenommen werden soll: - pExclusions: Wenn pExclusions angegeben
    ist, werden die Elemente (durch ein Trennzeichen getrennt) aus der Untergruppe ausgeschlossen. Die
    Platzhalterzeichen ''*'' und ''?'' sind zulässig. - pAddToSubset: Wenn die angegebene Untergruppe
    bereits existiert, steuert dieser Parameter, ob Elemente zur vorhandenen Untergruppe hinzugefügt werden
    (Wert 1) oder eine neue Untergruppe erstellt wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy of a Dimension\
    \ that consists of all elements.\n\n# Note:\n# This process uses modification parameters to determine\
    \ what to include in the subset:\n# - pExclusions: If pExclusions is specified then the elements (separated\
    \ by a delimiter) will be\n#                excluded from the subset. Wildcards characters `*` and\
    \ `?` are accepted.\n# - pAddToSubset: If the specified subset already exists then this parameter\
    \ will control whether elements will\n#                 be added to the existing subset (value 1)\
    \ or a new subset will be created (value 0).\n#EndRegion @DOC\n\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub    \
    \        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pAddToSubset:%pAddToSubset%, pExclusions:%pExclusions%,\
    \ pDelim:%pDelim%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_'\
    \ | pDim;\nnErrors = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors\
    \ = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n   \
    \                           'pStrictErrorHandling', pStrictErrorHandling,\n                      \
    \        'pDim', pDim,\n                              'pHier',pHier,\n                           \
    \   'pSub', pSub,\n                              'pExclusions', pExclusions,\n                   \
    \           'pDelim', pDelim,\n                              'pAddToSubset', pAddToSubset,\n     \
    \                         'pAlias', pAlias,\n                              'pTemp', pTemp\n      \
    \                      );\n\nIf(nRet <> 0);\n nErrors = 1;\n sMessage = 'Subset create process has\
    \ errors';\n LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n \n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### If errors\
    \ occurred terminate process with a major error status ###\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see\
    \ above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Develop an IBM Turbo Integrator process to create a static subset in the hierarchy of a dimension
    that consists of all elements. Use the following modification parameters to determine what to include
    in the subset: - pExclusions: If pExclusions is specified, the elements (separated by a delimiter)
    will be excluded from the subset. Wildcard characters ''*'' and ''?'' are accepted. - pAddToSubset:
    If the specified subset already exists, this parameter will control whether elements will be added
    to the existing subset (value 1) or a new subset will be created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy of a Dimension\
    \ that consists of all elements.\n\n# Note:\n# This process uses modification parameters to determine\
    \ what to include in the subset:\n# - pExclusions: If pExclusions is specified then the elements (separated\
    \ by a delimiter) will be\n#                excluded from the subset. Wildcards characters `*` and\
    \ `?` are accepted.\n# - pAddToSubset: If the specified subset already exists then this parameter\
    \ will control whether elements will\n#                 be added to the existing subset (value 1)\
    \ or a new subset will be created (value 0).\n#EndRegion @DOC\n\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub    \
    \        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pAddToSubset:%pAddToSubset%, pExclusions:%pExclusions%,\
    \ pDelim:%pDelim%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_'\
    \ | pDim;\nnErrors = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors\
    \ = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n   \
    \                           'pStrictErrorHandling', pStrictErrorHandling,\n                      \
    \        'pDim', pDim,\n                              'pHier',pHier,\n                           \
    \   'pSub', pSub,\n                              'pExclusions', pExclusions,\n                   \
    \           'pDelim', pDelim,\n                              'pAddToSubset', pAddToSubset,\n     \
    \                         'pAlias', pAlias,\n                              'pTemp', pTemp\n      \
    \                      );\n\nIf(nRet <> 0);\n nErrors = 1;\n sMessage = 'Subset create process has\
    \ errors';\n LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n \n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### If errors\
    \ occurred terminate process with a major error status ###\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see\
    \ above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der eine statische Teilmenge in der Hierarchie
    einer Dimension erstellt, die aus allen Elementen mit einem pAttr Attributwert besteht, der dem pAttrValue
    entspricht. Beachte, dass dieser Prozess folgende Anpassungsparameter verwendet, um zu bestimmen,
    was in die Teilmenge aufgenommen wird: pAttr: Wenn angegeben, werden nur Elemente mit einem Wert,
    der pAttrValue entspricht, in die Teilmenge aufgenommen. Wenn leer, wird dieser Filter ignoriert.
    pExclusions: Wenn pExclusions angegeben ist, werden die Elemente (durch ein Trennzeichen getrennt)
    von der Teilmenge ausgeschlossen. Platzhalterzeichen `*` und `?` werden akzeptiert. pAddToSubset:
    Wenn die angegebene Teilmenge bereits existiert, bestimmt dieser Parameter, ob Elemente zur bestehenden
    Teilmenge hinzugefügt (Wert 1) oder eine neue Teilmenge erstellt wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy of a Dimension\
    \ that consists of all\n# elements with pAttr attribute value equivalent to pAttrValue.\n\n# Note:\n\
    # This process uses a modification parameters to determine what to include in the subset:\n# - pAttr:\
    \ If specified, only elements that have a value equivalent to pAttrValue will be included\n#     \
    \     in the subset. If blank, this filter will be ignored.\n# - pExclusions: If pExclusions is specified\
    \ then the elements (separated by a delimiter) will be\n#                excluded from the subset.\
    \ Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset: If the specified subset already\
    \ exists then this parameter will control whether elements will\n#                 be added to the\
    \ existing subset (value 1) or a new subset will be created (value 0).\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pAttr:%pAttr%, pAttrValue:%pAttrValue%, pExclusions:%pExclusions%, pDelim:%pDelim%,\
    \ pAddToSubset:%pAddToSubset%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_'\
    \ | pDim;\nnErrors = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors\
    \ = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n   \
    \                         'pStrictErrorHandling', pStrictErrorHandling,\n                        \
    \    'pDim', pDim,\n                            'pHier', pHier,\n                            'pSub',\
    \ pSub,\n                            'pAttr', pAttr,\n                            'pAttrValue', pAttrValue,\n\
    \                            'pExclusions', pExclusions,\n                            'pDelim', pDelim,\n\
    \                            'pAddToSubset', pAddToSubset,\n                            'pAlias',\
    \ pAlias,\n                            'pTemp', pTemp\n                            );\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in the hierarchy of
    a dimension composed of all elements with a pAttr attribute value equivalent to pAttrValue. Note that
    this process uses the following modification parameters to determine what to include in the subset:
    pAttr: If specified, only elements that have a value equivalent to pAttrValue will be included in
    the subset. If blank, this filter will be ignored. pExclusions: If pExclusions is specified, the elements
    (separated by a delimiter) will be excluded from the subset. Wildcard characters `*` and `?` are accepted.
    pAddToSubset: If the specified subset already exists, this parameter will control whether elements
    will be added to the existing subset (value 1) or a new subset will be created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy of a Dimension\
    \ that consists of all\n# elements with pAttr attribute value equivalent to pAttrValue.\n\n# Note:\n\
    # This process uses a modification parameters to determine what to include in the subset:\n# - pAttr:\
    \ If specified, only elements that have a value equivalent to pAttrValue will be included\n#     \
    \     in the subset. If blank, this filter will be ignored.\n# - pExclusions: If pExclusions is specified\
    \ then the elements (separated by a delimiter) will be\n#                excluded from the subset.\
    \ Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset: If the specified subset already\
    \ exists then this parameter will control whether elements will\n#                 be added to the\
    \ existing subset (value 1) or a new subset will be created (value 0).\n#EndRegion @DOC\n\n### Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pAttr:%pAttr%, pAttrValue:%pAttrValue%, pExclusions:%pExclusions%, pDelim:%pDelim%,\
    \ pAddToSubset:%pAddToSubset%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_'\
    \ | pDim;\nnErrors = 0;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors\
    \ = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n   \
    \                         'pStrictErrorHandling', pStrictErrorHandling,\n                        \
    \    'pDim', pDim,\n                            'pHier', pHier,\n                            'pSub',\
    \ pSub,\n                            'pAttr', pAttr,\n                            'pAttrValue', pAttrValue,\n\
    \                            'pExclusions', pExclusions,\n                            'pDelim', pDelim,\n\
    \                            'pAddToSubset', pAddToSubset,\n                            'pAlias',\
    \ pAlias,\n                            'pTemp', pTemp\n                            );\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der einen statischen Teilbaum in der Hierarchie
    einer Dimension erstellt, der aus allen Blattelementen besteht, die den Attributwert von pAttr haben,
    der mit dem Wert pAttrValue übereinstimmt. Beachte, dass dieser Prozess Modifikationsparameter verwendet,
    um zu bestimmen, welche Elemente in den Teilbaum aufgenommen werden. Diese Parameter sind: pAttr,
    der lediglich Elemente einbezieht, deren Attributwert mit pAttrValue übereinstimmt, es sei denn, pAttr
    ist leer. pExclusions, das spezifizierte Elemente (durch ein Trennzeichen getrennt) aus dem Teilbaum
    ausschließt, wobei auch Platzhalter wie ''*'' und ''?'' genutzt werden können. pAddToSubset, das steuert,
    ob Elemente zu einem bestehenden Teilbaum hinzugefügt werden, falls dieser bereits existiert (Wert
    1) oder ob ein neuer Teilbaum erstellt wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy of a Dimension\
    \ that consists of all\n# leaf elements with pAttr attribute value equivalent to pAttrValue.\n\n#\
    \ Note:\n# This process uses a modification parameters to determine what to include in the subset:\n\
    # - pAttr: If specified, only elements that have a value equivalent to pAttrValue will be included\n\
    #          in the subset. If blank, this filter will be ignored.\n# - pExclusions: If pExclusions\
    \ is specified then the elements (separated by a delimiter) will be\n#                excluded from\
    \ the subset. Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset: If the specified subset\
    \ already exists then this parameter will control whether elements will\n#                 be added\
    \ to the existing subset (value 1) or a new subset will be created (value 0).\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\nnErrors = 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\n\
    cUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pAttr:%pAttr%, pAttrValue:%pAttrValue%, pExclusions:%pExclusions%, pDelim:%pDelim%,\
    \ pAddToSubset:%pAddToSubset%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_'\
    \ | pDim;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n                         \
    \     'pStrictErrorHandling', pStrictErrorHandling,\n                              'pDim', pDim,\n\
    \                              'pHier', pHier,\n                              'pSub', pSub,\n    \
    \                          'pAttr', pAttr,\n                              'pAttrValue', pAttrValue,\n\
    \                              'pLevelFrom', 0,\n                              'pLevelTo', 0,\n  \
    \                            'pExclusions', pExclusions,\n                              'pDelim',\
    \ pDelim,\n                              'pAddToSubset', pAddToSubset,\n                         \
    \     'pAlias', pAlias,\n                              'pTemp', pTemp\n                          \
    \  );\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in the hierarchy of
    a dimension consisting of all leaf elements with an attribute value of pAttr that matches pAttrValue.
    Note that this process uses modification parameters to determine which elements to include in the
    subset. These parameters are: pAttr, which only includes elements with an attribute value equivalent
    to pAttrValue, unless pAttr is blank. pExclusions, which excludes specified elements (separated by
    a delimiter) from the subset, also accepting wildcard characters ''*'' and ''?''. pAddToSubset, which
    controls whether elements are added to an existing subset if it already exists (value 1) or if a new
    subset is created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy of a Dimension\
    \ that consists of all\n# leaf elements with pAttr attribute value equivalent to pAttrValue.\n\n#\
    \ Note:\n# This process uses a modification parameters to determine what to include in the subset:\n\
    # - pAttr: If specified, only elements that have a value equivalent to pAttrValue will be included\n\
    #          in the subset. If blank, this filter will be ignored.\n# - pExclusions: If pExclusions\
    \ is specified then the elements (separated by a delimiter) will be\n#                excluded from\
    \ the subset. Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset: If the specified subset\
    \ already exists then this parameter will control whether elements will\n#                 be added\
    \ to the existing subset (value 1) or a new subset will be created (value 0).\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\nnErrors = 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\n\
    cUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pAttr:%pAttr%, pAttrValue:%pAttrValue%, pExclusions:%pExclusions%, pDelim:%pDelim%,\
    \ pAddToSubset:%pAddToSubset%, pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_'\
    \ | pDim;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\nnRet = ExecuteProcess('}bedrock.hier.sub.create',\n                         \
    \     'pStrictErrorHandling', pStrictErrorHandling,\n                              'pDim', pDim,\n\
    \                              'pHier', pHier,\n                              'pSub', pSub,\n    \
    \                          'pAttr', pAttr,\n                              'pAttrValue', pAttrValue,\n\
    \                              'pLevelFrom', 0,\n                              'pLevelTo', 0,\n  \
    \                            'pExclusions', pExclusions,\n                              'pDelim',\
    \ pDelim,\n                              'pAddToSubset', pAddToSubset,\n                         \
    \     'pAlias', pAlias,\n                              'pTemp', pTemp\n                          \
    \  );\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der ein statisches Teilset in einer Hierarchie
    der Zieldimension basierend auf einer Liste bereitgestellter Elemente erstellt. Beachte dabei: - pAddToSubset:
    Wenn das angegebene Teilset bereits existiert, steuert dieser Parameter, ob Elemente dem bestehenden
    Teilset hinzugefügt werden (Wert 1) oder ob ein neues Teilset erstellt wird (Wert 0). - pExpandConsol:
    Wenn die angegebene Liste von Elementen konsolidierte Elemente enthält, werden sie durch ihre Nachkommata
    auf Blattebene ersetzt. Achtung: Der Prozess akzeptiert keine Platzhalter in Elementnamen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy of target\
    \ Dimension based on a list of\n# supplied elements.\n\n# Note:\n# - pAddToSubset: If the specified\
    \ subset already exists then this parameter will control whether elements will\n#                \
    \ be added to the existing subset (value 1) or a new subset will be created (value 0).\n# - pExpandConsol:\
    \ If the specified list of elements contains consolidated elements they will be replaced with \n#\
    \                 their leaf level descendants\n# Caution: Process doesn't accept wildcards in element\
    \ names.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pEle:%pEle%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%, pExpandConsol:%pExpandConsol%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n## LogOutput\
    \ parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n\n\
    ### Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A\
    \ hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim   \
    \     = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\nIf( Trim( pDim\
    \ ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'Invalid dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n## Validate Hierarchy\n\nIF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy:\
    \ ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf(\
    \ Trim( pHier ) @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim,\
    \ pHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\nIf( Trim(\
    \ pSub ) @= '' );\n  nErrors = 1;\n  sMessage = 'No subset specified';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate elements\nIf( Trim( pEle ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No elements specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate delimiter\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# Validate\
    \ add to subset\nIf( pAddToSubset <> 0 & pAddToSubset <> 1 );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \ value for pAddToSubset: ' | NumberToString( pAddToSubset ) | '. Valid values are 0 and 1';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate expand consolidations\nIf( pExpandConsol\
    \ <> 0 & pExpandConsol <> 1 & pExpandConsol <> 2 );\n  nErrors = 1;\n  sMessage = 'Invalid value for\
    \ pExpandConsol: ' | NumberToString( pExpandConsol ) | '. Valid values are 0, 1 and 2';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Alias\nsDimAttr = '}ElementAttributes_'\
    \ | pDim;\nIF(pAlias @<> '' );\n  IF(DimensionExists( sDimAttr ) = 0 );\n    sMessage = 'No attributes\
    \ exist for the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n  IF(DIMIX( sDimAttr, pAlias )\
    \ = 0 );\n    sMessage = 'The Alias: ' | pAlias | ' does not exist in the dimension: ' | pDim;\n \
    \   pAlias = '';\n  EndIf;\n\n  IF(\n  DTYPE( sDimAttr, pAlias ) @<> 'AA' );\n    sMessage = 'The\
    \ Alias: ' | pAlias | ' is not an Alias in the dimension: ' | sDimAttr;\n    pAlias = '';\n  EndIf;\n\
    ENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong\
    \ parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Prepare subset ###\nIf( HierarchySubsetExists( pDim, pHier, pSub ) = 1 );\n\
    \  If( pAddtoSubset <> 1 );\n    HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\n    nSubsetSize\
    \ = 0;\n  Else;\n    nSubsetSize = HierarchySubsetGetSize( pDim, pHier, pSub );\n  EndIf;\nElse;\n\
    \  If( nErrors = 0 );\n    HierarchySubsetCreate( pDim, pHier, pSub, pTemp );\n  EndIf;\n  nSubsetSize\
    \ = 0;\nEndIf;\n\n### Assign Alias to subset\nIF(pAlias @<> '' );\n  HierarchySubsetAliasSet( pDim,\
    \ pHier, pSub, pAlias );\nENDIF;\n\n### Insert elements ###\n\nnSubsetIndex = 1;\nsElements = pEle;\n\
    nDelimIndex = 1;\n\n# Split filter into seperate dimensions\nWhile( nDelimIndex <> 0 & Long( sElements\
    \ ) > 0 );\n\n  nDelimIndex = Scan( pDelim, sElements );\n  If( nDelimIndex <> 0 );\n    sElement\
    \ = Trim( SubSt( sElements, 1, nDelimIndex - 1 ) );\n    sElements = Trim( SubSt( sElements, nDelimIndex\
    \ + Long( pDelim ), Long( sElements ) ) );\n  Else;\n    sElement = Trim( sElements );\n  EndIf;\n\
    \n  If( ElementIndex( pDim, pHier, sElement ) <> 0 );\n    If( nErrors = 0 );\n      IF(ElementLevel(\
    \ pDim, pHier, sElement) > 0);\n        If( pExpandConsol = 1 );\n          ExecuteProcess('}bedrock.hier.sub.create',\n\
    \                         'pStrictErrorHandling', pStrictErrorHandling,\n                        \
    \ 'pDim', pDim,\n                         'pHier',pHier,\n                         'pSub', pSub,\n\
    \                         'pConsol', sElement,\n                         'pExclusions', '',\n    \
    \                     'pDelim', pDelim,\n                         'pAddToSubset', 1,\n           \
    \              'pAlias', '',\n                         'pTemp', pTemp\n                        );\n\
    \        ElseIf( pExpandConsol = 2 );\n          ExecuteProcess('}bedrock.hier.sub.create',\n    \
    \                     'pStrictErrorHandling', pStrictErrorHandling,\n                         'pDim',\
    \ pDim,\n                         'pHier',pHier,\n                         'pSub', pSub,\n       \
    \                  'pConsol', sElement,\n                         'pLevelFrom', 0,\n             \
    \            'pLevelTo', 0,\n                         'pExclusions', '',\n                       \
    \  'pDelim', pDelim,\n                         'pAddToSubset', 1,\n                         'pAlias',\
    \ '',\n                         'pTemp', pTemp\n                        );\n        Else;\n      \
    \    HierarchySubsetElementInsert( pDim, pHIer, pSub, sElement, nSubsetIndex );\n        EndIf;\n\
    \      ELSE;\n        HierarchySubsetElementInsert( pDim, pHIer, pSub, sElement, nSubsetIndex );\n\
    \      ENDIF;\n    EndIf;\n    nSubsetIndex = nSubsetIndex + 1;\n  EndIf;\nEnd;\n\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in a hierarchy of the
    target dimension based on a list of supplied elements. Note: - pAddToSubset: If the specified subset
    already exists, this parameter will control whether elements will be added to the existing subset
    (value 1) or a new subset will be created (value 0). - pExpandConsol: If the specified list of elements
    contains consolidated elements, they will be replaced with their leaf-level descendants. Caution:
    Process doesn''t accept wildcards in element names.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy of target\
    \ Dimension based on a list of\n# supplied elements.\n\n# Note:\n# - pAddToSubset: If the specified\
    \ subset already exists then this parameter will control whether elements will\n#                \
    \ be added to the existing subset (value 1) or a new subset will be created (value 0).\n# - pExpandConsol:\
    \ If the specified list of elements contains consolidated elements they will be replaced with \n#\
    \                 their leaf level descendants\n# Caution: Process doesn't accept wildcards in element\
    \ names.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pEle:%pEle%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%, pExpandConsol:%pExpandConsol%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n## LogOutput\
    \ parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n\n\
    ### Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A\
    \ hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into dimension\
    \ & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim   \
    \     = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\n\nIf( Trim( pDim\
    \ ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'Invalid dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n## Validate Hierarchy\n\nIF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy:\
    \ ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf(\
    \ Trim( pHier ) @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim,\
    \ pHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\nIf( Trim(\
    \ pSub ) @= '' );\n  nErrors = 1;\n  sMessage = 'No subset specified';\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate elements\nIf( Trim( pEle ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No elements specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate delimiter\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# Validate\
    \ add to subset\nIf( pAddToSubset <> 0 & pAddToSubset <> 1 );\n  nErrors = 1;\n  sMessage = 'Invalid\
    \ value for pAddToSubset: ' | NumberToString( pAddToSubset ) | '. Valid values are 0 and 1';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate expand consolidations\nIf( pExpandConsol\
    \ <> 0 & pExpandConsol <> 1 & pExpandConsol <> 2 );\n  nErrors = 1;\n  sMessage = 'Invalid value for\
    \ pExpandConsol: ' | NumberToString( pExpandConsol ) | '. Valid values are 0, 1 and 2';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Alias\nsDimAttr = '}ElementAttributes_'\
    \ | pDim;\nIF(pAlias @<> '' );\n  IF(DimensionExists( sDimAttr ) = 0 );\n    sMessage = 'No attributes\
    \ exist for the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n  IF(DIMIX( sDimAttr, pAlias )\
    \ = 0 );\n    sMessage = 'The Alias: ' | pAlias | ' does not exist in the dimension: ' | pDim;\n \
    \   pAlias = '';\n  EndIf;\n\n  IF(\n  DTYPE( sDimAttr, pAlias ) @<> 'AA' );\n    sMessage = 'The\
    \ Alias: ' | pAlias | ' is not an Alias in the dimension: ' | sDimAttr;\n    pAlias = '';\n  EndIf;\n\
    ENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong\
    \ parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Prepare subset ###\nIf( HierarchySubsetExists( pDim, pHier, pSub ) = 1 );\n\
    \  If( pAddtoSubset <> 1 );\n    HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\n    nSubsetSize\
    \ = 0;\n  Else;\n    nSubsetSize = HierarchySubsetGetSize( pDim, pHier, pSub );\n  EndIf;\nElse;\n\
    \  If( nErrors = 0 );\n    HierarchySubsetCreate( pDim, pHier, pSub, pTemp );\n  EndIf;\n  nSubsetSize\
    \ = 0;\nEndIf;\n\n### Assign Alias to subset\nIF(pAlias @<> '' );\n  HierarchySubsetAliasSet( pDim,\
    \ pHier, pSub, pAlias );\nENDIF;\n\n### Insert elements ###\n\nnSubsetIndex = 1;\nsElements = pEle;\n\
    nDelimIndex = 1;\n\n# Split filter into seperate dimensions\nWhile( nDelimIndex <> 0 & Long( sElements\
    \ ) > 0 );\n\n  nDelimIndex = Scan( pDelim, sElements );\n  If( nDelimIndex <> 0 );\n    sElement\
    \ = Trim( SubSt( sElements, 1, nDelimIndex - 1 ) );\n    sElements = Trim( SubSt( sElements, nDelimIndex\
    \ + Long( pDelim ), Long( sElements ) ) );\n  Else;\n    sElement = Trim( sElements );\n  EndIf;\n\
    \n  If( ElementIndex( pDim, pHier, sElement ) <> 0 );\n    If( nErrors = 0 );\n      IF(ElementLevel(\
    \ pDim, pHier, sElement) > 0);\n        If( pExpandConsol = 1 );\n          ExecuteProcess('}bedrock.hier.sub.create',\n\
    \                         'pStrictErrorHandling', pStrictErrorHandling,\n                        \
    \ 'pDim', pDim,\n                         'pHier',pHier,\n                         'pSub', pSub,\n\
    \                         'pConsol', sElement,\n                         'pExclusions', '',\n    \
    \                     'pDelim', pDelim,\n                         'pAddToSubset', 1,\n           \
    \              'pAlias', '',\n                         'pTemp', pTemp\n                        );\n\
    \        ElseIf( pExpandConsol = 2 );\n          ExecuteProcess('}bedrock.hier.sub.create',\n    \
    \                     'pStrictErrorHandling', pStrictErrorHandling,\n                         'pDim',\
    \ pDim,\n                         'pHier',pHier,\n                         'pSub', pSub,\n       \
    \                  'pConsol', sElement,\n                         'pLevelFrom', 0,\n             \
    \            'pLevelTo', 0,\n                         'pExclusions', '',\n                       \
    \  'pDelim', pDelim,\n                         'pAddToSubset', 1,\n                         'pAlias',\
    \ '',\n                         'pTemp', pTemp\n                        );\n        Else;\n      \
    \    HierarchySubsetElementInsert( pDim, pHIer, pSub, sElement, nSubsetIndex );\n        EndIf;\n\
    \      ELSE;\n        HierarchySubsetElementInsert( pDim, pHIer, pSub, sElement, nSubsetIndex );\n\
    \      ENDIF;\n    EndIf;\n    nSubsetIndex = nSubsetIndex + 1;\n  EndIf;\nEnd;\n\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der statische Subsets mit dem Namen ''Alle
    Ebene <nn>'' für die angegebenen Konsolidierungsebenen in einer Hierarchie einer Dimension erstellt.
    Beachte, dass die Option zum Sortieren des Subsets nur für die Sortierung nach den Hauptelementnamen
    verfügbar ist. Vorsicht: Die Zielhierarchie darf nicht ''Leaves'' sein.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates static subsets named 'All level <nn>' for the\
    \ specified consolidation\n# levels in a Hierarchy of a Dimension.\n\n# Note:\n# Option to sort subset\
    \ is available only for sorting per element principal names.\n\n# Caution: Target hierarchy cannot\
    \ be `Leaves`.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub    \
    \        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSort:%pSort%, pConvertStatic:%pConvertStatic%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncSubs \
    \              = '' ;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n\n### Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim\
    \ ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by\
    \ splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim )\
    \ + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate\
    \ dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists( pDim ) =\
    \ 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier @= 'Leaves' );\n  nErrors = 1;\n\
    \  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\n\
    IF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension Hierarchy:\
    \ ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate\
    \ Alias\nIF(pAlias @<> '' );\n\n  sDimAttr = '}ElementAttributes_' | pDim;\n  IF(\n  DimensionExists(\
    \ sDimAttr ) = 0 );\n    sMessage = 'No attributes exist for the dimension: ' | pDim;\n    pAlias\
    \ = '';\n  EndIf;\n\n  IF(DIMIX( sDimAttr, pAlias ) = 0 );\n    sMessage = 'The Alias: ' | pAlias\
    \ | ' does not exist in the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n  IF(DTYPE( sDimAttr,\
    \ pAlias ) @<> 'AA' );\n    sMessage = 'The Alias: ' | pAlias | ' is not an Alias in the dimension:\
    \ ' | sDimAttr;\n    pAlias = '';\n  EndIf;\nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Build Subset ###\n\n\
    If( nErrors = 0 );\n  nLevel = 0;\n  nLevelMax = DnLev( pDim|':'|sHier ) - 1;\n  While( nLevel <=\
    \ nLevelMax );\n    # Loop through the levels of the dimension.\n    sLevel = NumberToString( nLevel\
    \ );\n    sSubset = 'All Level ' | Fill( '0', 2 - Long( sLevel ) ) | sLevel;\n    cSubs = cSubs |\
    \ ' ' | sSubset | ','  ;\n    If( HierarchySubsetExists( pDim, sHier, sSubset ) = 1 );\n      # Need\
    \ to destroy the subset because the subset may change from an MDX subset to a Static Subset.\n   \
    \   HierarchySubsetDestroy( pDim, sHier, sSubset );\n    EndIf;\n\n    # Generate MDX\n    sMDX =\
    \ '{ TM1FILTERBYLEVEL( { TM1SUBSETALL( [' | pDim|':'|sHier | '] ) }, ' | sLevel | ' ) }';\n    If(\
    \ pSort = 1 );\n      sMDX = '{ TM1SORT( ' | sMDX | ', ASC ) }';\n    EndIf;\n\n    ## Build Subset\
    \ for the level.\n    If( pConvertStatic = 1 );\n      # Convert the subset to a static subset\n \
    \     sSubsetMDX = '}' | cThisProcName | '.' | NumberToString( Int( Rand() * 100000 ) );\n      If(\
    \ HierarchySubsetExists( pDim, pHier, sSubsetMDX ) = 1 );\n        HierarchySubsetDestroy( pDim, sHier,\
    \ sSubsetMDX );\n      EndIF;\n      SubsetCreatebyMDX( sSubsetMDX, sMDX, pDim, pTemp );\n      nSubsetSize\
    \ = HierarchySubsetGetSize( pDim, sHier, sSubsetMDX );\n      nSubsetIndex = 0;\n      HierarchySubsetCreate(\
    \ pDim, sHier, sSubset, pTemp );\n      While( nSubsetIndex < nSubsetSize );\n        nSubsetIndex\
    \ = nSubsetIndex + 1;\n        sTemp =    HierarchySubsetElementGetIndex (pDim, sHier, sSubsetMDX,\
    \ '', nSubsetIndex);\n        sElement = HierarchySubsetGetElementName( pDim, sHier, sSubsetMDX, nSubsetIndex\
    \ );\n        HierarchySubsetElementInsert( pDim, sHier, sSubset, sElement, nSubsetIndex );\n    \
    \  End;\n    Else;\n      SubsetCreatebyMDX( sSubset, sMDX, pDim, pTemp );\n    EndIf;\n\n    ###\
    \ Assign Alias to subset\n    IF(pAlias @<> '' );\n      If( nErrors = 0 );\n        HierarchySubsetAliasSet(\
    \ pDim, pHier, sSubset, pAlias );\n      EndIf;\n    ENDIF;\n    nLevel = nLevel + 1;\n  End;\nEndIf;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset(s) %cSubs% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates static subsets named ''All level <nn>''
    for the specified consolidation levels in a hierarchy of a dimension. Note that the option to sort
    the subset is only available for sorting by element principal names. Caution: The target hierarchy
    cannot be ''Leaves''.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process creates static subsets named 'All level <nn>' for the\
    \ specified consolidation\n# levels in a Hierarchy of a Dimension.\n\n# Note:\n# Option to sort subset\
    \ is available only for sorting per element principal names.\n\n# Caution: Target hierarchy cannot\
    \ be `Leaves`.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub    \
    \        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSort:%pSort%, pConvertStatic:%pConvertStatic%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncSubs \
    \              = '' ;\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n\n### Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim\
    \ ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error by\
    \ splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim )\
    \ + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate\
    \ dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( DimensionExists( pDim ) =\
    \ 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier @= 'Leaves' );\n  nErrors = 1;\n\
    \  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\n\
    IF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension Hierarchy:\
    \ ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate\
    \ Alias\nIF(pAlias @<> '' );\n\n  sDimAttr = '}ElementAttributes_' | pDim;\n  IF(\n  DimensionExists(\
    \ sDimAttr ) = 0 );\n    sMessage = 'No attributes exist for the dimension: ' | pDim;\n    pAlias\
    \ = '';\n  EndIf;\n\n  IF(DIMIX( sDimAttr, pAlias ) = 0 );\n    sMessage = 'The Alias: ' | pAlias\
    \ | ' does not exist in the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n  IF(DTYPE( sDimAttr,\
    \ pAlias ) @<> 'AA' );\n    sMessage = 'The Alias: ' | pAlias | ' is not an Alias in the dimension:\
    \ ' | sDimAttr;\n    pAlias = '';\n  EndIf;\nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Build Subset ###\n\n\
    If( nErrors = 0 );\n  nLevel = 0;\n  nLevelMax = DnLev( pDim|':'|sHier ) - 1;\n  While( nLevel <=\
    \ nLevelMax );\n    # Loop through the levels of the dimension.\n    sLevel = NumberToString( nLevel\
    \ );\n    sSubset = 'All Level ' | Fill( '0', 2 - Long( sLevel ) ) | sLevel;\n    cSubs = cSubs |\
    \ ' ' | sSubset | ','  ;\n    If( HierarchySubsetExists( pDim, sHier, sSubset ) = 1 );\n      # Need\
    \ to destroy the subset because the subset may change from an MDX subset to a Static Subset.\n   \
    \   HierarchySubsetDestroy( pDim, sHier, sSubset );\n    EndIf;\n\n    # Generate MDX\n    sMDX =\
    \ '{ TM1FILTERBYLEVEL( { TM1SUBSETALL( [' | pDim|':'|sHier | '] ) }, ' | sLevel | ' ) }';\n    If(\
    \ pSort = 1 );\n      sMDX = '{ TM1SORT( ' | sMDX | ', ASC ) }';\n    EndIf;\n\n    ## Build Subset\
    \ for the level.\n    If( pConvertStatic = 1 );\n      # Convert the subset to a static subset\n \
    \     sSubsetMDX = '}' | cThisProcName | '.' | NumberToString( Int( Rand() * 100000 ) );\n      If(\
    \ HierarchySubsetExists( pDim, pHier, sSubsetMDX ) = 1 );\n        HierarchySubsetDestroy( pDim, sHier,\
    \ sSubsetMDX );\n      EndIF;\n      SubsetCreatebyMDX( sSubsetMDX, sMDX, pDim, pTemp );\n      nSubsetSize\
    \ = HierarchySubsetGetSize( pDim, sHier, sSubsetMDX );\n      nSubsetIndex = 0;\n      HierarchySubsetCreate(\
    \ pDim, sHier, sSubset, pTemp );\n      While( nSubsetIndex < nSubsetSize );\n        nSubsetIndex\
    \ = nSubsetIndex + 1;\n        sTemp =    HierarchySubsetElementGetIndex (pDim, sHier, sSubsetMDX,\
    \ '', nSubsetIndex);\n        sElement = HierarchySubsetGetElementName( pDim, sHier, sSubsetMDX, nSubsetIndex\
    \ );\n        HierarchySubsetElementInsert( pDim, sHier, sSubset, sElement, nSubsetIndex );\n    \
    \  End;\n    Else;\n      SubsetCreatebyMDX( sSubset, sMDX, pDim, pTemp );\n    EndIf;\n\n    ###\
    \ Assign Alias to subset\n    IF(pAlias @<> '' );\n      If( nErrors = 0 );\n        HierarchySubsetAliasSet(\
    \ pDim, pHier, sSubset, pAlias );\n      EndIf;\n    ENDIF;\n    nLevel = nLevel + 1;\n  End;\nEndIf;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset(s) %cSubs% from dimension %pDim%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der einen dynamischen Subset aus einem MDX-Ausdruck
    erstellt, der zu einer nicht-leeren Menge in der angegebenen Dimension evaluiert. Dieser Prozess ist
    sowohl für die Produktion als auch für die Entwicklung vorgesehen. Das Hauptziel ist es, einen dynamischen
    Subset zur Nutzung in einer Ansicht zu erstellen. Beachte, dass der Prozess bei ungültigem Dimensionsnamen
    (pDim) abbricht. Falls der MDX-Ausdruck nicht kompiliert oder eine leere Menge produziert, tritt ein
    Fehler im Prozess auf. Wenn die Option zum Konvertieren in statisch (pConvertToStatic) auf 1 gesetzt
    ist, wird der MDX-Subset durch einen statischen Subset ersetzt.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Create a dynamic subset from an MDX expression\
    \ that evaluates to a non-empty set in the specified dimension.\n\n# Use case: Intended for Production\
    \ & Development\n#1/ Create a dynamic subset for use in a view\n\n# Note:\n# Naturally, valid dimension\
    \ name (pDim) are mandatory otherwise the process will abort.\n# If the MDX does not compile or produces\
    \ an empty set, the process will error.\n# If convert to static (pConvertToStatic) is set to 1 then\
    \ the MDX subset will be replaced by a static subset.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \   = GetProcessName();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName | '_' | cTimeStamp | '_'\
    \ | cRandomInt;\ncTempFile       = GetProcessErrorFileDirectory | cTempSub | '.csv';\ncUserName  \
    \     = TM1User();\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pMDXExpr:%pMDXExpr%, pConvertToStatic:%pConvertToStatic%, pTemp:%pTemp%,\
    \ pAlias:%pAlias%.' ;\nsMDXExpr        = pMDXExpr;\n\n## LogOutput parameters\nIF( pLogoutput  = 1\
    \ );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors\
    \         = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as\
    \ dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier  \
    \     = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan(\
    \ ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim )  @= '' );\n    nErrors    \
    \ = 1;\n    sMessage    = 'No dimension specified';\n    DataSourceType= 'NULL';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIf( DimensionExists( pDim ) = 0 );\n    nErrors     = 1;\n\
    \    sMessage    = 'Invalid dimension: ' | pDim;\n    DataSourceType = 'NULL';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate hierarchy\nIf( Trim( pHier ) @= '' );\n   \
    \ sHier = pDim;\nElse;\n    sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, pHier ) = 0 );\n  \
    \  nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|pHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pSub ) @=\
    \ '' );\n    nErrors = 1;\n    sMessage = 'No subset specified';\n    DataSourceType = 'NULL';\n \
    \   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate MDX\nIf( Trim(\
    \ sMDXExpr ) @= '' );\n    nErrors = 1;\n    sMessage = 'No MDX expression specified.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\n\
    IF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only\
    \ 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ Alias exists\nIf ( pAlias @<> '' & \n    DimIx ( Expand ( '}ElementAttributes_%pDim%' ), pAlias\
    \ ) = 0\n);\n  nErrors = 1;\n  sMessage = 'Alias does not exist in dimension %pDim%.';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;  \n\n# Validate alias attribute name is actually\
    \ an alias\nIf ( pAlias @<> '' & \n    Dtype ( Expand ( '}ElementAttributes_%pDim%' ), pAlias ) @<>\
    \ 'AA'  \n);\n  nErrors = 1;\n  sMessage = 'Attribute %pAlias% is not an alias in dimension %pDim%.';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n### Create Subset ###\nIf(\
    \ nErrors = 0 );\n  If( ElementCount( pDim, sHier ) = 0 & pConvertToStatic <> 0);\n    HierarchySubsetCreate(\
    \ pDim, sHier, pSub );\n  Else;\n    If( HierarchySubsetExists( pDim,sHier, pSub ) = 1 );\n      \
    \  HierarchySubsetMDXSet( pDim, sHier, pSub, sMDXExpr );\n    Else;\n        SubsetCreateByMDX( pSub,\
    \ sMDXExpr, pDim|':'|sHier, pTemp );\n    EndIf;\n    If( pConvertToStatic = 1 );\n        HierarchySubsetElementInsert(\
    \ pDim, sHier, pSub, ElementName( pDim, sHier, 1 ), 1 );\n        HierarchySubsetElementDelete( pDim,\
    \ sHier, pSub, 1 );\n    EndIf;\n  EndIf;\n  \n  # Set Alias\n  If ( pAlias @<> '' );\n      If (\
    \ pDim @= sHier );\n          SubsetAliasSet( pDim, pSub, pAlias);\n      Else;\n          SubsetAliasSet(\
    \ pDim | ':' | sHier, pSub, pAlias);\n      EndIf;\n  EndIf;\nEndIf;\n\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\n#Section\
    \ Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Destroy Temporary\
    \ Subset ###\n\nIf( pConvertToStatic = 1 & pTemp = 0 );\n\n  If( HierarchySubsetExists( pDim , pHier,\
    \ cTempSub) = 1 );\n    HierarchySubsetDestroy( pDim, pHier, cTempSub );\n  EndIf;\n\nEndIf;\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates a dynamic subset from an MDX expression
    that evaluates to a non-empty set in the specified dimension. This process is intended for both production
    and development. The main goal is to create a dynamic subset for use in a view. Note that the process
    will abort if an invalid dimension name (pDim) is provided. If the MDX expression does not compile
    or produces an empty set, the process will error. If the convert to static option (pConvertToStatic)
    is set to 1, the MDX subset will be replaced by a static subset.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Create a dynamic subset from an MDX expression\
    \ that evaluates to a non-empty set in the specified dimension.\n\n# Use case: Intended for Production\
    \ & Development\n#1/ Create a dynamic subset for use in a view\n\n# Note:\n# Naturally, valid dimension\
    \ name (pDim) are mandatory otherwise the process will abort.\n# If the MDX does not compile or produces\
    \ an empty set, the process will error.\n# If convert to static (pConvertToStatic) is set to 1 then\
    \ the MDX subset will be replaced by a static subset.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \   = GetProcessName();\ncTimeStamp      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      =\
    \ NumberToString( INT( RAND( ) * 1000 ));\ncTempSub        = cThisProcName | '_' | cTimeStamp | '_'\
    \ | cRandomInt;\ncTempFile       = GetProcessErrorFileDirectory | cTempSub | '.csv';\ncUserName  \
    \     = TM1User();\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo        = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pMDXExpr:%pMDXExpr%, pConvertToStatic:%pConvertToStatic%, pTemp:%pTemp%,\
    \ pAlias:%pAlias%.' ;\nsMDXExpr        = pMDXExpr;\n\n## LogOutput parameters\nIF( pLogoutput  = 1\
    \ );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors\
    \         = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as\
    \ dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier  \
    \     = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan(\
    \ ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim )  @= '' );\n    nErrors    \
    \ = 1;\n    sMessage    = 'No dimension specified';\n    DataSourceType= 'NULL';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\nIf( DimensionExists( pDim ) = 0 );\n    nErrors     = 1;\n\
    \    sMessage    = 'Invalid dimension: ' | pDim;\n    DataSourceType = 'NULL';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate hierarchy\nIf( Trim( pHier ) @= '' );\n   \
    \ sHier = pDim;\nElse;\n    sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, pHier ) = 0 );\n  \
    \  nErrors = 1;\n    sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|pHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pSub ) @=\
    \ '' );\n    nErrors = 1;\n    sMessage = 'No subset specified';\n    DataSourceType = 'NULL';\n \
    \   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate MDX\nIf( Trim(\
    \ sMDXExpr ) @= '' );\n    nErrors = 1;\n    sMessage = 'No MDX expression specified.';\n    DataSourceType\
    \ = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\n\
    IF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only\
    \ 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate\
    \ Alias exists\nIf ( pAlias @<> '' & \n    DimIx ( Expand ( '}ElementAttributes_%pDim%' ), pAlias\
    \ ) = 0\n);\n  nErrors = 1;\n  sMessage = 'Alias does not exist in dimension %pDim%.';\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;  \n\n# Validate alias attribute name is actually\
    \ an alias\nIf ( pAlias @<> '' & \n    Dtype ( Expand ( '}ElementAttributes_%pDim%' ), pAlias ) @<>\
    \ 'AA'  \n);\n  nErrors = 1;\n  sMessage = 'Attribute %pAlias% is not an alias in dimension %pDim%.';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\n### Create Subset ###\nIf(\
    \ nErrors = 0 );\n  If( ElementCount( pDim, sHier ) = 0 & pConvertToStatic <> 0);\n    HierarchySubsetCreate(\
    \ pDim, sHier, pSub );\n  Else;\n    If( HierarchySubsetExists( pDim,sHier, pSub ) = 1 );\n      \
    \  HierarchySubsetMDXSet( pDim, sHier, pSub, sMDXExpr );\n    Else;\n        SubsetCreateByMDX( pSub,\
    \ sMDXExpr, pDim|':'|sHier, pTemp );\n    EndIf;\n    If( pConvertToStatic = 1 );\n        HierarchySubsetElementInsert(\
    \ pDim, sHier, pSub, ElementName( pDim, sHier, 1 ), 1 );\n        HierarchySubsetElementDelete( pDim,\
    \ sHier, pSub, 1 );\n    EndIf;\n  EndIf;\n  \n  # Set Alias\n  If ( pAlias @<> '' );\n      If (\
    \ pDim @= sHier );\n          SubsetAliasSet( pDim, pSub, pAlias);\n      Else;\n          SubsetAliasSet(\
    \ pDim | ':' | sHier, pSub, pAlias);\n      EndIf;\n  EndIf;\nEndIf;\n\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\n#Section\
    \ Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Destroy Temporary\
    \ Subset ###\n\nIf( pConvertToStatic = 1 & pTemp = 0 );\n\n  If( HierarchySubsetExists( pDim , pHier,\
    \ cTempSub) = 1 );\n    HierarchySubsetDestroy( pDim, pHier, cTempSub );\n  EndIf;\n\nEndIf;\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der ein statisches Teilset in einer Hierarchie
    einer Zieldimension erstellt, das aus allen Nachkommen eines angegebenen konsolidierten Elements besteht,
    einschließlich der konsolidierten Elemente. Dieser Prozess sollte die Option bieten, bestimmte Elemente
    basierend auf dem Parameter pExclusions auszuschließen, wobei die Elemente durch ein Trennzeichen
    getrennt werden und Platzhalterzeichen wie '*' und '?' zulässig sind. Zusätzlich sollte der Parameter
    pAddToSubset festlegen, ob bei vorhandenen Subsets Elemente hinzugefügt werden (Wert 1) oder ein neues
    Subset erstellt werden soll (Wert 0). Beachte, dass die Anzahl der verarbeiteten konsolidierten Ebenen
    auf maximal 99 begrenzt ist.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy of target\
    \ Dimension that consists of\n# all descendants of a specified consolidated element, including consolidated\
    \ elements.\n\n# Note:\n# - pExclusions: If pExclusions is specified then the elements (separated\
    \ by a delimiter) will be\n#   excluded from the subset. Wildcards characters `*` and `?` are accepted.\n\
    # - pAddToSubset : If the specified subset already exists then this parameter will control whether\n\
    #   elements will be added to the existing subset (value 1) or a new subset will be created\n#   (value\
    \ 0).\n\n# Caution: Number of consolidated levels that are processed is limited to maximum of 99.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName      \
    \   = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorShell = Expand('Executing process %cThisProcName%\
    \ has failed.');\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%,\
    \ pConsol:%pConsol%, pAddToSubset:%pAddToSubset%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAlias:%pAlias%,\
    \ pTemp:%pTemp%.' ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n\
    \    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = \nExecuteProcess( '}bedrock.hier.sub.create',\
    \ 'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim', pDim,\
    \ 'pHier', pHier, 'pSub', pSub, 'pConsol', pConsol,\n    'pAttr', '', 'pAttrValue', '',\n    'pLevelFrom',\
    \ 0, 'pLevelTo', 999,\n    'pExclusions', pExclusions, 'pDelim', pDelim,\n    'pAddToSubset', pAddToSubset,\n\
    \    'pAlias', pAlias, 'pTemp', pTemp\n);\n                            \nIF ( nRet <> ProcessExitNormal()\
    \ );\n  sMessage = cMsgErrorShell;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \ ProcessError();\nENDIF;\n\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates a static subset in a hierarchy of a target
    dimension consisting of all descendants of a specified consolidated element, including consolidated
    elements. This process should offer the option to exclude certain elements based on the pExclusions
    parameter, with elements separated by a delimiter and wildcard characters like '*' and '?' accepted.
    Additionally, the pAddToSubset parameter should determine whether elements will be added to an existing
    subset (value 1) or a new subset should be created (value 0). Note that the number of consolidated
    levels processed is limited to a maximum of 99.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy of target\
    \ Dimension that consists of\n# all descendants of a specified consolidated element, including consolidated\
    \ elements.\n\n# Note:\n# - pExclusions: If pExclusions is specified then the elements (separated\
    \ by a delimiter) will be\n#   excluded from the subset. Wildcards characters `*` and `?` are accepted.\n\
    # - pAddToSubset : If the specified subset already exists then this parameter will control whether\n\
    #   elements will be added to the existing subset (value 1) or a new subset will be created\n#   (value\
    \ 0).\n\n# Caution: Number of consolidated levels that are processed is limited to maximum of 99.\n\
    #EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName      \
    \   = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorShell = Expand('Executing process %cThisProcName%\
    \ has failed.');\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%,\
    \ pConsol:%pConsol%, pAddToSubset:%pAddToSubset%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAlias:%pAlias%,\
    \ pTemp:%pTemp%.' ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n\
    \    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = \nExecuteProcess( '}bedrock.hier.sub.create',\
    \ 'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim', pDim,\
    \ 'pHier', pHier, 'pSub', pSub, 'pConsol', pConsol,\n    'pAttr', '', 'pAttrValue', '',\n    'pLevelFrom',\
    \ 0, 'pLevelTo', 999,\n    'pExclusions', pExclusions, 'pDelim', pDelim,\n    'pAddToSubset', pAddToSubset,\n\
    \    'pAlias', pAlias, 'pTemp', pTemp\n);\n                            \nIF ( nRet <> ProcessExitNormal()\
    \ );\n  sMessage = cMsgErrorShell;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \ ProcessError();\nENDIF;\n\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension %pDim%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der einen statischen Subset in einer Hierarchie
    der Zieldimension erstellt, der aus allen Blattnachfahren eines angegebenen konsolidierten Elements
    besteht. Beachte: Wenn pExclusions angegeben ist, werden die durch ein Trennzeichen getrennten Elemente
    vom Subset ausgeschlossen, wobei Platzhalterzeichen ''*'' und ''?'' akzeptiert werden. Wenn das angegebene
    Subset bereits existiert, steuert der Parameter pAddToSubset, ob Elemente zum bestehenden Subset hinzugefügt
    werden (Wert 1) oder ein neues Subset erstellt wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy of target\
    \ Dimension that consists of\n# all leaf descendants of a specified consolidated element.\n\n# Note:\n\
    # - pExclusions: If pExclusions is specified then the elements (separated by a delimiter) will be\n\
    #   excluded from the subset. Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset : If\
    \ the specified subset already exists then this parameter will control whether\n#   elements will\
    \ be added to the existing subset (value 1) or a new subset will be created\n#   (value 0).\n\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName      \
    \   = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorShell = Expand('Executing process %cThisProcName%\
    \ has failed.');\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%,\
    \ pConsol:%pConsol%, pAddToSubset:%pAddToSubset%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAlias:%pAlias%,\
    \ pTemp:%pTemp%.' ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n\
    \    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = \nExecuteProcess( '}bedrock.hier.sub.create',\
    \ 'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim', pDim,\
    \ 'pHier', pHier, 'pSub', pSub, 'pConsol', pConsol,\n    'pAttr', '', 'pAttrValue', '',\n    'pLevelFrom',\
    \ 0, 'pLevelTo', 0,\n    'pExclusions', pExclusions,\n    'pDelim', pDelim, 'pAddToSubset', pAddToSubset,\n\
    \    'pAlias', pAlias, 'pTemp', pTemp\n);\n\n                            \nIF ( nRet <> ProcessExitNormal()\
    \ );\n  sMessage = cMsgErrorShell;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \ ProcessError();\nENDIF;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in a hierarchy of the
    target dimension consisting of all leaf descendants of a specified consolidated element. Note: If
    pExclusions is specified, the elements separated by a delimiter will be excluded from the subset,
    with wildcard characters ''*'' and ''?'' being accepted. If the specified subset already exists, the
    parameter pAddToSubset controls whether elements will be added to the existing subset (value 1) or
    a new subset will be created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy of target\
    \ Dimension that consists of\n# all leaf descendants of a specified consolidated element.\n\n# Note:\n\
    # - pExclusions: If pExclusions is specified then the elements (separated by a delimiter) will be\n\
    #   excluded from the subset. Wildcards characters `*` and `?` are accepted.\n# - pAddToSubset : If\
    \ the specified subset already exists then this parameter will control whether\n#   elements will\
    \ be added to the existing subset (value 1) or a new subset will be created\n#   (value 0).\n\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\n\ncThisProcName = GetProcessName();\ncUserName      \
    \   = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorShell = Expand('Executing process %cThisProcName%\
    \ has failed.');\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%,\
    \ pConsol:%pConsol%, pAddToSubset:%pAddToSubset%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAlias:%pAlias%,\
    \ pTemp:%pTemp%.' ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n\
    \    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nnRet = \nExecuteProcess( '}bedrock.hier.sub.create',\
    \ 'pLogOutput', pLogOutput,\n    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim', pDim,\
    \ 'pHier', pHier, 'pSub', pSub, 'pConsol', pConsol,\n    'pAttr', '', 'pAttrValue', '',\n    'pLevelFrom',\
    \ 0, 'pLevelTo', 0,\n    'pExclusions', pExclusions,\n    'pDelim', pDelim, 'pAddToSubset', pAddToSubset,\n\
    \    'pAlias', pAlias, 'pTemp', pTemp\n);\n\n                            \nIF ( nRet <> ProcessExitNormal()\
    \ );\n  sMessage = cMsgErrorShell;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n \
    \ ProcessError();\nENDIF;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully created subset %pSub% from dimension\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der ein statisches Subset in der Hierarchie
    einer Dimension erstellt, das aus allen Blatt-Elementen besteht. Der Prozess soll Modifikationsparameter
    verwenden, um zu bestimmen, welche Elemente im Subset enthalten sein sollen: - pExclusions: Wenn pExclusions
    angegeben wird, sollen die durch einen Trenner getrennten Elemente aus dem Subset ausgeschlossen werden.
    Platzhalterzeichen wie ''*'' und ''?'' sollen akzeptiert werden. - pAddToSubset: Wenn das angegebene
    Subset bereits existiert, steuert dieser Parameter, ob Elemente dem bestehenden Subset hinzugefügt
    werden (Wert 1) oder ein neues Subset erstellt wird (Wert 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy of a Dimension\
    \ that consists of all leaf\n# elements.\n\n# Note:\n# This process uses modification parameters to\
    \ determine what to include in the subset:\n# - pExclusions: If pExclusions is specified then the\
    \ elements (separated by a delimiter) will be\n#                excluded from the subset. Wildcards\
    \ characters `*` and `?` are accepted.\n# - pAddToSubset: If the specified subset already exists then\
    \ this parameter will control whether elements will\n#                 be added to the existing subset\
    \ (value 1) or a new subset will be created (value 0).\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\nnErrors = 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName      \
    \     = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        \
    \  = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.';\ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n\n## LogOutput\
    \ parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors\
    \ = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong\
    \ parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nnRet = \nExecuteProcess( '}bedrock.hier.sub.create', 'pLogOutput', pLogOutput,\n\
    \    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim', pDim, 'pHier',pHier, 'pSub', pSub,\n\
    \    'pLevelFrom', 0, 'pLevelTo', 0,\n    'pExclusions', pExclusions, 'pAddToSubset', pAddToSubset,\n\
    \    'pDelim', pDelim, 'pAlias', pAlias, 'pTemp', pTemp\n);\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in the hierarchy of
    a dimension consisting of all leaf elements. The process should use modification parameters to determine
    what to include in the subset: - pExclusions: If pExclusions is specified, elements separated by a
    delimiter should be excluded from the subset. Wildcard characters ''*'' and ''?'' should be accepted.
    - pAddToSubset: If the specified subset already exists, this parameter will control whether elements
    will be added to the existing subset (value 1) or a new subset will be created (value 0).'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in Hierarchy of a Dimension\
    \ that consists of all leaf\n# elements.\n\n# Note:\n# This process uses modification parameters to\
    \ determine what to include in the subset:\n# - pExclusions: If pExclusions is specified then the\
    \ elements (separated by a delimiter) will be\n#                excluded from the subset. Wildcards\
    \ characters `*` and `?` are accepted.\n# - pAddToSubset: If the specified subset already exists then\
    \ this parameter will control whether elements will\n#                 be added to the existing subset\
    \ (value 1) or a new subset will be created (value 0).\n#EndRegion @DOC\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\nnErrors = 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName      \
    \     = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        \
    \  = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pExclusions:%pExclusions%, pDelim:%pDelim%, pAddToSubset:%pAddToSubset%,\
    \ pAlias:%pAlias%, pTemp:%pTemp%.';\ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n\n## LogOutput\
    \ parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors\
    \ = 0;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors = 1;\n    sMessage = 'Wrong\
    \ parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nnRet = \nExecuteProcess( '}bedrock.hier.sub.create', 'pLogOutput', pLogOutput,\n\
    \    'pStrictErrorHandling', pStrictErrorHandling,\n    'pDim', pDim, 'pHier',pHier, 'pSub', pSub,\n\
    \    'pLevelFrom', 0, 'pLevelTo', 0,\n    'pExclusions', pExclusions, 'pAddToSubset', pAddToSubset,\n\
    \    'pDelim', pDelim, 'pAlias', pAlias, 'pTemp', pTemp\n);\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der ein statisches Subset in einer Hierarchie
    der Zieldimension erstellt, das aus allen Waisenelementen besteht. Beachte: Ein Waisenelement ist
    ein konsolidiertes Element ohne Kinder oder ein Blattelement ohne Eltern.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy of target\
    \ Dimension that consists of\n# all orphan elements.\n\n# Note:\n# Orphan element is defined as:\n\
    # - Consolidated element without children.\n# - Leaf element without parent.\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncSubsetOrphanC\
    \ = 'Orphan C Elements (no children)';\ncSubsetOrphanN = 'Orphan N Elements (no parents)';\n\n## LogOutput\
    \ parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n###\
    \ Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension:\
    \ ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\n\
    IF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n\
    \  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors\
    \ = 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n   \
    \ nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Create Subsets ###\nIf( nErrors = 0\
    \ );\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanC ) = 1 );\n    HierarchySubsetDeleteAllElements(\
    \ pDim, sHier, cSubsetOrphanC );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanC,\
    \ pTemp );\n  EndIf;\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanN ) = 1 );\n    HierarchySubsetDeleteAllElements(\
    \ pDim, sHier, cSubsetOrphanN );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanN,\
    \ pTemp );\n  EndIf;\nEndIf;\n\n### Populate subsets ###\nnElementCount = DimSiz( pDim|':'|sHier);\n\
    nElementIndex = 1;\nnLeafCount = 0;\nnConsolCount = 0;\nWhile( nElementIndex <= nElementCount );\n\
    \  sElement = ElementName( pDim, sHier, nElementIndex );\n  If( ElementType( pDim, sHier, sElement\
    \ ) @= 'N' & ElementParent( pDim, sHier, sElement, 1 ) @= '' );\n    # N element with no parents\n\
    \    nLeafCount = nLeafCount + 1;\n    HierarchySubsetElementInsert( pDim, sHier, cSubsetOrphanN,\
    \ sElement, nLeafCount );\n  EndIf;\n  If(ElementType(pDim,sHier, sElement) @= 'C' & ElementComponentCount(pDim,\
    \ sHier, sElement) = 0);\n    # C element with no children\n    nConsolCount = nConsolCount + 1;\n\
    \    HierarchySubsetElementInsert( pDim, sHier, cSubsetOrphanC, sElement, nConsolCount );\n  EndIf;\n\
    \  nElementIndex = nElementIndex + 1;\nEnd;\n\n### Tidy up ###\n\n# If no orphans then destroy empty\
    \ subsets\nIf( nErrors = 0 );\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanN ) = 0 );\n\
    \    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanN );\n  EndIf;\n  If( HierarchySubsetGetSize(\
    \ pDim, sHier, cSubsetOrphanC ) = 0 );\n    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanC );\n\
    \  EndIf;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    If( nLeafCount > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully\
    \ created subset %cSubsetOrphanN% from dimension %pDim%:%pHier%.' );\n       sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n       If( pLogoutput\
    \ = 1 );\n           LogOutput('INFO', Expand( sProcessAction ) );\n           nProcessReturnCode\
    \ = 0; \n       EndIf;\n    EndIf ;\n    \n    If( nConsolCount > 0 );\n       sProcessAction = Expand(\
    \ 'Process:%cThisProcName% successfully created subset %cSubsetOrphanC% from dimension %pDim%:%pHier%.'\
    \ );\n \n       sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode\
    \ = 1;\n\n      If( pLogoutput = 1 );\n          LogOutput('INFO', Expand( sProcessAction ) );   \n\
    \      EndIf;\n    Endif ;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in a hierarchy of the
    target dimension consisting of all orphan elements. Note: An orphan element is defined as a consolidated
    element without children or a leaf element without parent.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy of target\
    \ Dimension that consists of\n# all orphan elements.\n\n# Note:\n# Orphan element is defined as:\n\
    # - Consolidated element without children.\n# - Leaf element without parent.\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncSubsetOrphanC\
    \ = 'Orphan C Elements (no children)';\ncSubsetOrphanN = 'Orphan N Elements (no parents)';\n\n## LogOutput\
    \ parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n###\
    \ Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension:\
    \ ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\n\
    IF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n\
    \  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors\
    \ = 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n   \
    \ nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Create Subsets ###\nIf( nErrors = 0\
    \ );\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanC ) = 1 );\n    HierarchySubsetDeleteAllElements(\
    \ pDim, sHier, cSubsetOrphanC );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanC,\
    \ pTemp );\n  EndIf;\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanN ) = 1 );\n    HierarchySubsetDeleteAllElements(\
    \ pDim, sHier, cSubsetOrphanN );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanN,\
    \ pTemp );\n  EndIf;\nEndIf;\n\n### Populate subsets ###\nnElementCount = DimSiz( pDim|':'|sHier);\n\
    nElementIndex = 1;\nnLeafCount = 0;\nnConsolCount = 0;\nWhile( nElementIndex <= nElementCount );\n\
    \  sElement = ElementName( pDim, sHier, nElementIndex );\n  If( ElementType( pDim, sHier, sElement\
    \ ) @= 'N' & ElementParent( pDim, sHier, sElement, 1 ) @= '' );\n    # N element with no parents\n\
    \    nLeafCount = nLeafCount + 1;\n    HierarchySubsetElementInsert( pDim, sHier, cSubsetOrphanN,\
    \ sElement, nLeafCount );\n  EndIf;\n  If(ElementType(pDim,sHier, sElement) @= 'C' & ElementComponentCount(pDim,\
    \ sHier, sElement) = 0);\n    # C element with no children\n    nConsolCount = nConsolCount + 1;\n\
    \    HierarchySubsetElementInsert( pDim, sHier, cSubsetOrphanC, sElement, nConsolCount );\n  EndIf;\n\
    \  nElementIndex = nElementIndex + 1;\nEnd;\n\n### Tidy up ###\n\n# If no orphans then destroy empty\
    \ subsets\nIf( nErrors = 0 );\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanN ) = 0 );\n\
    \    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanN );\n  EndIf;\n  If( HierarchySubsetGetSize(\
    \ pDim, sHier, cSubsetOrphanC ) = 0 );\n    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanC );\n\
    \  EndIf;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    If( nLeafCount > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully\
    \ created subset %cSubsetOrphanN% from dimension %pDim%:%pHier%.' );\n       sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n       If( pLogoutput\
    \ = 1 );\n           LogOutput('INFO', Expand( sProcessAction ) );\n           nProcessReturnCode\
    \ = 0; \n       EndIf;\n    EndIf ;\n    \n    If( nConsolCount > 0 );\n       sProcessAction = Expand(\
    \ 'Process:%cThisProcName% successfully created subset %cSubsetOrphanC% from dimension %pDim%:%pHier%.'\
    \ );\n \n       sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode\
    \ = 1;\n\n      If( pLogoutput = 1 );\n          LogOutput('INFO', Expand( sProcessAction ) );   \n\
    \      EndIf;\n    Endif ;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der ein statisches Teilset in einer Hierarchie
    der Zieldimension erstellt, welches aus allen Waisenelementen besteht. Ein Waisenelement ist definiert
    als: Ein konsolidiertes Element ohne Kinder oder ein Blattelement ohne Elternteil.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy of target\
    \ Dimension that consists of\n# all orphan elements.\n\n# Note:\n# Orphan element is defined as:\n\
    # - Consolidated element without children.\n# - Leaf element without parent.\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncSubsetOrphanC\
    \ = 'Orphan C Elements (no children)';\ncSubsetOrphanN = 'Orphan N Elements (no parents)';\n\n## LogOutput\
    \ parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n###\
    \ Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension:\
    \ ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\n\
    IF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n\
    \  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors\
    \ = 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n   \
    \ nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Create Subsets ###\nIf( nErrors = 0\
    \ );\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanC ) = 1 );\n    HierarchySubsetDeleteAllElements(\
    \ pDim, sHier, cSubsetOrphanC );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanC,\
    \ pTemp );\n  EndIf;\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanN ) = 1 );\n    HierarchySubsetDeleteAllElements(\
    \ pDim, sHier, cSubsetOrphanN );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanN,\
    \ pTemp );\n  EndIf;\nEndIf;\n\n### Populate subsets ###\nnElementCount = DimSiz( pDim|':'|sHier);\n\
    nElementIndex = 1;\nnLeafCount = 0;\nnConsolCount = 0;\nWhile( nElementIndex <= nElementCount );\n\
    \  sElement = ElementName( pDim, sHier, nElementIndex );\n  If( ElementType( pDim, sHier, sElement\
    \ ) @= 'N' & ElementParent( pDim, sHier, sElement, 1 ) @= '' );\n    # N element with no parents\n\
    \    nLeafCount = nLeafCount + 1;\n    HierarchySubsetElementInsert( pDim, sHier, cSubsetOrphanN,\
    \ sElement, nLeafCount );\n  EndIf;\n  If(ElementType(pDim,sHier, sElement) @= 'C' & ElementComponentCount(pDim,\
    \ sHier, sElement) = 0);\n    # C element with no children\n    nConsolCount = nConsolCount + 1;\n\
    \    HierarchySubsetElementInsert( pDim, sHier, cSubsetOrphanC, sElement, nConsolCount );\n  EndIf;\n\
    \  nElementIndex = nElementIndex + 1;\nEnd;\n\n### Tidy up ###\n\n# If no orphans then destroy empty\
    \ subsets\nIf( nErrors = 0 );\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanN ) = 0 );\n\
    \    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanN );\n  EndIf;\n  If( HierarchySubsetGetSize(\
    \ pDim, sHier, cSubsetOrphanC ) = 0 );\n    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanC );\n\
    \  EndIf;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    If( nLeafCount > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully\
    \ created subset %cSubsetOrphanN% from dimension %pDim%:%pHier%.' );\n       sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n       If( pLogoutput\
    \ = 1 );\n           LogOutput('INFO', Expand( sProcessAction ) );\n           nProcessReturnCode\
    \ = 0; \n       EndIf;\n    EndIf ;\n    \n    If( nConsolCount > 0 );\n       sProcessAction = Expand(\
    \ 'Process:%cThisProcName% successfully created subset %cSubsetOrphanC% from dimension %pDim%:%pHier%.'\
    \ );\n \n       sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode\
    \ = 1;\n\n      If( pLogoutput = 1 );\n          LogOutput('INFO', Expand( sProcessAction ) );   \n\
    \      EndIf;\n    Endif ;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that creates a static subset in a Hierarchy of the
    target dimension consisting of all orphan elements. An orphan element is defined as: A consolidated
    element without children or a leaf element without a parent.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a static subset in a Hierarchy of target\
    \ Dimension that consists of\n# all orphan elements.\n\n# Note:\n# Orphan element is defined as:\n\
    # - Consolidated element without children.\n# - Leaf element without parent.\n#EndRegion @DOC\n\n\
    ### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncSubsetOrphanC\
    \ = 'Orphan C Elements (no children)';\ncSubsetOrphanN = 'Orphan N Elements (no parents)';\n\n## LogOutput\
    \ parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n###\
    \ Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy\
    \ has been passed as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n\
    \    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim,\
    \ 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors\
    \ = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension:\
    \ ' | pDim;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\n\
    IF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n\
    \  sHier = pDim;\nElse;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors\
    \ = 1;\n  sMessage = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n   \
    \ nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Create Subsets ###\nIf( nErrors = 0\
    \ );\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanC ) = 1 );\n    HierarchySubsetDeleteAllElements(\
    \ pDim, sHier, cSubsetOrphanC );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanC,\
    \ pTemp );\n  EndIf;\n  If( HierarchySubsetExists( pDim, sHier, cSubsetOrphanN ) = 1 );\n    HierarchySubsetDeleteAllElements(\
    \ pDim, sHier, cSubsetOrphanN );\n  Else;\n    HierarchySubsetCreate( pDim, sHier, cSubsetOrphanN,\
    \ pTemp );\n  EndIf;\nEndIf;\n\n### Populate subsets ###\nnElementCount = DimSiz( pDim|':'|sHier);\n\
    nElementIndex = 1;\nnLeafCount = 0;\nnConsolCount = 0;\nWhile( nElementIndex <= nElementCount );\n\
    \  sElement = ElementName( pDim, sHier, nElementIndex );\n  If( ElementType( pDim, sHier, sElement\
    \ ) @= 'N' & ElementParent( pDim, sHier, sElement, 1 ) @= '' );\n    # N element with no parents\n\
    \    nLeafCount = nLeafCount + 1;\n    HierarchySubsetElementInsert( pDim, sHier, cSubsetOrphanN,\
    \ sElement, nLeafCount );\n  EndIf;\n  If(ElementType(pDim,sHier, sElement) @= 'C' & ElementComponentCount(pDim,\
    \ sHier, sElement) = 0);\n    # C element with no children\n    nConsolCount = nConsolCount + 1;\n\
    \    HierarchySubsetElementInsert( pDim, sHier, cSubsetOrphanC, sElement, nConsolCount );\n  EndIf;\n\
    \  nElementIndex = nElementIndex + 1;\nEnd;\n\n### Tidy up ###\n\n# If no orphans then destroy empty\
    \ subsets\nIf( nErrors = 0 );\n  If( HierarchySubsetGetSize( pDim, sHier, cSubsetOrphanN ) = 0 );\n\
    \    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanN );\n  EndIf;\n  If( HierarchySubsetGetSize(\
    \ pDim, sHier, cSubsetOrphanC ) = 0 );\n    HierarchySubsetDestroy( pDim, sHier, cSubsetOrphanC );\n\
    \  EndIf;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    If( nLeafCount > 0 );\n       sProcessAction = Expand( 'Process:%cThisProcName% successfully\
    \ created subset %cSubsetOrphanN% from dimension %pDim%:%pHier%.' );\n       sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode = 1;\n       If( pLogoutput\
    \ = 1 );\n           LogOutput('INFO', Expand( sProcessAction ) );\n           nProcessReturnCode\
    \ = 0; \n       EndIf;\n    EndIf ;\n    \n    If( nConsolCount > 0 );\n       sProcessAction = Expand(\
    \ 'Process:%cThisProcName% successfully created subset %cSubsetOrphanC% from dimension %pDim%:%pHier%.'\
    \ );\n \n       sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n       nProcessReturnCode\
    \ = 1;\n\n      If( pLogoutput = 1 );\n          LogOutput('INFO', Expand( sProcessAction ) );   \n\
    \      EndIf;\n    Endif ;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine Top-Level-Hierarchie durch N-Level-Elemente
    erstellt. Diese Hierarchie soll eine Teilmenge aller 'Top-Knoten'-Elemente enthalten, also konsolidierte
    Elemente, die keine Eltern haben.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n\n# This process will Create a Top Level Hierarchy by N-Level Elements\n\
    # that is a subset of all 'top node' elements ( Consolidated elements that have no parents )\n\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pConvertToStatic:%pConvertToStatic%, pAlias:%pAlias%, pTemp:%pTemp%.';\
    \ \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n\n### Validate Parameters ###\n\nnErrors\
    \ = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt(\
    \ pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage\
    \ = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    If( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier\
    \ @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\n\
    Else;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( DnLev( pDim|':'|sHier ) <= 1 );\n  # Create by MDX would return empty set and\
    \ fail so need to abort here\n  nErrors = 1;\n  sMessage = 'Cannot continue, dimension hierarchy is\
    \ flat: ' | pDim|':'|sHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIF;\n\n\
    # Validate subset\nIf( Trim( pSub ) @= '' );\n  pSub = 'Top Level Hierarchies';\nEndIf;\n\n## Validate\
    \ Alias\nsDimAttr = '}ElementAttributes_' | pDim;\nIF(pAlias @<> '' );\n  IF(DimensionExists( sDimAttr\
    \ ) = 0 );\n    sMessage = 'No attributes exist for the dimension: ' | pDim;\n    pAlias = '';\n \
    \ EndIf;\n\n  IF(DIMIX( sDimAttr, pAlias ) = 0 );\n    sMessage = 'The Alias: ' | pAlias | ' does\
    \ not exist in the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n  IF(DTYPE( sDimAttr, pAlias\
    \ ) @<> 'AA' );\n    sMessage = 'The Alias: ' | pAlias | ' is not an Alias in the dimension: ' | sDimAttr;\n\
    \    pAlias = '';\n  EndIf;\nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors\
    \ = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### MDX for creating subset ###\n\nsMDX = '{EXCEPT( {FILTER(\
    \ {TM1SUBSETALL( [' | pDim|':'|sHier | '] )}, MemberToStr( [' |\n       pDim|':'|sHier | '].CurrentMember.Parent\
    \ ) = '' )},' |\n       '{TM1FILTERBYLEVEL( {TM1SUBSETALL( [' | pDim|':'|sHier | '] )},0 )} )}';\n\
    \n### Create Subset ###\n\nIf( nErrors = 0 );\n\n  # For a dynamic subset, the original subset MUST\
    \ be destroyed first or the MDX will fail\n  If( pConvertToStatic = 0 );\n    If( HierarchySubsetExists(\
    \ pDim, sHier, pSub ) = 1 );\n      HierarchySubsetDestroy( pDim, sHier, pSub );\n    EndIf;\n   \
    \ SubsetCreateByMDX( pSub, sMDX, pDim, pTemp );\n\n  # For a static subset the subset does not need\
    \ to be destroyed but its elements need to be deleted first\n  Else;\n    If( HierarchySubsetExists(\
    \ pDim, sHier, pSub ) = 1 );\n      HierarchySubsetDeleteAllElements( pDim, sHier, pSub );\n    Else;\n\
    \      HierarchySubsetCreate( pDim, sHier, pSub, pTemp );\n    EndIf;\n\n    # Create a temporary\
    \ MDX subset for processing\n    sSubsetMDX = cThisProcName |'.' | NumberToString( Int( Rand() * 100000\
    \ ) );\n    # It is unlikely that the subset already exists due to the random number in the subset\
    \ name\n    # However, it the SubsetDestroy is included in case the same random number is generated\n\
    \    If( HierarchySubsetExists( pDim, sHier, sSubsetMDX ) = 1 );\n      HierarchySubsetDestroy( pDim,\
    \ sHier, sSubsetMDX );\n    EndIf;\n    SubsetCreateByMDX( sSubsetMDX, sMDX, pDim, pTemp );\n\n  \
    \  # Transfer the elements from the MDX subset to the static subset\n    nSubsetSize = HierarchySubsetGetSize(\
    \ pDim, sHier,sSubsetMDX );\n    nSubsetIndex = 0;\n    While( nSubsetIndex < nSubsetSize );\n   \
    \   nSubsetIndex = nSubsetIndex + 1;\n      sTemp = HierarchySubsetElementGetIndex (pDim, sHier, sSubsetMDX,\
    \ '', nSubsetIndex);\n      sElement = HierarchySubsetGetElementName( pDim, sHier, sSubsetMDX, nSubsetIndex\
    \ );\n      HierarchySubsetElementInsert( pDim, sHier, pSub, sElement, nSubsetIndex );\n    End;\n\
    \  EndIf;\n\nEndIf;\n\n### Set Alias ##\nIF(pAlias @<> '' );\n  If( nErrors = 0 );\n    HierarchySubsetAliasSet(\
    \ pDim, pHier, pSub, pAlias );\n  EndIf;\nENDIF;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully created\
    \ subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates a top-level hierarchy by N-level elements.
    This hierarchy should be a subset of all 'top node' elements, meaning consolidated elements that have
    no parents.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n\n# This process will Create a Top Level Hierarchy by N-Level Elements\n\
    # that is a subset of all 'top node' elements ( Consolidated elements that have no parents )\n\n#EndRegion\
    \ @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub            = cThisProcName |'_'| cTimeStamp\
    \ |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pDim:%pDim%,\
    \ pHier:%pHier%, pSub:%pSub%, pConvertToStatic:%pConvertToStatic%, pAlias:%pAlias%, pTemp:%pTemp%.';\
    \ \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n\n### Validate Parameters ###\n\nnErrors\
    \ = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension.\
    \ Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt(\
    \ pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim\
    \ ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage\
    \ = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    If( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\nIF(pHier\
    \ @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\n\
    Else;\n  sHier = pHier;\nEndIf;\n\nIF(HierarchyExists(pDim, sHier ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'Invalid dimension Hierarchy: ' | pDim |':'|sHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\nIf( DnLev( pDim|':'|sHier ) <= 1 );\n  # Create by MDX would return empty set and\
    \ fail so need to abort here\n  nErrors = 1;\n  sMessage = 'Cannot continue, dimension hierarchy is\
    \ flat: ' | pDim|':'|sHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIF;\n\n\
    # Validate subset\nIf( Trim( pSub ) @= '' );\n  pSub = 'Top Level Hierarchies';\nEndIf;\n\n## Validate\
    \ Alias\nsDimAttr = '}ElementAttributes_' | pDim;\nIF(pAlias @<> '' );\n  IF(DimensionExists( sDimAttr\
    \ ) = 0 );\n    sMessage = 'No attributes exist for the dimension: ' | pDim;\n    pAlias = '';\n \
    \ EndIf;\n\n  IF(DIMIX( sDimAttr, pAlias ) = 0 );\n    sMessage = 'The Alias: ' | pAlias | ' does\
    \ not exist in the dimension: ' | pDim;\n    pAlias = '';\n  EndIf;\n\n  IF(DTYPE( sDimAttr, pAlias\
    \ ) @<> 'AA' );\n    sMessage = 'The Alias: ' | pAlias | ' is not an Alias in the dimension: ' | sDimAttr;\n\
    \    pAlias = '';\n  EndIf;\nENDIF;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <> 1 );\n    nErrors\
    \ = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n### MDX for creating subset ###\n\nsMDX = '{EXCEPT( {FILTER(\
    \ {TM1SUBSETALL( [' | pDim|':'|sHier | '] )}, MemberToStr( [' |\n       pDim|':'|sHier | '].CurrentMember.Parent\
    \ ) = '' )},' |\n       '{TM1FILTERBYLEVEL( {TM1SUBSETALL( [' | pDim|':'|sHier | '] )},0 )} )}';\n\
    \n### Create Subset ###\n\nIf( nErrors = 0 );\n\n  # For a dynamic subset, the original subset MUST\
    \ be destroyed first or the MDX will fail\n  If( pConvertToStatic = 0 );\n    If( HierarchySubsetExists(\
    \ pDim, sHier, pSub ) = 1 );\n      HierarchySubsetDestroy( pDim, sHier, pSub );\n    EndIf;\n   \
    \ SubsetCreateByMDX( pSub, sMDX, pDim, pTemp );\n\n  # For a static subset the subset does not need\
    \ to be destroyed but its elements need to be deleted first\n  Else;\n    If( HierarchySubsetExists(\
    \ pDim, sHier, pSub ) = 1 );\n      HierarchySubsetDeleteAllElements( pDim, sHier, pSub );\n    Else;\n\
    \      HierarchySubsetCreate( pDim, sHier, pSub, pTemp );\n    EndIf;\n\n    # Create a temporary\
    \ MDX subset for processing\n    sSubsetMDX = cThisProcName |'.' | NumberToString( Int( Rand() * 100000\
    \ ) );\n    # It is unlikely that the subset already exists due to the random number in the subset\
    \ name\n    # However, it the SubsetDestroy is included in case the same random number is generated\n\
    \    If( HierarchySubsetExists( pDim, sHier, sSubsetMDX ) = 1 );\n      HierarchySubsetDestroy( pDim,\
    \ sHier, sSubsetMDX );\n    EndIf;\n    SubsetCreateByMDX( sSubsetMDX, sMDX, pDim, pTemp );\n\n  \
    \  # Transfer the elements from the MDX subset to the static subset\n    nSubsetSize = HierarchySubsetGetSize(\
    \ pDim, sHier,sSubsetMDX );\n    nSubsetIndex = 0;\n    While( nSubsetIndex < nSubsetSize );\n   \
    \   nSubsetIndex = nSubsetIndex + 1;\n      sTemp = HierarchySubsetElementGetIndex (pDim, sHier, sSubsetMDX,\
    \ '', nSubsetIndex);\n      sElement = HierarchySubsetGetElementName( pDim, sHier, sSubsetMDX, nSubsetIndex\
    \ );\n      HierarchySubsetElementInsert( pDim, sHier, pSub, sElement, nSubsetIndex );\n    End;\n\
    \  EndIf;\n\nEndIf;\n\n### Set Alias ##\nIF(pAlias @<> '' );\n  If( nErrors = 0 );\n    HierarchySubsetAliasSet(\
    \ pDim, pHier, pSub, pAlias );\n  EndIf;\nENDIF;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully created\
    \ subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der öffentliche Teilmengen aus ausgewählten
    Dimensionen und Hierarchien löscht. Die Dimensionen, Hierarchien und Teilmengen können als durch ein
    Trennzeichen geteilte Liste angegeben werden. Platzhalter in Form von ''*'' und ''?'' sind akzeptiert.
    Beachte die folgenden Parameter: pDim, um die Dimensionen anzugeben, von denen Teilmengen gelöscht
    werden sollen; pHier, um anzugeben, von welchen Hierarchien die Teilmengen gelöscht werden sollen;
    pSub, um die zu löschenden Teilmengen zu spezifizieren; pDelim, um einen benutzerdefinierten Trennzeichen
    zu definieren; und pMode, um entweder alle gefundenen Teilmengen zu zerstören oder nur zu leeren.
    Stelle sicher, dass du die Bedeutung und Verwendung jedes Parameters verstehst und Beispiele für die
    Platzhaltersuche bereitstellst.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes public subsets from selected dimension and\
    \ hierarchies. Dimensions, hierarchies\n# and subsets can be specified as a delimited list. Wildcards\
    \ are accepted as `*` and `?` characters.\n\n# Note:\n# - pDim: To specify which dimensions to delete\
    \ subsets from use the pDim parameter.\n#   - To delete subsets from a single dimension only just\
    \ specify that dimension name e.g. `Product`.\n#   - To delete subsets from multiple dimensions specify\
    \ each dimension name separated by a delimiter\n#     e.g. `Product & Customer & Account`.\n#   -\
    \ To delete subsets from all dimensions then leave pDim parameter blank or supply `ALL`.\n#   - If\
    \ any invalid dimensions are specified they will be skipped but the process will continue to \n# \
    \    process the other dimensions.\n#   - When specifying dimension names wildcards are permitted\
    \ and all dimensions that match the \n#     wildcard search string will be searched - for syntax see\
    \ below pSub parameter.\n# - pHier: To specify which hierarchies to delete subsets from use the pHier\
    \ parameter.\n#   - To specify default hierachy, leave parameter value empty.\n#   - To specify all\
    \ available hierarchies, set parameter value to `*`.\n#   - When specifying hierarchy names wildcards\
    \ are permitted and all hierachies that match the wildcard \n#     search string will be searched\
    \ - for syntax see below pSub parameter.\n# - pSub: To specify which subsets to delete use the pSub\
    \ parameter.\n#   - This parameter must be specified, a blank value will cause the process to terminate.\n\
    #   - To delete a single subset only just specify that subset name e.g. `SmallProducts`.\n#   - To\
    \ delete multiple subsets specify each subset name separated by a delimiter\n#     e.g. `SmallProducts\
    \ & LargeProducts`.\n# - pDelim: The delimiter is used when specifying multiple dimensions and/or\
    \ multiple subsets.\n#   - The default delimiter is `&`.\n#   - Any delimiter can be used by specifying\
    \ a value for pDelim.\n#   - Choose a delimiter that won't be used in either the wildcard search strings\
    \ or dimension names.\n# - pMode:\n#   - When set to value less or equal to `1`: all found subsets\
    \ will be destroyed.\n#   - When set to value of `2`: all found subsets will be emptied.  \n# __Example__:\n\
    # - When specifying subset names wildcards are permitted and all subsets that match the wildcard \n\
    #   search string will be deleted:\n#     - The wildcard search string follows the same format as\
    \ wildcards used in Subset Editor.\n#     - To delete all subsets that __start__ with a specific string\
    \ use a trailing `*` e.g. `Bedrock*`.\n#     - To delete all subsets that __end__ in a specific string\
    \ use a leading `*` e.g. `*Bedrock`.\n#     - To delete all subsets that __contain__ a specific string\
    \ use leading and trailing `*`'s e.g. `*Bedrock*`.\n#     - To delete a single specific subset only\
    \ don't use `*`'s at all e.g. `Bedrock`.\n#     - To specify multiple search stings list them all\
    \ separated by a delimiter e.g. `Bedrock* & *Temp & *Test*`.\n#     - Similarly you can use `?` as\
    \ wildcard specifying one character - usage is similar as above specified examples for `*`.\n#   \
    \  - Specific subset names and wildcard based names can both be used together e.g. `SalesByProduct;Bedrock*`\n\
    #EndRegion @DOC\n\n### Global Variables\n\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants\n\ncThisProcName     = GetProcessName();\ncTimeStamp     \
    \   = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncTempSubDim       = cThisProcName\
    \ |'_Dim_'| cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo    \
    \      = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pMode:%pMode%.';\n\
    cAll              = 'ALL';\ncDimDimensions    = '}Dimensions';\ncCharAny          = '?';\ncStringAny\
    \        = '*';\ncCharDimHier      = ':';\n\n### Flag - quit before parsing of parameters\nnSkipParsing\
    \      = 0;\nsProcessAction    = '';\n\n### LogOutput parameters\nIF( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\n\nnErrors = 0;\n\nIf( Scan( '*', pDim\
    \ ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n\
    \    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into\
    \ dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n \
    \   pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate delimiter\nIf(\
    \ Trim( pDelim ) @= '' );\n  pDelim = '&';\nEndIf;\n\n### Validate dimension\nIf( Trim( pDim ) @=\
    \ '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\nIf( SCAN( cCharAny, pDim ) = 0 & SCAN( cStringAny, pDim ) = 0 & SCAN( pDelim, pDim\
    \ ) = 0 & SCAN( cCharDimHier, pDim ) > 0 & pHier @= '' );\n    pHier = SubSt( pDim, SCAN( cCharDimHier,\
    \ pDim ) + 1, Long( pDim ) );\n    pDim = SubSt( pDim, 1, SCAN( cCharDimHier, pDim ) - 1 );\nEndIf;\n\
    \n## Validate Hierarchy\n\nIF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy:\
    \ ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf(\
    \ Trim( pHier ) @<> '' );\n  sHier = pHier;\nEndIf;\n\n### Validate subset\nIf( Trim( pSub ) @= ''\
    \ );\n  nErrors = 1;\n  sMessage = 'No subsets specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n### Destroy subset if exactly specified in parameters - important for recursive calls\n\
    If ( SCAN( cCharAny, pDim ) = 0 & SCAN( cStringAny, pDim ) = 0 & SCAN( pDelim, pDim ) = 0 &\n    \
    \ SCAN( cCharAny, pHier ) = 0 & SCAN( cStringAny, pHier ) = 0 & SCAN( pDelim, pHier ) = 0 &\n    \
    \ SCAN( cCharAny, pSub ) = 0 & SCAN( cStringAny, pSub ) = 0 & SCAN( pDelim, pSub ) = 0 );\n  If (\
    \ DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = Expand( 'Dimension %pDim% doesn''t\
    \ exist.' );\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\n  EndIf;\n  If ( pHier\
    \ @<> '' & HierarchyExists( pDim, pHier ) = 0 );\n    nErrors = 1;\n    sMessage = Expand( 'Hierarchy\
    \ %pHier% doesn''t exist in dimension %pDim%.' );\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\n  EndIf;\n  If ( HierarchySubsetExists( pDim, pHier, pSub ) = 0 );\n    nErrors = 1;\n\
    \    sMessage = Expand( 'Subset %pSub% doesn''t exist in hierarchy %pHier% of dimension %pDim%.' );\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\n  EndIf;\n  If ( pHier @=\
    \ '' );\n    pHier = pDim;\n  EndIf;\n  If ( pMode <= 1 );\n    HierarchySubsetDestroy( pDim, pHier,\
    \ pSub );\n    sProcessAction = Expand( 'Destroyed subset %pSub% on dimension %pDim% in hierarchy\
    \ %pHier%.' );\n  ElseIf ( pMode = 2 );\n    HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\n\
    \    sProcessAction = Expand( 'Deleted all elements from subset %pSub% on dimension %pDim% in hierarchy\
    \ %pHier%.' );\n  EndIf;\n  ### We don't need to parse any parameters as this was exact match, so\
    \ we will finish processing\n  nSkipParsing = 1;\nEndIf;\n\n### Need to process parameters before\
    \ cleaning\nIf ( nSkipParsing = 0 );\n  \n  ### Validate all dimension case\n  If( Trim( pDim ) @=\
    \ '*' );\n    pDim = cAll;\n  EndIf;\n  \n  ### Handle All dimensions or a dimension list\n  ### We\
    \ will exclude hierarchies in this step and will filter them in connection with subsets in later steps\n\
    \  If ( TRIM( pDim ) @= cAll );\n    sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}' );\n  Else;\n    sDimTokenizer = TRIM( pDim );\n    sMDX = '';\n    ### Loop and\
    \ tokenize dimension list\n    While ( sDimTokenizer @<> '' );\n      nPos = SCAN( pDelim, sDimTokenizer\
    \ );\n      If ( nPos = 0 );\n        nPos = LONG( sDimTokenizer ) + 1;\n      EndIf;\n      sSearchDim\
    \ = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n      If( sMDX @= '' );\n        sMDX = Expand(\
    \ '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}, '%sSearchDim%')}' );\n      Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n      EndIf;\n\
    \      ### Consume dimension and delimiter\n      sDimTokenizer = TRIM( DELET( sDimTokenizer, 1, nPos\
    \ + LONG( pDelim ) - 1 ) );\n    End;\n    sMDX = Expand( '{%sMDX%}' );\n  EndIf;\n  \n  ### Create\
    \ dimensions subset\n  If ( SubsetExists( cDimDimensions, cTempSub ) = 1 );\n    SubsetMDXSet( cDimDimensions,\
    \ cTempSub, sMDX );\n  Else;\n    SubsetCreatebyMDX( cTempSub, sMDX, cDimDimensions, 1 );\n  EndIf;\n\
    \  nMaxDim = SubsetGetSize( cDimDimensions, cTempSub );\n  \n  ### Loop through dimensions\n  nCurDim\
    \ = 1;\n  While ( nCurDim <= nMaxDim );\n    sCurDim = SubsetGetElementName( cDimDimensions, cTempSub,\
    \ nCurDim );\n    sCurSubDim = Expand( '}Subsets_%sCurDim%' );\n    ### We will lookup subsets in\
    \ }Subsets_ dimension of current dim\n    If ( DimensionExists( sCurSubDim ) <> 0 );\n      If ( pHier\
    \ @= '' );\n        sHier = sCurDim;\n      Else;\n        sHier = pHier;\n      EndIf;\n      sHierTokenizer\
    \ = TRIM( sHier );\n      sMDX = '';\n      ### Loop and tokenize hierarchies list\n      While (\
    \ sHierTokenizer @<> '' );\n        nPos = SCAN( pDelim, sHierTokenizer );\n        If ( nPos = 0\
    \ );\n          nPos = LONG( sHierTokenizer ) + 1;\n        EndIf;\n        sSearchHier = TRIM( SUBST(\
    \ sHierTokenizer, 1, nPos - 1 ) );\n        sSubTokenizer = TRIM( pSub );\n        ### Loop and tokenize\
    \ subset list\n        While ( sSubTokenizer @<> '' );\n          nPos1 = SCAN( pDelim, sSubTokenizer\
    \ );\n          If ( nPos1 = 0 );\n            nPos1 = LONG( sSubTokenizer ) + 1;\n          EndIf;\n\
    \          sSearchSubset = TRIM( SUBST( sSubTokenizer, 1, nPos1 - 1 ) );\n          If ( sSearchHier\
    \ @<> '*' );\n            If ( sSearchHier @= sCurDim );\n              sSearchMDX = sSearchSubset;\n\
    \            Else;\n              sSearchMDX = Expand( '%sSearchHier%:%sSearchSubset%' );\n      \
    \      EndIf;\n            If( sMDX @= '' );\n              sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL(\
    \ [%sCurSubDim%] ), '%sSearchMDX%')}' );\n            Else;\n              sMDX = Expand( '%sMDX%\
    \ + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX%')}' );\n            EndIf;\n\
    \          Else;\n            # We need to handle special case of * specified as hierarchy filter\
    \ - this is interpreted as ALL hierarchies - otherwise we would be skipping default hierarchy\n  \
    \          sSearchMDX1 = Expand( '%sSearchHier%:%sSearchSubset%' );\n            sSearchMDX2 = Expand(\
    \ '%sSearchSubset%' );\n            If( sMDX @= '' );\n              sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL(\
    \ [%sCurSubDim%] ), '%sSearchMDX1%')} + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX2%')}'\
    \ );\n            Else;\n              sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN(TM1SUBSETALL(\
    \ [%sCurSubDim%] ), '%sSearchMDX1%')} + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX2%')}'\
    \ );\n            EndIf;\n          EndIf;\n          ### Consume subset and delimiter\n         \
    \ sSubTokenizer = TRIM( DELET( sSubTokenizer, 1, nPos1 + LONG( pDelim ) - 1 ) );\n        End;\n \
    \       ### Consume hierarchy and delimiter\n        sHierTokenizer = TRIM( DELET( sHierTokenizer,\
    \ 1, nPos + LONG( pDelim )- 1 ) );\n      End;\n      ### Query the hierarchies/subsets\n      If\
    \ ( SubsetExists( sCurSubDim, cTempSub ) = 1 );\n        SubsetMDXSet( sCurSubDim, cTempSub, sMDX\
    \ );\n      Else;\n        SubsetCreatebyMDX( cTempSub, sMDX, sCurSubDim, 1 );\n      EndIf;\n   \
    \   nMaxSubs = SubsetGetSize( sCurSubDim, cTempSub );\n      nCurSubs = nMaxSubs;\n      While ( nCurSubs\
    \ >= 1 );\n        sCurSubs = SubsetGetElementName( sCurSubDim, cTempSub, nCurSubs );\n        nColPos\
    \ = SCAN( ':', sCurSubs );\n        If ( nColPos = 0 );\n          sHierarchy = sCurDim;\n       \
    \   sSubset = sCurSubs;\n        Else;\n          sHierarchy = SUBST( sCurSubs, 1, nColPos - 1 );\n\
    \          sSubset = SUBST( sCurSubs, nColPos + 1, LONG(sCurSubs) - nColPos ); \n        EndIf;\n\
    \        If ( pMode <= 1 );\n          ### Recursive call to consume process error in this process\
    \ and not to broadcast it to the parent caller process\n          ExecuteProcess( cThisProcName,\n\
    \            'pStrictErrorHandling', pStrictErrorHandling,\n            'pLogOutput', pLogOutput,\n\
    \            'pDim', sCurDim,\n            'pHier', sHierarchy,\n            'pSub', sSubset,\n  \
    \          'pDelim', pDelim,\n            'pMode', pMode\n          );\n        ElseIf ( pMode = 2\
    \ );\n          ### No need for a recursive call as we suppose this call is not going to raise a process\
    \ error - this will save processing time significantly\n          HierarchySubsetDeleteAllElements(\
    \ pDim, pHier, pSub );\n          sProcessAction = Expand( 'Deleted all elements from subset %pSub%\
    \ on dimension %pDim% in hierarchy %pHier%.' );\n        EndIf;  \n        nCurSubs = nCurSubs - 1;\n\
    \      End;\n    EndIf;\n    nCurDim = nCurDim + 1;\n  End;\nEndIf;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Develop an IBM Turbo Integrator process that deletes public subsets from selected dimensions
    and hierarchies. Dimensions, hierarchies, and subsets can be specified as a delimited list, with wildcards
    accepted in the form of ''*'' and ''?''. Note the following parameters: pDim for specifying the dimensions
    from which subsets should be deleted; pHier for specifying the hierarchies from which subsets should
    be deleted; pSub to specify the subsets to be deleted; pDelim to define a custom delimiter; and pMode
    to either destroy or just empty all found subsets. Ensure you understand the significance and usage
    of each parameter and provide examples for wildcard searches.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process deletes public subsets from selected dimension and\
    \ hierarchies. Dimensions, hierarchies\n# and subsets can be specified as a delimited list. Wildcards\
    \ are accepted as `*` and `?` characters.\n\n# Note:\n# - pDim: To specify which dimensions to delete\
    \ subsets from use the pDim parameter.\n#   - To delete subsets from a single dimension only just\
    \ specify that dimension name e.g. `Product`.\n#   - To delete subsets from multiple dimensions specify\
    \ each dimension name separated by a delimiter\n#     e.g. `Product & Customer & Account`.\n#   -\
    \ To delete subsets from all dimensions then leave pDim parameter blank or supply `ALL`.\n#   - If\
    \ any invalid dimensions are specified they will be skipped but the process will continue to \n# \
    \    process the other dimensions.\n#   - When specifying dimension names wildcards are permitted\
    \ and all dimensions that match the \n#     wildcard search string will be searched - for syntax see\
    \ below pSub parameter.\n# - pHier: To specify which hierarchies to delete subsets from use the pHier\
    \ parameter.\n#   - To specify default hierachy, leave parameter value empty.\n#   - To specify all\
    \ available hierarchies, set parameter value to `*`.\n#   - When specifying hierarchy names wildcards\
    \ are permitted and all hierachies that match the wildcard \n#     search string will be searched\
    \ - for syntax see below pSub parameter.\n# - pSub: To specify which subsets to delete use the pSub\
    \ parameter.\n#   - This parameter must be specified, a blank value will cause the process to terminate.\n\
    #   - To delete a single subset only just specify that subset name e.g. `SmallProducts`.\n#   - To\
    \ delete multiple subsets specify each subset name separated by a delimiter\n#     e.g. `SmallProducts\
    \ & LargeProducts`.\n# - pDelim: The delimiter is used when specifying multiple dimensions and/or\
    \ multiple subsets.\n#   - The default delimiter is `&`.\n#   - Any delimiter can be used by specifying\
    \ a value for pDelim.\n#   - Choose a delimiter that won't be used in either the wildcard search strings\
    \ or dimension names.\n# - pMode:\n#   - When set to value less or equal to `1`: all found subsets\
    \ will be destroyed.\n#   - When set to value of `2`: all found subsets will be emptied.  \n# __Example__:\n\
    # - When specifying subset names wildcards are permitted and all subsets that match the wildcard \n\
    #   search string will be deleted:\n#     - The wildcard search string follows the same format as\
    \ wildcards used in Subset Editor.\n#     - To delete all subsets that __start__ with a specific string\
    \ use a trailing `*` e.g. `Bedrock*`.\n#     - To delete all subsets that __end__ in a specific string\
    \ use a leading `*` e.g. `*Bedrock`.\n#     - To delete all subsets that __contain__ a specific string\
    \ use leading and trailing `*`'s e.g. `*Bedrock*`.\n#     - To delete a single specific subset only\
    \ don't use `*`'s at all e.g. `Bedrock`.\n#     - To specify multiple search stings list them all\
    \ separated by a delimiter e.g. `Bedrock* & *Temp & *Test*`.\n#     - Similarly you can use `?` as\
    \ wildcard specifying one character - usage is similar as above specified examples for `*`.\n#   \
    \  - Specific subset names and wildcard based names can both be used together e.g. `SalesByProduct;Bedrock*`\n\
    #EndRegion @DOC\n\n### Global Variables\n\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants\n\ncThisProcName     = GetProcessName();\ncTimeStamp     \
    \   = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub          = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncTempSubDim       = cThisProcName\
    \ |'_Dim_'| cTimeStamp |'_'| cRandomInt;\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\n\
    cMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo    \
    \      = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pMode:%pMode%.';\n\
    cAll              = 'ALL';\ncDimDimensions    = '}Dimensions';\ncCharAny          = '?';\ncStringAny\
    \        = '*';\ncCharDimHier      = ':';\n\n### Flag - quit before parsing of parameters\nnSkipParsing\
    \      = 0;\nsProcessAction    = '';\n\n### LogOutput parameters\nIF( pLogoutput = 1 );\n  LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\n\nnErrors = 0;\n\nIf( Scan( '*', pDim\
    \ ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @= '' );\n\
    \    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier into\
    \ dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n \
    \   pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n### Validate delimiter\nIf(\
    \ Trim( pDelim ) @= '' );\n  pDelim = '&';\nEndIf;\n\n### Validate dimension\nIf( Trim( pDim ) @=\
    \ '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\nIf( SCAN( cCharAny, pDim ) = 0 & SCAN( cStringAny, pDim ) = 0 & SCAN( pDelim, pDim\
    \ ) = 0 & SCAN( cCharDimHier, pDim ) > 0 & pHier @= '' );\n    pHier = SubSt( pDim, SCAN( cCharDimHier,\
    \ pDim ) + 1, Long( pDim ) );\n    pDim = SubSt( pDim, 1, SCAN( cCharDimHier, pDim ) - 1 );\nEndIf;\n\
    \n## Validate Hierarchy\n\nIF(pHier @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy:\
    \ ' | pDim |':'|pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf(\
    \ Trim( pHier ) @<> '' );\n  sHier = pHier;\nEndIf;\n\n### Validate subset\nIf( Trim( pSub ) @= ''\
    \ );\n  nErrors = 1;\n  sMessage = 'No subsets specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n### Destroy subset if exactly specified in parameters - important for recursive calls\n\
    If ( SCAN( cCharAny, pDim ) = 0 & SCAN( cStringAny, pDim ) = 0 & SCAN( pDelim, pDim ) = 0 &\n    \
    \ SCAN( cCharAny, pHier ) = 0 & SCAN( cStringAny, pHier ) = 0 & SCAN( pDelim, pHier ) = 0 &\n    \
    \ SCAN( cCharAny, pSub ) = 0 & SCAN( cStringAny, pSub ) = 0 & SCAN( pDelim, pSub ) = 0 );\n  If (\
    \ DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage = Expand( 'Dimension %pDim% doesn''t\
    \ exist.' );\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\n  EndIf;\n  If ( pHier\
    \ @<> '' & HierarchyExists( pDim, pHier ) = 0 );\n    nErrors = 1;\n    sMessage = Expand( 'Hierarchy\
    \ %pHier% doesn''t exist in dimension %pDim%.' );\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\n  EndIf;\n  If ( HierarchySubsetExists( pDim, pHier, pSub ) = 0 );\n    nErrors = 1;\n\
    \    sMessage = Expand( 'Subset %pSub% doesn''t exist in hierarchy %pHier% of dimension %pDim%.' );\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n    EndIf;\n  EndIf;\n  If ( pHier @=\
    \ '' );\n    pHier = pDim;\n  EndIf;\n  If ( pMode <= 1 );\n    HierarchySubsetDestroy( pDim, pHier,\
    \ pSub );\n    sProcessAction = Expand( 'Destroyed subset %pSub% on dimension %pDim% in hierarchy\
    \ %pHier%.' );\n  ElseIf ( pMode = 2 );\n    HierarchySubsetDeleteAllElements( pDim, pHier, pSub );\n\
    \    sProcessAction = Expand( 'Deleted all elements from subset %pSub% on dimension %pDim% in hierarchy\
    \ %pHier%.' );\n  EndIf;\n  ### We don't need to parse any parameters as this was exact match, so\
    \ we will finish processing\n  nSkipParsing = 1;\nEndIf;\n\n### Need to process parameters before\
    \ cleaning\nIf ( nSkipParsing = 0 );\n  \n  ### Validate all dimension case\n  If( Trim( pDim ) @=\
    \ '*' );\n    pDim = cAll;\n  EndIf;\n  \n  ### Handle All dimensions or a dimension list\n  ### We\
    \ will exclude hierarchies in this step and will filter them in connection with subsets in later steps\n\
    \  If ( TRIM( pDim ) @= cAll );\n    sMDX = Expand( '{FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}' );\n  Else;\n    sDimTokenizer = TRIM( pDim );\n    sMDX = '';\n    ### Loop and\
    \ tokenize dimension list\n    While ( sDimTokenizer @<> '' );\n      nPos = SCAN( pDelim, sDimTokenizer\
    \ );\n      If ( nPos = 0 );\n        nPos = LONG( sDimTokenizer ) + 1;\n      EndIf;\n      sSearchDim\
    \ = TRIM( SUBST( sDimTokenizer, 1, nPos - 1 ) );\n      If( sMDX @= '' );\n        sMDX = Expand(\
    \ '{TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]), INSTR([%cDimDimensions%].CurrentMember.Name,\
    \ '':'' ) = 0 )}, '%sSearchDim%')}' );\n      Else;\n        sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN({FILTER(TM1SUBSETALL([%cDimDimensions%]),\
    \ INSTR([%cDimDimensions%].CurrentMember.Name, '':'' ) = 0 )}, '%sSearchDim%')}' );\n      EndIf;\n\
    \      ### Consume dimension and delimiter\n      sDimTokenizer = TRIM( DELET( sDimTokenizer, 1, nPos\
    \ + LONG( pDelim ) - 1 ) );\n    End;\n    sMDX = Expand( '{%sMDX%}' );\n  EndIf;\n  \n  ### Create\
    \ dimensions subset\n  If ( SubsetExists( cDimDimensions, cTempSub ) = 1 );\n    SubsetMDXSet( cDimDimensions,\
    \ cTempSub, sMDX );\n  Else;\n    SubsetCreatebyMDX( cTempSub, sMDX, cDimDimensions, 1 );\n  EndIf;\n\
    \  nMaxDim = SubsetGetSize( cDimDimensions, cTempSub );\n  \n  ### Loop through dimensions\n  nCurDim\
    \ = 1;\n  While ( nCurDim <= nMaxDim );\n    sCurDim = SubsetGetElementName( cDimDimensions, cTempSub,\
    \ nCurDim );\n    sCurSubDim = Expand( '}Subsets_%sCurDim%' );\n    ### We will lookup subsets in\
    \ }Subsets_ dimension of current dim\n    If ( DimensionExists( sCurSubDim ) <> 0 );\n      If ( pHier\
    \ @= '' );\n        sHier = sCurDim;\n      Else;\n        sHier = pHier;\n      EndIf;\n      sHierTokenizer\
    \ = TRIM( sHier );\n      sMDX = '';\n      ### Loop and tokenize hierarchies list\n      While (\
    \ sHierTokenizer @<> '' );\n        nPos = SCAN( pDelim, sHierTokenizer );\n        If ( nPos = 0\
    \ );\n          nPos = LONG( sHierTokenizer ) + 1;\n        EndIf;\n        sSearchHier = TRIM( SUBST(\
    \ sHierTokenizer, 1, nPos - 1 ) );\n        sSubTokenizer = TRIM( pSub );\n        ### Loop and tokenize\
    \ subset list\n        While ( sSubTokenizer @<> '' );\n          nPos1 = SCAN( pDelim, sSubTokenizer\
    \ );\n          If ( nPos1 = 0 );\n            nPos1 = LONG( sSubTokenizer ) + 1;\n          EndIf;\n\
    \          sSearchSubset = TRIM( SUBST( sSubTokenizer, 1, nPos1 - 1 ) );\n          If ( sSearchHier\
    \ @<> '*' );\n            If ( sSearchHier @= sCurDim );\n              sSearchMDX = sSearchSubset;\n\
    \            Else;\n              sSearchMDX = Expand( '%sSearchHier%:%sSearchSubset%' );\n      \
    \      EndIf;\n            If( sMDX @= '' );\n              sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL(\
    \ [%sCurSubDim%] ), '%sSearchMDX%')}' );\n            Else;\n              sMDX = Expand( '%sMDX%\
    \ + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX%')}' );\n            EndIf;\n\
    \          Else;\n            # We need to handle special case of * specified as hierarchy filter\
    \ - this is interpreted as ALL hierarchies - otherwise we would be skipping default hierarchy\n  \
    \          sSearchMDX1 = Expand( '%sSearchHier%:%sSearchSubset%' );\n            sSearchMDX2 = Expand(\
    \ '%sSearchSubset%' );\n            If( sMDX @= '' );\n              sMDX = Expand( '{TM1FILTERBYPATTERN(TM1SUBSETALL(\
    \ [%sCurSubDim%] ), '%sSearchMDX1%')} + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX2%')}'\
    \ );\n            Else;\n              sMDX = Expand( '%sMDX% + {TM1FILTERBYPATTERN(TM1SUBSETALL(\
    \ [%sCurSubDim%] ), '%sSearchMDX1%')} + {TM1FILTERBYPATTERN(TM1SUBSETALL( [%sCurSubDim%] ), '%sSearchMDX2%')}'\
    \ );\n            EndIf;\n          EndIf;\n          ### Consume subset and delimiter\n         \
    \ sSubTokenizer = TRIM( DELET( sSubTokenizer, 1, nPos1 + LONG( pDelim ) - 1 ) );\n        End;\n \
    \       ### Consume hierarchy and delimiter\n        sHierTokenizer = TRIM( DELET( sHierTokenizer,\
    \ 1, nPos + LONG( pDelim )- 1 ) );\n      End;\n      ### Query the hierarchies/subsets\n      If\
    \ ( SubsetExists( sCurSubDim, cTempSub ) = 1 );\n        SubsetMDXSet( sCurSubDim, cTempSub, sMDX\
    \ );\n      Else;\n        SubsetCreatebyMDX( cTempSub, sMDX, sCurSubDim, 1 );\n      EndIf;\n   \
    \   nMaxSubs = SubsetGetSize( sCurSubDim, cTempSub );\n      nCurSubs = nMaxSubs;\n      While ( nCurSubs\
    \ >= 1 );\n        sCurSubs = SubsetGetElementName( sCurSubDim, cTempSub, nCurSubs );\n        nColPos\
    \ = SCAN( ':', sCurSubs );\n        If ( nColPos = 0 );\n          sHierarchy = sCurDim;\n       \
    \   sSubset = sCurSubs;\n        Else;\n          sHierarchy = SUBST( sCurSubs, 1, nColPos - 1 );\n\
    \          sSubset = SUBST( sCurSubs, nColPos + 1, LONG(sCurSubs) - nColPos ); \n        EndIf;\n\
    \        If ( pMode <= 1 );\n          ### Recursive call to consume process error in this process\
    \ and not to broadcast it to the parent caller process\n          ExecuteProcess( cThisProcName,\n\
    \            'pStrictErrorHandling', pStrictErrorHandling,\n            'pLogOutput', pLogOutput,\n\
    \            'pDim', sCurDim,\n            'pHier', sHierarchy,\n            'pSub', sSubset,\n  \
    \          'pDelim', pDelim,\n            'pMode', pMode\n          );\n        ElseIf ( pMode = 2\
    \ );\n          ### No need for a recursive call as we suppose this call is not going to raise a process\
    \ error - this will save processing time significantly\n          HierarchySubsetDeleteAllElements(\
    \ pDim, pHier, pSub );\n          sProcessAction = Expand( 'Deleted all elements from subset %pSub%\
    \ on dimension %pDim% in hierarchy %pHier%.' );\n        EndIf;  \n        nCurSubs = nCurSubs - 1;\n\
    \      End;\n    EndIf;\n    nCurDim = nCurDim + 1;\n  End;\nEndIf;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted subset %pSub% from dimension %pDim%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der es ermöglicht, bestimmte Elemente aus einer
    Teilmenge in einer Hierarchie der Ziel-Dimension zu entfernen. Beachte, dass Platzhalterzeichen wie
    `*` und `?` in der Liste der auszuschließenden Elemente akzeptiert werden. Wenn ein Element auf Blattebene
    angegeben wird, wird es eigenständig entfernt. Bei Angabe eines konsolidierten Elements wird es zusammen
    mit seinen Nachkommen entfernt. Vorsicht: Die Zielhierarchie darf nicht ''Leaves'' sein.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will remove specified elements from a subset in a Hierarchy\
    \ of target Dimension.\n# Wildcard characters `*`and `?` are accepted in list of elements to be excluded.\n\
    \n# Note:\n# - If a leaf level element is specified, it will be removed on its own.\n# - If a consolidated\
    \ element is specified it will be removed as well as its descendants.\n\n# Caution: Target hierarchy\
    \ cannot be `Leaves`.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub    \
    \        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pExclusions:%pExclusions%, pDelim:%pDelim%,\
    \ pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier\
    \       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan(\
    \ ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n\
    \  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\n\nIF(pHier\
    \ @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\n\
    Else;\n  sHier = pHier;\nEndIf;\n\nIf( HierarchyExists( pDim, sHier ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'The Hierachy ' | sHier | ' does not exists.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pSub ) @= '' );\n  nErrors = 1;\n  sMessage = 'No subset\
    \ specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( HierarchySubsetExists(\
    \ pDim,sHier, pSub ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid subset: ' | pSub | ' in dimension:Hierarchy\
    \ ' | pDim |':' | sHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n#\
    \ Validate Elements\nIf( Trim( pExclusions ) @= '' );\n  nErrors = 1;\n  sMessage = 'No Elements specified';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate delimiter\nIf( pExclusions\
    \ @<> '' & pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Process Elements ###\n\
    If(nErrors = 0);\n  nDelimIndex = 1;\n  sExclusions = pExclusions;\n\n  While( nDelimIndex <> 0 &\
    \ Long( sExclusions ) > 0 );\n\n    nDelimIndex = Scan( pDelim, sExclusions );\n    If( nDelimIndex\
    \ <> 0 );\n      sExclusion = Trim( SubSt( sExclusions, 1, nDelimIndex - 1 ) );\n      sExclusions\
    \ = Trim( SubSt( sExclusions, nDelimIndex + Long( pDelim ), Long( sExclusions ) ) );\n    Else;\n\
    \      sExclusion = Trim( sExclusions );\n    EndIf;\n    If(Scan('*',sExclusion) = 0 & Scan('?',sExclusion)\
    \ = 0);\n      # Check that Element is present in the dimension\n      If( ElementIndex ( pDim, sHier,\
    \ sExclusion ) <> 0 );\n        sExclusion = HierarchyElementPrincipalName( pDim, sHier, sExclusion\
    \ );\n        # Work through subset and remove Element\n        nSubsetIndex = 1;\n        nSubsetSize\
    \ = HierarchySubsetGetSize( pDim, sHier, pSub );\n        While( nSubsetIndex <= nSubsetSize );\n\
    \          sTemp = HierarchySubsetElementGetIndex (pDim, sHier, pSub, '', nSubsetIndex);\n       \
    \   sElement = HierarchySubsetGetElementName( pDim, sHier, pSub, nSubsetIndex );\n          # If Element\
    \ is found or a descendant of the Element is found the remove from subset\n          If( sElement\
    \ @= sExclusion % ElementIsAncestor( pDim, sHier, sExclusion, sElement ) = 1 );\n            sTemp\
    \ = HierarchySubsetElementGetIndex (pDim, sHier, pSub, '', nSubsetIndex);\n            HierarchySubsetElementDelete\
    \ ( pDim, sHier, pSub, nSubsetIndex );\n            nSubsetSize = nSubsetSize - 1;\n          Else;\n\
    \            nSubsetIndex = nSubsetIndex + 1;\n          EndIf;\n        End;\n      \n      EndIf;\n\
    \    Else;\n      # Wildcard search string\n        sExclusion = '''|sExclusion|''';\n        stempSub\
    \ = cThisProcName| cRandomInt;\n        sProc = '}bedrock.hier.sub.create.bymdx';\n        sMdx =\
    \ '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |pDim|':'|sHier |' ])},'| sExclusion| ')}';\n        ExecuteProcess(sProc,\n\
    \                      'pStrictErrorHandling', pStrictErrorHandling,\n                    \t'pDim',pDim,\n\
    \                    \t'pHier',sHier,\n                    \t'pSub',stempSub,\n                  \
    \  \t'pMDXExpr',sMdx,\n                    \t'pConvertToStatic',1,\n                    \t'pTemp',\
    \ pTemp);\n        nSubsetindex = 1;\n        nSubsetSize = HierarchySubsetGetSize(pDim, sHier, stempSub);\n\
    \        While (nSubsetindex <= nSubsetSize);\n          sTemp = HierarchySubsetElementGetIndex (pDim,\
    \ sHier, stempSub, '', nSubsetIndex);\n          sElement = HierarchySubsetGetElementName(pDim, sHier,\
    \ stempSub, nSubsetindex);\n          HierarchySubsetElementDelete( pDim, sHier,stempSub,nSubsetindex\
    \ );\n          nSubsetSize = nSubsetSize -1;\n          ## Delete Element from main subset\n    \
    \      If(HierarchySubsetElementExists(pDim, sHier, pSub, sElement)>0);\n            nSearchIndex\
    \ = 1;\n            nSearchSize = HierarchySubsetGetSize(pDim, sHier, pSub);\n            While( nSearchIndex\
    \ <= nSearchSize  );\n              sSearchElement = HierarchySubsetGetElementName( pDim, sHier, pSub,\
    \ nSearchIndex );\n               # If Element is found or a descendant of the Element is found the\
    \ remove from subset\n                If( sElement @= sSearchElement % ElementIsAncestor( pDim, sHier,\
    \ sElement, sSearchElement ) = 1 );\n                  sTemp = HierarchySubsetElementGetIndex (pDim,\
    \ sHier, pSub, '', nSearchIndex);\n                  HierarchySubsetElementDelete ( pDim, sHier, pSub,\
    \ nSearchIndex );\n                  nSearchSize = 0;\n                Else;\n                  nSearchIndex\
    \ = nSearchIndex + 1;\n                EndIf;\n            End;\n          Endif;\n          ######\n\
    \        End;\n        HierarchySubsetDestroy(pDim, sHier,stempSub);\n    EndIf;\n\n  End;\n\nEndIf;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully excluded elements from subset %pSub% from dimension\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that allows for removing specified elements from
    a subset in a hierarchy of the target dimension. Note that wildcard characters like `*` and `?` are
    accepted in the list of elements to be excluded. If a leaf level element is specified, it will be
    removed on its own. If a consolidated element is specified, it will be removed along with its descendants.
    Caution: The target hierarchy cannot be ''Leaves''.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will remove specified elements from a subset in a Hierarchy\
    \ of target Dimension.\n# Wildcard characters `*`and `?` are accepted in list of elements to be excluded.\n\
    \n# Note:\n# - If a leaf level element is specified, it will be removed on its own.\n# - If a consolidated\
    \ element is specified it will be removed as well as its descendants.\n\n# Caution: Target hierarchy\
    \ cannot be `Leaves`.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub    \
    \        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pExclusions:%pExclusions%, pDelim:%pDelim%,\
    \ pTemp:%pTemp%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\n\n## LogOutput parameters\n\
    IF ( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\n\nnErrors = 0;\n\nIf( Scan( ':', pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed\
    \ as dimension. Handle the input error by splitting dim:hier into dimension & hierarchy\n    pHier\
    \       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan(\
    \ ':', pDim ) - 1 );\nEndIf;\n\n# Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n\
    \  sMessage = 'No dimension specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\nIf( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n## Validate Hierarchy\n\nIF(pHier\
    \ @= 'Leaves' );\n  nErrors = 1;\n  sMessage = 'Invalid  Hierarchy: ' | pDim |':'|pHier;\n  LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( Trim( pHier ) @= '' );\n  sHier = pDim;\n\
    Else;\n  sHier = pHier;\nEndIf;\n\nIf( HierarchyExists( pDim, sHier ) = 0 );\n  nErrors = 1;\n  sMessage\
    \ = 'The Hierachy ' | sHier | ' does not exists.';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# Validate subset\nIf( Trim( pSub ) @= '' );\n  nErrors = 1;\n  sMessage = 'No subset\
    \ specified';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( HierarchySubsetExists(\
    \ pDim,sHier, pSub ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid subset: ' | pSub | ' in dimension:Hierarchy\
    \ ' | pDim |':' | sHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n#\
    \ Validate Elements\nIf( Trim( pExclusions ) @= '' );\n  nErrors = 1;\n  sMessage = 'No Elements specified';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate delimiter\nIf( pExclusions\
    \ @<> '' & pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n## Validate pTemp\nIF( pTemp <> 0 & pTemp <>\
    \ 1 );\n    nErrors = 1;\n    sMessage = 'Wrong parameter pTemp value (only 0 or 1 accepted).';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Process Elements ###\n\
    If(nErrors = 0);\n  nDelimIndex = 1;\n  sExclusions = pExclusions;\n\n  While( nDelimIndex <> 0 &\
    \ Long( sExclusions ) > 0 );\n\n    nDelimIndex = Scan( pDelim, sExclusions );\n    If( nDelimIndex\
    \ <> 0 );\n      sExclusion = Trim( SubSt( sExclusions, 1, nDelimIndex - 1 ) );\n      sExclusions\
    \ = Trim( SubSt( sExclusions, nDelimIndex + Long( pDelim ), Long( sExclusions ) ) );\n    Else;\n\
    \      sExclusion = Trim( sExclusions );\n    EndIf;\n    If(Scan('*',sExclusion) = 0 & Scan('?',sExclusion)\
    \ = 0);\n      # Check that Element is present in the dimension\n      If( ElementIndex ( pDim, sHier,\
    \ sExclusion ) <> 0 );\n        sExclusion = HierarchyElementPrincipalName( pDim, sHier, sExclusion\
    \ );\n        # Work through subset and remove Element\n        nSubsetIndex = 1;\n        nSubsetSize\
    \ = HierarchySubsetGetSize( pDim, sHier, pSub );\n        While( nSubsetIndex <= nSubsetSize );\n\
    \          sTemp = HierarchySubsetElementGetIndex (pDim, sHier, pSub, '', nSubsetIndex);\n       \
    \   sElement = HierarchySubsetGetElementName( pDim, sHier, pSub, nSubsetIndex );\n          # If Element\
    \ is found or a descendant of the Element is found the remove from subset\n          If( sElement\
    \ @= sExclusion % ElementIsAncestor( pDim, sHier, sExclusion, sElement ) = 1 );\n            sTemp\
    \ = HierarchySubsetElementGetIndex (pDim, sHier, pSub, '', nSubsetIndex);\n            HierarchySubsetElementDelete\
    \ ( pDim, sHier, pSub, nSubsetIndex );\n            nSubsetSize = nSubsetSize - 1;\n          Else;\n\
    \            nSubsetIndex = nSubsetIndex + 1;\n          EndIf;\n        End;\n      \n      EndIf;\n\
    \    Else;\n      # Wildcard search string\n        sExclusion = '''|sExclusion|''';\n        stempSub\
    \ = cThisProcName| cRandomInt;\n        sProc = '}bedrock.hier.sub.create.bymdx';\n        sMdx =\
    \ '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |pDim|':'|sHier |' ])},'| sExclusion| ')}';\n        ExecuteProcess(sProc,\n\
    \                      'pStrictErrorHandling', pStrictErrorHandling,\n                    \t'pDim',pDim,\n\
    \                    \t'pHier',sHier,\n                    \t'pSub',stempSub,\n                  \
    \  \t'pMDXExpr',sMdx,\n                    \t'pConvertToStatic',1,\n                    \t'pTemp',\
    \ pTemp);\n        nSubsetindex = 1;\n        nSubsetSize = HierarchySubsetGetSize(pDim, sHier, stempSub);\n\
    \        While (nSubsetindex <= nSubsetSize);\n          sTemp = HierarchySubsetElementGetIndex (pDim,\
    \ sHier, stempSub, '', nSubsetIndex);\n          sElement = HierarchySubsetGetElementName(pDim, sHier,\
    \ stempSub, nSubsetindex);\n          HierarchySubsetElementDelete( pDim, sHier,stempSub,nSubsetindex\
    \ );\n          nSubsetSize = nSubsetSize -1;\n          ## Delete Element from main subset\n    \
    \      If(HierarchySubsetElementExists(pDim, sHier, pSub, sElement)>0);\n            nSearchIndex\
    \ = 1;\n            nSearchSize = HierarchySubsetGetSize(pDim, sHier, pSub);\n            While( nSearchIndex\
    \ <= nSearchSize  );\n              sSearchElement = HierarchySubsetGetElementName( pDim, sHier, pSub,\
    \ nSearchIndex );\n               # If Element is found or a descendant of the Element is found the\
    \ remove from subset\n                If( sElement @= sSearchElement % ElementIsAncestor( pDim, sHier,\
    \ sElement, sSearchElement ) = 1 );\n                  sTemp = HierarchySubsetElementGetIndex (pDim,\
    \ sHier, pSub, '', nSearchIndex);\n                  HierarchySubsetElementDelete ( pDim, sHier, pSub,\
    \ nSearchIndex );\n                  nSearchSize = 0;\n                Else;\n                  nSearchIndex\
    \ = nSearchIndex + 1;\n                EndIf;\n            End;\n          Endif;\n          ######\n\
    \        End;\n        HierarchySubsetDestroy(pDim, sHier,stempSub);\n    EndIf;\n\n  End;\n\nEndIf;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully excluded elements from subset %pSub% from dimension\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der einen Subset in einer Hierarchie einer
    Dimension in eine Datei exportiert. Verwende einen benutzerdefinierten Datensatz-Trennzeichen, das
    entweder durch ein Zeichen oder seinen ASCII-Code spezifiziert wird. Das Format der Datei sollte folgendermaßen
    sein: Die erste Zeile enthält Metadaten der Datei mit einer Zusammenfassung der Dimension, der Hierarchie,
    des Subset-Namens, der Anzahl der Elemente und dem Datum/Zeitpunkt der Dateierstellung. Die zweite
    und alle folgenden Zeilen enthalten die Elementexportdaten. Beachte, dass ein gültiger Dimensionsname
    (pDim), Subset-Name (pSub) und die Angabe, ob ein Header enthalten sein soll (pTitleRecord), obligatorisch
    sind, andernfalls wird der Prozess abgebrochen. Das Zielverzeichnis (pTgtDir) muss existieren. Falls
    gewünscht, kann ein benutzerdefiniertes Trennzeichen verwendet werden, indem der Parameter pDelim
    als entweder ein genaues Zeichen oder als ein dreistelliger (dezimaler) ASCII-Code spezifiziert wird.
    Beispielsweise kann für ein TAB als Trennzeichen 009 genutzt werden.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Export a subset in a Hierarchy of a Dimension\
    \ to a file. Custom record delimiter\n# (specified by a character or its ASCII code) can be used.\n\
    # __Format of the file:__  \n# - 1st line: File metadata contains summary information about the dimension,\
    \ hierarchy, subset\n#   name, number of elements and date/time when file was generated.\n# - 2nd\
    \ line and forth: Elements export data.\n\n# Note:\n# Valid dimension name (pDim), subset name (pSub),\
    \ inclusion of header (pTitleRecord)\n# are mandatory otherwise the process will abort. Target folder\
    \ (pTgtDir) must exist.\n# If needed, custom delimiter might be used by specifying parameter pDelim\
    \ value as either exactly one\n# character or as a 3-digit (decimal) ASCII code. For example to use\
    \ TAB as a delimiter, use 009.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub    \
    \        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%,\
    \ pTitleRecord:%pTitleRecord%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncLenASCIICode\
    \       = 3;\n\npDelim = TRIM(pDelim);\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':',\
    \ pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error\
    \ by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim\
    \ ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n#\
    \ Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n\
    \  DataSourceType = 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    If( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n \
    \ DataSourceType = 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate hierarchy\nIF( Trim(pHier) @= '' );\n  pHier = pDim;\nEndIf;\n\nIF(\nHierarchyExists(pDim,\
    \ pHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid Source Hierarchy: ' | pDim |':'|pHier;\n \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\nIf( Trim(\
    \ pSub ) @= '' );\n  nErrors = 1;\n  sMessage = 'No subset specified';\n    DataSourceType = 'NULL';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( HierarchySubsetExists(\
    \ pDim, pHier, pSub ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid subset: ' | pSub | ' in dimension:Hierarchy\
    \ ' | pDim |':' | pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n##\
    \ check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate file path\n# Strip off\
    \ trailing backslash (if present)\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n  pTgtDir\
    \ = SubSt( pTgtDir, 1, Long( pTgtDir ) - 1 );\nEndIf;\nIf( FileExists( pTgtDir ) = 0 );\n  nErrors\
    \ = 1;\n  sMessage = 'Invalid export path specified. Folder does not exist.';\n  DataSourceType =\
    \ 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npTgtDir = pTgtDir |\
    \ sOSDelim;\n\n# Validate file delimiter & quote character\nIf( pDelim @= '' );\n    pDelim = ',';\n\
    Else;\n    # If length of pDelim is exactly 3 chars and each of them is decimal digit, then the pDelim\
    \ is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim) = cLenASCIICode );\n      nChar\
    \ = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pDelim, nChar )>=CODE( '0', 1 )\
    \ & CODE( pDelim, nChar )<=CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid\
    \ = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n\
    \      pDelim=CHAR(StringToNumber( pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1,\
    \ 1 );\n    EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length\
    \ of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII\
    \ code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While (\
    \ nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar\
    \ ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n\
    \        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber(\
    \ pQuote ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate\
    \ filename\n# If no file name then default to Dimension.Subset.Export.csv (or Dimension.Hierarchy.Subset.Export.csv\
    \ in case of alternate hierarchy usage)\nIf( pTgtFile @= '' );\n  If( pHier @= pHier );\n    pTgtFile\
    \ = pDim |'.'| pSub |'.Export.csv';\n  Else;\n    pTgtFile = pDim |'.'| pHier |'.'| pSub |'.Export.csv';\n\
    \  EndIf;\nElse;\n  If( Scan( '.', pTgtFile ) = 0 );\n    # No file extension specified\n    pTgtFile\
    \ = pTgtFile | '.csv';\n  EndIf;\nEndIf;\nsFile = pTgtDir | pTgtFile;\n\n# Validate Character Set\n\
    If(Trim( pCharacterSet ) @= '' );\n  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n### Initialise & declare\
    \ variables ###\n\nnRecordCount = 0;\n\n### Determine if alias exists ###\n\nsAttributeDim = '}ElementAttributes_'\
    \ | pDim;\nsAlias = '(no alias)';\nIf( DimensionExists( sAttributeDim ) = 1 );\n  nElementIndex =\
    \ 1;\n  nElementCount = DimSiz( sAttributeDim );\n  While( nElementIndex <= nElementCount );\n   \
    \ sAttribute = DimNm( sAttributeDim, nElementIndex );\n    If( SubSt( DType( sAttributeDim, sAttribute\
    \ ), 2, 1 ) @= 'A' );\n      sAlias = sAttribute;\n      nElementIndex = nElementCount;\n    EndIf;\n\
    \    nElementIndex = nElementIndex + 1;\n  End;\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Assign Data Source ###\n\nDatasourceNameForServer = pDim|':'|pHier;\nDatasourceNameForClient\
    \ = pDim|':'|pHier;\nDataSourceType = 'SUBSET';\nDatasourceDimensionSubset = pSub;\nDatasourceAsciiDelimiter=\
    \ pDelim;\nDatasourceAsciiQuoteCharacter = pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n# Set the output character set\nSetOutputCharacterSet(\
    \ sFile, pCharacterSet );\n\n### Check for error in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Check whether\
    \ to write title records ###\n\nnRecordCount = nRecordCount + 1;\n\nIf( nRecordCount = 1 & pTitleRecord\
    \ = 1 );\n\n  nSubsetSize = HierarchySubSetGetSize( pDim, pHier, pSub );\n\n  # Write params\n  TextOutput(\n\
    \    sFile,\n    'Export from dimension: ' | pDim | ',Hierarchy:'|pHier|',Subset:'|pSub|\n    ', Total\
    \ elements: ' | NumberToString( nSubsetSize ) |\n    '. On ' | Date( Now, 1 ) | ' at ' | Time\n  \
    \ );\n  # Write header records\n  TextOutput(\n    sFile,\n    'Subix',\n    'Element',\n    'Alias:\
    \ ' | sAlias,\n    'Dimix',\n    'El Type',\n    'Level',\n    'Num Children',\n    'Parent 1',\n\
    \    'Weight 1',\n    'Parent 2',\n    'Weight 2',\n    'Parent 3',\n    'Weight 3',\n    'Parent\
    \ 4',\n    'Weight 4',\n    'Parent 5',\n    'Weight 5'\n  );\n\nEndIf;\n\n### Write dimension info\
    \ to flat file ###\nsElement = HierarchyElementPrincipalName( pDim, pHier, vElement );\nsSubix = NumberToString(\
    \ nRecordCount );\nsIndex = NumberToString( ElementIndex( pDim, pHier, vElement ) );\nsType = ElementType(\
    \ pDim, PHier, vElement );\nsLevel = NumberToString( ElementLevel( pDim, pHier, vElement ) );\nsChild\
    \ = NumberToString( ElementComponentCount( pDim, pHier, vElement ) );\nsParent1 = ElementParent( pDim,pHier,\
    \ vElement, 1 );\nsParent2 = ElementParent( pDim,pHier, vElement, 2 );\nsParent3 = ElementParent(\
    \ pDim,pHier, vElement, 3 );\nsParent4 = ElementParent( pDim,pHier, vElement, 4 );\nsParent5 = ElementParent(\
    \ pDim,pHier, vElement, 5 );\nsParent6 = ElementParent( pDim,pHier, vElement, 6 );\nsParent7 = ElementParent(\
    \ pDim,pHier, vElement, 7 );\nsParent8 = ElementParent( pDim,pHier, vElement, 8 );\nsWeight1 = NumberToString(\
    \ ElementWeight( pDim, pHier, sParent1, vElement ) );\nsWeight2 = NumberToString( ElementWeight( pDim,\
    \ pHier, sParent2, vElement ) );\nsWeight3 = NumberToString( ElementWeight( pDim, pHier, sParent3,\
    \ vElement ) );\nsWeight4 = NumberToString( ElementWeight( pDim, pHier, sParent4, vElement ) );\n\
    sWeight5 = NumberToString( ElementWeight( pDim, pHier, sParent5, vElement ) );\nsWeight6 = NumberToString(\
    \ ElementWeight( pDim, pHier, sParent6, vElement ) );\nsWeight7 = NumberToString( ElementWeight( pDim,\
    \ pHier, sParent7, vElement ) );\nsWeight8 = NumberToString( ElementWeight( pDim, pHier, sParent8,\
    \ vElement ) );\n\nIf( sAlias @<> '(no alias)' );\n  sAliasValue = ElementAttrS( pDim, pHier, vElement,\
    \ sAlias );\nElse;\n  sAliasValue = '';\nEndIf;\n\n  TextOutput(\n    sFile,\n    sSubix,\n    sElement,\n\
    \    sAliasValue,\n    sIndex,\n    sType,\n    sLevel,\n    sChild,\n    sParent1,\n    sWeight1,\n\
    \    sParent2,\n    sWeight2,\n    sParent3,\n    sWeight3,\n    sParent4,\n    sWeight4,\n    sParent5,\n\
    \    sWeight5,\n    sParent6,\n    sWeight6,\n    sParent7,\n    sWeight7,\n    sParent8,\n    sWeight8\n\
    \  );\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully exported subset %pSub% from dimension\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that exports a subset in a hierarchy of a dimension
    to a file. Use a custom record delimiter specified by a character or its ASCII code. The file format
    should be as follows: The first line contains file metadata with summary information about the dimension,
    hierarchy, subset name, number of elements, and the date/time when the file was generated. The second
    and subsequent lines contain the elements export data. Note that a valid dimension name (pDim), subset
    name (pSub), and whether to include a header (pTitleRecord) are mandatory, otherwise the process will
    abort. The target folder (pTgtDir) must exist. If needed, a custom delimiter might be used by specifying
    the parameter pDelim value as either exactly one character or a 3-digit (decimal) ASCII code. For
    instance, to use TAB as a delimiter, use 009.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Export a subset in a Hierarchy of a Dimension\
    \ to a file. Custom record delimiter\n# (specified by a character or its ASCII code) can be used.\n\
    # __Format of the file:__  \n# - 1st line: File metadata contains summary information about the dimension,\
    \ hierarchy, subset\n#   name, number of elements and date/time when file was generated.\n# - 2nd\
    \ line and forth: Elements export data.\n\n# Note:\n# Valid dimension name (pDim), subset name (pSub),\
    \ inclusion of header (pTitleRecord)\n# are mandatory otherwise the process will abort. Target folder\
    \ (pTgtDir) must exist.\n# If needed, custom delimiter might be used by specifying parameter pDelim\
    \ value as either exactly one\n# character or as a 3-digit (decimal) ASCII code. For example to use\
    \ TAB as a delimiter, use 009.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub    \
    \        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pHier:%pHier%, pSub:%pSub%, pTgtDir:%pTgtDir%, pTgtFile:%pTgtFile%,\
    \ pTitleRecord:%pTitleRecord%.'; \ncAttributeDim       = '}ElementAttributes_' | pDim;\ncLenASCIICode\
    \       = 3;\n\npDelim = TRIM(pDelim);\n\n## LogOutput parameters\nIF ( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\nnErrors = 0;\n\nIf( Scan( ':',\
    \ pDim ) > 0 & pHier @= '' );\n    # A hierarchy has been passed as dimension. Handle the input error\
    \ by splitting dim:hier into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim\
    \ ) + 1, Long( pDim ) );\n    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n#\
    \ Validate dimension\nIf( Trim( pDim ) @= '' );\n  nErrors = 1;\n  sMessage = 'No dimension specified';\n\
    \  DataSourceType = 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    If( DimensionExists( pDim ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid dimension: ' | pDim;\n \
    \ DataSourceType = 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Validate hierarchy\nIF( Trim(pHier) @= '' );\n  pHier = pDim;\nEndIf;\n\nIF(\nHierarchyExists(pDim,\
    \ pHier ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid Source Hierarchy: ' | pDim |':'|pHier;\n \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate subset\nIf( Trim(\
    \ pSub ) @= '' );\n  nErrors = 1;\n  sMessage = 'No subset specified';\n    DataSourceType = 'NULL';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\nIf( HierarchySubsetExists(\
    \ pDim, pHier, pSub ) = 0 );\n  nErrors = 1;\n  sMessage = 'Invalid subset: ' | pSub | ' in dimension:Hierarchy\
    \ ' | pDim |':' | pHier;\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n##\
    \ check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n# Validate file path\n# Strip off\
    \ trailing backslash (if present)\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @= sOSDelim );\n  pTgtDir\
    \ = SubSt( pTgtDir, 1, Long( pTgtDir ) - 1 );\nEndIf;\nIf( FileExists( pTgtDir ) = 0 );\n  nErrors\
    \ = 1;\n  sMessage = 'Invalid export path specified. Folder does not exist.';\n  DataSourceType =\
    \ 'NULL';\n  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\npTgtDir = pTgtDir |\
    \ sOSDelim;\n\n# Validate file delimiter & quote character\nIf( pDelim @= '' );\n    pDelim = ',';\n\
    Else;\n    # If length of pDelim is exactly 3 chars and each of them is decimal digit, then the pDelim\
    \ is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pDelim) = cLenASCIICode );\n      nChar\
    \ = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pDelim, nChar )>=CODE( '0', 1 )\
    \ & CODE( pDelim, nChar )<=CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid\
    \ = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n\
    \      pDelim=CHAR(StringToNumber( pDelim ));\n    Else;\n      pDelim = SubSt( Trim( pDelim ), 1,\
    \ 1 );\n    EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length\
    \ of pQuote is exactly 3 chars and each of them is decimal digit, then the pQuote is entered as ASCII\
    \ code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While (\
    \ nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar\
    \ ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n\
    \        nChar = nChar + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber(\
    \ pQuote ));\n    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate\
    \ filename\n# If no file name then default to Dimension.Subset.Export.csv (or Dimension.Hierarchy.Subset.Export.csv\
    \ in case of alternate hierarchy usage)\nIf( pTgtFile @= '' );\n  If( pHier @= pHier );\n    pTgtFile\
    \ = pDim |'.'| pSub |'.Export.csv';\n  Else;\n    pTgtFile = pDim |'.'| pHier |'.'| pSub |'.Export.csv';\n\
    \  EndIf;\nElse;\n  If( Scan( '.', pTgtFile ) = 0 );\n    # No file extension specified\n    pTgtFile\
    \ = pTgtFile | '.csv';\n  EndIf;\nEndIf;\nsFile = pTgtDir | pTgtFile;\n\n# Validate Character Set\n\
    If(Trim( pCharacterSet ) @= '' );\n  pCharacterSet = 'TM1CS_UTF8';\nEndIf;\n\n### Initialise & declare\
    \ variables ###\n\nnRecordCount = 0;\n\n### Determine if alias exists ###\n\nsAttributeDim = '}ElementAttributes_'\
    \ | pDim;\nsAlias = '(no alias)';\nIf( DimensionExists( sAttributeDim ) = 1 );\n  nElementIndex =\
    \ 1;\n  nElementCount = DimSiz( sAttributeDim );\n  While( nElementIndex <= nElementCount );\n   \
    \ sAttribute = DimNm( sAttributeDim, nElementIndex );\n    If( SubSt( DType( sAttributeDim, sAttribute\
    \ ), 2, 1 ) @= 'A' );\n      sAlias = sAttribute;\n      nElementIndex = nElementCount;\n    EndIf;\n\
    \    nElementIndex = nElementIndex + 1;\n  End;\nEndIf;\n\n### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n\n### Assign Data Source ###\n\nDatasourceNameForServer = pDim|':'|pHier;\nDatasourceNameForClient\
    \ = pDim|':'|pHier;\nDataSourceType = 'SUBSET';\nDatasourceDimensionSubset = pSub;\nDatasourceAsciiDelimiter=\
    \ pDelim;\nDatasourceAsciiQuoteCharacter = pQuote;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n# Set the output character set\nSetOutputCharacterSet(\
    \ sFile, pCharacterSet );\n\n### Check for error in prolog ###\n\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Check whether\
    \ to write title records ###\n\nnRecordCount = nRecordCount + 1;\n\nIf( nRecordCount = 1 & pTitleRecord\
    \ = 1 );\n\n  nSubsetSize = HierarchySubSetGetSize( pDim, pHier, pSub );\n\n  # Write params\n  TextOutput(\n\
    \    sFile,\n    'Export from dimension: ' | pDim | ',Hierarchy:'|pHier|',Subset:'|pSub|\n    ', Total\
    \ elements: ' | NumberToString( nSubsetSize ) |\n    '. On ' | Date( Now, 1 ) | ' at ' | Time\n  \
    \ );\n  # Write header records\n  TextOutput(\n    sFile,\n    'Subix',\n    'Element',\n    'Alias:\
    \ ' | sAlias,\n    'Dimix',\n    'El Type',\n    'Level',\n    'Num Children',\n    'Parent 1',\n\
    \    'Weight 1',\n    'Parent 2',\n    'Weight 2',\n    'Parent 3',\n    'Weight 3',\n    'Parent\
    \ 4',\n    'Weight 4',\n    'Parent 5',\n    'Weight 5'\n  );\n\nEndIf;\n\n### Write dimension info\
    \ to flat file ###\nsElement = HierarchyElementPrincipalName( pDim, pHier, vElement );\nsSubix = NumberToString(\
    \ nRecordCount );\nsIndex = NumberToString( ElementIndex( pDim, pHier, vElement ) );\nsType = ElementType(\
    \ pDim, PHier, vElement );\nsLevel = NumberToString( ElementLevel( pDim, pHier, vElement ) );\nsChild\
    \ = NumberToString( ElementComponentCount( pDim, pHier, vElement ) );\nsParent1 = ElementParent( pDim,pHier,\
    \ vElement, 1 );\nsParent2 = ElementParent( pDim,pHier, vElement, 2 );\nsParent3 = ElementParent(\
    \ pDim,pHier, vElement, 3 );\nsParent4 = ElementParent( pDim,pHier, vElement, 4 );\nsParent5 = ElementParent(\
    \ pDim,pHier, vElement, 5 );\nsParent6 = ElementParent( pDim,pHier, vElement, 6 );\nsParent7 = ElementParent(\
    \ pDim,pHier, vElement, 7 );\nsParent8 = ElementParent( pDim,pHier, vElement, 8 );\nsWeight1 = NumberToString(\
    \ ElementWeight( pDim, pHier, sParent1, vElement ) );\nsWeight2 = NumberToString( ElementWeight( pDim,\
    \ pHier, sParent2, vElement ) );\nsWeight3 = NumberToString( ElementWeight( pDim, pHier, sParent3,\
    \ vElement ) );\nsWeight4 = NumberToString( ElementWeight( pDim, pHier, sParent4, vElement ) );\n\
    sWeight5 = NumberToString( ElementWeight( pDim, pHier, sParent5, vElement ) );\nsWeight6 = NumberToString(\
    \ ElementWeight( pDim, pHier, sParent6, vElement ) );\nsWeight7 = NumberToString( ElementWeight( pDim,\
    \ pHier, sParent7, vElement ) );\nsWeight8 = NumberToString( ElementWeight( pDim, pHier, sParent8,\
    \ vElement ) );\n\nIf( sAlias @<> '(no alias)' );\n  sAliasValue = ElementAttrS( pDim, pHier, vElement,\
    \ sAlias );\nElse;\n  sAliasValue = '';\nEndIf;\n\n  TextOutput(\n    sFile,\n    sSubix,\n    sElement,\n\
    \    sAliasValue,\n    sIndex,\n    sType,\n    sLevel,\n    sChild,\n    sParent1,\n    sWeight1,\n\
    \    sParent2,\n    sWeight2,\n    sParent3,\n    sWeight3,\n    sParent4,\n    sWeight4,\n    sParent5,\n\
    \    sWeight5,\n    sParent6,\n    sWeight6,\n    sParent7,\n    sWeight7,\n    sParent8,\n    sWeight8\n\
    \  );\n\n### End Data ###\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully exported subset %pSub% from dimension\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der alle untergeordneten Elemente von einer
    spezifischen Konsolidierung (pConsol) in einer Hierarchie in der Ziel-Dimension entfernt. Wenn rekursiv
    (pRecursive=1) angegeben ist, löst der Prozess auch alle Konsolidierungen auf, die Nachkommen des
    Ziels unabhängig von der Tiefe sind. Andernfalls werden nur die direkten untergeordneten Elemente
    der Ziel-Konsolidierung entfernt. Dies ist sinnvoll für Produktions- und Entwicklungsprototypen. Im
    Produktionskontext wird der Prozess vor dem Hauptaufbau der Dimension aufgerufen, um geänderte Zuordnungsbeziehungen
    zu berücksichtigen und eine doppelte Zählung zu vermeiden. Zusammen mit }ti.hier.emptyconsols.delete
    kann der Prozess auch verwendet werden, um verwaiste Rollups zu entfernen. In der Entwicklung dient
    er der manuellen Bereinigung der Dimensionen vor der Produktion. Ein gültiger Name für die Quelldimension
    (pDim) ist erforderlich, sonst wird der Prozess abgebrochen. Ein leeres pHier-Profil bezieht sich
    nur auf die gleichnamige Hierarchie jeder verarbeiteten Dimension. Ein ''*'' im pConsol-Parameter
    verarbeitet alle Konsolidierungsstufen in der angegebenen Hierarchie. Eine durch Trennzeichen begrenzte
    Liste oder ein Platzhalter für pDim oder pHier oder eine durch Trennzeichen begrenzte Konsolidierungsliste
    für pConsol sorgt für rekursive Prozessaufrufe. Achtung: Wenn Konsolidierungen auch in nicht zusammenhängenden
    Konsolidierungen verwendet werden und rekursiv ausgewählt ist, führt dies zu verwaisten Konsolidierungen
    in anderen Rollups.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will remove all children from a specific target consolidation\
    \ (pConsol) in a Hierarchy\n# in target Dimension. If recursive (pRecursive=1), it will also unwind\
    \ all consolidations that are \n# descendants of the target regardless of depth. If not recursive\
    \ (pRecursive=0) then only immediate children\n# of the target consolidation will be removed.\n#\n\
    # Use case: Intended for both production and development/prototyping scenarios.\n# 1. **Production**\
    \ call prior to main dimension build process in case mapping relationships have changed to ensure\
    \ no double-counting steming from leaf elements \n#    rolling into multiple parents within the same\
    \ rollup or hierarhcy\n# 2. **Production** combine with }bedrock.hier.emptyconsols.delete to remove\
    \ orphaned rollups\n# 3. **Development** manual cleanup of dimensions during prototyping or prior\
    \ to going to production\n#\n# Note:\n# * A valid source dimension name (pDim) is mandatory otherwise\
    \ the process will abort.\n# * A blank pHier parameter will process _only the same named hierarchy_\
    \ for each of the dimensions processed.\n# * A \\* pConsol parameter will process ALL C level items\
    \ in the given hierarchy (pHier).\n# * A delimited list or wildcard for pDim or pHier or a delimited\
    \ list of consolidations for pConsol will result in recursive calls of the process.\n#\n# Caution:\
    \ \n# If consolidations are also used in unrelated consolidations and recursive is selected this\n\
    # will result in orphan consolidations in the other rollups.\n#EndRegion @DOC\n\n##Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp\
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncTempSubOuter   = '}OuterLoop_'\
    \ | cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncTempSubInner   = '}InnerLoop_' | cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncMsgInfoContent = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\n\
    cLogInfo        = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pConsol:%pConsol%,\
    \ pRecursive:%pRecursive%, pDelim:%pDelim%.' ;\ncHierAttr       = 'Bedrock.Descendant';\ncAttrVal\
    \        = 'Descendant';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*',\
    \ pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @=\
    \ '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n\
    \    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n## Validate Source dimension\n\
    IF( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim )\
    \ = 0 & Scan( pDelim, pDim ) = 0 & DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate hierarchy (can only validate hierarchy up front if dimension is fixed and doesn't\
    \ contain wildcards)\nIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0\
    \ & pHier @= '');\n    pHier = pDim;\nElseIf( Scan( '*', pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan(\
    \ pDelim, pHier ) = 0 & pHier @<> '' & DimensionExists( pDim ) = 1 & HierarchyExists( pDim, pHier\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension hierarchy: ' | pHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\nIf( Trim( pHier ) @= '' );\n    ## use\
    \ same name as Dimension. Since wildcards are allowed, this is managed inside the code below\nEndIf;\n\
    \n# Validate consol\nIf( pConsol @<> '');\n    If( Scan( '*', pConsol ) = 0 & Scan( '?', pConsol )\
    \ = 0 & Scan( pDelim, pConsol ) = 0 & ElementIndex( pDim, pHier, pConsol ) = 0 );\n        nErrors\
    \ = 1;\n        sMessage = 'Item ' | pConsol | ' does NOT exist. Please enter a valid consolidation\
    \ element in the ' |pDim| ':' |pHier| ' dimension:hierarchy.';  \n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    ElseIf( Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 &\
    \ Scan( pDelim, pConsol ) = 0 & ElementType( pDim, pHier, pConsol ) @<> 'C' );\n        nErrors =\
    \ 1;\n        sMessage = 'Item ' | pConsol | ' is NOT a consolidated item. Please enter a valid consolidation\
    \ element in the ' |pDim| ':' |pHier| ' dimension:hierarchy.';  \n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    ElseIf( Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 &\
    \ Scan( pDelim, pConsol ) = 0 & ElementComponentCount( pDim, pHier, pConsol ) = 0 );\n        nErrors\
    \ = 1;\n        sMessage = 'Invalid consolidation: ' | pConsol | ' has no children.';\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Endif;\nElseIf( Trim( pConsol ) @= '' );\n  \
    \  nErrors = 1;\n    sMessage = 'No consolidated element specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;\n\n# If blank delimiter specified then convert to default\n\
    If( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nElse;\n  # If subset required will be set later\n  DataSourceType = 'NULL';\nEndIf;\n\n\
    ### If there is no separator and wildcard in the parameters, execute the unwind of the specific consolidated\
    \ element\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*',\
    \ pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan(\
    \ '?', pConsol ) = 0 & Scan( pDelim, pConsol ) = 0 );\n\n    ### In case alias used for pConsol convert\
    \ to principal name \n    If( ElementIndex( pDim, pHier, pConsol ) > 0 );\n        pConsol = HierarchyElementPrincipalName(\
    \ pDim, pHier, pConsol );\n    EndIf;\n\n    ### Turn-off Logging in the Attribute cube\n    sAttrCube\
    \ = '}ElementAttributes_' | pDim;\n    If( CubeExists( sAttrCube ) = 1 );\n        nLogging = CubeGetLogChanges(\
    \ sAttrCube );\n        CubeSetLogChanges( sAttrCube, 0 );\n    EndIf;\n    \n    ### Create Temp\
    \ Descendent Attribute\n    AttrDelete( pDim, cHierAttr );\n    AttrInsert( pDim, '', cHierAttr, 'S'\
    \ );\n    \n    ### Assign data source ###\n    If( pRecursive      = 1);\n        # Set Descendent\
    \ attribute value\n        nElementIndex   = 1;\n        nElementCount   = ElementCount( pDim , pHier\
    \ );\n        While( nElementIndex <= nElementCount );\n            sElement = ElementName( pDim,\
    \ pHier, nElementIndex );\n            If( ElementIsAncestor( pDim, pHier, pConsol, sElement ) = 1\
    \ % pConsol @= sElement );\n                ElementAttrPutS( cAttrVal, pDim, pHier, sElement, cHierAttr\
    \ );\n            EndIf;\n            nElementIndex = nElementIndex + 1;\n        End;\n        #\
    \ Assign Data Source\n        DataSourceType            = 'SUBSET';\n        DatasourceNameForServer\
    \   = pDim|':'|pHier;\n        DatasourceNameForClient   = pDim|':'|pHier;\n        DatasourceDimensionSubset\
    \ = 'ALL';\n    Else;\n        ### Remove direct children from the target consol ###\n        If(\
    \ ElementComponentCount( pDim, pHier, pConsol ) > 0 );\n            If( pLogOutput = 1 );\n      \
    \          LogOutput( 'INFO', Expand( 'Deleting all components from consolidation %pConsol% in hierarchy\
    \ '%pHier%' of '%pDim%' dimension.' ) );\n            EndIf;\n            nComp = ElementComponentCount(\
    \ pDim, pHier, pConsol );\n            While( nComp > 0 );\n                sComp = ElementComponent(\
    \ pDim, pHier, pConsol, nComp );\n                HierarchyElementComponentDelete( pDim, pHier, pConsol,\
    \ sComp );\n                nComp = nComp - 1;\n            End;\n        EndIf;\n        # No data\
    \ source, straight to Epilog\n        DataSourceType = 'NULL';\n    EndIf;\n\n### If pConsol is '*'\
    \ and there is no separator and wildcard in the pDim & pHier parameters then unwind the whole hierarchy\n\
    ElseIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier\
    \ ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Trim( pConsol ) @= '*' );\n\n    #\
    \ as pConsol is * wildcard it doesn't matter if recursive or not. We unwind everything. As speed enhancement\
    \ rather than removing children delete and add back C elements to empty children in one step (not\
    \ steps = count of children)\n    nMaxEle = ElementCount( pDim, pHier );\n    nCtrEle = 1;\n    While(\
    \ nCtrEle <= nMaxEle );\n        sEle = ElementName( pDim, pHier, nCtrEle);\n        If( ElementComponentCount(\
    \ pDim, pHier, sEle ) > 0 );\n            If( nCtrEle < nMaxEle );\n                sEleNext = ElementName(\
    \ pDim, pHier, nCtrEle + 1 );\n            Else;\n                sEleNext = '';\n            EndIf;\n\
    \            HierarchyElementDelete( pDim, pHier, sEle );\n            HierarchyElementInsert( pDim,\
    \ pHier, sEleNext, sEle, 'C' );\n        EndIf;\n        nCtrEle = nCtrEle + 1;\n    End;\n\n    #\
    \ since hierarchy already fully unwound no subset; datasource = NULL\n    DataSourceType = 'NULL';\n\
    \n## Otherwise, if there is a separator or wildcard in the parameters, tokenize the string and self-call\
    \ the process recursively.\nElse;\n    # No data source, straight to Epilog\n    DataSourceType =\
    \ 'NULL';\n    \n    # Loop through dimensions in pDim\n    sDims = pDim;\n    nDimDelimiterIndex\
    \ = 1;\n    sMdx = '';\n    # Get 1st dimension\n    While( nDimDelimiterIndex <> 0 );\n        #\
    \ Extract 1st dimension > sDim\n        nDimDelimiterIndex = Scan( pDelim, sDims );\n        If( nDimDelimiterIndex\
    \ = 0 );\n            sDim = sDims;\n        Else;\n            sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n            sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims\
    \ ) ) );\n        EndIf;\n        \n        # Create subset of dimensions using Wildcard to loop through\
    \ dimensions in pDim with wildcard\n        sDimExp = '''|sDim|''';\n        sMdxPart = Expand('{TM1FILTERBYPATTERN(\
    \ EXCEPT( TM1SUBSETALL( [}Dimensions].[}Dimensions] ), TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions].[}Dimensions]\
    \ ) , '*:*') ) , %sDimExp% )}');\n        If( sMdx @= ''); \n            sMdx = sMdxPart; \n     \
    \   Else;\n            sMdx = sMdx | ' + ' | sMdxPart;\n        EndIf;\n    End;\n  \n    If( SubsetExists(\
    \ '}Dimensions' , cTempSubOuter ) = 1 );\n        # If a delimited list of dim names includes wildcards\
    \ then we may have to re-use the subset multiple times\n        SubsetMDXSet( '}Dimensions' , cTempSubOuter,\
    \ sMDX );\n    Else;\n        # temp subset, therefore no need to destroy in epilog\n        SubsetCreatebyMDX(\
    \ cTempSubOuter, sMDX, '}Dimensions' , 1 );\n    EndIf;\n  \n    # Loop through dimensions in subset\
    \ created based on wildcard\n    nCountDim = SubsetGetSize( '}Dimensions' , cTempSubOuter );\n   \
    \ While( nCountDim >= 1 );\n        sDim = SubsetGetElementName( '}Dimensions' , cTempSubOuter, nCountDim\
    \ );\n        # Validate dimension name\n        If( DimensionExists(sDim) = 0 );\n            nErrors\
    \ = 1;\n            sMessage = Expand( 'Dimension '%sDim%' does not exist.' );\n            LogOutput(\
    \ 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            If( pLogOutput = 1 );\n     \
    \           sMessage = Expand( 'Dimension '%sDim%' being processed....' );\n                LogOutput(\
    \ 'INFO', Expand( cMsgInfoContent ) );\n            EndIf;\n            # Loop through hierarchies\
    \ in pHier\n            If( Trim( pHier ) @= '' );\n                ### Use main hierarchy for each\
    \ dimension if pHier is empty\n                sHierarchies  = sDim;\n            Else;\n        \
    \        sHierarchies  = pHier;\n            EndIf;\n            nDelimiterIndexA  = 1;\n        \
    \    sHierDim          = '}Dimensions' ;\n            sMdxHier          = '';\n            While(\
    \ nDelimiterIndexA <> 0 );\n                nDelimiterIndexA = Scan( pDelim, sHierarchies );\n   \
    \             If( nDelimiterIndexA = 0 );\n                    sHierarchy   = sHierarchies;\n    \
    \            Else;\n                    sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA\
    \ - 1 ) );\n                    sHierarchies  = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim),\
    \ Long( sHierarchies ) ) );\n                EndIf;\n      \n                # Create subset of Hierarchies\
    \ using Wildcard\n                If( sDim @= sHierarchy );\n                    sHierExp = '''| sDim\
    \ |''';\n                Else;\n                    sHierExp = '''| sDim | ':' | sHierarchy|''';\n\
    \                EndIf;\n                    sMdxHierPart = Expand('{TM1FILTERBYPATTERN( {TM1SUBSETALL([%sHierDim%].[%sHierDim%])},\
    \ %sHierExp% )}');\n                If( sMdxHier @= ''); \n                    sMdxHier = sMdxHierPart;\
    \ \n                Else;\n                    sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n     \
    \           EndIf;\n            End;\n          \n            # include the named hierarchy in case\
    \ ALL hierachies\n            If( Trim(pHier) @= '*' );\n                sMdxHier = Expand('{[%sHierDim%].[%sHierDim%].[%sDim%]}\
    \ + %sMdxHier%');\n            EndIf;\n  \n            If( SubsetExists( sHierDim, cTempSubInner )\
    \ = 1 );\n                # If a delimited list of hierarchy names includes wildcards then we may\
    \ have to re-use the subset multiple times\n                SubsetMDXSet( sHierDim, cTempSubInner,\
    \ sMdxHier );\n            Else;\n                # temp subset, therefore no need to destroy in epilog\n\
    \                SubsetCreatebyMDX( cTempSubInner, sMdxHier, sHierDim, 1 );\n            EndIf;\n\n\
    \            # Loop through subset of hierarchies created based on wildcard\n            nCountHier\
    \ = SubsetGetSize( sHierDim, cTempSubInner );\n            While( nCountHier >= 1 );\n           \
    \     sCurrHier = SubsetGetElementName( sHierDim, cTempSubInner, nCountHier );\n                sCurrHierName\
    \ = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n                # Validate hierarchy\
    \ name in sHierDim\n                If( Dimix( sHierDim , sCurrHier ) = 0 );\n                   \
    \ sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n  \
    \                  LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n                ElseIf( sCurrHierName\
    \ @= 'Leaves' );\n                    sMessage = Expand('Skipping %sCurrHier% hierarchy. No need to\
    \ unwind!');\n                    If( pLogOutput = 1 );\n                        LogOutput( 'INFO',\
    \ Expand( cMsgInfoContent ) );\n                    EndIf;\n                Else;\n              \
    \      If( pLogOutput = 1 );\n                        sMessage = Expand( 'Hierarchy '%sCurrHierName%'\
    \ in Dimension '%sDim%' being processed....' );\n                        LogOutput( 'INFO', Expand(\
    \ cMsgInfoContent ) );\n                    EndIf;\n                    # Loop through consolidated\
    \ elements in pConsol\n                    sEles = Trim( pConsol );\n                    If( sEles\
    \ @= '*' );\n                        # no need for recursive call for ALL wildcard. We can just unwind\
    \ whole hierarchy\n                        nMaxEle = ElementCount( sDim, sCurrHierName );\n      \
    \                  nCtrEle = 1;\n                        While( nCtrEle <= nMaxEle );\n          \
    \                  sEle = ElementName( sDim, sCurrHierName, nCtrEle);\n                          \
    \  If( ElementComponentCount( sDim, sCurrHierName, sEle ) > 0 );\n                               \
    \ If( nCtrEle < nMaxEle );\n                                    sEleNext = ElementName( sDim, sCurrHierName,\
    \ nCtrEle + 1 );\n                                Else;\n                                    sEleNext\
    \ = '';\n                                EndIf;\n                                HierarchyElementDelete(\
    \ sDim, sCurrHierName, sEle );\n                                HierarchyElementInsert( sDim, sCurrHierName,\
    \ sEleNext, sEle, 'C' );\n                            EndIf;\n                            nCtrEle\
    \ = nCtrEle + 1;\n                        End;\n                    Else;\n                      \
    \  # a delimited list of consolidations is given. Handle with recursive call and temp descendents\
    \ attribute\n                        nDelimiterIndexB = 1;\n                        While( nDelimiterIndexB\
    \ <> 0 );\n                            nDelimiterIndexB = Scan( pDelim, sEles );\n               \
    \             If( nDelimiterIndexB = 0 );\n                                sEle = sEles;\n       \
    \                     Else;\n                                sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB\
    \ - 1 ) );\n                                sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim),\
    \ Long( sEles ) ) );\n                            EndIf;\n                        \n             \
    \               # Wildcard search string\n                            sEle = '''|sEle|''';\n     \
    \                       sMdxEle = Expand('{TM1FILTERBYPATTERN( {TM1SUBSETALL([%sCurrHier%])}, %sEle%\
    \ )}');\n      \n                            If( HierarchySubsetExists( sDim, sCurrHierName, cTempSub\
    \ ) = 1 );\n                                # If a delimited list of dim names includes wildcards\
    \ then we may have to re-use the subset multiple times\n                                HierarchySubsetMDXSet(\
    \ sDim, sCurrHierName, cTempSub, sMDXEle );\n                            Else;\n                 \
    \               # temp subset, therefore no need to destroy in epilog\n                          \
    \      SubsetCreatebyMDX( cTempSub, sMDXEle, sCurrHier, 1 );\n                            EndIf;\n\
    \      \n                            # Loop through subset of Consolidated elements created based\
    \ on wildcard\n                            nCountElems = HierarchySubsetGetSize(sDim, sCurrHierName,\
    \ cTempSub);\n                            While( nCountElems >= 1 );\n                           \
    \     sElement = HierarchySubsetGetElementName(sDim, sCurrHierName, cTempSub, nCountElems);\n    \
    \                            ## Check that the element is consolidated and has children\n        \
    \                        If( DType( sCurrHier, sElement ) @= 'C' & ElementComponentCount( sDim, sCurrHierName,\
    \ sElement ) > 0 );\n                                    If( pLogOutput = 1 );\n                 \
    \                       LogOutput( 'INFO', Expand( 'Process called recursively for '%sElement%' in\
    \ hierarchy '%sDim%:%sCurrHierName%'.' ) );\n                                    EndIf;\n        \
    \                            ExecuteProcess( cThisProcName, 'pLogOutput', pLogOutput,\n          \
    \                              'pStrictErrorHandling', pStrictErrorHandling,\n                   \
    \                     'pDim', sDim, 'pHier', sCurrHierName,\n                                    \
    \    'pConsol', sElement, 'pRecursive', pRecursive,\n                                        'pDelim',\
    \ pDelim\n                                    );\n                                EndIf;\n       \
    \                         \n                                nCountElems = nCountElems - 1;\n     \
    \                       End;\n                        End;\n                    EndIf;\n         \
    \       Endif;\n            \n                nCountHier = nCountHier - 1;\n            End;\n   \
    \           \n        EndIf;\n      \n        nCountDim = nCountDim - 1;\n    End;\nEndIf;\n\n###\
    \ End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### If Leaf or already unwound\
    \ then skip\nIf( ElementComponentCount( pDim, pHier, vElement ) = 0 );\n    ItemSkip;\nEndIf;\n  \
    \  \n### Break all parent/child links below target consol ###\nIf( pConsol @= '*' );\n    sAttrVal\
    \ = cAttrVal;\nElse;\n    sAttrVal = ElementAttrS( pDim, pHier, vElement, cHierAttr );\nEndIf;\n\n\
    If( sAttrVal @= cAttrVal );\n    bFastUnwind = 1;\n\n    # Cannot check nPars > 1 as due to ordering\
    \ of elements processes some parents may have already been removed\n    nPars = ElementParentCount(\
    \ pDim, pHier, vElement );\n    nPar = 1;\n    While( nPar <= nPars );\n        sPar = ElementParent(\
    \ pDim, pHier, vElement, nPar );\n        If( ElementAttrS( pDim, pHier, sPar, cHierAttr ) @<> cAttrVal\
    \ );\n            # Parent does not belong to unwinding intersection. Cannot delete C children, must\
    \ unwind.\n            bFastUnwind = 0;\n        EndIf;\n        nPar = nPar + 1;\n    End;\n    \
    \    \n    If( bFastUnwind = 1 );\n        # delete and recreate C element (Fast)\n        sEleNext\
    \ = ElementName( pDim, pHier, ElementIndex( pDim, pHier, vElement ) + 1 );\n        HierarchyElementDelete(\
    \ pDim, pHier, vElement );\n        HierarchyElementInsert( pDim, pHier, sEleNext, vElement, 'C' );\n\
    \    Else;\n        # unwind C element without deletion (Slow for consols with many children)\n  \
    \      nComp = ElementComponentCount( pDim, pHier, vElement );\n        While( nComp > 0 );\n    \
    \        sComp = ElementComponent( pDim, pHier, vElement, nComp );\n            HierarchyElementComponentDelete(\
    \ pDim, pHier, vElement, sComp );\n            nComp = nComp - 1;\n        End;\n    EndIf;\n    \n\
    EndIf;\n\n### End Metadata ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\nElse;\n\n    ### Remove Descendent attribute\n    IF( Scan( '*', pDim ) = 0 &  Scan( '?', pDim\
    \ ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim,\
    \ pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 & Scan( pDelim, pConsol ) = 0\
    \ );\n      AttrDelete( pDim, cHierAttr );\n    EndIf;\nEndIf;\n\n### Reset Logging in the Attribute\
    \ cube\nIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*',\
    \ pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan(\
    \ '?', pConsol ) = 0 & Scan( pDelim, pConsol ) = 0 );\n    If( CubeExists( sAttrCube ) = 1 );\n  \
    \      If( nLogging = 1 );\n            CubeSetLogChanges( sAttrCube, 1 );\n        EndIf;\n    EndIf;\n\
    EndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n   \
    \ nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully unwound the appropriate consolidated\
    \ items the %pDim%:%pHier% dimension:hierarchy.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that removes all children from a specific target
    consolidation (pConsol) in a hierarchy within the target dimension. If recursive (pRecursive=1) is
    specified, the process will also unwind all consolidations that are descendants of the target regardless
    of depth. Otherwise, only immediate children of the target consolidation will be removed. This is
    intended for both production and development prototyping scenarios. In production, the process is
    called prior to the main dimension build process to account for changed mapping relationships and
    avoid double-counting. Combined with }ti.hier.emptyconsols.delete, it can also remove orphaned rollups.
    In development, it provides manual cleanup of dimensions before deployment. A valid source dimension
    name (pDim) is mandatory; otherwise, the process will abort. A blank pHier parameter processes only
    the same named hierarchy for each dimension processed. A ''*'' in the pConsol parameter processes
    all C-level items in the given hierarchy. A delimited list or wildcard for pDim or pHier or a delimited
    list of consolidations for pConsol results in recursive calls of the process. Caution: If consolidations
    are also used in unrelated consolidations and recursive is selected, this will result in orphan consolidations
    in other rollups.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will remove all children from a specific target consolidation\
    \ (pConsol) in a Hierarchy\n# in target Dimension. If recursive (pRecursive=1), it will also unwind\
    \ all consolidations that are \n# descendants of the target regardless of depth. If not recursive\
    \ (pRecursive=0) then only immediate children\n# of the target consolidation will be removed.\n#\n\
    # Use case: Intended for both production and development/prototyping scenarios.\n# 1. **Production**\
    \ call prior to main dimension build process in case mapping relationships have changed to ensure\
    \ no double-counting steming from leaf elements \n#    rolling into multiple parents within the same\
    \ rollup or hierarhcy\n# 2. **Production** combine with }bedrock.hier.emptyconsols.delete to remove\
    \ orphaned rollups\n# 3. **Development** manual cleanup of dimensions during prototyping or prior\
    \ to going to production\n#\n# Note:\n# * A valid source dimension name (pDim) is mandatory otherwise\
    \ the process will abort.\n# * A blank pHier parameter will process _only the same named hierarchy_\
    \ for each of the dimensions processed.\n# * A \\* pConsol parameter will process ALL C level items\
    \ in the given hierarchy (pHier).\n# * A delimited list or wildcard for pDim or pHier or a delimited\
    \ list of consolidations for pConsol will result in recursive calls of the process.\n#\n# Caution:\
    \ \n# If consolidations are also used in unrelated consolidations and recursive is selected this\n\
    # will result in orphan consolidations in the other rollups.\n#EndRegion @DOC\n\n##Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp\
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncTempSub        = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncTempSubOuter   = '}OuterLoop_'\
    \ | cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncTempSubInner   = '}InnerLoop_' | cThisProcName\
    \ |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\ncMsgErrorContent= 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncMsgInfoContent = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\n\
    cLogInfo        = 'Process:%cThisProcName% run with parameters pDim:%pDim%, pHier:%pHier%, pConsol:%pConsol%,\
    \ pRecursive:%pRecursive%, pDelim:%pDelim%.' ;\ncHierAttr       = 'Bedrock.Descendant';\ncAttrVal\
    \        = 'Descendant';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIf( Scan( '*',\
    \ pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( ':', pDim ) > 0 & pHier @=\
    \ '' );\n    # A hierarchy has been passed as dimension. Handle the input error by splitting dim:hier\
    \ into dimension & hierarchy\n    pHier       = SubSt( pDim, Scan( ':', pDim ) + 1, Long( pDim ) );\n\
    \    pDim        = SubSt( pDim, 1, Scan( ':', pDim ) - 1 );\nEndIf;\n\n## Validate Source dimension\n\
    IF( Trim( pDim ) @= '' );\n    nErrors = 1;\n    sMessage = 'No dimension specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim )\
    \ = 0 & Scan( pDelim, pDim ) = 0 & DimensionExists( pDim ) = 0 );\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid dimension: ' | pDim;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate hierarchy (can only validate hierarchy up front if dimension is fixed and doesn't\
    \ contain wildcards)\nIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0\
    \ & pHier @= '');\n    pHier = pDim;\nElseIf( Scan( '*', pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan(\
    \ pDelim, pHier ) = 0 & pHier @<> '' & DimensionExists( pDim ) = 1 & HierarchyExists( pDim, pHier\
    \ ) = 0 );\n    nErrors = 1;\n    sMessage = 'Invalid dimension hierarchy: ' | pHier;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\n\nIf( Trim( pHier ) @= '' );\n    ## use\
    \ same name as Dimension. Since wildcards are allowed, this is managed inside the code below\nEndIf;\n\
    \n# Validate consol\nIf( pConsol @<> '');\n    If( Scan( '*', pConsol ) = 0 & Scan( '?', pConsol )\
    \ = 0 & Scan( pDelim, pConsol ) = 0 & ElementIndex( pDim, pHier, pConsol ) = 0 );\n        nErrors\
    \ = 1;\n        sMessage = 'Item ' | pConsol | ' does NOT exist. Please enter a valid consolidation\
    \ element in the ' |pDim| ':' |pHier| ' dimension:hierarchy.';  \n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    ElseIf( Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 &\
    \ Scan( pDelim, pConsol ) = 0 & ElementType( pDim, pHier, pConsol ) @<> 'C' );\n        nErrors =\
    \ 1;\n        sMessage = 'Item ' | pConsol | ' is NOT a consolidated item. Please enter a valid consolidation\
    \ element in the ' |pDim| ':' |pHier| ' dimension:hierarchy.';  \n        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    ElseIf( Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 &\
    \ Scan( pDelim, pConsol ) = 0 & ElementComponentCount( pDim, pHier, pConsol ) = 0 );\n        nErrors\
    \ = 1;\n        sMessage = 'Invalid consolidation: ' | pConsol | ' has no children.';\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    Endif;\nElseIf( Trim( pConsol ) @= '' );\n  \
    \  nErrors = 1;\n    sMessage = 'No consolidated element specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;\n\n# If blank delimiter specified then convert to default\n\
    If( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors\
    \ <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nElse;\n  # If subset required will be set later\n  DataSourceType = 'NULL';\nEndIf;\n\n\
    ### If there is no separator and wildcard in the parameters, execute the unwind of the specific consolidated\
    \ element\nIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*',\
    \ pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan(\
    \ '?', pConsol ) = 0 & Scan( pDelim, pConsol ) = 0 );\n\n    ### In case alias used for pConsol convert\
    \ to principal name \n    If( ElementIndex( pDim, pHier, pConsol ) > 0 );\n        pConsol = HierarchyElementPrincipalName(\
    \ pDim, pHier, pConsol );\n    EndIf;\n\n    ### Turn-off Logging in the Attribute cube\n    sAttrCube\
    \ = '}ElementAttributes_' | pDim;\n    If( CubeExists( sAttrCube ) = 1 );\n        nLogging = CubeGetLogChanges(\
    \ sAttrCube );\n        CubeSetLogChanges( sAttrCube, 0 );\n    EndIf;\n    \n    ### Create Temp\
    \ Descendent Attribute\n    AttrDelete( pDim, cHierAttr );\n    AttrInsert( pDim, '', cHierAttr, 'S'\
    \ );\n    \n    ### Assign data source ###\n    If( pRecursive      = 1);\n        # Set Descendent\
    \ attribute value\n        nElementIndex   = 1;\n        nElementCount   = ElementCount( pDim , pHier\
    \ );\n        While( nElementIndex <= nElementCount );\n            sElement = ElementName( pDim,\
    \ pHier, nElementIndex );\n            If( ElementIsAncestor( pDim, pHier, pConsol, sElement ) = 1\
    \ % pConsol @= sElement );\n                ElementAttrPutS( cAttrVal, pDim, pHier, sElement, cHierAttr\
    \ );\n            EndIf;\n            nElementIndex = nElementIndex + 1;\n        End;\n        #\
    \ Assign Data Source\n        DataSourceType            = 'SUBSET';\n        DatasourceNameForServer\
    \   = pDim|':'|pHier;\n        DatasourceNameForClient   = pDim|':'|pHier;\n        DatasourceDimensionSubset\
    \ = 'ALL';\n    Else;\n        ### Remove direct children from the target consol ###\n        If(\
    \ ElementComponentCount( pDim, pHier, pConsol ) > 0 );\n            If( pLogOutput = 1 );\n      \
    \          LogOutput( 'INFO', Expand( 'Deleting all components from consolidation %pConsol% in hierarchy\
    \ '%pHier%' of '%pDim%' dimension.' ) );\n            EndIf;\n            nComp = ElementComponentCount(\
    \ pDim, pHier, pConsol );\n            While( nComp > 0 );\n                sComp = ElementComponent(\
    \ pDim, pHier, pConsol, nComp );\n                HierarchyElementComponentDelete( pDim, pHier, pConsol,\
    \ sComp );\n                nComp = nComp - 1;\n            End;\n        EndIf;\n        # No data\
    \ source, straight to Epilog\n        DataSourceType = 'NULL';\n    EndIf;\n\n### If pConsol is '*'\
    \ and there is no separator and wildcard in the pDim & pHier parameters then unwind the whole hierarchy\n\
    ElseIf( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier\
    \ ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Trim( pConsol ) @= '*' );\n\n    #\
    \ as pConsol is * wildcard it doesn't matter if recursive or not. We unwind everything. As speed enhancement\
    \ rather than removing children delete and add back C elements to empty children in one step (not\
    \ steps = count of children)\n    nMaxEle = ElementCount( pDim, pHier );\n    nCtrEle = 1;\n    While(\
    \ nCtrEle <= nMaxEle );\n        sEle = ElementName( pDim, pHier, nCtrEle);\n        If( ElementComponentCount(\
    \ pDim, pHier, sEle ) > 0 );\n            If( nCtrEle < nMaxEle );\n                sEleNext = ElementName(\
    \ pDim, pHier, nCtrEle + 1 );\n            Else;\n                sEleNext = '';\n            EndIf;\n\
    \            HierarchyElementDelete( pDim, pHier, sEle );\n            HierarchyElementInsert( pDim,\
    \ pHier, sEleNext, sEle, 'C' );\n        EndIf;\n        nCtrEle = nCtrEle + 1;\n    End;\n\n    #\
    \ since hierarchy already fully unwound no subset; datasource = NULL\n    DataSourceType = 'NULL';\n\
    \n## Otherwise, if there is a separator or wildcard in the parameters, tokenize the string and self-call\
    \ the process recursively.\nElse;\n    # No data source, straight to Epilog\n    DataSourceType =\
    \ 'NULL';\n    \n    # Loop through dimensions in pDim\n    sDims = pDim;\n    nDimDelimiterIndex\
    \ = 1;\n    sMdx = '';\n    # Get 1st dimension\n    While( nDimDelimiterIndex <> 0 );\n        #\
    \ Extract 1st dimension > sDim\n        nDimDelimiterIndex = Scan( pDelim, sDims );\n        If( nDimDelimiterIndex\
    \ = 0 );\n            sDim = sDims;\n        Else;\n            sDim = Trim( SubSt( sDims, 1, nDimDelimiterIndex\
    \ - 1 ) );\n            sDims = Trim( Subst( sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims\
    \ ) ) );\n        EndIf;\n        \n        # Create subset of dimensions using Wildcard to loop through\
    \ dimensions in pDim with wildcard\n        sDimExp = '''|sDim|''';\n        sMdxPart = Expand('{TM1FILTERBYPATTERN(\
    \ EXCEPT( TM1SUBSETALL( [}Dimensions].[}Dimensions] ), TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions].[}Dimensions]\
    \ ) , '*:*') ) , %sDimExp% )}');\n        If( sMdx @= ''); \n            sMdx = sMdxPart; \n     \
    \   Else;\n            sMdx = sMdx | ' + ' | sMdxPart;\n        EndIf;\n    End;\n  \n    If( SubsetExists(\
    \ '}Dimensions' , cTempSubOuter ) = 1 );\n        # If a delimited list of dim names includes wildcards\
    \ then we may have to re-use the subset multiple times\n        SubsetMDXSet( '}Dimensions' , cTempSubOuter,\
    \ sMDX );\n    Else;\n        # temp subset, therefore no need to destroy in epilog\n        SubsetCreatebyMDX(\
    \ cTempSubOuter, sMDX, '}Dimensions' , 1 );\n    EndIf;\n  \n    # Loop through dimensions in subset\
    \ created based on wildcard\n    nCountDim = SubsetGetSize( '}Dimensions' , cTempSubOuter );\n   \
    \ While( nCountDim >= 1 );\n        sDim = SubsetGetElementName( '}Dimensions' , cTempSubOuter, nCountDim\
    \ );\n        # Validate dimension name\n        If( DimensionExists(sDim) = 0 );\n            nErrors\
    \ = 1;\n            sMessage = Expand( 'Dimension '%sDim%' does not exist.' );\n            LogOutput(\
    \ 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            If( pLogOutput = 1 );\n     \
    \           sMessage = Expand( 'Dimension '%sDim%' being processed....' );\n                LogOutput(\
    \ 'INFO', Expand( cMsgInfoContent ) );\n            EndIf;\n            # Loop through hierarchies\
    \ in pHier\n            If( Trim( pHier ) @= '' );\n                ### Use main hierarchy for each\
    \ dimension if pHier is empty\n                sHierarchies  = sDim;\n            Else;\n        \
    \        sHierarchies  = pHier;\n            EndIf;\n            nDelimiterIndexA  = 1;\n        \
    \    sHierDim          = '}Dimensions' ;\n            sMdxHier          = '';\n            While(\
    \ nDelimiterIndexA <> 0 );\n                nDelimiterIndexA = Scan( pDelim, sHierarchies );\n   \
    \             If( nDelimiterIndexA = 0 );\n                    sHierarchy   = sHierarchies;\n    \
    \            Else;\n                    sHierarchy   = Trim( SubSt( sHierarchies, 1, nDelimiterIndexA\
    \ - 1 ) );\n                    sHierarchies  = Trim( Subst( sHierarchies, nDelimiterIndexA + Long(pDelim),\
    \ Long( sHierarchies ) ) );\n                EndIf;\n      \n                # Create subset of Hierarchies\
    \ using Wildcard\n                If( sDim @= sHierarchy );\n                    sHierExp = '''| sDim\
    \ |''';\n                Else;\n                    sHierExp = '''| sDim | ':' | sHierarchy|''';\n\
    \                EndIf;\n                    sMdxHierPart = Expand('{TM1FILTERBYPATTERN( {TM1SUBSETALL([%sHierDim%].[%sHierDim%])},\
    \ %sHierExp% )}');\n                If( sMdxHier @= ''); \n                    sMdxHier = sMdxHierPart;\
    \ \n                Else;\n                    sMdxHier = sMdxHier | ' + ' | sMdxHierPart;\n     \
    \           EndIf;\n            End;\n          \n            # include the named hierarchy in case\
    \ ALL hierachies\n            If( Trim(pHier) @= '*' );\n                sMdxHier = Expand('{[%sHierDim%].[%sHierDim%].[%sDim%]}\
    \ + %sMdxHier%');\n            EndIf;\n  \n            If( SubsetExists( sHierDim, cTempSubInner )\
    \ = 1 );\n                # If a delimited list of hierarchy names includes wildcards then we may\
    \ have to re-use the subset multiple times\n                SubsetMDXSet( sHierDim, cTempSubInner,\
    \ sMdxHier );\n            Else;\n                # temp subset, therefore no need to destroy in epilog\n\
    \                SubsetCreatebyMDX( cTempSubInner, sMdxHier, sHierDim, 1 );\n            EndIf;\n\n\
    \            # Loop through subset of hierarchies created based on wildcard\n            nCountHier\
    \ = SubsetGetSize( sHierDim, cTempSubInner );\n            While( nCountHier >= 1 );\n           \
    \     sCurrHier = SubsetGetElementName( sHierDim, cTempSubInner, nCountHier );\n                sCurrHierName\
    \ = Subst( sCurrHier, Scan(':', sCurrHier)+1, Long(sCurrHier) );\n                # Validate hierarchy\
    \ name in sHierDim\n                If( Dimix( sHierDim , sCurrHier ) = 0 );\n                   \
    \ sMessage = Expand('The '%sCurrHier%' hierarchy does NOT exist in the '%sDim%' dimension.');\n  \
    \                  LogOutput( 'INFO' , Expand( cMsgInfoContent ) );\n                ElseIf( sCurrHierName\
    \ @= 'Leaves' );\n                    sMessage = Expand('Skipping %sCurrHier% hierarchy. No need to\
    \ unwind!');\n                    If( pLogOutput = 1 );\n                        LogOutput( 'INFO',\
    \ Expand( cMsgInfoContent ) );\n                    EndIf;\n                Else;\n              \
    \      If( pLogOutput = 1 );\n                        sMessage = Expand( 'Hierarchy '%sCurrHierName%'\
    \ in Dimension '%sDim%' being processed....' );\n                        LogOutput( 'INFO', Expand(\
    \ cMsgInfoContent ) );\n                    EndIf;\n                    # Loop through consolidated\
    \ elements in pConsol\n                    sEles = Trim( pConsol );\n                    If( sEles\
    \ @= '*' );\n                        # no need for recursive call for ALL wildcard. We can just unwind\
    \ whole hierarchy\n                        nMaxEle = ElementCount( sDim, sCurrHierName );\n      \
    \                  nCtrEle = 1;\n                        While( nCtrEle <= nMaxEle );\n          \
    \                  sEle = ElementName( sDim, sCurrHierName, nCtrEle);\n                          \
    \  If( ElementComponentCount( sDim, sCurrHierName, sEle ) > 0 );\n                               \
    \ If( nCtrEle < nMaxEle );\n                                    sEleNext = ElementName( sDim, sCurrHierName,\
    \ nCtrEle + 1 );\n                                Else;\n                                    sEleNext\
    \ = '';\n                                EndIf;\n                                HierarchyElementDelete(\
    \ sDim, sCurrHierName, sEle );\n                                HierarchyElementInsert( sDim, sCurrHierName,\
    \ sEleNext, sEle, 'C' );\n                            EndIf;\n                            nCtrEle\
    \ = nCtrEle + 1;\n                        End;\n                    Else;\n                      \
    \  # a delimited list of consolidations is given. Handle with recursive call and temp descendents\
    \ attribute\n                        nDelimiterIndexB = 1;\n                        While( nDelimiterIndexB\
    \ <> 0 );\n                            nDelimiterIndexB = Scan( pDelim, sEles );\n               \
    \             If( nDelimiterIndexB = 0 );\n                                sEle = sEles;\n       \
    \                     Else;\n                                sEle = Trim( SubSt( sEles, 1, nDelimiterIndexB\
    \ - 1 ) );\n                                sEles = Trim( Subst( sEles, nDelimiterIndexB + Long(pDelim),\
    \ Long( sEles ) ) );\n                            EndIf;\n                        \n             \
    \               # Wildcard search string\n                            sEle = '''|sEle|''';\n     \
    \                       sMdxEle = Expand('{TM1FILTERBYPATTERN( {TM1SUBSETALL([%sCurrHier%])}, %sEle%\
    \ )}');\n      \n                            If( HierarchySubsetExists( sDim, sCurrHierName, cTempSub\
    \ ) = 1 );\n                                # If a delimited list of dim names includes wildcards\
    \ then we may have to re-use the subset multiple times\n                                HierarchySubsetMDXSet(\
    \ sDim, sCurrHierName, cTempSub, sMDXEle );\n                            Else;\n                 \
    \               # temp subset, therefore no need to destroy in epilog\n                          \
    \      SubsetCreatebyMDX( cTempSub, sMDXEle, sCurrHier, 1 );\n                            EndIf;\n\
    \      \n                            # Loop through subset of Consolidated elements created based\
    \ on wildcard\n                            nCountElems = HierarchySubsetGetSize(sDim, sCurrHierName,\
    \ cTempSub);\n                            While( nCountElems >= 1 );\n                           \
    \     sElement = HierarchySubsetGetElementName(sDim, sCurrHierName, cTempSub, nCountElems);\n    \
    \                            ## Check that the element is consolidated and has children\n        \
    \                        If( DType( sCurrHier, sElement ) @= 'C' & ElementComponentCount( sDim, sCurrHierName,\
    \ sElement ) > 0 );\n                                    If( pLogOutput = 1 );\n                 \
    \                       LogOutput( 'INFO', Expand( 'Process called recursively for '%sElement%' in\
    \ hierarchy '%sDim%:%sCurrHierName%'.' ) );\n                                    EndIf;\n        \
    \                            ExecuteProcess( cThisProcName, 'pLogOutput', pLogOutput,\n          \
    \                              'pStrictErrorHandling', pStrictErrorHandling,\n                   \
    \                     'pDim', sDim, 'pHier', sCurrHierName,\n                                    \
    \    'pConsol', sElement, 'pRecursive', pRecursive,\n                                        'pDelim',\
    \ pDelim\n                                    );\n                                EndIf;\n       \
    \                         \n                                nCountElems = nCountElems - 1;\n     \
    \                       End;\n                        End;\n                    EndIf;\n         \
    \       Endif;\n            \n                nCountHier = nCountHier - 1;\n            End;\n   \
    \           \n        EndIf;\n      \n        nCountDim = nCountDim - 1;\n    End;\nEndIf;\n\n###\
    \ End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Check for errors in prolog ###\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### If Leaf or already unwound\
    \ then skip\nIf( ElementComponentCount( pDim, pHier, vElement ) = 0 );\n    ItemSkip;\nEndIf;\n  \
    \  \n### Break all parent/child links below target consol ###\nIf( pConsol @= '*' );\n    sAttrVal\
    \ = cAttrVal;\nElse;\n    sAttrVal = ElementAttrS( pDim, pHier, vElement, cHierAttr );\nEndIf;\n\n\
    If( sAttrVal @= cAttrVal );\n    bFastUnwind = 1;\n\n    # Cannot check nPars > 1 as due to ordering\
    \ of elements processes some parents may have already been removed\n    nPars = ElementParentCount(\
    \ pDim, pHier, vElement );\n    nPar = 1;\n    While( nPar <= nPars );\n        sPar = ElementParent(\
    \ pDim, pHier, vElement, nPar );\n        If( ElementAttrS( pDim, pHier, sPar, cHierAttr ) @<> cAttrVal\
    \ );\n            # Parent does not belong to unwinding intersection. Cannot delete C children, must\
    \ unwind.\n            bFastUnwind = 0;\n        EndIf;\n        nPar = nPar + 1;\n    End;\n    \
    \    \n    If( bFastUnwind = 1 );\n        # delete and recreate C element (Fast)\n        sEleNext\
    \ = ElementName( pDim, pHier, ElementIndex( pDim, pHier, vElement ) + 1 );\n        HierarchyElementDelete(\
    \ pDim, pHier, vElement );\n        HierarchyElementInsert( pDim, pHier, sEleNext, vElement, 'C' );\n\
    \    Else;\n        # unwind C element without deletion (Slow for consols with many children)\n  \
    \      nComp = ElementComponentCount( pDim, pHier, vElement );\n        While( nComp > 0 );\n    \
    \        sComp = ElementComponent( pDim, pHier, vElement, nComp );\n            HierarchyElementComponentDelete(\
    \ pDim, pHier, vElement, sComp );\n            nComp = nComp - 1;\n        End;\n    EndIf;\n    \n\
    EndIf;\n\n### End Metadata ###\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\nElse;\n\n    ### Remove Descendent attribute\n    IF( Scan( '*', pDim ) = 0 &  Scan( '?', pDim\
    \ ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*', pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim,\
    \ pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan( '?', pConsol ) = 0 & Scan( pDelim, pConsol ) = 0\
    \ );\n      AttrDelete( pDim, cHierAttr );\n    EndIf;\nEndIf;\n\n### Reset Logging in the Attribute\
    \ cube\nIF( Scan( '*', pDim ) = 0 & Scan( '?', pDim ) = 0 & Scan( pDelim, pDim ) = 0 & Scan( '*',\
    \ pHier ) = 0 & Scan( '?', pHier ) = 0 & Scan( pDelim, pHier ) = 0 & Scan( '*', pConsol ) = 0 & Scan(\
    \ '?', pConsol ) = 0 & Scan( pDelim, pConsol ) = 0 );\n    If( CubeExists( sAttrCube ) = 1 );\n  \
    \      If( nLogging = 1 );\n            CubeSetLogChanges( sAttrCube, 1 );\n        EndIf;\n    EndIf;\n\
    EndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n   \
    \ nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully unwound the appropriate consolidated\
    \ items the %pDim%:%pHier% dimension:hierarchy.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Erstelle eine Beschreibung für einen IBM Turbo Integrator Prozess. Die Beschreibung sollte
    klar und präzise darstellen, was der Prozess tut, sowie den Anwendungsfall erläutern. Außerdem sollten
    wichtige Hinweise für die Benutzer angegeben werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# A description of what this process does here.\n# Use case:\n# A\
    \ description of the use cast for this process does here.\n# Note:\n# * List any notes for users to\
    \ be aware of here.\n#EndRegion @DOC\n\n#Region Process Declarations\n### Process Parameters\n# a\
    \ short description of what the process does goes here in cAction variable, e.g. 'copied data from\
    \ cube A to cube B'. This will be written to the message log if pLogOutput=1\ncAction            \
    \ = 'ran with no action';\ncParamArray         = '';\n# to use the parameter array remove the line\
    \ above and uncomment the line below, adding the needed parameters in the provided format\n#cParamArray\
    \         = 'pLogOutput:%pLogOutput%, pTemp:%pTemp%';\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\n\n### Standard Constants\ncThisProcName       = GetProcessName();\n\
    cUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempObjName        = Expand('%cThisProcName%_%cTimeStamp%_%cRandomInt%');\n\
    cViewClr            = '}bedrock_clear_' | cTempObjName;\ncViewSrc            = '}bedrock_source_'\
    \ | cTempObjName;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters %cParamArray%';\n\
    sDelimEleStart      = '¦';\nsDelimDim           = '&';\nsDelimEle           = '+';\nnProcessReturnCode\
    \  = 0;\nnErrors             = 0;\nnMetadataRecordCount= 0;\nnDataRecordCount    = 0;\n\n### Process\
    \ Specific Constants\ncCubeSrc            = 'Source Cube';\ncCubeTgt            = 'Target Cube';\n\
    \n#EndRegion Process Declarations\n\n### LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n#Region Validate Parameters\n\n# pLogOutput\nIf( pLogOutput\
    \ >= 1 );\n    pLogOutput = 1;\nElse;\n    pLogOutput = 0;\nEndIf;\n    \n# pTemp\nIf( pTemp >= 1\
    \ );\n    pTemp = 1;\nElse;\n    pTemp = 0;\nEndIf;\n\n# Validate source cube\nIf( Trim( cCubeSrc\
    \ ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No source cube specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( cCubeSrc ) = 0 );\n    nErrors\
    \ = nErrors + 1;\n    sMessage = Expand( 'Invalid source cube specified: %cCubeSrc%.');\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate target cube\nIf( Trim( cCubeTgt\
    \ ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No target cube specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( cCubeTgt ) = 0 );\n    nErrors\
    \ = nErrors + 1;\n    sMessage = Expand( 'Invalid target cube specified: %cCubeTgt%.');\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If any parameters fail validation then\
    \ set data source of process to null and go directly to epilog\nIf( nErrors > 0 );\n    DataSourceType\
    \ = 'NULL';\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\nEndIf;\n\n#EndRegion Validate Parameters\n\n### If required switch transaction logging\
    \ off (this should be done AFTER the escape/reject if parameters fail validation and BEFORE the zero\
    \ out commences)\nnCubeLogChanges = CubeGetLogChanges( cCubeTgt );\nCubeSetLogChanges( cCubeTgt, 0\
    \ );\n\n#Region - ZeroOut\n\nsProc       = '}bedrock.cube.data.clear';\n# Set filter as per logic\
    \ requirement of the ZeroOut\nsFilter     = 'Dim1' | sDelimEleStart | 'El1' | sDelimDim | 'Dim2' |\
    \ sDelimEleStart | 'El2';\nnRet        = ExecuteProcess( sProc, 'pLogOutput', pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n\t'pCube', cCubeTgt, 'pView', cViewClr, 'pFilter', sFilter,\n\t'pDimDelim',\
    \ sDelimDim, 'pEleStartDelim', sDelimEleStart, 'pEleDelim', sDelimEle,\n\t'pTemp', pTemp \n);\nIf(\
    \ nRet <> ProcessExitNormal() );\n    nErrors = nErrors + 1;\n    sMessage= 'Error in ZeroOut.';\n\
    \    DataSourceType = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n#EndRegion - ZeroOut\n\n#Region - DataSource\n\nsProc   = '}bedrock.cube.view.create';\n# Set filter\
    \ as per logic requirement of the data source processing\nsFilter = Expand('Dim1%sDelimEleStart%El1%%sDelimDim%Dim2%sDelimEleStart%El2%');\n\
    # Adjust parameters for skipping of blanks / consols / rule calcs as required\nbSuppressNull   = 1;\n\
    bSuppressC      = 1;\nbSuppressRule   = 1;\nnRet = ExecuteProcess( sProc, 'pLogOutput', pLogOutput,\
    \ \n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pCube', cCubeSrc, 'pView', cViewSrc, 'pFilter',\
    \ sFilter,\n\t'pSuppressZero', bSuppressNull, 'pSuppressConsol', bSuppressC, 'pSuppressRules', bSuppressRule,\n\
    \t'pDimDelim', sDelimDim, 'pEleStartDelim', sDelimEleStart, 'pEleDelim', sDelimEle,\n\t'pTemp', pTemp\n\
    );\nIf( nRet <> ProcessExitNormal() );\n    nErrors = nErrors + 1;\n    sMessage= 'Error in source\
    \ view creation.';\n    DataSourceType = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Assign data source\nIf( nErrors = 0 );\n    DatasourceType          = 'VIEW';\n\
    \    DatasourceNameForServer = cCubeSrc;\n    DatasourceCubeView      = cViewSrc;\nEndIf;\n\n#EndRegion\
    \ - DataSource\n\n### End Prolog ###\n#Section Metadaten\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\nIf( pLogOutput >= 1 );\n   nMetadataRecordCount = nMetadataRecordCount\
    \ + 1;\nEndIf;\n\n#Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \nIf( pLogOutput >= 1 );\n   nDataRecordCount = nDataRecordCount + 1;\nEndIf;\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### If required switch\
    \ transaction logging back on \nCubeSetLogChanges( cCubeTgt, nCubeLogChanges );\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully %cAction%. %nDataRecordCount% records processed.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Create a description for an IBM Turbo Integrator process. The description should clearly and
    precisely explain what the process does, detail the use case, and include any important notes for
    users.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# A description of what this process does here.\n# Use case:\n# A\
    \ description of the use cast for this process does here.\n# Note:\n# * List any notes for users to\
    \ be aware of here.\n#EndRegion @DOC\n\n#Region Process Declarations\n### Process Parameters\n# a\
    \ short description of what the process does goes here in cAction variable, e.g. 'copied data from\
    \ cube A to cube B'. This will be written to the message log if pLogOutput=1\ncAction            \
    \ = 'ran with no action';\ncParamArray         = '';\n# to use the parameter array remove the line\
    \ above and uncomment the line below, adding the needed parameters in the provided format\n#cParamArray\
    \         = 'pLogOutput:%pLogOutput%, pTemp:%pTemp%';\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\n\n### Standard Constants\ncThisProcName       = GetProcessName();\n\
    cUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncTempObjName        = Expand('%cThisProcName%_%cTimeStamp%_%cRandomInt%');\n\
    cViewClr            = '}bedrock_clear_' | cTempObjName;\ncViewSrc            = '}bedrock_source_'\
    \ | cTempObjName;\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters %cParamArray%';\n\
    sDelimEleStart      = '¦';\nsDelimDim           = '&';\nsDelimEle           = '+';\nnProcessReturnCode\
    \  = 0;\nnErrors             = 0;\nnMetadataRecordCount= 0;\nnDataRecordCount    = 0;\n\n### Process\
    \ Specific Constants\ncCubeSrc            = 'Source Cube';\ncCubeTgt            = 'Target Cube';\n\
    \n#EndRegion Process Declarations\n\n### LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n#Region Validate Parameters\n\n# pLogOutput\nIf( pLogOutput\
    \ >= 1 );\n    pLogOutput = 1;\nElse;\n    pLogOutput = 0;\nEndIf;\n    \n# pTemp\nIf( pTemp >= 1\
    \ );\n    pTemp = 1;\nElse;\n    pTemp = 0;\nEndIf;\n\n# Validate source cube\nIf( Trim( cCubeSrc\
    \ ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No source cube specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( cCubeSrc ) = 0 );\n    nErrors\
    \ = nErrors + 1;\n    sMessage = Expand( 'Invalid source cube specified: %cCubeSrc%.');\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate target cube\nIf( Trim( cCubeTgt\
    \ ) @= '' );\n    nErrors = nErrors + 1;\n    sMessage = 'No target cube specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists( cCubeTgt ) = 0 );\n    nErrors\
    \ = nErrors + 1;\n    sMessage = Expand( 'Invalid target cube specified: %cCubeTgt%.');\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If any parameters fail validation then\
    \ set data source of process to null and go directly to epilog\nIf( nErrors > 0 );\n    DataSourceType\
    \ = 'NULL';\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    Else;\n        ProcessBreak;\n\
    \    EndIf;\nEndIf;\n\n#EndRegion Validate Parameters\n\n### If required switch transaction logging\
    \ off (this should be done AFTER the escape/reject if parameters fail validation and BEFORE the zero\
    \ out commences)\nnCubeLogChanges = CubeGetLogChanges( cCubeTgt );\nCubeSetLogChanges( cCubeTgt, 0\
    \ );\n\n#Region - ZeroOut\n\nsProc       = '}bedrock.cube.data.clear';\n# Set filter as per logic\
    \ requirement of the ZeroOut\nsFilter     = 'Dim1' | sDelimEleStart | 'El1' | sDelimDim | 'Dim2' |\
    \ sDelimEleStart | 'El2';\nnRet        = ExecuteProcess( sProc, 'pLogOutput', pLogOutput,\n  'pStrictErrorHandling',\
    \ pStrictErrorHandling,\n\t'pCube', cCubeTgt, 'pView', cViewClr, 'pFilter', sFilter,\n\t'pDimDelim',\
    \ sDelimDim, 'pEleStartDelim', sDelimEleStart, 'pEleDelim', sDelimEle,\n\t'pTemp', pTemp \n);\nIf(\
    \ nRet <> ProcessExitNormal() );\n    nErrors = nErrors + 1;\n    sMessage= 'Error in ZeroOut.';\n\
    \    DataSourceType = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n#EndRegion - ZeroOut\n\n#Region - DataSource\n\nsProc   = '}bedrock.cube.view.create';\n# Set filter\
    \ as per logic requirement of the data source processing\nsFilter = Expand('Dim1%sDelimEleStart%El1%%sDelimDim%Dim2%sDelimEleStart%El2%');\n\
    # Adjust parameters for skipping of blanks / consols / rule calcs as required\nbSuppressNull   = 1;\n\
    bSuppressC      = 1;\nbSuppressRule   = 1;\nnRet = ExecuteProcess( sProc, 'pLogOutput', pLogOutput,\
    \ \n  'pStrictErrorHandling', pStrictErrorHandling,\n\t'pCube', cCubeSrc, 'pView', cViewSrc, 'pFilter',\
    \ sFilter,\n\t'pSuppressZero', bSuppressNull, 'pSuppressConsol', bSuppressC, 'pSuppressRules', bSuppressRule,\n\
    \t'pDimDelim', sDelimDim, 'pEleStartDelim', sDelimEleStart, 'pEleDelim', sDelimEle,\n\t'pTemp', pTemp\n\
    );\nIf( nRet <> ProcessExitNormal() );\n    nErrors = nErrors + 1;\n    sMessage= 'Error in source\
    \ view creation.';\n    DataSourceType = 'NULL';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Assign data source\nIf( nErrors = 0 );\n    DatasourceType          = 'VIEW';\n\
    \    DatasourceNameForServer = cCubeSrc;\n    DatasourceCubeView      = cViewSrc;\nEndIf;\n\n#EndRegion\
    \ - DataSource\n\n### End Prolog ###\n#Section Metadaten\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\nIf( pLogOutput >= 1 );\n   nMetadataRecordCount = nMetadataRecordCount\
    \ + 1;\nEndIf;\n\n#Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \nIf( pLogOutput >= 1 );\n   nDataRecordCount = nDataRecordCount + 1;\nEndIf;\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### If required switch\
    \ transaction logging back on \nCubeSetLogChanges( cCubeTgt, nCubeLogChanges );\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully %cAction%. %nDataRecordCount% records processed.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der die Sicherheit von einem Benutzer auf einen
    anderen kopiert. Wenn der Zielbenutzer oder die Zielbenutzer noch nicht existieren, sollen sie automatisch
    erstellt werden. Dieser Prozess soll für den produktiven Einsatz vorgesehen sein. Er ermöglicht es,
    das Profil neuer Mitarbeiter durch Klonen eines bestehenden Mitarbeiters zu erstellen. Hinweis: Ein
    gültiger Quellbenutzer (pSrcClient) ist obligatorisch, andernfalls wird der Prozess abgebrochen. Ebenso
    muss ein gültiger Zielbenutzer oder müssen gültige Zielbenutzer (pTgtClient) angegeben werden, andernfalls
    wird der Prozess abgebrochen. Mehrere Zielbenutzer können mit einem Trennzeichen angegeben werden.
    Wenn der Zielbenutzer noch nicht existiert, soll die Funktion Bedrock.Security.Client.Create aufgerufen
    werden. Der Prozess hat zwei Modi: Im REPLACE-Modus (Standard) werden alle bestehenden Gruppenmitgliedschaften
    gelöscht; im ADD-Modus werden nur neue Mitgliedschaften hinzugefügt.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will copy security from one user to another. Target\
    \ client(s) will be created if it doesn't exist.\n\n# Use case: Intended for production.\n# 1/ When\
    \ a company hires new employees their profile can be set up by cloning an existing employee.\n\n#\
    \ Note:\n# Naturally, a valid source client (pSrcClient) is mandatory otherwise the process will abort.\n\
    # Also, a valid target client(s) (pTgtClient) must be specified, otherwise the process will abort:\n\
    # - Multiple target clients can be specified separated by a delimiter.\n# - If target client doesn't\
    \ already exist then Bedrock.Security.Client.Create will be called.\n# - The process has 2 modes REPLACE\
    \ (default) clears any existing group memberships. ADD only adds new ones. \n#EndRegion @DOC\n\n##Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\nsRandomInt          = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pSrcClient:%pSrcClient%, pTgtClient:%pTgtClient%, pMode:%pMode%, pDelim:%pDelim%.'\
    \ ;  \n  \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n    pDelim          = '&';\nEndIf;\n\n#\
    \ If blank mode specified then convert to default\nIf( pMode @= '' );\n    pMode           = 'REPLACE';\n\
    EndIf;\n\n# If unsupported mode specified then abort\nIf( pMode @= 'ADD' % pMode @= 'REPLACE' );\n\
    \    # all is OK\nElse; \n    nErrors         = 1;\n    sMessage        = 'Invalid mode specified.\
    \ Must be ADD or REPLACE';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# If no source client has been specified then terminate process\nIf( Trim( pSrcClient ) @= '' );\n\
    \    nErrors         = 1;\n    sMessage        = 'No source client specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( DimIx( '}Clients', pSrcClient ) = 0 );\n    nErrors     \
    \    = 1;\n    sMessage        = 'Source client does not exist';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElse;\n    pSrcClient      = DimensionElementPrincipalName( '}Clients', pSrcClient\
    \ );\nEndIf;\n\n# If no target clients have been specified then terminate process\nIf( Trim( pTgtClient\
    \ ) @= '' );\n    nErrors         = 1;\n    sMessage        = 'No target client(s) specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimIx( '}Clients', pTgtClient\
    \ ) > 0 );\n    pTgtClient      = DimensionElementPrincipalName( '}Clients', pTgtClient );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Split pClients into individual\
    \ Clients and add only if they don't exist ###\n\nsClients            = Trim( pTgtClient );\nnDelimiterIndex\
    \     = 1;\n\n# loop delimited string of target clients\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex\
    \ = Scan( pDelim, sClients );\n    If( nDelimiterIndex = 0 );\n        sClient     = sClients;\n \
    \   Else;\n        sClient     = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n        sClients\
    \    = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n    EndIf;\n\
    \    # Don't attempt to add a blank client\n    If( sClient @<> '' );\n        If( DimIx( '}Clients',\
    \ sClient ) = 0 );\n            ExecuteProcess( '}bedrock.security.client.create', 'pStrictErrorHandling',\
    \ pStrictErrorHandling, 'pClient', sClient);\n        EndIf;\n    EndIf;\nEnd;\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Update\
    \ group memberships ###\nsClients            = Trim( pTgtClient );\nnDelimiterIndex     = 1;\n\n#\
    \ loop delimited string of target clients\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex = Scan(\
    \ pDelim, sClients );\n    If( nDelimiterIndex = 0 );\n        sClient     = sClients;\n    Else;\n\
    \        sClient     = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n        sClients    = Trim(\
    \ Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n    EndIf;\n    If( DimIx(\
    \ '}Clients', sClient ) >= 1 );\n        IF (pPassword @<>'');\n          sPassExists = CellGetS('}ClientProperties',\
    \ sClient, 'PASSWORD');\n          IF (sPassExists @='');\n            AssignClientPassword( sClient,\
    \ pPassword );\n          EndIf;  \n        EndIf;\n        sClient     = DimensionElementPrincipalName(\
    \ '}Clients', sClient );\n        # loop all security groups\n        nGroupIndex = 1;\n        nMaxGroups\
    \  = DimSiz( '}Groups' );\n        While( nGroupIndex <= nMaxGroups );\n            sGroup  = DimNm(\
    \ '}Groups', nGroupIndex );\n            If( sGroup @= CellGetS( '}ClientGroups', pSrcClient, sGroup\
    \ ) );\n                AssignClientToGroup( sClient, sGroup );\n            Else;\n             \
    \   If( pMode @= 'REPLACE' );\n                    # don't need to check if user in group. If user\
    \ not in group then no error with RemoveClientFromGroup function\n                    RemoveClientFromGroup(\
    \ sClient, sGroup );\n                EndIf;\n            EndIf;\n            nGroupIndex = nGroupIndex\
    \ + 1;\n            # exit loop of }Groups \n        End;\n    EndIf;\n    # exit loop of target clients\
    \ \nEnd;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n   \
    \ nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned %pSrcClient% to %pTgtClient%\
    \ by %pMode%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n \
    \   nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that copies security from one user to another. If
    the target user(s) do not exist, they should be automatically created. This process is intended for
    production use. It allows the setup of new employee profiles by cloning an existing employee. Note:
    A valid source client (pSrcClient) is mandatory; otherwise, the process will abort. Similarly, a valid
    target client(s) (pTgtClient) must be specified; otherwise, the process will abort. Multiple target
    clients can be specified, separated by a delimiter. If the target client does not already exist, the
    Bedrock.Security.Client.Create function should be called. The process has two modes: In REPLACE mode
    (default), all existing group memberships are cleared; in ADD mode, only new memberships are added.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will copy security from one user to another. Target\
    \ client(s) will be created if it doesn't exist.\n\n# Use case: Intended for production.\n# 1/ When\
    \ a company hires new employees their profile can be set up by cloning an existing employee.\n\n#\
    \ Note:\n# Naturally, a valid source client (pSrcClient) is mandatory otherwise the process will abort.\n\
    # Also, a valid target client(s) (pTgtClient) must be specified, otherwise the process will abort:\n\
    # - Multiple target clients can be specified separated by a delimiter.\n# - If target client doesn't\
    \ already exist then Bedrock.Security.Client.Create will be called.\n# - The process has 2 modes REPLACE\
    \ (default) clears any existing group memberships. ADD only adds new ones. \n#EndRegion @DOC\n\n##Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp\
    \          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\nsRandomInt          = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pSrcClient:%pSrcClient%, pTgtClient:%pTgtClient%, pMode:%pMode%, pDelim:%pDelim%.'\
    \ ;  \n  \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo\
    \ ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n    pDelim          = '&';\nEndIf;\n\n#\
    \ If blank mode specified then convert to default\nIf( pMode @= '' );\n    pMode           = 'REPLACE';\n\
    EndIf;\n\n# If unsupported mode specified then abort\nIf( pMode @= 'ADD' % pMode @= 'REPLACE' );\n\
    \    # all is OK\nElse; \n    nErrors         = 1;\n    sMessage        = 'Invalid mode specified.\
    \ Must be ADD or REPLACE';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n# If no source client has been specified then terminate process\nIf( Trim( pSrcClient ) @= '' );\n\
    \    nErrors         = 1;\n    sMessage        = 'No source client specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( DimIx( '}Clients', pSrcClient ) = 0 );\n    nErrors     \
    \    = 1;\n    sMessage        = 'Source client does not exist';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElse;\n    pSrcClient      = DimensionElementPrincipalName( '}Clients', pSrcClient\
    \ );\nEndIf;\n\n# If no target clients have been specified then terminate process\nIf( Trim( pTgtClient\
    \ ) @= '' );\n    nErrors         = 1;\n    sMessage        = 'No target client(s) specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( DimIx( '}Clients', pTgtClient\
    \ ) > 0 );\n    pTgtClient      = DimensionElementPrincipalName( '}Clients', pTgtClient );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Split pClients into individual\
    \ Clients and add only if they don't exist ###\n\nsClients            = Trim( pTgtClient );\nnDelimiterIndex\
    \     = 1;\n\n# loop delimited string of target clients\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex\
    \ = Scan( pDelim, sClients );\n    If( nDelimiterIndex = 0 );\n        sClient     = sClients;\n \
    \   Else;\n        sClient     = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n        sClients\
    \    = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n    EndIf;\n\
    \    # Don't attempt to add a blank client\n    If( sClient @<> '' );\n        If( DimIx( '}Clients',\
    \ sClient ) = 0 );\n            ExecuteProcess( '}bedrock.security.client.create', 'pStrictErrorHandling',\
    \ pStrictErrorHandling, 'pClient', sClient);\n        EndIf;\n    EndIf;\nEnd;\n\n### End Prolog ###\n\
    #Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n\
    #Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Update\
    \ group memberships ###\nsClients            = Trim( pTgtClient );\nnDelimiterIndex     = 1;\n\n#\
    \ loop delimited string of target clients\nWhile( nDelimiterIndex <> 0 );\n    nDelimiterIndex = Scan(\
    \ pDelim, sClients );\n    If( nDelimiterIndex = 0 );\n        sClient     = sClients;\n    Else;\n\
    \        sClient     = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n        sClients    = Trim(\
    \ Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n    EndIf;\n    If( DimIx(\
    \ '}Clients', sClient ) >= 1 );\n        IF (pPassword @<>'');\n          sPassExists = CellGetS('}ClientProperties',\
    \ sClient, 'PASSWORD');\n          IF (sPassExists @='');\n            AssignClientPassword( sClient,\
    \ pPassword );\n          EndIf;  \n        EndIf;\n        sClient     = DimensionElementPrincipalName(\
    \ '}Clients', sClient );\n        # loop all security groups\n        nGroupIndex = 1;\n        nMaxGroups\
    \  = DimSiz( '}Groups' );\n        While( nGroupIndex <= nMaxGroups );\n            sGroup  = DimNm(\
    \ '}Groups', nGroupIndex );\n            If( sGroup @= CellGetS( '}ClientGroups', pSrcClient, sGroup\
    \ ) );\n                AssignClientToGroup( sClient, sGroup );\n            Else;\n             \
    \   If( pMode @= 'REPLACE' );\n                    # don't need to check if user in group. If user\
    \ not in group then no error with RemoveClientFromGroup function\n                    RemoveClientFromGroup(\
    \ sClient, sGroup );\n                EndIf;\n            EndIf;\n            nGroupIndex = nGroupIndex\
    \ + 1;\n            # exit loop of }Groups \n        End;\n    EndIf;\n    # exit loop of target clients\
    \ \nEnd;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n   \
    \ nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully cloned %pSrcClient% to %pTgtClient%\
    \ by %pMode%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n \
    \   nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der zur Erstellung von Clients für mehrere neue
    Mitarbeiter gleichzeitig dient. Der Prozess weist jedem erstellten Client ein Passwort und eine maximale
    Anzahl von Ports zu. Beachte, dass die Angabe eines Clients (pClient) zwingend erforderlich ist, da
    der Prozess sonst abbricht. Mehrere Clients können durch ein Trennzeichen getrennt angegeben werden.
    Wenn ein Client bereits existiert, wird der Prozess ihn nicht erneut erstellen, sondern stattdessen
    das Passwort und die maximale Anzahl von Ports zurücksetzen. Beachte, dass jedem Client anschließend
    eine Gruppe zugewiesen werden muss. Dieser Prozess ist für die Produktion gedacht.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create clients, assign a password and max ports.\n\
    \n# Use case: Intended for production.\n# 1/ Create clients for multiple new hires simultaneously.\n\
    \n# Note:\n# Naturally, a client (pClient) is mandatory otherwise the process will abort.\n# - Multiple\
    \ clients can be specified separated by a delimiter.\n# - If client already exists then the process\
    \ will not attempt to re-create it but will reset password and max ports.\n# - Each client will have\
    \ to be assigned to a group afterwards.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pPassword:******,\
    \ pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n\n# If blank\
    \ delimiter specified then convert to default\nIf( pDelim @= '' );\n  pDelim            = '&';\nEndIf;\n\
    \n# If no clients have been specified then terminate process\nIf( Trim( pClient ) @= '' );\n  nErrors\
    \           = 1;\n  sMessage          = 'No clients specified.';\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n \
    \ If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n# Alias\nIf( pAlias @<> '' );\n    If( DimensionExists( '}ElementAttributes_}Clients' )\
    \ = 0 );\n        AttrInsert( '}Clients', '', '}TM1_DefaultDisplayValue', 'A' );\n    ElseIf( DimIx(\
    \ '}ElementAttributes_}Clients', '}TM1_DefaultDisplayValue' ) = 0 );\n        AttrInsert( '}Clients',\
    \ '', '}TM1_DefaultDisplayValue', 'A' );\n    EndIf;\nEndIf;\n\n### Split pClient into individual\
    \ Clients and add ###\nsClients            = pClient;\nnDelimiterIndex     = 1;\nWhile( nDelimiterIndex\
    \ <> 0 );\n    nDelimiterIndex   = Scan( pDelim, sClients );\n    If( nDelimiterIndex = 0 );\n   \
    \     sClient         = sClients;\n    Else;\n        sClient         = Trim( SubSt( sClients, 1,\
    \ nDelimiterIndex - 1 ) );\n        sClients        = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim),\
    \ Long( sClients ) ) );\n    EndIf;\n    # Don't attempt to add a blank client\n    If( sClient @<>\
    \ '' );\n        If( DimIx( '}Clients', sClient ) = 0 );\n            If( nErrors = 0 );\n       \
    \         AddClient( sClient );\n            EndIf;\n        EndIf;\n    EndIf;\nEnd;\n\nIf( nErrors\
    \ = 0 );\n    DimensionSortOrder( '}Clients', 'ByName', 'Ascending', 'ByName' , 'Ascending' );\nEndIf;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Update password & Alias\n\nIf( nErrors = 0 );\n\n  sAliases  = pAlias;\n  sClients  = pClient;\n\
    \  nDelimiterIndex = 1;\n\n  While( nDelimiterIndex > 0 );\n    nDelimiterIndex = Scan( pDelim, sAliases\
    \ );\n    If( nDelimiterIndex = 0 );\n      sAlias    = sAliases;\n    Else;\n      sAlias    = Trim(\
    \ SubSt( sAliases, 1, nDelimiterIndex - 1 ) );\n      sAliases  = Trim( Subst( sAliases, nDelimiterIndex\
    \ + Long(pDelim), Long( sAliases ) ) );\n    EndIf;\n    nDelimiterIndex = Scan( pDelim, sClients\
    \ );\n    If( nDelimiterIndex = 0 );\n      sClient   = sClients;\n    Else;\n      sClient   = Trim(\
    \ SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n      sClients  = Trim( Subst( sClients, nDelimiterIndex\
    \ + Long(pDelim), Long( sClients ) ) );\n    EndIf;\n    \n    If( DimIx( '}Clients', sClient ) >\
    \ 0 );\n      AssignClientPassword( sClient, pPassword );\n      If( sAlias @<> '' );\n        AttrPutS(\
    \ sAlias, '}Clients', sClient, '}TM1_DefaultDisplayValue', 1 );\n      EndIf;\n    EndIf;\n  End;\n\
    \nEndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n   \
    \ nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully added user(s) %pClient% to }Clients\
    \ Dimension.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n  \
    \  nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process to create clients for multiple new hires simultaneously.
    The process assigns a password and a maximum number of ports to each created client. Note that specifying
    a client (pClient) is mandatory; otherwise, the process will abort. Multiple clients can be specified,
    separated by a delimiter. If a client already exists, the process will not attempt to recreate it
    but will reset the password and the maximum number of ports. Note that each client must be assigned
    to a group afterwards. This process is intended for production.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create clients, assign a password and max ports.\n\
    \n# Use case: Intended for production.\n# 1/ Create clients for multiple new hires simultaneously.\n\
    \n# Note:\n# Naturally, a client (pClient) is mandatory otherwise the process will abort.\n# - Multiple\
    \ clients can be specified separated by a delimiter.\n# - If client already exists then the process\
    \ will not attempt to re-create it but will reset password and max ports.\n# - Each client will have\
    \ to be assigned to a group afterwards.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pPassword:******,\
    \ pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n\n# If blank\
    \ delimiter specified then convert to default\nIf( pDelim @= '' );\n  pDelim            = '&';\nEndIf;\n\
    \n# If no clients have been specified then terminate process\nIf( Trim( pClient ) @= '' );\n  nErrors\
    \           = 1;\n  sMessage          = 'No clients specified.';\n  LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n \
    \ If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n# Alias\nIf( pAlias @<> '' );\n    If( DimensionExists( '}ElementAttributes_}Clients' )\
    \ = 0 );\n        AttrInsert( '}Clients', '', '}TM1_DefaultDisplayValue', 'A' );\n    ElseIf( DimIx(\
    \ '}ElementAttributes_}Clients', '}TM1_DefaultDisplayValue' ) = 0 );\n        AttrInsert( '}Clients',\
    \ '', '}TM1_DefaultDisplayValue', 'A' );\n    EndIf;\nEndIf;\n\n### Split pClient into individual\
    \ Clients and add ###\nsClients            = pClient;\nnDelimiterIndex     = 1;\nWhile( nDelimiterIndex\
    \ <> 0 );\n    nDelimiterIndex   = Scan( pDelim, sClients );\n    If( nDelimiterIndex = 0 );\n   \
    \     sClient         = sClients;\n    Else;\n        sClient         = Trim( SubSt( sClients, 1,\
    \ nDelimiterIndex - 1 ) );\n        sClients        = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim),\
    \ Long( sClients ) ) );\n    EndIf;\n    # Don't attempt to add a blank client\n    If( sClient @<>\
    \ '' );\n        If( DimIx( '}Clients', sClient ) = 0 );\n            If( nErrors = 0 );\n       \
    \         AddClient( sClient );\n            EndIf;\n        EndIf;\n    EndIf;\nEnd;\n\nIf( nErrors\
    \ = 0 );\n    DimensionSortOrder( '}Clients', 'ByName', 'Ascending', 'ByName' , 'Ascending' );\nEndIf;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Update password & Alias\n\nIf( nErrors = 0 );\n\n  sAliases  = pAlias;\n  sClients  = pClient;\n\
    \  nDelimiterIndex = 1;\n\n  While( nDelimiterIndex > 0 );\n    nDelimiterIndex = Scan( pDelim, sAliases\
    \ );\n    If( nDelimiterIndex = 0 );\n      sAlias    = sAliases;\n    Else;\n      sAlias    = Trim(\
    \ SubSt( sAliases, 1, nDelimiterIndex - 1 ) );\n      sAliases  = Trim( Subst( sAliases, nDelimiterIndex\
    \ + Long(pDelim), Long( sAliases ) ) );\n    EndIf;\n    nDelimiterIndex = Scan( pDelim, sClients\
    \ );\n    If( nDelimiterIndex = 0 );\n      sClient   = sClients;\n    Else;\n      sClient   = Trim(\
    \ SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n      sClients  = Trim( Subst( sClients, nDelimiterIndex\
    \ + Long(pDelim), Long( sClients ) ) );\n    EndIf;\n    \n    If( DimIx( '}Clients', sClient ) >\
    \ 0 );\n      AssignClientPassword( sClient, pPassword );\n      If( sAlias @<> '' );\n        AttrPutS(\
    \ sAlias, '}Clients', sClient, '}TM1_DefaultDisplayValue', 1 );\n      EndIf;\n    EndIf;\n  End;\n\
    \nEndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the\
    \ process incurred at least 1 error. Please see above lines in this file for more details.';\n   \
    \ nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully added user(s) %pClient% to }Clients\
    \ Dimension.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n  \
    \  nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der zur Löschung von Klienten bestimmt ist.
    Der Anwendungsfall umfasst die Bereinigung der Benutzer nach der Umstellung in der Entwicklungs- und
    Produktionsumgebung sowie die Entfernung ehemaliger Mitarbeiter bei deren Kündigung. Bitte beachte,
    dass ein gültiger Klient oder mehrere Klienten erforderlich sind, ansonsten wird der Prozess abgebrochen.
    Mehrere Klienten können durch ein Trennzeichen angegeben werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete clients.\n\n# Use case: Intended for development\
    \ and production.\n# 1/ Clean up users after go live.\n# 2/ Remove old employees from the system on\
    \ termination.\n\n# Note:\n# Naturally, a valid client(s) (pClient) is mandatory otherwise the process\
    \ will abort:\n# - Multiple clients can be specified separated by a delimiter. \n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName = GetProcessName();\ncTimeStamp = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub = cThisProcName\
    \ | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile = GetProcessErrorFileDirectory | cTempSub | '.csv';\n\
    cClientDim = '}Clients';\ncClientHier = cClientDim;\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pDelim:%pDelim%.'\
    \ ; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# If blank delimiter specified then convert\
    \ to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# If no clients have been specified\
    \ then terminate process\nIf( Trim( pClient ) @= '' );\n  nErrors = 1;\n  sMessage = 'No clients specified';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check alias exists\nIf( DimensionExists('}ElementAttributes_'|cClientDim)\
    \ = 0 % DimIx('}ElementAttributes_'|cClientDim, '}TM1_DefaultDisplayValue') = 0 );\n    AttrInsert(\
    \ cClientDim, '', '}TM1_DefaultDisplayValue', 'A' );\nEndIf;\n\n### Split pClient into individual\
    \ clients and delete ###\nsClients            = pClient;\nnDelimiterIndex     = 1;\nWhile( nDelimiterIndex\
    \ <> 0 );\n  nDelimiterIndex = Scan( pDelim, sClients );\n  If( nDelimiterIndex = 0 );\n    sClient\
    \ = sClients;\n  Else;\n    sClient = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n    sClients\
    \ = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n  EndIf;\n  \n \
    \ If( Scan( '*', sClient ) = 0);\n    If( sClient @<> '' );\n      If( DimIx( cClientDim, sClient\
    \ ) <> 0 );\n        sClient = DimensionElementPrincipalName(cClientDim,sClient);\n        If( sClient\
    \ @<> 'Admin' & sClient @<> TM1User() );\n            DeleteClient(sClient);\n        ElseIf( sClient\
    \ @= 'Admin' );\n            nErrors = 1;\n            sMessage = 'Skipping attempt to delete Admin\
    \ user.';\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ElseIf( sClient\
    \ @= TM1User() );\n            nErrors = 1;\n            sMessage = 'Skipping attempt to delete self.';\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        EndIf;\n      Else;\n\
    \        nErrors = 1;\n        sMessage = 'Client: ' | sClient | ' does not exist.';\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      Endif;\n      If( nErrors > 0 );\n        \
    \  ItemReject( Expand( cMsgErrorContent ) );\n      EndIf;\n    Endif;  \n  Else;\n  # Wildcard search\
    \ string\n    iCount = 0;\n    iCheck = 1;\n    sChar = sClient;\n    While (iCheck > 0);\n      iCheck\
    \ = Scan('*',sChar);\n      If( iCheck > 0 );\n        iCount = iCount + 1;\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n\
    \      Endif;\n    End;\n    If(iCount = 1);\n      ##If the wilcardsearch is *String, below code\
    \ will get executed\n      if(Subst(sClient,iCount,1) @= '*');\n        sClient1 = '''| Subst(sClient,iCount+1,(Long(sClient)-\
    \ iCount))|''';\n        sTempCount = NumbertoString(Long(sClient)-iCount);\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (Right( ['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|')\
    \ ='|sClient1|'))}+\n                {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (Right( ['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'| sTempCount|') ='|sClient1|'))}';\n\
    \        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a delimited list of Client\
    \ names includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ cClientDim, cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n        EndIf;\n   \
    \     \n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n    \
    \    nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n          sTemp = HierarchySubsetElementGetIndex(cClientDim,\
    \ cClientHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier,\
    \ cTempSub, nCount);\n          If( sElement @<> 'Admin' & sElement @<> TM1User() );\n           \
    \   DeleteClient(sElement);\n          ElseIf( sElement @= 'Admin' );\n              LogOutput( 'WARN',\
    \ 'Skipping attempt to delete Admin user.' );\n          ElseIf( sElement @= TM1User() );\n      \
    \        LogOutput( 'WARN', 'Skipping attempt to delete self.' );\n          EndIf;\n          nCount\
    \ = nCount -1;\n        End;\n        ##If the wilcardsearch is String*, below code will get executed\n\
    \        ElseIf(Subst(sClient,Long(sClient),1) @= '*');\n\n        sClient1 = '''| Subst(sClient,iCount,(Long(sClient)-\
    \ iCount))|''';\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n   \
    \             (INSTR('| NumbertoString(iCount)|', ['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}+\n                {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n   \
    \         # If a delimited list of Client names includes wildcards then we may have to re-use the\
    \ subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n        Else;\n\
    \            # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cClientDim, 1 );\n        EndIf;\n\n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim,\
    \ cClientHier, cTempSub);\n        nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n      \
    \    sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '', 1);\n        \
    \  sElement = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub, nCount);\n        \
    \  If( sElement @<> 'Admin' & sElement @<> TM1User() );\n              DeleteClient(sElement);\n \
    \         ElseIf( sElement @= 'Admin' );\n              LogOutput( 'WARN', 'Skipping attempt to delete\
    \ Admin user.' );\n          ElseIf( sElement @= TM1User() );\n              LogOutput( 'WARN', 'Skipping\
    \ attempt to delete self.' );\n          EndIf;\n          nCount = nCount -1;\n        End;\n   \
    \   Endif;\n    Else;\n      ##If the wilcardsearch is *String*, below code will get executed\n  \
    \    sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n      sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \              (INSTR(1,['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ <> 0))}+\n              {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n          \
    \    (INSTR(1,['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'|sClient1|') <> 0))}';\n    \
    \  If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a delimited list of Client names\
    \ includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ cClientDim, cTempSub, sMDX );\n      Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n      EndIf;\n\n   \
    \   nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n      nCount = nHier_Sub_Size;\n\
    \      While (nCount >= 1);\n        sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier,\
    \ cTempSub, '', 1);\n        sElement = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub,\
    \ nCount);\n          If( sElement @<> 'Admin' & sElement @<> TM1User() );\n              DeleteClient(sElement);\n\
    \          ElseIf( sElement @= 'Admin' );\n              LogOutput( 'WARN', 'Skipping attempt to delete\
    \ Admin user.' );\n          ElseIf( sElement @= TM1User() );\n              LogOutput( 'WARN', 'Skipping\
    \ attempt to delete self.' );\n          EndIf;\n        nCount = nCount -1;\n      End;\n    Endif;\n\
    \  EndIf;\nEnd;\n\nIf( nErrors = 0 );\n  DimensionSortOrder( cClientDim, 'ByName', 'Ascending', 'ByName'\
    \ , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted Client %pClient% from\
    \ dimension %cClientDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process designed to delete clients. The use case includes
    cleaning up users after go-live in development and production environments and removing former employees
    upon termination. Note that a valid client or clients (pClient) are mandatory; otherwise, the process
    will abort. Multiple clients can be specified separated by a delimiter.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete clients.\n\n# Use case: Intended for development\
    \ and production.\n# 1/ Clean up users after go live.\n# 2/ Remove old employees from the system on\
    \ termination.\n\n# Note:\n# Naturally, a valid client(s) (pClient) is mandatory otherwise the process\
    \ will abort:\n# - Multiple clients can be specified separated by a delimiter. \n#EndRegion @DOC\n\
    \n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName = GetProcessName();\ncTimeStamp = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub = cThisProcName\
    \ | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile = GetProcessErrorFileDirectory | cTempSub | '.csv';\n\
    cClientDim = '}Clients';\ncClientHier = cClientDim;\ncUserName         = TM1User();\ncMsgErrorLevel\
    \    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pDelim:%pDelim%.'\
    \ ; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# If blank delimiter specified then convert\
    \ to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n# If no clients have been specified\
    \ then terminate process\nIf( Trim( pClient ) @= '' );\n  nErrors = 1;\n  sMessage = 'No clients specified';\n\
    \  LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check alias exists\nIf( DimensionExists('}ElementAttributes_'|cClientDim)\
    \ = 0 % DimIx('}ElementAttributes_'|cClientDim, '}TM1_DefaultDisplayValue') = 0 );\n    AttrInsert(\
    \ cClientDim, '', '}TM1_DefaultDisplayValue', 'A' );\nEndIf;\n\n### Split pClient into individual\
    \ clients and delete ###\nsClients            = pClient;\nnDelimiterIndex     = 1;\nWhile( nDelimiterIndex\
    \ <> 0 );\n  nDelimiterIndex = Scan( pDelim, sClients );\n  If( nDelimiterIndex = 0 );\n    sClient\
    \ = sClients;\n  Else;\n    sClient = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n    sClients\
    \ = Trim( Subst( sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n  EndIf;\n  \n \
    \ If( Scan( '*', sClient ) = 0);\n    If( sClient @<> '' );\n      If( DimIx( cClientDim, sClient\
    \ ) <> 0 );\n        sClient = DimensionElementPrincipalName(cClientDim,sClient);\n        If( sClient\
    \ @<> 'Admin' & sClient @<> TM1User() );\n            DeleteClient(sClient);\n        ElseIf( sClient\
    \ @= 'Admin' );\n            nErrors = 1;\n            sMessage = 'Skipping attempt to delete Admin\
    \ user.';\n            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        ElseIf( sClient\
    \ @= TM1User() );\n            nErrors = 1;\n            sMessage = 'Skipping attempt to delete self.';\n\
    \            LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n        EndIf;\n      Else;\n\
    \        nErrors = 1;\n        sMessage = 'Client: ' | sClient | ' does not exist.';\n        LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n      Endif;\n      If( nErrors > 0 );\n        \
    \  ItemReject( Expand( cMsgErrorContent ) );\n      EndIf;\n    Endif;  \n  Else;\n  # Wildcard search\
    \ string\n    iCount = 0;\n    iCheck = 1;\n    sChar = sClient;\n    While (iCheck > 0);\n      iCheck\
    \ = Scan('*',sChar);\n      If( iCheck > 0 );\n        iCount = iCount + 1;\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n\
    \      Endif;\n    End;\n    If(iCount = 1);\n      ##If the wilcardsearch is *String, below code\
    \ will get executed\n      if(Subst(sClient,iCount,1) @= '*');\n        sClient1 = '''| Subst(sClient,iCount+1,(Long(sClient)-\
    \ iCount))|''';\n        sTempCount = NumbertoString(Long(sClient)-iCount);\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (Right( ['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|')\
    \ ='|sClient1|'))}+\n                {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (Right( ['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'| sTempCount|') ='|sClient1|'))}';\n\
    \        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a delimited list of Client\
    \ names includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ cClientDim, cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n        EndIf;\n   \
    \     \n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n    \
    \    nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n          sTemp = HierarchySubsetElementGetIndex(cClientDim,\
    \ cClientHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier,\
    \ cTempSub, nCount);\n          If( sElement @<> 'Admin' & sElement @<> TM1User() );\n           \
    \   DeleteClient(sElement);\n          ElseIf( sElement @= 'Admin' );\n              LogOutput( 'WARN',\
    \ 'Skipping attempt to delete Admin user.' );\n          ElseIf( sElement @= TM1User() );\n      \
    \        LogOutput( 'WARN', 'Skipping attempt to delete self.' );\n          EndIf;\n          nCount\
    \ = nCount -1;\n        End;\n        ##If the wilcardsearch is String*, below code will get executed\n\
    \        ElseIf(Subst(sClient,Long(sClient),1) @= '*');\n\n        sClient1 = '''| Subst(sClient,iCount,(Long(sClient)-\
    \ iCount))|''';\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n   \
    \             (INSTR('| NumbertoString(iCount)|', ['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}+\n                {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n   \
    \         # If a delimited list of Client names includes wildcards then we may have to re-use the\
    \ subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n        Else;\n\
    \            # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cClientDim, 1 );\n        EndIf;\n\n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim,\
    \ cClientHier, cTempSub);\n        nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n      \
    \    sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '', 1);\n        \
    \  sElement = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub, nCount);\n        \
    \  If( sElement @<> 'Admin' & sElement @<> TM1User() );\n              DeleteClient(sElement);\n \
    \         ElseIf( sElement @= 'Admin' );\n              LogOutput( 'WARN', 'Skipping attempt to delete\
    \ Admin user.' );\n          ElseIf( sElement @= TM1User() );\n              LogOutput( 'WARN', 'Skipping\
    \ attempt to delete self.' );\n          EndIf;\n          nCount = nCount -1;\n        End;\n   \
    \   Endif;\n    Else;\n      ##If the wilcardsearch is *String*, below code will get executed\n  \
    \    sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n      sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n\
    \              (INSTR(1,['|cClientDim|'].['|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ <> 0))}+\n              {FILTER({TM1SUBSETALL(['|cClientDim|'].['|cClientHier|'])},\n          \
    \    (INSTR(1,['|cClientDim|'].['|cClientHier|'].CurrentMember.Name,'|sClient1|') <> 0))}';\n    \
    \  If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a delimited list of Client names\
    \ includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ cClientDim, cTempSub, sMDX );\n      Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n      EndIf;\n\n   \
    \   nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n      nCount = nHier_Sub_Size;\n\
    \      While (nCount >= 1);\n        sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier,\
    \ cTempSub, '', 1);\n        sElement = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub,\
    \ nCount);\n          If( sElement @<> 'Admin' & sElement @<> TM1User() );\n              DeleteClient(sElement);\n\
    \          ElseIf( sElement @= 'Admin' );\n              LogOutput( 'WARN', 'Skipping attempt to delete\
    \ Admin user.' );\n          ElseIf( sElement @= TM1User() );\n              LogOutput( 'WARN', 'Skipping\
    \ attempt to delete self.' );\n          EndIf;\n        nCount = nCount -1;\n      End;\n    Endif;\n\
    \  EndIf;\nEnd;\n\nIf( nErrors = 0 );\n  DimensionSortOrder( cClientDim, 'ByName', 'Ascending', 'ByName'\
    \ , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted Client %pClient% from\
    \ dimension %cClientDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der die Sicherheitszuweisung von Kunden und
    Gruppen verwaltet. Dieser Prozess ist für die Produktionsumgebung gedacht und wird verwendet, nachdem
    neue Benutzer über ''}ti.security.client.create'' hinzugefügt wurden, da diesen Benutzern Gruppen
    zugewiesen werden müssen. Beachte, dass ein gültiger Kunde (pClient) erforderlich ist, um Zuweisungen
    vornehmen zu können. Der Prozess kann Kunden je nach pAddOrRemove zu Gruppen hinzufügen oder aus diesen
    entfernen. Er unterstützt die Verarbeitung eines einzelnen oder mehrerer Kunden, die durch ein Trennzeichen
    getrennt sind, sowie eines einzelnen oder mehrerer Gruppen, die ebenfalls durch ein Trennzeichen getrennt
    sind. Daher kann er verwendet werden, um: einen einzelnen Kunden zu einer einzelnen Gruppe hinzuzufügen
    oder daraus zu entfernen, viele Kunden zu einer einzelnen Gruppe hinzuzufügen oder daraus zu entfernen,
    einen einzelnen Kunden zu mehreren Gruppen hinzuzufügen oder daraus zu entfernen, oder viele Kunden
    zu mehreren Gruppen hinzuzufügen oder daraus zu entfernen. Der Prozess erlaubt es dem Anwender, zu
    entscheiden, ob die Sicherheit am Ende aktualisiert werden soll, wobei die Standardeinstellung auf
    ''ja'' gesetzt ist.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will assign Client and Group Security.\n\n# Use case:\
    \ Intended for production.\n# 1/ After adding new user(s) using '}bedrock.security.client.create'\
    \ they must be assigned to groups.\n\n# Note:\n# Naturally, valid  client (pClient) is mandatory otherwise\
    \ the process can't make assignments:\n# - This process can either add or remove clients to groups\
    \ based on pAddOrRemove.\n# - This process can work on a single client or multiple clients separated\
    \ by a delimiter.\n# - This process can work on a single group or multiple groups separated by a delimiter.\n\
    # - Therefore, it can be used to:\n#   - Add/remove a single client to/from a single group.\n#   -\
    \ Add/remove many clients to/from a single group.\n#   - Add/remove a single client to/from many groups.\n\
    #   - Add/remove many clients to/from many groups.\n# - The caller can choose whether or not to refresh\
    \ security at the end. Default is yes.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \ = GetProcessName();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName         = TM1User();\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run\
    \ with parameters pClient:%pClient%, pGroup:%pGroup%, pDelim:%pDelim%, pAddOrRemove:%pAddOrRemove%,\
    \ pSecurityRefresh:%pSecurityRefresh%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n  \
    \  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\
    \n# If no clients have been specified then terminate process\nIf( Trim( pClient ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No clients specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If no groups have been specified then terminate process\nIf( Trim( pGroup ) @=\
    \ '' );\n    nErrors = 1;\n    sMessage = 'No groups specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# If pSecurityRefresh is blank then default to yes\nIf(\
    \ Trim( pSecurityRefresh ) @= '' );\n    pSecurityRefresh = 'Yes';\nEndIf;\n\n# If pAddOrDelete has\
    \ not been specified correctly then terminate process\nIf( Upper( pAddOrRemove ) @<> 'ADD' & Upper(\
    \ pAddOrRemove ) @<> 'REMOVE' );\n    nErrors = 1;\n    sMessage = 'Incorrect value for pAddOrRemove:\
    \ ' | pAddOrRemove | '. Valid values are Add or Remove';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If pSecurityRefresh has not been specified correctly then terminate process\n\
    If( Upper( pSecurityRefresh ) @<> 'YES' & Upper( pSecurityRefresh ) @<> 'NO' );\n    nErrors = 1;\n\
    \    sMessage = 'Incorrect value for pSecurityRefresh: ' | pSecurityRefresh | '. Valid values are\
    \ Yes or No';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank\
    \ delimiter specified then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n###\
    \ Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Add/remove clients to/from\
    \ groups ###\n\n# Loop through list of clients\nsClients            = pClient;\nnClientDelimIndex\
    \   = 1;\nWhile( nClientDelimIndex <> 0 );\n  nClientDelimIndex = Scan( pDelim, sClients );\n  If(\
    \ nClientDelimIndex = 0 );\n    sClient         = sClients;\n  Else;\n    sClient         = Trim(\
    \ SubSt( sClients, 1, nClientDelimIndex - 1 ) );\n    sClients        = Trim( Subst( sClients, nClientDelimIndex\
    \ + Long(pDelim), Long( sClients ) ) );\n  EndIf;\n  \n  If(Scan('*', sClient) = 0 & Scan('?', sClient)\
    \ = 0);\n  # Don't attempt to process a blank client\n   If( sClient @<> '' );\n     # Check that\
    \ client exists\n     If( DimIx( '}Clients', sClient ) = 0 );\n        nErrors     = 1;\n        sMessage\
    \    = 'Client: ' | sClient | ' does not exists';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n     ELSE;\n        # Loop through list of Groups\n        sGroups                 = pGroup;\n\
    \        nGroupDelimIndex        = 1;\n        While( nGroupDelimIndex <> 0 );\n            nGroupDelimIndex\
    \    = Scan( pDelim, sGroups );\n            If( nGroupDelimIndex = 0 );\n                sGroup \
    \         = sGroups;\n            Else;\n                sGroup          = Trim( SubSt( sGroups, 1,\
    \ nGroupDelimIndex - 1 ) );\n                sGroups         = Trim( Subst( sGroups, nGroupDelimIndex\
    \ + Long(pDelim), Long( sGroups ) ) );\n            EndIf;\n            If( Scan( '*', sGroup ) =\
    \ 0 & Scan('?', sGroup ) = 0 );\n                # Don't attempt to process a blank Group\n      \
    \          If( sGroup @<> '' );\n                    # Check that group exists\n                 \
    \   If( DimIx( '}Groups', sGroup ) = 0 );\n                        nErrors = 1;\n                \
    \        sMessage = 'Group: ' | sGroup | ' does not exists';\n                        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n                    ELSE;\n                        # Add/Remove Client\n\
    \                        If( Upper( pAddOrRemove ) @= 'ADD' );\n                            AssignClientToGroup(\
    \ sClient, sGroup );\n                        ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n     \
    \                       RemoveClientFromGroup( sClient, sGroup );\n                        EndIf;\n\
    \                    EndIf;\n                EndIf;\n            ELSE;\n                # Wildcard\
    \ search string\n                sGroup = '''|sGroup|''';\n                sGroupDim = '}Groups';\n\
    \                sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sGroupDim| '])},'| sGroup| ')}';\n\
    \                If( SubsetExists( sGroupDim, cTempSub ) = 1 );\n                    # If a delimited\
    \ list of Groups includes wildcards then we may have to re-use the subset multiple times\n       \
    \             SubsetMDXSet( sGroupDim, cTempSub, sMDX );\n                Else;\n                \
    \    # temp subset, therefore no need to destroy in epilog\n                    SubsetCreatebyMDX(\
    \ cTempSub, sMDX, sGroupDim, 1 );\n                EndIf;\n                nCountGrp = SubsetGetSize(\
    \ sGroupDim, cTempSub );\n                While( nCountGrp >= 1 );\n                    sGroup = SubsetGetElementName(\
    \ sGroupDim, cTempSub, nCountGrp );\n                    # Add/Remove Client\n                   \
    \ If( Upper( pAddOrRemove ) @= 'ADD' );\n                        AssignClientToGroup( sClient, sGroup\
    \ );\n                    ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n                        RemoveClientFromGroup(\
    \ sClient, sGroup );\n                    EndIf;\n                    nCountGrp = nCountGrp - 1;\n\
    \                End;\n            Endif;    \n        End;\n     EndIf;\n   EndIf;\n  ELSE;\n  #\
    \ Wildcard search string\n        sClientDim = '}Clients';\n        sClient = '''|sClient|''';\n \
    \       sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sClientDim| '])},'| sClient| ')}';\n     \
    \   If( SubsetExists( sClientDim, cTempSub ) = 1 );\n            # If a delimited list of Clients\
    \ includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ sClientDim, cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, sClientDim, 1 );\n        EndIf;\n   \
    \     # Loop through dimensions in clients with wildcard\n        nCountClient = SubsetGetSize( '}Clients'\
    \ , cTempSub );\n        While( nCountClient >= 1 );\n            \n            sClient = SubsetGetElementName(\
    \ '}Clients' , cTempSub, nCountClient );\n            # Validate client name\n            If( Dimix('}Clients',\
    \ sClient) = 0 );\n                nErrors = 1;\n                sMessage = Expand( 'Client '%sClient%'\
    \ does not exist.' );\n                LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n       \
    \     Else;\n              # Loop through list of Groups\n              sGroups = pGroup;\n      \
    \        nGroupDelimIndex = 1;\n              While( nGroupDelimIndex <> 0 );\n                nGroupDelimIndex\
    \ = Scan( pDelim, sGroups );\n                If( nGroupDelimIndex = 0 );\n                   sGroup\
    \ = sGroups;\n                Else;\n                   sGroup = Trim( SubSt( sGroups, 1, nGroupDelimIndex\
    \ - 1 ) );\n                   sGroups = Trim( Subst( sGroups, nGroupDelimIndex + Long(pDelim), Long(\
    \ sGroups ) ) );\n                EndIf;\n                If( Scan( '*', sGroup ) = 0 & Scan('?',sGroup\
    \ ) = 0);\n                  # Don't attempt to process a blank Group\n                  If( sGroup\
    \ @<> '' );\n                    # Check that group exists\n                    If( DimIx( '}Groups',\
    \ sGroup ) = 0 );\n                        nErrors = 1;\n                        sMessage = 'Group:\
    \ ' | sGroup | ' does not exists';\n                        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n                    ELSE;\n                      # Add/Remove Client\n                   \
    \   If( Upper( pAddOrRemove ) @= 'ADD' );\n                        AssignClientToGroup( sClient, sGroup\
    \ );\n                      ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n                       \
    \ RemoveClientFromGroup( sClient, sGroup );\n                      EndIf;\n                    EndIf;\n\
    \                  EndIf;\n                ELSE;\n                # Wildcard search string\n     \
    \           sGroup = '''|sGroup|''';\n                sGroupDim = '}Groups';\n                sMdx\
    \ = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sGroupDim| '])},'| sGroup| ')}';\n                If(\
    \ SubsetExists( sGroupDim, cTempSub ) = 1 );\n                   # If a delimited list of objects\
    \ includes wildcards then we may have to re-use the subset multiple times\n                   SubsetMDXSet(\
    \ sGroupDim, cTempSub, sMDX );\n                Else;\n                   # temp subset, therefore\
    \ no need to destroy in epilog\n                   SubsetCreatebyMDX( cTempSub, sMDX, sGroupDim, 1\
    \ );\n                EndIf;\n                nCountGrp = SubsetGetSize( sGroupDim, cTempSub );\n\
    \                  While( nCountGrp >= 1 );\n                      sGroup = SubsetGetElementName(\
    \ sGroupDim, cTempSub, nCountGrp );\n                      # Add/Remove Client\n                 \
    \     If( Upper( pAddOrRemove ) @= 'ADD' );\n                          AssignClientToGroup( sClient,\
    \ sGroup );\n                      ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n                \
    \          RemoveClientFromGroup( sClient, sGroup );\n                      EndIf;\n             \
    \         nCountGrp = nCountGrp - 1;\n                  End;\n               EndIf;\n            \
    \  End;\n            Endif;\n            nCountClient = nCountClient - 1;\n        End;\n  Endif;\
    \  \nEnd;\n\n### Refresh Security ###\n\nIf( Upper( pSecurityRefresh ) @= 'YES' );\n  SecurityRefresh;\n\
    EndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully performed %pAddOrRemove% for client %pClient% to\
    \ group %pGroup%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that manages the assignment of client and group security.
    This process is intended for the production environment and is used after adding new users via ''}ti.security.client.create'',
    as these users need to be assigned to groups. Note that a valid client (pClient) is mandatory for
    making assignments. The process can add or remove clients from groups based on pAddOrRemove. It supports
    processing a single client or multiple clients separated by a delimiter, as well as a single group
    or multiple groups separated by a delimiter. Therefore, it can be used to: add/remove a single client
    to/from a single group, add/remove many clients to/from a single group, add/remove a single client
    to/from many groups, or add/remove many clients to/from many groups. The process allows the user to
    choose whether to refresh security at the end, with the default setting being ''yes''.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will assign Client and Group Security.\n\n# Use case:\
    \ Intended for production.\n# 1/ After adding new user(s) using '}bedrock.security.client.create'\
    \ they must be assigned to groups.\n\n# Note:\n# Naturally, valid  client (pClient) is mandatory otherwise\
    \ the process can't make assignments:\n# - This process can either add or remove clients to groups\
    \ based on pAddOrRemove.\n# - This process can work on a single client or multiple clients separated\
    \ by a delimiter.\n# - This process can work on a single group or multiple groups separated by a delimiter.\n\
    # - Therefore, it can be used to:\n#   - Add/remove a single client to/from a single group.\n#   -\
    \ Add/remove many clients to/from a single group.\n#   - Add/remove a single client to/from many groups.\n\
    #   - Add/remove many clients to/from many groups.\n# - The caller can choose whether or not to refresh\
    \ security at the end. Default is yes.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \ = GetProcessName();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName         = TM1User();\ncTempSub          = cThisProcName |'_'|\
    \ cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run\
    \ with parameters pClient:%pClient%, pGroup:%pGroup%, pDelim:%pDelim%, pAddOrRemove:%pAddOrRemove%,\
    \ pSecurityRefresh:%pSecurityRefresh%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n  \
    \  LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\
    \n# If no clients have been specified then terminate process\nIf( Trim( pClient ) @= '' );\n    nErrors\
    \ = 1;\n    sMessage = 'No clients specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If no groups have been specified then terminate process\nIf( Trim( pGroup ) @=\
    \ '' );\n    nErrors = 1;\n    sMessage = 'No groups specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndIf;\n\n# If pSecurityRefresh is blank then default to yes\nIf(\
    \ Trim( pSecurityRefresh ) @= '' );\n    pSecurityRefresh = 'Yes';\nEndIf;\n\n# If pAddOrDelete has\
    \ not been specified correctly then terminate process\nIf( Upper( pAddOrRemove ) @<> 'ADD' & Upper(\
    \ pAddOrRemove ) @<> 'REMOVE' );\n    nErrors = 1;\n    sMessage = 'Incorrect value for pAddOrRemove:\
    \ ' | pAddOrRemove | '. Valid values are Add or Remove';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If pSecurityRefresh has not been specified correctly then terminate process\n\
    If( Upper( pSecurityRefresh ) @<> 'YES' & Upper( pSecurityRefresh ) @<> 'NO' );\n    nErrors = 1;\n\
    \    sMessage = 'Incorrect value for pSecurityRefresh: ' | pSecurityRefresh | '. Valid values are\
    \ Yes or No';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank\
    \ delimiter specified then convert to default\nIf( pDelim @= '' );\n  pDelim = '&';\nEndIf;\n\n###\
    \ Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n  \
    \    ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Add/remove clients to/from\
    \ groups ###\n\n# Loop through list of clients\nsClients            = pClient;\nnClientDelimIndex\
    \   = 1;\nWhile( nClientDelimIndex <> 0 );\n  nClientDelimIndex = Scan( pDelim, sClients );\n  If(\
    \ nClientDelimIndex = 0 );\n    sClient         = sClients;\n  Else;\n    sClient         = Trim(\
    \ SubSt( sClients, 1, nClientDelimIndex - 1 ) );\n    sClients        = Trim( Subst( sClients, nClientDelimIndex\
    \ + Long(pDelim), Long( sClients ) ) );\n  EndIf;\n  \n  If(Scan('*', sClient) = 0 & Scan('?', sClient)\
    \ = 0);\n  # Don't attempt to process a blank client\n   If( sClient @<> '' );\n     # Check that\
    \ client exists\n     If( DimIx( '}Clients', sClient ) = 0 );\n        nErrors     = 1;\n        sMessage\
    \    = 'Client: ' | sClient | ' does not exists';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n     ELSE;\n        # Loop through list of Groups\n        sGroups                 = pGroup;\n\
    \        nGroupDelimIndex        = 1;\n        While( nGroupDelimIndex <> 0 );\n            nGroupDelimIndex\
    \    = Scan( pDelim, sGroups );\n            If( nGroupDelimIndex = 0 );\n                sGroup \
    \         = sGroups;\n            Else;\n                sGroup          = Trim( SubSt( sGroups, 1,\
    \ nGroupDelimIndex - 1 ) );\n                sGroups         = Trim( Subst( sGroups, nGroupDelimIndex\
    \ + Long(pDelim), Long( sGroups ) ) );\n            EndIf;\n            If( Scan( '*', sGroup ) =\
    \ 0 & Scan('?', sGroup ) = 0 );\n                # Don't attempt to process a blank Group\n      \
    \          If( sGroup @<> '' );\n                    # Check that group exists\n                 \
    \   If( DimIx( '}Groups', sGroup ) = 0 );\n                        nErrors = 1;\n                \
    \        sMessage = 'Group: ' | sGroup | ' does not exists';\n                        LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n                    ELSE;\n                        # Add/Remove Client\n\
    \                        If( Upper( pAddOrRemove ) @= 'ADD' );\n                            AssignClientToGroup(\
    \ sClient, sGroup );\n                        ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n     \
    \                       RemoveClientFromGroup( sClient, sGroup );\n                        EndIf;\n\
    \                    EndIf;\n                EndIf;\n            ELSE;\n                # Wildcard\
    \ search string\n                sGroup = '''|sGroup|''';\n                sGroupDim = '}Groups';\n\
    \                sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sGroupDim| '])},'| sGroup| ')}';\n\
    \                If( SubsetExists( sGroupDim, cTempSub ) = 1 );\n                    # If a delimited\
    \ list of Groups includes wildcards then we may have to re-use the subset multiple times\n       \
    \             SubsetMDXSet( sGroupDim, cTempSub, sMDX );\n                Else;\n                \
    \    # temp subset, therefore no need to destroy in epilog\n                    SubsetCreatebyMDX(\
    \ cTempSub, sMDX, sGroupDim, 1 );\n                EndIf;\n                nCountGrp = SubsetGetSize(\
    \ sGroupDim, cTempSub );\n                While( nCountGrp >= 1 );\n                    sGroup = SubsetGetElementName(\
    \ sGroupDim, cTempSub, nCountGrp );\n                    # Add/Remove Client\n                   \
    \ If( Upper( pAddOrRemove ) @= 'ADD' );\n                        AssignClientToGroup( sClient, sGroup\
    \ );\n                    ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n                        RemoveClientFromGroup(\
    \ sClient, sGroup );\n                    EndIf;\n                    nCountGrp = nCountGrp - 1;\n\
    \                End;\n            Endif;    \n        End;\n     EndIf;\n   EndIf;\n  ELSE;\n  #\
    \ Wildcard search string\n        sClientDim = '}Clients';\n        sClient = '''|sClient|''';\n \
    \       sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sClientDim| '])},'| sClient| ')}';\n     \
    \   If( SubsetExists( sClientDim, cTempSub ) = 1 );\n            # If a delimited list of Clients\
    \ includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ sClientDim, cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, sClientDim, 1 );\n        EndIf;\n   \
    \     # Loop through dimensions in clients with wildcard\n        nCountClient = SubsetGetSize( '}Clients'\
    \ , cTempSub );\n        While( nCountClient >= 1 );\n            \n            sClient = SubsetGetElementName(\
    \ '}Clients' , cTempSub, nCountClient );\n            # Validate client name\n            If( Dimix('}Clients',\
    \ sClient) = 0 );\n                nErrors = 1;\n                sMessage = Expand( 'Client '%sClient%'\
    \ does not exist.' );\n                LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n       \
    \     Else;\n              # Loop through list of Groups\n              sGroups = pGroup;\n      \
    \        nGroupDelimIndex = 1;\n              While( nGroupDelimIndex <> 0 );\n                nGroupDelimIndex\
    \ = Scan( pDelim, sGroups );\n                If( nGroupDelimIndex = 0 );\n                   sGroup\
    \ = sGroups;\n                Else;\n                   sGroup = Trim( SubSt( sGroups, 1, nGroupDelimIndex\
    \ - 1 ) );\n                   sGroups = Trim( Subst( sGroups, nGroupDelimIndex + Long(pDelim), Long(\
    \ sGroups ) ) );\n                EndIf;\n                If( Scan( '*', sGroup ) = 0 & Scan('?',sGroup\
    \ ) = 0);\n                  # Don't attempt to process a blank Group\n                  If( sGroup\
    \ @<> '' );\n                    # Check that group exists\n                    If( DimIx( '}Groups',\
    \ sGroup ) = 0 );\n                        nErrors = 1;\n                        sMessage = 'Group:\
    \ ' | sGroup | ' does not exists';\n                        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n                    ELSE;\n                      # Add/Remove Client\n                   \
    \   If( Upper( pAddOrRemove ) @= 'ADD' );\n                        AssignClientToGroup( sClient, sGroup\
    \ );\n                      ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n                       \
    \ RemoveClientFromGroup( sClient, sGroup );\n                      EndIf;\n                    EndIf;\n\
    \                  EndIf;\n                ELSE;\n                # Wildcard search string\n     \
    \           sGroup = '''|sGroup|''';\n                sGroupDim = '}Groups';\n                sMdx\
    \ = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sGroupDim| '])},'| sGroup| ')}';\n                If(\
    \ SubsetExists( sGroupDim, cTempSub ) = 1 );\n                   # If a delimited list of objects\
    \ includes wildcards then we may have to re-use the subset multiple times\n                   SubsetMDXSet(\
    \ sGroupDim, cTempSub, sMDX );\n                Else;\n                   # temp subset, therefore\
    \ no need to destroy in epilog\n                   SubsetCreatebyMDX( cTempSub, sMDX, sGroupDim, 1\
    \ );\n                EndIf;\n                nCountGrp = SubsetGetSize( sGroupDim, cTempSub );\n\
    \                  While( nCountGrp >= 1 );\n                      sGroup = SubsetGetElementName(\
    \ sGroupDim, cTempSub, nCountGrp );\n                      # Add/Remove Client\n                 \
    \     If( Upper( pAddOrRemove ) @= 'ADD' );\n                          AssignClientToGroup( sClient,\
    \ sGroup );\n                      ElseIf( Upper( pAddOrRemove ) @= 'REMOVE' );\n                \
    \          RemoveClientFromGroup( sClient, sGroup );\n                      EndIf;\n             \
    \         nCountGrp = nCountGrp - 1;\n                  End;\n               EndIf;\n            \
    \  End;\n            Endif;\n            nCountClient = nCountClient - 1;\n        End;\n  Endif;\
    \  \nEnd;\n\n### Refresh Security ###\n\nIf( Upper( pSecurityRefresh ) @= 'YES' );\n  SecurityRefresh;\n\
    EndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process\
    \ incurred at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully performed %pAddOrRemove% for client %pClient% to\
    \ group %pGroup%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der von Administratoren verwendet werden kann,
    um das Passwort eines Kunden zurückzusetzen. Dieser Prozess ist für den Einsatz in der Produktion
    gedacht. Wenn ein Benutzer sein Passwort vergessen hat, kann dieser TI-Prozess verwendet werden, um
    es zurückzusetzen. Beachten Sie, dass ein gültiger Kunde (oder gültige Kunden) als zwingend erforderlich
    angegeben werden muss, da der Prozess sonst abbricht. Mehrere Kunden können durch ein Trennzeichen
    angegeben werden. Der Prozess muss von einer administrativen Person durchgeführt werden, da er sonst
    abgebrochen wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can be used by admins to reset a client password.\n\
    \n# Use case: Intended for production.\n# 1/ When a user has forgotten his/her password this TI can\
    \ be used to reset it.\n\n# Note:\n# Naturally, a valid client(s) (pClient) is mandatory otherwise\
    \ the process will abort.\n# Multiple clients can be specified separated by a delimiter.\n# It has\
    \ to be run by an ADMIN person otherwsie it will abort.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub    \
    \        = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory\
    \ | cTempSub | '.csv';\ncClientDim          = '}Clients';\ncClientHier         = cClientDim;\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pPassword:******,\
    \ pDelim:%pDelim%.' ;  \n\n### Validate Parameters ###\nnErrors             = 0;\n\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n# If no clients\
    \ have been specified then terminate process\nIf( Trim( pClient ) @= '' );\n    nErrors = 1;\n   \
    \ sMessage = 'No clients specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Check if the person executing the process has admin rights\n\nIF( CELLGETS( '}ClientGroups',\
    \ cUserName, 'Admin' ) @<> 'ADMIN' & CELLGETS( '}ClientGroups', cUserName, 'DataAdmin' ) @<> 'DataAdmin'\
    \ & cUserName @<> pClient );\n    nErrors = 1;\n    sMessage = 'No Admin access to change other clients\
    \ password.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nENDIF;\n\n### Check for\
    \ errors before continuing\nIf( nErrors > 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Split pClient into individual clients and\
    \ reset password ###\n\nsClients = pClient;\nnDelimiterIndex = 1;\n\nWhile( nDelimiterIndex <> 0 );\n\
    \  nDelimiterIndex = Scan( pDelim, sClients );\n  If( nDelimiterIndex = 0 );\n    sClient = sClients;\n\
    \  Else;\n    sClient = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n    sClients = Trim( Subst(\
    \ sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n  EndIf;\n  \n  If(Scan('*',sClient)\
    \ = 0);\n  # Don't attempt to update a blank client\n    If( sClient @<> '' );\n      If( DimIx( '}Clients',\
    \ sClient ) <> 0 );\n        If( nErrors = 0 );\n          sClient = DimensionElementPrincipalName(\
    \ '}Clients', sClient );\n          AssignClientPassword( sClient, pPassword );\n        EndIf;\n\
    \      EndIf;\n    EndIf;\n  Else;\n    # Wildcard search string\n    iCount = 0;\n    iCheck = 1;\n\
    \    sChar = sClient;\n    While (iCheck > 0);\n      iCheck = Scan('*',sChar);\n      If( iCheck\
    \ > 0 );\n        iCount = iCount + 1;\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n\
    \      Endif;\n    End;\n    If(iCount = 1);\n      ##If the wilcardsearch is *String, below code\
    \ will get executed\n      if(Subst(sClient,iCount,1) @= '*');\n        sClient1 = '''| Subst(sClient,iCount+1,(Long(sClient)-\
    \ iCount))|''';\n        sTempCount = NumbertoString(Long(sClient)-iCount);\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n\
    \                (Right( ['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|')\
    \ ='|sClient1|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a\
    \ delimited list of client names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n        Else;\n            # temp\
    \ subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim,\
    \ 1 );\n        EndIf;        \n\n        nCount = 1;\n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim,\
    \ cClientHier, cTempSub);\n        While (nCount <= nHier_Sub_Size);\n          nSubsetIndex = 1;\n\
    \          sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '', nSubsetIndex);\n\
    \          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub, nCount);\n\
    \          AssignClientPassword(sElement,pPassword);\n          nCount = nCount +1;\n        End;\n\
    \        ##If the wilcardsearch is String*, below code will get executed\n        ElseIf(Subst(sClient,Long(sClient),1)\
    \ @= '*');\n      \n        sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n \
    \       sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n                (INSTR('|\
    \ NumbertoString(iCount)|', ['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n   \
    \         # If a delimited list of client names includes wildcards then we may have to re-use the\
    \ subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n        Else;\n\
    \            # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cClientDim, 1 );\n        EndIf;        \n\n        nCount = 1;\n        nHier_Sub_Size\
    \ = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n        While (nCount <= nHier_Sub_Size);\n\
    \          nSubsetIndex = 1;\n          sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier,\
    \ cTempSub, '', nSubsetIndex);\n          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier,\
    \ cTempSub, nCount);\n          AssignClientPassword(sElement,pPassword);\n          nCount = nCount\
    \ +1;\n        End;\n      Endif;\n    Else;\n      ##If the wilcardsearch is *String*, below code\
    \ will get executed\n      sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n  \
    \    sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n              (INSTR(1,['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ <> 0))}';\n      If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a delimited list\
    \ of Client names includes wildcards then we may have to re-use the subset multiple times\n      \
    \      SubsetMDXSet( cClientDim, cTempSub, sMDX );\n      Else;\n            # temp subset, therefore\
    \ no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n\
    \      EndIf;\n\n      nCount = 1;\n      nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier,\
    \ cTempSub);\n      While (nCount <= nHier_Sub_Size);\n        nSubsetIndex = 1;\n        sTemp =\
    \ HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '', nSubsetIndex);\n        sElement\
    \ = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub, nCount);\n        AssignClientPassword(sElement,pPassword);\n\
    \        nCount = nCount +1;\n      End;\n    Endif;\n  EndIf;\nEnd;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully reset password for client %pClient% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that can be used by administrators to reset a client's
    password. This process is intended for production use. When a user has forgotten his or her password,
    this TI process can be utilized to reset it. Note that specifying a valid client (or clients) is mandatory,
    or the process will abort. Multiple clients can be specified, separated by a delimiter. The process
    has to be executed by an administrative person; otherwise, it will abort.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process can be used by admins to reset a client password.\n\
    \n# Use case: Intended for production.\n# 1/ When a user has forgotten his/her password this TI can\
    \ be used to reset it.\n\n# Note:\n# Naturally, a valid client(s) (pClient) is mandatory otherwise\
    \ the process will abort.\n# Multiple clients can be specified separated by a delimiter.\n# It has\
    \ to be run by an ADMIN person otherwsie it will abort.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncUserName           = TM1User();\ncTimeStamp          = TimSt( Now, '\\\
    Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub    \
    \        = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\ncTempFile           = GetProcessErrorFileDirectory\
    \ | cTempSub | '.csv';\ncClientDim          = '}Clients';\ncClientHier         = cClientDim;\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pClient:%pClient%, pPassword:******,\
    \ pDelim:%pDelim%.' ;  \n\n### Validate Parameters ###\nnErrors             = 0;\n\n# If blank delimiter\
    \ specified then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n# If no clients\
    \ have been specified then terminate process\nIf( Trim( pClient ) @= '' );\n    nErrors = 1;\n   \
    \ sMessage = 'No clients specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Check if the person executing the process has admin rights\n\nIF( CELLGETS( '}ClientGroups',\
    \ cUserName, 'Admin' ) @<> 'ADMIN' & CELLGETS( '}ClientGroups', cUserName, 'DataAdmin' ) @<> 'DataAdmin'\
    \ & cUserName @<> pClient );\n    nErrors = 1;\n    sMessage = 'No Admin access to change other clients\
    \ password.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nENDIF;\n\n### Check for\
    \ errors before continuing\nIf( nErrors > 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit;\
    \ \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Split pClient into individual clients and\
    \ reset password ###\n\nsClients = pClient;\nnDelimiterIndex = 1;\n\nWhile( nDelimiterIndex <> 0 );\n\
    \  nDelimiterIndex = Scan( pDelim, sClients );\n  If( nDelimiterIndex = 0 );\n    sClient = sClients;\n\
    \  Else;\n    sClient = Trim( SubSt( sClients, 1, nDelimiterIndex - 1 ) );\n    sClients = Trim( Subst(\
    \ sClients, nDelimiterIndex + Long(pDelim), Long( sClients ) ) );\n  EndIf;\n  \n  If(Scan('*',sClient)\
    \ = 0);\n  # Don't attempt to update a blank client\n    If( sClient @<> '' );\n      If( DimIx( '}Clients',\
    \ sClient ) <> 0 );\n        If( nErrors = 0 );\n          sClient = DimensionElementPrincipalName(\
    \ '}Clients', sClient );\n          AssignClientPassword( sClient, pPassword );\n        EndIf;\n\
    \      EndIf;\n    EndIf;\n  Else;\n    # Wildcard search string\n    iCount = 0;\n    iCheck = 1;\n\
    \    sChar = sClient;\n    While (iCheck > 0);\n      iCheck = Scan('*',sChar);\n      If( iCheck\
    \ > 0 );\n        iCount = iCount + 1;\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n\
    \      Endif;\n    End;\n    If(iCount = 1);\n      ##If the wilcardsearch is *String, below code\
    \ will get executed\n      if(Subst(sClient,iCount,1) @= '*');\n        sClient1 = '''| Subst(sClient,iCount+1,(Long(sClient)-\
    \ iCount))|''';\n        sTempCount = NumbertoString(Long(sClient)-iCount);\n        sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n\
    \                (Right( ['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|')\
    \ ='|sClient1|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a\
    \ delimited list of client names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n        Else;\n            # temp\
    \ subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim,\
    \ 1 );\n        EndIf;        \n\n        nCount = 1;\n        nHier_Sub_Size = HierarchySubsetGetSize(cClientDim,\
    \ cClientHier, cTempSub);\n        While (nCount <= nHier_Sub_Size);\n          nSubsetIndex = 1;\n\
    \          sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '', nSubsetIndex);\n\
    \          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub, nCount);\n\
    \          AssignClientPassword(sElement,pPassword);\n          nCount = nCount +1;\n        End;\n\
    \        ##If the wilcardsearch is String*, below code will get executed\n        ElseIf(Subst(sClient,Long(sClient),1)\
    \ @= '*');\n      \n        sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n \
    \       sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n                (INSTR('|\
    \ NumbertoString(iCount)|', ['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cClientDim, cTempSub ) = 1 );\n   \
    \         # If a delimited list of client names includes wildcards then we may have to re-use the\
    \ subset multiple times\n            SubsetMDXSet( cClientDim, cTempSub, sMDX );\n        Else;\n\
    \            # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX(\
    \ cTempSub, sMDX, cClientDim, 1 );\n        EndIf;        \n\n        nCount = 1;\n        nHier_Sub_Size\
    \ = HierarchySubsetGetSize(cClientDim, cClientHier, cTempSub);\n        While (nCount <= nHier_Sub_Size);\n\
    \          nSubsetIndex = 1;\n          sTemp = HierarchySubsetElementGetIndex (cClientDim, cClientHier,\
    \ cTempSub, '', nSubsetIndex);\n          sElement = HierarchySubsetGetElementName(cClientDim, cClientHier,\
    \ cTempSub, nCount);\n          AssignClientPassword(sElement,pPassword);\n          nCount = nCount\
    \ +1;\n        End;\n      Endif;\n    Else;\n      ##If the wilcardsearch is *String*, below code\
    \ will get executed\n      sClient1 = '''| Subst(sClient,iCount,(Long(sClient)- iCount))|''';\n  \
    \    sMdx = '{FILTER({TM1SUBSETALL(['|cClientDim|':'|cClientHier|'])},\n              (INSTR(1,['|cClientDim|':'|cClientHier|'].[}TM1_DefaultDisplayValue],'|sClient1|')\
    \ <> 0))}';\n      If( SubsetExists( cClientDim, cTempSub ) = 1 );\n            # If a delimited list\
    \ of Client names includes wildcards then we may have to re-use the subset multiple times\n      \
    \      SubsetMDXSet( cClientDim, cTempSub, sMDX );\n      Else;\n            # temp subset, therefore\
    \ no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cClientDim, 1 );\n\
    \      EndIf;\n\n      nCount = 1;\n      nHier_Sub_Size = HierarchySubsetGetSize(cClientDim, cClientHier,\
    \ cTempSub);\n      While (nCount <= nHier_Sub_Size);\n        nSubsetIndex = 1;\n        sTemp =\
    \ HierarchySubsetElementGetIndex (cClientDim, cClientHier, cTempSub, '', nSubsetIndex);\n        sElement\
    \ = HierarchySubsetGetElementName(cClientDim, cClientHier, cTempSub, nCount);\n        AssignClientPassword(sElement,pPassword);\n\
    \        nCount = nCount +1;\n      End;\n    Endif;\n  EndIf;\nEnd;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully reset password for client %pClient% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der ein Zellsicherheitswürfel für einen angegebenen
    Würfel und eine bestimmte Liste von Dimensionen erstellt. Verwende die TI-Funktion _CellSecurityCubeCreate_,
    um dies zu ermöglichen. Dieser Prozess hat den Vorteil, dass man nicht jedes Mal einen benutzerdefinierten
    Prozess schreiben muss, um einen Zellsicherheitswürfel zu erstellen. Beachte, dass ein gültiger Würfel
    (pCube) zwingend erforderlich ist, da der Prozess sonst abbricht. Wenn die Zellsicherheit bereits
    eingerichtet wurde, wird der TI-Prozess ebenfalls abgebrochen. Der pDim-Parameter muss alle Dimensionen
    im Würfel in der Reihenfolge mit einer 0 oder 1 abbilden. Dieser Prozess ist für Entwicklungszwecke
    gedacht und dient zum Einrichten von Zellsicherheitswürfeln.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a cell security cube for the specified\
    \ cube for the specified list of dimensions \n# using the TI function _CellSecurityCubeCreate_. The\
    \ benefit of this process is not needing to write a custom\n# process each time in order to create\
    \ a cell security cube.\n\n# Use case: Intended for development.\n# 1/ Set up cell security cubes\n\
    \n# Note:\n# * Naturally, a valid cube (pCube) is mandatory otherwise the process will abort.\n# *\
    \ If cell security has already been set up the TI will abort.\n# * The pDim parameter must map _ALL_\
    \ the dimensions in order in the cube with a 0 or 1.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDim:%pDim%.' ;\
    \  \ncDelim              = ':';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# If no cube has\
    \ been specified then terminate process\nIf( Trim( pCube ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists(\
    \ pCube ) = 0 );\n    nErrors = 1;\n    sMessage = Expand('Cube %pCube% does not exist.');\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check if cell security cube already exists\n\
    If( CubeExists(  '}CellSecurity_' | pCube ) = 1 );\n    nErrors = 1;\n    sMessage = 'Cell Security\
    \ cube already exists.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Count dimensions in cube\
    \ ###\nnDims               = 0;\niDim                = 1;\nWhile( TabDim( pCube, iDim ) @<> '' );\n\
    \   nDims            = iDim;\n   iDim             = iDim + 1;\nEnd;\n\n### Count dimensions mapped\
    \ in pDim ###\nsDimensions         = pDim;\nnDelimiterIndex     = 1;\nnMapDims            = 0;\niDim\
    \                = 1;\nWhile( nDelimiterIndex <> 0 );\n    nMapDims        = iDim;\n    nDelimiterIndex\
    \ = Scan( cDelim, sDimensions );\n    If( nDelimiterIndex = 0 );\n        sDimension  = sDimensions;\n\
    \    Else;\n        sDimension  = Trim( SubSt( sDimensions, 1, nDelimiterIndex - 1 ) );\n        sDimensions\
    \ = Trim( Subst( sDimensions, nDelimiterIndex + Long(cDelim), Long( sDimensions ) ) );\n    EndIf;\n\
    \    # Redundant?\n    If( sDimension @= '1' );\n        sMessage    = ' INCLUDE in cell security\
    \ cube';\n    ElseIf( sDimension @= '0' );\n        sMessage    = ' EXCLUDE from cell security cube';\n\
    \    Else;\n        sMessage    = ' INVALID map parameter: ' | sDimension;\n    EndIF;\n    iDim \
    \           = iDim + 1;\nEnd;\n\n### Check dimension count of dimension map vs. dimensions in cube\
    \ ###\nIf( nDims <> nMapDims );\n    nErrors         = 1;\n    sMessage        = 'Parameter count\
    \ of dimension map does not match dimension count of cube!';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElse;\n    nRet            = CellSecurityCubeCreate ( pCube, pDim );\n  \
    \  If( nRet = 1 );\n        sMessage    = '}CellSecurity_' | pCube | ' successfully created';\n  \
    \      LogOutput( 'INFO', Expand( cMsgErrorContent ) );\n    Else;\n        sMessage    = 'Error.\
    \ Could not create }CellSecurity_' | pCube;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully created cell security for %pCube%\
    \ and %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n \
    \   nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that creates a cell security cube for a specified
    cube and a specified list of dimensions. Use the TI function _CellSecurityCubeCreate_ to achieve this.
    The advantage of this process is that it eliminates the need to write a custom process each time to
    create a cell security cube. Note that a valid cube (pCube) is mandatory, otherwise the process will
    abort. If cell security has already been set up, the TI process will also abort. The pDim parameter
    must map all dimensions in order in the cube with either a 0 or 1. This process is intended for development
    purposes and is used to set up cell security cubes.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create a cell security cube for the specified\
    \ cube for the specified list of dimensions \n# using the TI function _CellSecurityCubeCreate_. The\
    \ benefit of this process is not needing to write a custom\n# process each time in order to create\
    \ a cell security cube.\n\n# Use case: Intended for development.\n# 1/ Set up cell security cubes\n\
    \n# Note:\n# * Naturally, a valid cube (pCube) is mandatory otherwise the process will abort.\n# *\
    \ If cell security has already been set up the TI will abort.\n# * The pDim parameter must map _ALL_\
    \ the dimensions in order in the cube with a 0 or 1.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pCube:%pCube%, pDim:%pDim%.' ;\
    \  \ncDelim              = ':';\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\n# If no cube has\
    \ been specified then terminate process\nIf( Trim( pCube ) @= '' );\n    nErrors = 1;\n    sMessage\
    \ = 'No cube specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( CubeExists(\
    \ pCube ) = 0 );\n    nErrors = 1;\n    sMessage = Expand('Cube %pCube% does not exist.');\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check if cell security cube already exists\n\
    If( CubeExists(  '}CellSecurity_' | pCube ) = 1 );\n    nErrors = 1;\n    sMessage = 'Cell Security\
    \ cube already exists.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Count dimensions in cube\
    \ ###\nnDims               = 0;\niDim                = 1;\nWhile( TabDim( pCube, iDim ) @<> '' );\n\
    \   nDims            = iDim;\n   iDim             = iDim + 1;\nEnd;\n\n### Count dimensions mapped\
    \ in pDim ###\nsDimensions         = pDim;\nnDelimiterIndex     = 1;\nnMapDims            = 0;\niDim\
    \                = 1;\nWhile( nDelimiterIndex <> 0 );\n    nMapDims        = iDim;\n    nDelimiterIndex\
    \ = Scan( cDelim, sDimensions );\n    If( nDelimiterIndex = 0 );\n        sDimension  = sDimensions;\n\
    \    Else;\n        sDimension  = Trim( SubSt( sDimensions, 1, nDelimiterIndex - 1 ) );\n        sDimensions\
    \ = Trim( Subst( sDimensions, nDelimiterIndex + Long(cDelim), Long( sDimensions ) ) );\n    EndIf;\n\
    \    # Redundant?\n    If( sDimension @= '1' );\n        sMessage    = ' INCLUDE in cell security\
    \ cube';\n    ElseIf( sDimension @= '0' );\n        sMessage    = ' EXCLUDE from cell security cube';\n\
    \    Else;\n        sMessage    = ' INVALID map parameter: ' | sDimension;\n    EndIF;\n    iDim \
    \           = iDim + 1;\nEnd;\n\n### Check dimension count of dimension map vs. dimensions in cube\
    \ ###\nIf( nDims <> nMapDims );\n    nErrors         = 1;\n    sMessage        = 'Parameter count\
    \ of dimension map does not match dimension count of cube!';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nElse;\n    nRet            = CellSecurityCubeCreate ( pCube, pDim );\n  \
    \  If( nRet = 1 );\n        sMessage    = '}CellSecurity_' | pCube | ' successfully created';\n  \
    \      LogOutput( 'INFO', Expand( cMsgErrorContent ) );\n    Else;\n        sMessage    = 'Error.\
    \ Could not create }CellSecurity_' | pCube;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    EndIf;\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully created cell security for %pCube%\
    \ and %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n \
    \   nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der dazu bestimmt ist, das Zellen-Sicherheitswürfel(n)
    für die angegebenen Würfel zu löschen. Der Anwendungsfall ist für die Entwicklung gedacht und ermöglicht
    es, die Zellenebene-Sicherheit für einen oder mehrere Würfel zu entfernen. Beachte, dass ein gültiger
    Würfel (pCube) zwingend erforderlich ist, andernfalls wird der Prozess abgebrochen. Wenn für einen
    Würfel keine Zellen-Sicherheit eingerichtet ist, wird dieser Würfel übersprungen, jedoch ein Fehler
    protokolliert. Es können mehrere Würfel angegeben werden, die durch das Trennzeichen pDelim oder durch
    die Verwendung von Platzhaltern (*) voneinander getrennt sind.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will destroy the cell security cube(s) for the specified\
    \ cube(s).\n\n# Use case: Intended for development.\n# 1/ Remove cell level security for one or more\
    \ cubes.\n\n# Note:\n# Naturally, a valid cube (pCube) is mandatory otherwise the process will abort.\n\
    # If the cube does not have cell security set up, it will skip that cube but log an error.\n# Multiple\
    \ cubes can be specified separated by the pDelim or by using wildcards (*).\n#EndRegion @DOC\n\n##Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName = GetProcessName();\ncTimeStamp = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000 ));\nDatasourceASCIIQuoteCharacter\
    \ = '';\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% Message:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with\
    \ parameters pCube:%pCube%, pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n### Validate Parameters ###\nnErrors = 0;\n\n# If blank delimiter specified then convert to default\n\
    If( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n# If no cubes have been specified then terminate\
    \ process\nIf( Trim( pCube ) @= '' );\n    nErrors = 1;\n    sMessage = 'No cube(s) specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before\
    \ continuing\nIf( nErrors <> 0 );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n \
    \   Else;\n        ProcessBreak;\n    EndIf;\nEndIf;\n\n### Split pCubes into individual Cubes  ###\n\
    sCubes                  = pCube;\nnDelimiterIndex         = 1;\nWhile( nDelimiterIndex <> 0 );\n \
    \   nDelimiterIndex     = Scan( pDelim, sCubes );\n    If( nDelimiterIndex = 0 );\n        sCube \
    \          = sCubes;\n    Else;\n        sCube           = Trim( SubSt( sCubes, 1, nDelimiterIndex\
    \ - 1 ) );\n        sCubes          = Trim( Subst( sCubes, nDelimiterIndex + Long(pDelim), Long( sCubes\
    \ ) ) );\n    EndIf;\n  \n    # Check if a wildcard has been used to specify the Cube name.\n    #\
    \ If it hasn't then just delete the Cube if it exists\n    # If it has then search the relevant Cube\
    \ folder to find the matches\n    If( Scan( '*', sCube ) = 0 );\n        If( CubeExists( sCube ) =\
    \ 1 ); \n            If(CubeExists( '}CellSecurity_' | sCube ) = 1);\n                nRet = CellSecurityCubeDestroy(\
    \ sCube );\n                If( nRet = 1 );\n                    sMessage = '}CellSecurity_' | sCube\
    \ | ' successfully destroyed.';\n                    LogOutput( 'INFO', Expand( cMsgErrorContent )\
    \ );\n                Else;\n                    nErrors = 1;\n                    sMessage = 'Error.\
    \ Could not destroy }CellSecurity_' | sCube;\n                    LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n                EndIf;\n            Endif;\n        Endif;\n    Else;\n        # Wildcard\
    \ search string\n        sSearch                     = Expand('.%sOSDelim%%sCube%.cub');\n\n     \
    \   # Find all Cubes that match search string\n        sFilename                   = WildcardFileSearch(\
    \ sSearch, '' );\n        While( sFilename @<> '' );\n            # Trim .cub off the filename\n \
    \           sCube                   = SubSt( sFilename, 1, Long( sFilename ) - 4 );\n            #\
    \ Destroy Cube\n            If( CubeExists( sCube ) = 1 ); \n                If(CubeExists( '}CellSecurity_'\
    \ | sCube ) = 1);\n                    nRet            = CellSecurityCubeDestroy( sCube );\n     \
    \               If( nRet = 1 );\n                        sMessage    = '}CellSecurity_' | sCube |\
    \ ' successfully destroyed.';\n                        LogOutput( 'INFO', Expand( cMsgErrorContent\
    \ ) );\n                    Else;\n                        nErrors     = 1;\n                    \
    \    sMessage    = 'Error. Could not destroy }CellSecurity_' | sCube;\n                        LogOutput(\
    \ 'ERROR', Expand( cMsgErrorContent ) );\n                    EndIf;\n                Endif;\n   \
    \         Endif;\n            sFilename               = WildcardFileSearch( sSearch, sFilename );\n\
    \        End;\n    EndIf;\n\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully detsroyed\
    \ cell security for cube  %pCube%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\nsProcessReturnCode = pCube;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process intended to destroy the cell security cube(s) for
    the specified cube(s). This use case is intended for development and allows removing cell level security
    for one or more cubes. Note that a valid cube (pCube) is mandatory; otherwise, the process will abort.
    If a cube does not have cell security set up, it will skip that cube but log an error. Multiple cubes
    can be specified, separated by the delimiter pDelim or by using wildcards (*).
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will destroy the cell security cube(s) for the specified\
    \ cube(s).\n\n# Use case: Intended for development.\n# 1/ Remove cell level security for one or more\
    \ cubes.\n\n# Note:\n# Naturally, a valid cube (pCube) is mandatory otherwise the process will abort.\n\
    # If the cube does not have cell security set up, it will skip that cube but log an error.\n# Multiple\
    \ cubes can be specified separated by the pDelim or by using wildcards (*).\n#EndRegion @DOC\n\n##Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName = GetProcessName();\ncTimeStamp = TimSt(\
    \ Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString( INT( RAND( ) * 1000 ));\nDatasourceASCIIQuoteCharacter\
    \ = '';\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName%\
    \ Process:%cThisProcName% Message:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName% run with\
    \ parameters pCube:%pCube%, pDelim:%pDelim%.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n### Validate Parameters ###\nnErrors = 0;\n\n# If blank delimiter specified then convert to default\n\
    If( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n# If no cubes have been specified then terminate\
    \ process\nIf( Trim( pCube ) @= '' );\n    nErrors = 1;\n    sMessage = 'No cube(s) specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before\
    \ continuing\nIf( nErrors <> 0 );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n \
    \   Else;\n        ProcessBreak;\n    EndIf;\nEndIf;\n\n### Split pCubes into individual Cubes  ###\n\
    sCubes                  = pCube;\nnDelimiterIndex         = 1;\nWhile( nDelimiterIndex <> 0 );\n \
    \   nDelimiterIndex     = Scan( pDelim, sCubes );\n    If( nDelimiterIndex = 0 );\n        sCube \
    \          = sCubes;\n    Else;\n        sCube           = Trim( SubSt( sCubes, 1, nDelimiterIndex\
    \ - 1 ) );\n        sCubes          = Trim( Subst( sCubes, nDelimiterIndex + Long(pDelim), Long( sCubes\
    \ ) ) );\n    EndIf;\n  \n    # Check if a wildcard has been used to specify the Cube name.\n    #\
    \ If it hasn't then just delete the Cube if it exists\n    # If it has then search the relevant Cube\
    \ folder to find the matches\n    If( Scan( '*', sCube ) = 0 );\n        If( CubeExists( sCube ) =\
    \ 1 ); \n            If(CubeExists( '}CellSecurity_' | sCube ) = 1);\n                nRet = CellSecurityCubeDestroy(\
    \ sCube );\n                If( nRet = 1 );\n                    sMessage = '}CellSecurity_' | sCube\
    \ | ' successfully destroyed.';\n                    LogOutput( 'INFO', Expand( cMsgErrorContent )\
    \ );\n                Else;\n                    nErrors = 1;\n                    sMessage = 'Error.\
    \ Could not destroy }CellSecurity_' | sCube;\n                    LogOutput( 'ERROR', Expand( cMsgErrorContent\
    \ ) );\n                EndIf;\n            Endif;\n        Endif;\n    Else;\n        # Wildcard\
    \ search string\n        sSearch                     = Expand('.%sOSDelim%%sCube%.cub');\n\n     \
    \   # Find all Cubes that match search string\n        sFilename                   = WildcardFileSearch(\
    \ sSearch, '' );\n        While( sFilename @<> '' );\n            # Trim .cub off the filename\n \
    \           sCube                   = SubSt( sFilename, 1, Long( sFilename ) - 4 );\n            #\
    \ Destroy Cube\n            If( CubeExists( sCube ) = 1 ); \n                If(CubeExists( '}CellSecurity_'\
    \ | sCube ) = 1);\n                    nRet            = CellSecurityCubeDestroy( sCube );\n     \
    \               If( nRet = 1 );\n                        sMessage    = '}CellSecurity_' | sCube |\
    \ ' successfully destroyed.';\n                        LogOutput( 'INFO', Expand( cMsgErrorContent\
    \ ) );\n                    Else;\n                        nErrors     = 1;\n                    \
    \    sMessage    = 'Error. Could not destroy }CellSecurity_' | sCube;\n                        LogOutput(\
    \ 'ERROR', Expand( cMsgErrorContent ) );\n                    EndIf;\n                Endif;\n   \
    \         Endif;\n            sFilename               = WildcardFileSearch( sSearch, sFilename );\n\
    \        End;\n    EndIf;\n\nEnd;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n\
    \    sMessage = 'the process incurred at least 1 error. Please see above lines in this file for more\
    \ details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully detsroyed\
    \ cell security for cube  %pCube%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\nsProcessReturnCode = pCube;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der identifiziert, welche Dimensionen über Sicherheit
    verfügen, insbesondere Elementesicherheit, und dynamische Teilmengen evaluiert, deren Ausdrücke von
    den neuesten MDX-Sicherheitsänderungen betroffen sind. Dieser Prozess ist sowohl für Entwicklungs-
    als auch für Produktivumgebungen gedacht.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will find out which dimensions have security on them\
    \ - element security - and evaluate dynamic subsets with expressions impacted by the latest MDX security\
    \ changes \n# Use case: Intended for development or production.\n#EndRegion @DOC\n\n##Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nStringGlobalVariable('sGlobPrivateSubsetsTotalString');\n\
    sGlobPrivateSubsetsTotalString = '';\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName \
    \      = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pNameSpace:%pNameSpace%, pFilePath:%pFilePath%,\
    \ pFileName:%pFileName%, pDelim:%pDelim%, pQuote:%pQuote%.' ;  \ncMsgInfoContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% InfoMsg:%sMessage%';\ncSecurityPrefix = '}ElementSecurity_';\ncDimDim =\
    \ '}Dimensions';\ncUserDim = '}Clients';\ncUserAttrDim= '}ElementAttributes_}Clients';\ncUserAlias\
    \ = '}TM1_DefaultDisplayValue';\ncSubsetPrefix = '}Subsets_';\ncGroupDim = '}Groups';\ncSecCube =\
    \ '}ClientGroups';\n\npFieldDelim       = TRIM(pDelim);\nsCRChar           = Char( 13 );\nsLFChar\
    \           = Char( 10 );\nsCRLF             = Char( 13 ) | Char( 10 );\ncLenASCIICode     = 3;\n\
    nDataCount        = 0;\nnErrors           = 0;\n\ncKeyWordList = 'DRILLDOWN&.Children&FirstChild&Ancestors&Ascendants&Cousin&DrillUp&FirstSibling&IsAncestor&FirstSibling&LastChild&LastSibling&Descendants';\n\
    cKeyWordList = UPPER ( cKeyWordList );\ncKeyWordDelimiter = '&';\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n\
    # Namespace\nIf( pNameSpace <> 0 & pNameSpace <> 1 );\n    nErrors         = 1;\n    sMessage    \
    \    = 'NameSpace parameter not valid';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndIf;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':'\
    \ );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0\
    \ );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n\
    # Validate file path\nIf(Trim( pFilePath ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf( SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\n    pFilePath = SubSt( pFilePath,\
    \ 1, Long( pFilePath ) -1 );\nEndIf;\nIf(  FileExists( pFilePath ) = 0 );\n    sMessage = Expand('Invalid\
    \ export directory: %pFilePath%');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\npFilePath = pFilePath | sOSDelim;\n\n# Validate file name\nIf( pFileName\
    \ @= '' );\n    sBaseFileName = Expand('%cThisProcName%_Export');\n    sExt = '.csv';\n    pFileName\
    \ = sBaseFileName | '.csv';\nElse;\n    # determine file extension. If no file extension entered then\
    \ use .csv as default\n    If( Scan( '.', pFileName ) = 0 );\n        sExt = '.csv';\n        sBaseFileName\
    \ = pFileName;\n    Else;\n        sExt = SubSt( pFileName, Scan( '.', pFileName ), Long( pFileName\
    \ ) );\n        sBaseFileName = SubSt( pFileName, 1, Scan( '.', pFileName ) - 1 );\n    EndIf;\n \
    \   pFileName = sBaseFileName | sExt;\nEndIf;\ncExportFile = pFilePath | pFileName;\n\n# Validate\
    \ file delimiter & quote character\nIf( pFieldDelim @= '' );\n    pFieldDelim = ',';\nElse;\n    #\
    \ If length of pFieldDelim is exactly 3 chars and each of them is decimal digit, then the pFieldDelim\
    \ is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pFieldDelim) = cLenASCIICode );\n     \
    \ nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pFieldDelim, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n\
    \          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If\
    \ ( nValid<>0 );\n      pFieldDelim=CHAR(StringToNumber( pFieldDelim ));\n    Else;\n      pFieldDelim\
    \ = SubSt( Trim( pFieldDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote\
    \ character \nElse;\n    # If length of pQuote is exactly 3 chars and each of them is decimal digit,\
    \ then the pQuote is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode\
    \ );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar )\
    \ >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n\
    \          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If\
    \ ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote = SubSt( Trim(\
    \ pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\nDatasourceAsciiDelimiter = pFieldDelim;\nDatasourceAsciiQuoteCharacter = '';\nsTotalRowString\
    \ = '';\n\nsTitleRow = '%pQuote%DIMENSION%pQuote%%pFieldDelim%%pQuote%HAS SECURITY%pQuote%%pFieldDelim%%pQuote%SUBSET\
    \ NAME%pQuote%';\nsTitleRow = sTitleRow|'%pFieldDelim%%pQuote%IS PRIVATE%pQuote%%pFieldDelim%%pQuote%MDX\
    \ EXPRESSION%pQuote%';\nsTitleRow = sTitleRow|'%pFieldDelim%%pQuote%KEYWORDS%pQuote%%pFieldDelim%%pQuote%ELEMENTS%pQuote%%pFieldDelim%%pQuote%USERS\
    \ WITH NO ACCESS%pQuote%';\nTextOutput( cExportFile, Expand(sTitleRow) );\nsTotalRowString = Expand(sTitleRow);\n\
    \niDim = 1;\nnMaxDim = DimSiz ( cDimDim );\n\nWhile ( iDim <= nMaxDim );\n    sDim = DimNm ( cDimDim,\
    \ iDim );\n    sSecurityCube = cSecurityPrefix | sDim;\n    If ( CubeExists ( sSecurityCube ) = 1\
    \ );\n        IF( pLogoutput = 1 );\n            sMessage = 'The dimension ' | sDim | ' has element\
    \ security assigned';\n            LogOutput('INFO', Expand( cMsgInfoContent ) );\n        ENDIF;\n\
    \        # now we need to go find subsets - two ways of doing this - data directory or }subset dimension\n\
    \        # data directory is the only place to find private subs but need to know the username to\
    \ loop through  \n        iUser = 1;\n        nMaxUser = DimSiz ( cUserDim );\n        While ( iUser\
    \ <= nMaxUser );\n            sUser = DimNm ( cUserDim, iUser );\n            # if CAMId is used folder\
    \ structure is different\n            If ( DimIx ( cUserAttrDim, cUserAlias ) > 0 );\n           \
    \     sAlias = AttrS ( cUserDim, sUser, cUserAlias );\n                If ( sAlias @= '' );\n    \
    \                sAlias = sUser;\n                EndIf;\n            EndIf; \n            sNamespacePrefix\
    \ = '';\n            # if CAMId is used folder structure is different\n            If ( pNamespace\
    \ = 1 );\n                # this \\ or / is hardcoded as it is the CAMID }TM1_DefaultDisplayValue\
    \ alias which sometimes uses back- and sometimes forward-slash. We aren't sanning for directory separator.\n\
    \                nEnd = Scan( '/', sAlias);\n                If ( nEnd = 0 );\n                  \
    \  nEnd = Scan ( '', sAlias );\n                EndIf;    \n                sNamespace = SubSt ( sAlias,\
    \ 1, nEnd - 1 );\n                sAlias = SubSt ( sAlias, nEnd + 1, Long ( sAlias ) - nEnd );\n \
    \               sNamespacePrefix = sNameSpace | sOSDelim;\n            EndIf;    \n            sSubset\
    \ = WildcardFileSearch( Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%*.sub') ,\
    \ '');\n            # loop through all subsets\n            While ( sSubset @<> '' );\n          \
    \      sSubsetName = Subst ( sSubset, 1, LONG ( sSubset ) - 4 );\n                sFile = Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%%sSubset%')\
    \ ;\n                IF( pLogoutput = 1 );\n                    sMessage = Expand('Private subset\
    \ called %sSubsetName% found for user %sAlias% in dimension %sDim%. File = %sFile%');\n          \
    \          LogOutput('INFO', Expand( cMsgInfoContent ) );\n                ENDIF;\n              \
    \  # run the sub process to evaluate the MDX\n                If ( sSubset @<> '' );\n           \
    \         nRet = ExecuteProcess('}bedrock.security.evaluate.mdx.private',\n                      \
    \         'pLogOutput', pLogOutput,\n                               'pStrictErrorHandling', pStrictErrorHandling,\n\
    \                               'pUser', sUser,\n                               'pDimension', sDim,\n\
    \                               'pSubset', sSubsetName,\n                               'pSubsetFile',\
    \ sFile,\n                               'pFilePath', pFilePath,\n                               'pFileName',\
    \ '',\n                               'pDelim', pDelim,\n                               'pQuote',\
    \ pQuote,\n                               'pWriteOutput', 0\n                      );\n          \
    \          If( nRet <> ProcessExitNormal() );\n                        nErrors = nErrors + 1;\n  \
    \                      sMessage= 'Error in evaluating private subsets.';\n                       \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                    EndIf;\n\n       \
    \         EndIf;  \n                sSubset = WildcardFileSearch( Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%*.sub')\
    \ , sSubset);                \n            End;    \n            iUser = iUser + 1;\n        End;\
    \ \n        \n        sSubsetDim = cSubsetPrefix | sDim;\n        iSub = 1;\n        nSubsetMax =\
    \ DimSiz ( sSubsetDim );\n        # loop through all subsets\n        While ( iSub <= nSubsetMax );\n\
    \            sSubsetName = DimNm ( sSubsetDim, iSub );\n            sMDX = '';\n            sMDX =\
    \ SubsetMDXGet ( sDim, sSubsetName );\n            sMDX = UPPER ( sMDX );\n            If ( sMDX @<>\
    \ '' );\n                ## Remove line breaks from MDX string\n                nMDXLen = Long( sMDX\
    \ );\n                nMDXCount = 1;\n                While( nMDXCount <= nMDXLen );\n           \
    \       sCharPoint = Subst( sMDX, nMDXCount, 1 );\n                  IF( sCharPoint @= sCRChar % sCharPoint\
    \ @= sLFChar );\n                      Delet( sMDX, nMDXCount, 1 );\n                      nMDXLen\
    \ = Long( sMDX );\n                  ENDIF;\n                  \n                  nMDXCount = nMDXCount\
    \ + 1;\n                End;\n                nMDXLen = Long( sMDX );\n                sMDXLastChar\
    \ = Subst( sMDX, nMDXLen, 1 );\n                While( sMDXLastChar @<> '}' );\n                 \
    \ sMDX = Subst( sMDX, 1, nMDXLen - 1 );\n                  nMDXLen = Long( sMDX );\n             \
    \     sMDXLastChar = Subst( sMDX, nMDXLen, 1 );\n                End;\n                sRow = '%pQuote%%sDim%%pQuote%%pFieldDelim%%pQuote%Y%pQuote%%pFieldDelim%%pQuote%%sSubsetName%%pQuote%%pFieldDelim%%pQuote%NO%pQuote%%pFieldDelim%%pQuote%%sMDX%%pQuote%';\n\
    \                IF( pLogoutput = 1 );\n                    sMessage = Expand('Public subset called\
    \ %sSubsetName% found in dimension %sDim% with MDX %sMDX%');\n                    LogOutput('INFO',\
    \ Expand( cMsgInfoContent ) );\n                ENDIF;\n                # now parse the MDX \n   \
    \             nKeywordFlag = 0;\n                sKeyWordString = '';\n                sKeywordList\
    \ = cKeywordList;\n                nKeywordLength = Long ( sKeywordList );\n                While\
    \ ( nKeywordLength > 0 );\n                    nDelimiter = Scan ( cKeywordDelimiter, sKeyWordList\
    \ );\n                    If ( nDelimiter = 0 );\n                        sKeyword = sKeyWordList;\n\
    \                        sKeyWordList = '';\n                    Else;\n                        nEnd\
    \ = nDelimiter - 1;\n                        sKeyWord = SubSt ( sKeywordList, 1, nEnd );\n       \
    \                 sKeyWordList = Subst ( sKeywordList, nEnd + 2, nKeywordLength - nEnd);\n       \
    \             EndIf;    \n                    If ( Scan( sKeyWord, sMDX ) > 0 );\n               \
    \         nKeyWordFlag = nKeyWordFlag + 1;\n                        IF( Long( sKeyWordString ) = 0\
    \ );\n                          sKeyWordString = sKeyWordString | sKeyWord;\n                    \
    \    ELSE;\n                          sKeyWordString = sKeyWordString | pDelim | ' ' | sKeyWord;\n\
    \                        ENDIF;\n                        IF( pLogoutput = 1 );\n                 \
    \           sMessage = 'Keyword ' | sKeyWord | ' found in ' | sMDX;\n                            LogOutput('INFO',\
    \ Expand( cMsgInfoContent ) );\n                        ENDIF;\n                    EndIf;   \n  \
    \                  nKeywordLength = Long ( sKeywordList );\n                End;    \n           \
    \     # if keywords found then see if we can match an element in the MDX with one in the dimension\n\
    \                # element will be included within [] but there will be [dimension][hierarchy][subset][attribute]\
    \ so could be a false positive\n                If ( nKeyWordFlag > 0 );\n                    sRow\
    \ = sRow|'%pFieldDelim%%pQuote%%sKeyWordString%%pQuote%';\n                    sUsersString = '';\n\
    \                    sElementString = '';\n                    sMDXTemp = sMDX;\n                \
    \    sStarter = '[';\n                    sEnder = ']';\n                    nMDXLength = Long ( sMDXTemp\
    \ );\n                    While ( nMDXLength > 0 );\n                        nStarter = SCAN ( sStarter,\
    \ sMDXTemp );\n                        If ( nStarter > 0 );\n                            nEnder =\
    \ SCAN ( sEnder, sMDXTemp );\n                            sElement = SubSt ( sMDXTemp, nStarter +\
    \ 1, nEnder - nStarter -1);\n                            nToGo = nMDXLength - nEnder + 1;\n      \
    \                      sMDXTemp = Subst ( sMDXTemp, nEnder + 1, nToGo );\n                       \
    \     # check if that is actually an element\n                            If ( DimIx ( sDim, sElement\
    \ ) > 0 );\n                                IF( Scan( sElement, sElementString ) = 0 );\n        \
    \                            IF( sElementString @= '' );\n                                       \
    \ sElementString = sElementString | sElement;\n                                    ELSE;\n       \
    \                                 sElementString = sElementString | pDelim | ' ' | sElement;\n   \
    \                                 ENDIF;\n                                ENDIF;\n               \
    \                 IF( pLogoutput = 1 );\n                                    sMessage = sElement |\
    \ ' is referenced in the MDX and exists in the dimension';\n                                    LogOutput('INFO',\
    \ Expand( cMsgInfoContent ) );\n                                ENDIF;\n                         \
    \       #loop thropugh all users\n                                iUser = 1;\n                   \
    \             nMaxUser = DimSiz ( cUserDim );\n                                While ( iUser <= nMaxUser\
    \ );\n                                    sUser = DimNm ( cUserDim, iUser );\n                   \
    \                 # now need to loop through relevant groups to see access\n                     \
    \               # loop through all groups to check access to this element\n                      \
    \              nUserCheck = 0;\n                                    iGroup = 1;\n                \
    \                    nGroupMax = DimSiz ( cGroupDim );\n                                    While\
    \ ( iGroup <= nGroupMax );\n                                        sGroup = DimNm ( cGroupDim, iGroup\
    \ );\n                                        #skip the admin groups!\n                          \
    \              If ( sGroup @<> 'ADMIN' & sGroup @<> 'SecurityAdmin' & sGroup @<> 'DataAdmin' & sGroup\
    \ @<> 'OperationsAdmin' );\n                                            nCheck = 1;\n            \
    \                                # if we have a user check membership and we don;t need to continue\
    \ if not in that group\n                                            If ( CellGetS ( cSecCube, sUser,\
    \ sGroup ) @= '' );\n                                                nCheck = 0;\n               \
    \                             EndIf;    \n                                            If ( nCheck\
    \ = 1 );\n                                                # get the groups security assignment\n \
    \                                               sAccess = CellGetS ( sSecurityCube, sElement, sGroup\
    \ );\n                                                # if the user has rights to that element then\
    \ all is good and we can quit the loops\n                                                If ( sAccess\
    \ @<> '' & sAccess @<> 'NONE' );\n                                                    nUserCheck =\
    \ 1;\n                                                    iGroup = nGroupMax + 1;\n              \
    \                                  EndIf;\n                                            EndIf;\n  \
    \                                      Else;\n                                            # if the\
    \ user is in an admin group them they will have access\n                                         \
    \   \n                                            If ( CellGetS ( cSecCube, sUser, sGroup ) @<> ''\
    \ );\n                                                nUserCheck = 1;\n                          \
    \                      iGroup = nGroupMax + 1;\n                                            EndIf;\
    \   \n                                        EndIf;    \n                                       \
    \ iGroup = iGroup + 1;\n                                    End;    \n                           \
    \         If ( nUserCheck = 0 );\n                                        IF( Scan( sUser, sUsersString\
    \ ) = 0 );\n                                            IF( sUsersString @= '' );\n              \
    \                                sUsersString = sUsersString | sUser;\n                          \
    \                  ELSE;\n                                              sUsersString = sUsersString\
    \ | pDelim | ' ' | sUser;\n                                            ENDIF;\n                  \
    \                      ENDIF;\n                                        IF( pLogoutput = 1 );\n   \
    \                                         sMessage = Expand('Public subset %sSubsetName% contains\
    \ a keyword and a specific element %sElement% that the user %sUser% do not have access to');\n   \
    \                                         LogOutput('INFO', Expand( cMsgInfoContent ) );\n       \
    \                                 ENDIF;\n                                    EndIf;\n           \
    \                         iUser = iUser + 1;\n                                End;\n             \
    \               EndIf;\n                            nMDXLength = Long ( sMDXTemp );\n            \
    \            Else;\n                            nMDXLength = 0;\n                        EndIf;  \n\
    \                    End;                      \n                    \n                sRow = sRow|'%pFieldDelim%%pQuote%%sElementString%%pQuote%%pFieldDelim%%pQuote%%sUsersString%%pQuote%';\n\
    \                sTotalRowString = sTotalRowString | sCRLF | Expand(sRow);\n                # Output\
    \ data\n                #TextOutput( cExportFile, Expand(sRow) );\n                EndIf;    \n  \
    \          EndIf;    \n            iSub = iSub + 1;\n        End;      \n    EndIf;    \n    iDim\
    \ = iDim + 1;\nEnd;\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Write Output data\nIf( nErrors = 0 );\n  TextOutput( cExportFile, sTotalRowString );\n  TextOutput(\
    \ cExportFile, sGlobPrivateSubsetsTotalString );\nENDIF;\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see\
    \ above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created report file.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that identifies which dimensions have security, particularly
    element security, and evaluates dynamic subsets with expressions impacted by the latest MDX security
    changes. This process is intended for both development and production environments.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will find out which dimensions have security on them\
    \ - element security - and evaluate dynamic subsets with expressions impacted by the latest MDX security\
    \ changes \n# Use case: Intended for development or production.\n#EndRegion @DOC\n\n##Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nStringGlobalVariable('sGlobPrivateSubsetsTotalString');\n\
    sGlobPrivateSubsetsTotalString = '';\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName \
    \      = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pNameSpace:%pNameSpace%, pFilePath:%pFilePath%,\
    \ pFileName:%pFileName%, pDelim:%pDelim%, pQuote:%pQuote%.' ;  \ncMsgInfoContent    = 'User:%cUserName%\
    \ Process:%cThisProcName% InfoMsg:%sMessage%';\ncSecurityPrefix = '}ElementSecurity_';\ncDimDim =\
    \ '}Dimensions';\ncUserDim = '}Clients';\ncUserAttrDim= '}ElementAttributes_}Clients';\ncUserAlias\
    \ = '}TM1_DefaultDisplayValue';\ncSubsetPrefix = '}Subsets_';\ncGroupDim = '}Groups';\ncSecCube =\
    \ '}ClientGroups';\n\npFieldDelim       = TRIM(pDelim);\nsCRChar           = Char( 13 );\nsLFChar\
    \           = Char( 10 );\nsCRLF             = Char( 13 ) | Char( 10 );\ncLenASCIICode     = 3;\n\
    nDataCount        = 0;\nnErrors           = 0;\n\ncKeyWordList = 'DRILLDOWN&.Children&FirstChild&Ancestors&Ascendants&Cousin&DrillUp&FirstSibling&IsAncestor&FirstSibling&LastChild&LastSibling&Descendants';\n\
    cKeyWordList = UPPER ( cKeyWordList );\ncKeyWordDelimiter = '&';\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n\
    # Namespace\nIf( pNameSpace <> 0 & pNameSpace <> 1 );\n    nErrors         = 1;\n    sMessage    \
    \    = 'NameSpace parameter not valid';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent )\
    \ );\nEndIf;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':'\
    \ );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0\
    \ );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n\
    # Validate file path\nIf(Trim( pFilePath ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf( SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\n    pFilePath = SubSt( pFilePath,\
    \ 1, Long( pFilePath ) -1 );\nEndIf;\nIf(  FileExists( pFilePath ) = 0 );\n    sMessage = Expand('Invalid\
    \ export directory: %pFilePath%');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\npFilePath = pFilePath | sOSDelim;\n\n# Validate file name\nIf( pFileName\
    \ @= '' );\n    sBaseFileName = Expand('%cThisProcName%_Export');\n    sExt = '.csv';\n    pFileName\
    \ = sBaseFileName | '.csv';\nElse;\n    # determine file extension. If no file extension entered then\
    \ use .csv as default\n    If( Scan( '.', pFileName ) = 0 );\n        sExt = '.csv';\n        sBaseFileName\
    \ = pFileName;\n    Else;\n        sExt = SubSt( pFileName, Scan( '.', pFileName ), Long( pFileName\
    \ ) );\n        sBaseFileName = SubSt( pFileName, 1, Scan( '.', pFileName ) - 1 );\n    EndIf;\n \
    \   pFileName = sBaseFileName | sExt;\nEndIf;\ncExportFile = pFilePath | pFileName;\n\n# Validate\
    \ file delimiter & quote character\nIf( pFieldDelim @= '' );\n    pFieldDelim = ',';\nElse;\n    #\
    \ If length of pFieldDelim is exactly 3 chars and each of them is decimal digit, then the pFieldDelim\
    \ is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pFieldDelim) = cLenASCIICode );\n     \
    \ nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pFieldDelim, nChar ) >= CODE(\
    \ '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n\
    \          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If\
    \ ( nValid<>0 );\n      pFieldDelim=CHAR(StringToNumber( pFieldDelim ));\n    Else;\n      pFieldDelim\
    \ = SubSt( Trim( pFieldDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf( pQuote @= '' );\n    ## Use no quote\
    \ character \nElse;\n    # If length of pQuote is exactly 3 chars and each of them is decimal digit,\
    \ then the pQuote is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pQuote) = cLenASCIICode\
    \ );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE( pQuote, nChar )\
    \ >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n          nValid = 1;\n        Else;\n\
    \          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n      End;\n    EndIf;\n    If\
    \ ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n    Else;\n      pQuote = SubSt( Trim(\
    \ pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\nDatasourceAsciiDelimiter = pFieldDelim;\nDatasourceAsciiQuoteCharacter = '';\nsTotalRowString\
    \ = '';\n\nsTitleRow = '%pQuote%DIMENSION%pQuote%%pFieldDelim%%pQuote%HAS SECURITY%pQuote%%pFieldDelim%%pQuote%SUBSET\
    \ NAME%pQuote%';\nsTitleRow = sTitleRow|'%pFieldDelim%%pQuote%IS PRIVATE%pQuote%%pFieldDelim%%pQuote%MDX\
    \ EXPRESSION%pQuote%';\nsTitleRow = sTitleRow|'%pFieldDelim%%pQuote%KEYWORDS%pQuote%%pFieldDelim%%pQuote%ELEMENTS%pQuote%%pFieldDelim%%pQuote%USERS\
    \ WITH NO ACCESS%pQuote%';\nTextOutput( cExportFile, Expand(sTitleRow) );\nsTotalRowString = Expand(sTitleRow);\n\
    \niDim = 1;\nnMaxDim = DimSiz ( cDimDim );\n\nWhile ( iDim <= nMaxDim );\n    sDim = DimNm ( cDimDim,\
    \ iDim );\n    sSecurityCube = cSecurityPrefix | sDim;\n    If ( CubeExists ( sSecurityCube ) = 1\
    \ );\n        IF( pLogoutput = 1 );\n            sMessage = 'The dimension ' | sDim | ' has element\
    \ security assigned';\n            LogOutput('INFO', Expand( cMsgInfoContent ) );\n        ENDIF;\n\
    \        # now we need to go find subsets - two ways of doing this - data directory or }subset dimension\n\
    \        # data directory is the only place to find private subs but need to know the username to\
    \ loop through  \n        iUser = 1;\n        nMaxUser = DimSiz ( cUserDim );\n        While ( iUser\
    \ <= nMaxUser );\n            sUser = DimNm ( cUserDim, iUser );\n            # if CAMId is used folder\
    \ structure is different\n            If ( DimIx ( cUserAttrDim, cUserAlias ) > 0 );\n           \
    \     sAlias = AttrS ( cUserDim, sUser, cUserAlias );\n                If ( sAlias @= '' );\n    \
    \                sAlias = sUser;\n                EndIf;\n            EndIf; \n            sNamespacePrefix\
    \ = '';\n            # if CAMId is used folder structure is different\n            If ( pNamespace\
    \ = 1 );\n                # this \\ or / is hardcoded as it is the CAMID }TM1_DefaultDisplayValue\
    \ alias which sometimes uses back- and sometimes forward-slash. We aren't sanning for directory separator.\n\
    \                nEnd = Scan( '/', sAlias);\n                If ( nEnd = 0 );\n                  \
    \  nEnd = Scan ( '', sAlias );\n                EndIf;    \n                sNamespace = SubSt ( sAlias,\
    \ 1, nEnd - 1 );\n                sAlias = SubSt ( sAlias, nEnd + 1, Long ( sAlias ) - nEnd );\n \
    \               sNamespacePrefix = sNameSpace | sOSDelim;\n            EndIf;    \n            sSubset\
    \ = WildcardFileSearch( Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%*.sub') ,\
    \ '');\n            # loop through all subsets\n            While ( sSubset @<> '' );\n          \
    \      sSubsetName = Subst ( sSubset, 1, LONG ( sSubset ) - 4 );\n                sFile = Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%%sSubset%')\
    \ ;\n                IF( pLogoutput = 1 );\n                    sMessage = Expand('Private subset\
    \ called %sSubsetName% found for user %sAlias% in dimension %sDim%. File = %sFile%');\n          \
    \          LogOutput('INFO', Expand( cMsgInfoContent ) );\n                ENDIF;\n              \
    \  # run the sub process to evaluate the MDX\n                If ( sSubset @<> '' );\n           \
    \         nRet = ExecuteProcess('}bedrock.security.evaluate.mdx.private',\n                      \
    \         'pLogOutput', pLogOutput,\n                               'pStrictErrorHandling', pStrictErrorHandling,\n\
    \                               'pUser', sUser,\n                               'pDimension', sDim,\n\
    \                               'pSubset', sSubsetName,\n                               'pSubsetFile',\
    \ sFile,\n                               'pFilePath', pFilePath,\n                               'pFileName',\
    \ '',\n                               'pDelim', pDelim,\n                               'pQuote',\
    \ pQuote,\n                               'pWriteOutput', 0\n                      );\n          \
    \          If( nRet <> ProcessExitNormal() );\n                        nErrors = nErrors + 1;\n  \
    \                      sMessage= 'Error in evaluating private subsets.';\n                       \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                    EndIf;\n\n       \
    \         EndIf;  \n                sSubset = WildcardFileSearch( Expand('%sNameSpacePrefix%%sAlias%%sOSDelim%%sDim%}subs%sOSDelim%*.sub')\
    \ , sSubset);                \n            End;    \n            iUser = iUser + 1;\n        End;\
    \ \n        \n        sSubsetDim = cSubsetPrefix | sDim;\n        iSub = 1;\n        nSubsetMax =\
    \ DimSiz ( sSubsetDim );\n        # loop through all subsets\n        While ( iSub <= nSubsetMax );\n\
    \            sSubsetName = DimNm ( sSubsetDim, iSub );\n            sMDX = '';\n            sMDX =\
    \ SubsetMDXGet ( sDim, sSubsetName );\n            sMDX = UPPER ( sMDX );\n            If ( sMDX @<>\
    \ '' );\n                ## Remove line breaks from MDX string\n                nMDXLen = Long( sMDX\
    \ );\n                nMDXCount = 1;\n                While( nMDXCount <= nMDXLen );\n           \
    \       sCharPoint = Subst( sMDX, nMDXCount, 1 );\n                  IF( sCharPoint @= sCRChar % sCharPoint\
    \ @= sLFChar );\n                      Delet( sMDX, nMDXCount, 1 );\n                      nMDXLen\
    \ = Long( sMDX );\n                  ENDIF;\n                  \n                  nMDXCount = nMDXCount\
    \ + 1;\n                End;\n                nMDXLen = Long( sMDX );\n                sMDXLastChar\
    \ = Subst( sMDX, nMDXLen, 1 );\n                While( sMDXLastChar @<> '}' );\n                 \
    \ sMDX = Subst( sMDX, 1, nMDXLen - 1 );\n                  nMDXLen = Long( sMDX );\n             \
    \     sMDXLastChar = Subst( sMDX, nMDXLen, 1 );\n                End;\n                sRow = '%pQuote%%sDim%%pQuote%%pFieldDelim%%pQuote%Y%pQuote%%pFieldDelim%%pQuote%%sSubsetName%%pQuote%%pFieldDelim%%pQuote%NO%pQuote%%pFieldDelim%%pQuote%%sMDX%%pQuote%';\n\
    \                IF( pLogoutput = 1 );\n                    sMessage = Expand('Public subset called\
    \ %sSubsetName% found in dimension %sDim% with MDX %sMDX%');\n                    LogOutput('INFO',\
    \ Expand( cMsgInfoContent ) );\n                ENDIF;\n                # now parse the MDX \n   \
    \             nKeywordFlag = 0;\n                sKeyWordString = '';\n                sKeywordList\
    \ = cKeywordList;\n                nKeywordLength = Long ( sKeywordList );\n                While\
    \ ( nKeywordLength > 0 );\n                    nDelimiter = Scan ( cKeywordDelimiter, sKeyWordList\
    \ );\n                    If ( nDelimiter = 0 );\n                        sKeyword = sKeyWordList;\n\
    \                        sKeyWordList = '';\n                    Else;\n                        nEnd\
    \ = nDelimiter - 1;\n                        sKeyWord = SubSt ( sKeywordList, 1, nEnd );\n       \
    \                 sKeyWordList = Subst ( sKeywordList, nEnd + 2, nKeywordLength - nEnd);\n       \
    \             EndIf;    \n                    If ( Scan( sKeyWord, sMDX ) > 0 );\n               \
    \         nKeyWordFlag = nKeyWordFlag + 1;\n                        IF( Long( sKeyWordString ) = 0\
    \ );\n                          sKeyWordString = sKeyWordString | sKeyWord;\n                    \
    \    ELSE;\n                          sKeyWordString = sKeyWordString | pDelim | ' ' | sKeyWord;\n\
    \                        ENDIF;\n                        IF( pLogoutput = 1 );\n                 \
    \           sMessage = 'Keyword ' | sKeyWord | ' found in ' | sMDX;\n                            LogOutput('INFO',\
    \ Expand( cMsgInfoContent ) );\n                        ENDIF;\n                    EndIf;   \n  \
    \                  nKeywordLength = Long ( sKeywordList );\n                End;    \n           \
    \     # if keywords found then see if we can match an element in the MDX with one in the dimension\n\
    \                # element will be included within [] but there will be [dimension][hierarchy][subset][attribute]\
    \ so could be a false positive\n                If ( nKeyWordFlag > 0 );\n                    sRow\
    \ = sRow|'%pFieldDelim%%pQuote%%sKeyWordString%%pQuote%';\n                    sUsersString = '';\n\
    \                    sElementString = '';\n                    sMDXTemp = sMDX;\n                \
    \    sStarter = '[';\n                    sEnder = ']';\n                    nMDXLength = Long ( sMDXTemp\
    \ );\n                    While ( nMDXLength > 0 );\n                        nStarter = SCAN ( sStarter,\
    \ sMDXTemp );\n                        If ( nStarter > 0 );\n                            nEnder =\
    \ SCAN ( sEnder, sMDXTemp );\n                            sElement = SubSt ( sMDXTemp, nStarter +\
    \ 1, nEnder - nStarter -1);\n                            nToGo = nMDXLength - nEnder + 1;\n      \
    \                      sMDXTemp = Subst ( sMDXTemp, nEnder + 1, nToGo );\n                       \
    \     # check if that is actually an element\n                            If ( DimIx ( sDim, sElement\
    \ ) > 0 );\n                                IF( Scan( sElement, sElementString ) = 0 );\n        \
    \                            IF( sElementString @= '' );\n                                       \
    \ sElementString = sElementString | sElement;\n                                    ELSE;\n       \
    \                                 sElementString = sElementString | pDelim | ' ' | sElement;\n   \
    \                                 ENDIF;\n                                ENDIF;\n               \
    \                 IF( pLogoutput = 1 );\n                                    sMessage = sElement |\
    \ ' is referenced in the MDX and exists in the dimension';\n                                    LogOutput('INFO',\
    \ Expand( cMsgInfoContent ) );\n                                ENDIF;\n                         \
    \       #loop thropugh all users\n                                iUser = 1;\n                   \
    \             nMaxUser = DimSiz ( cUserDim );\n                                While ( iUser <= nMaxUser\
    \ );\n                                    sUser = DimNm ( cUserDim, iUser );\n                   \
    \                 # now need to loop through relevant groups to see access\n                     \
    \               # loop through all groups to check access to this element\n                      \
    \              nUserCheck = 0;\n                                    iGroup = 1;\n                \
    \                    nGroupMax = DimSiz ( cGroupDim );\n                                    While\
    \ ( iGroup <= nGroupMax );\n                                        sGroup = DimNm ( cGroupDim, iGroup\
    \ );\n                                        #skip the admin groups!\n                          \
    \              If ( sGroup @<> 'ADMIN' & sGroup @<> 'SecurityAdmin' & sGroup @<> 'DataAdmin' & sGroup\
    \ @<> 'OperationsAdmin' );\n                                            nCheck = 1;\n            \
    \                                # if we have a user check membership and we don;t need to continue\
    \ if not in that group\n                                            If ( CellGetS ( cSecCube, sUser,\
    \ sGroup ) @= '' );\n                                                nCheck = 0;\n               \
    \                             EndIf;    \n                                            If ( nCheck\
    \ = 1 );\n                                                # get the groups security assignment\n \
    \                                               sAccess = CellGetS ( sSecurityCube, sElement, sGroup\
    \ );\n                                                # if the user has rights to that element then\
    \ all is good and we can quit the loops\n                                                If ( sAccess\
    \ @<> '' & sAccess @<> 'NONE' );\n                                                    nUserCheck =\
    \ 1;\n                                                    iGroup = nGroupMax + 1;\n              \
    \                                  EndIf;\n                                            EndIf;\n  \
    \                                      Else;\n                                            # if the\
    \ user is in an admin group them they will have access\n                                         \
    \   \n                                            If ( CellGetS ( cSecCube, sUser, sGroup ) @<> ''\
    \ );\n                                                nUserCheck = 1;\n                          \
    \                      iGroup = nGroupMax + 1;\n                                            EndIf;\
    \   \n                                        EndIf;    \n                                       \
    \ iGroup = iGroup + 1;\n                                    End;    \n                           \
    \         If ( nUserCheck = 0 );\n                                        IF( Scan( sUser, sUsersString\
    \ ) = 0 );\n                                            IF( sUsersString @= '' );\n              \
    \                                sUsersString = sUsersString | sUser;\n                          \
    \                  ELSE;\n                                              sUsersString = sUsersString\
    \ | pDelim | ' ' | sUser;\n                                            ENDIF;\n                  \
    \                      ENDIF;\n                                        IF( pLogoutput = 1 );\n   \
    \                                         sMessage = Expand('Public subset %sSubsetName% contains\
    \ a keyword and a specific element %sElement% that the user %sUser% do not have access to');\n   \
    \                                         LogOutput('INFO', Expand( cMsgInfoContent ) );\n       \
    \                                 ENDIF;\n                                    EndIf;\n           \
    \                         iUser = iUser + 1;\n                                End;\n             \
    \               EndIf;\n                            nMDXLength = Long ( sMDXTemp );\n            \
    \            Else;\n                            nMDXLength = 0;\n                        EndIf;  \n\
    \                    End;                      \n                    \n                sRow = sRow|'%pFieldDelim%%pQuote%%sElementString%%pQuote%%pFieldDelim%%pQuote%%sUsersString%%pQuote%';\n\
    \                sTotalRowString = sTotalRowString | sCRLF | Expand(sRow);\n                # Output\
    \ data\n                #TextOutput( cExportFile, Expand(sRow) );\n                EndIf;    \n  \
    \          EndIf;    \n            iSub = iSub + 1;\n        End;      \n    EndIf;    \n    iDim\
    \ = iDim + 1;\nEnd;\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Write Output data\nIf( nErrors = 0 );\n  TextOutput( cExportFile, sTotalRowString );\n  TextOutput(\
    \ cExportFile, sGlobPrivateSubsetsTotalString );\nENDIF;\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see\
    \ above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully created report file.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der darauf abzielt, die privaten dynamischen
    Teilmengen von Dimensionen zu identifizieren, die mit Element-Sicherheitsvorkehrungen versehen sind.
    Der Prozess sollte die durch die neuesten MDX-Sicherheitsänderungen betroffenen Ausdrücke bewerten
    und sowohl für Entwicklungs- als auch Produktionsumgebungen geeignet sein.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will find out PRIVATE dynamic subsets of dimensions\
    \ having security on them - element security - and evaluate expressions impacted by the latest MDX\
    \ security changes \n# Use case: Intended for development or production.\n#EndRegion @DOC\n\n##Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    StringGlobalVariable('sGlobPrivateSubsetsTotalString');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n\
    cRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pUser:%pUser%, pDimension:%pDimension%,\
    \ pSubset:%pSubset%, pSubsetFile:%pSubsetFile%, pFilePath:%pFilePath%, pFileName:%pFileName%, pDelim:%pDelim%,\
    \ pQuote:%pQuote%.' ;  \ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\n\
    cSecurityPrefix = '}ElementSecurity_';\ncDimDim = '}Dimensions';\ncUserDim = '}Clients';\ncUserAttrDim=\
    \ '}ElementAttributes_}Clients';\ncUserAlias = '}TM1_DefaultDisplayValue';\ncSubsetPrefix = '}Subsets_';\n\
    cGroupDim = '}Groups';\ncSecCube = '}ClientGroups';\nnGroupMax = DimSiz ( cGroupDim );\nnUserMax =\
    \ DimSiz ( cUserDim );\ncEleSecCube = cSecurityPrefix | pDimension;\n\npFieldDelim       = TRIM(pDelim);\n\
    sCRLF             = Char( 13 ) | Char( 10 );\ncLenASCIICode     = 3;\nnDataCount        = 0;\nnErrors\
    \           = 0;\n\n#reset flag and string\nnMDXFlag = 0;\nsMDX = '';\nsTotalRowString = '';\n\n#keywords\
    \ to look out for in an MDX expression\ncKeyWordList = 'DRILLDOWN&.Children&FirstChild&Ancestors&Ascendants&Cousin&DrillUp&FirstSibling&IsAncestor&FirstSibling&LastChild&LastSibling&Descendants';\n\
    cKeyWordList = UPPER ( cKeyWordList );\ncKeyWordDelimiter = '&';\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n\
    # Validate user\nIF( DimIx( cUserDim,  pUser) = 0 );\n    sMessage = Expand('Invalid user: %pUser%');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nENDIF;\n\
    \n# Validate dimension\nIF( DimIx( cDimDim,  pDimension) = 0 );\n    sMessage = Expand('Invalid dimension:\
    \ %pDimension%');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nENDIF;\n\n# Validate subset name\nIF( pSubset @= '' % Scan( pSubset, pSubsetFile ) = 0  );\n\
    \    sMessage = Expand('Invalid subset name: %pSubset%');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nENDIF;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n# Validate file path\nIf(Trim( pFilePath ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf( SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\n    pFilePath = SubSt( pFilePath,\
    \ 1, Long( pFilePath ) -1 );\nEndIf;\nIf(  FileExists( pFilePath ) = 0 );\n    sMessage = Expand('Invalid\
    \ export directory: %pFilePath%');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\npFilePath = pFilePath | sOSDelim;\n\n# Validate file name\nIf( pFileName\
    \ @= '' );\n    sBaseFileName = Expand('%cThisProcName%_%pUser%_%pDimension%_%pSubset%_Export');\n\
    \    sExt = '.csv';\n    pFileName = sBaseFileName | '.csv';\nElse;\n    # determine file extension.\
    \ If no file extension entered then use .csv as default\n    If( Scan( '.', pFileName ) = 0 );\n \
    \       sExt = '.csv';\n        sBaseFileName = pFileName;\n    Else;\n        sExt = SubSt( pFileName,\
    \ Scan( '.', pFileName ), Long( pFileName ) );\n        sBaseFileName = SubSt( pFileName, 1, Scan(\
    \ '.', pFileName ) - 1 );\n    EndIf;\n    pFileName = sBaseFileName | sExt;\nEndIf;\ncExportFile\
    \ = pFilePath | pFileName;\n\n# Validate file delimiter & quote character\nIf( pFieldDelim @= '' );\n\
    \    pFieldDelim = ',';\nElse;\n    # If length of pFieldDelim is exactly 3 chars and each of them\
    \ is decimal digit, then the pFieldDelim is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pFieldDelim)\
    \ = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE(\
    \ pFieldDelim, nChar ) >= CODE( '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE( '9', 1 ) );\n     \
    \     nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n\
    \      End;\n    EndIf;\n    If ( nValid<>0 );\n      pFieldDelim=CHAR(StringToNumber( pFieldDelim\
    \ ));\n    Else;\n      pFieldDelim = SubSt( Trim( pFieldDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf(\
    \ pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is exactly 3 chars\
    \ and each of them is decimal digit, then the pQuote is entered as ASCII code\n    nValid = 0;\n \
    \   If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n\
    \        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n\
    \          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n\
    \    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate subset\
    \ file\n\nIf ( FileExists( pSubsetFile ) = 0 );\n    sMessage = Expand('Invalid subset file: %pSubsetFile%');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Initialize output\n\n\
    sTotalOutputRowString = '';\nIF( pWriteOutput <> 0 );\n  sTitleRow = '%pQuote%DIMENSION%pQuote%%pFieldDelim%%pQuote%HAS\
    \ SECURITY%pQuote%%pFieldDelim%%pQuote%SUBSET NAME%pQuote%';\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%IS\
    \ PRIVATE%pQuote%%pFieldDelim%%pQuote%MDX EXPRESSION%pQuote%';\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%KEYWORDS%pQuote%%pFieldDelim%%pQuote%ELEMENTS%pQuote%%pFieldDelim%%pQuote%USERS\
    \ WITH NO ACCESS%pQuote%';\n  sTotalOutputRowString = Expand(sTitleRow);\nENDIF;\nsRow = '';\n\n###\
    \ Assign data source\nIf( nErrors = 0 );\n    DataSourceType ='CHARACTERDELIMITED';\n    DatasourceNameForServer\
    \ = pSubsetFile;\n    DatasourceASCIIDelimiter='@@';\nEndIF;\n\n#Section Metadaten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# MDX statement flag ends on 278\n\nIf ( Subst ( vLine, 1, 3\
    \ ) @= '278' );\n    # parse this MDX for keywords\n    sKeyWordString = '';\n    nKeywordFlag = 0;\n\
    \    sKeywordList = cKeywordList;\n    nKeywordLength = Long ( sKeywordList );\n    While ( nKeywordLength\
    \ > 0 );\n        nDelimiter = Scan ( cKeywordDelimiter, sKeyWordList );\n        If ( nDelimiter\
    \ = 0 );\n            sKeyword = sKeyWordList;\n            sKeyWordList = '';\n        Else;\n  \
    \          nEnd = nDelimiter - 1;\n            sKeyWord = SubSt ( sKeywordList, 1, nEnd );\n     \
    \       sKeyWordList = Subst ( sKeywordList, nEnd + 2, nKeywordLength - nEnd);\n        EndIf;   \
    \ \n\n        If ( Scan( sKeyWord, sMDX ) > 0 );\n            nKeyWordFlag = nKeyWordFlag + 1;\n \
    \           IF( Long( sKeyWordString ) = 0 );\n              sKeyWordString = sKeyWordString | sKeyWord;\n\
    \            ELSE;\n              sKeyWordString = sKeyWordString | pDelim | ' ' | sKeyWord;\n   \
    \         ENDIF;\n            IF( pLogoutput = 1 );\n                sMessage = 'Keyword ' | sKeyWord\
    \ | ' found in ' |sMDX;\n                LogOutput('INFO', Expand( cMsgInfoContent ) );\n        \
    \    ENDIF;\n        EndIf;   \n        nKeywordLength = Long ( sKeywordList );\n    End;\n    IF(\
    \ sKeyWordString @<> '' );\n        sRow = '%pQuote%%pDimension%%pQuote%%pFieldDelim%%pQuote%Y%pQuote%%pFieldDelim%%pQuote%%pSubset%%pQuote%%pFieldDelim%%pQuote%%pUser%%pQuote%';\n\
    \        sRow = sRow|'%pFieldDelim%%pQuote%%sMDX%%pQuote%';\n        sRow = sRow|'%pFieldDelim%%pQuote%%sKeyWordString%%pQuote%';\n\
    \    ENDIF;\n    # end parsing for keywords\n    # if keywords found then see if we can match an element\
    \ in the MDX with one in the dimension\n    # element will be included within [] but there will be\
    \ [dimension][hierarchy][subset][attribute] so could be a false positive\n    sElementString = '';\n\
    \    sUsersString = '';\n    If ( nKeyWordFlag > 0 );\n        sMDXTemp = sMDX;\n        sStarter\
    \ = '[';\n        sEnder = ']';\n        nMDXLength = Long ( sMDXTemp );\n        While ( nMDXLength\
    \ > 0 );\n            nStarter = SCAN ( sStarter, sMDXTemp );\n            If ( nStarter > 0 );\n\
    \                nEnder = SCAN ( sEnder, sMDXTemp );\n                sElement = SubSt ( sMDXTemp,\
    \ nStarter + 1, nEnder - nStarter -1);\n                nToGo = nMDXLength - nEnder + 1;\n       \
    \         sMDXTemp = Subst ( sMDXTemp, nEnder + 1, nToGo );\n                # check if that is actually\
    \ an element\n                If ( DimIx ( pDimension, sElement ) > 0 );\n                    IF(\
    \ Scan( sElement, sElementString ) = 0 );\n                        IF( sElementString @= '' );\n \
    \                           sElementString = sElementString | sElement;\n                        ELSE;\n\
    \                            sElementString = sElementString | pDelim | ' ' | sElement;\n        \
    \                ENDIF;\n                    ENDIF;\n                    IF( pLogoutput = 1 );\n \
    \                       sMessage = sElement | ' is referenced in the MDX and exists in the dimension';\n\
    \                        LogOutput('INFO', Expand( cMsgInfoContent ) );\n                    ENDIF;\n\
    \                    # now need to loop through relevant groups to see access\n                  \
    \  # loop through all groups to check access to this element\n                    nUserCheck = 0;\n\
    \                    iGroup = 1;\n                    While ( iGroup <= nGroupMax );\n           \
    \             sGroup = DimNm ( cGroupDim, iGroup );\n                        #skip the admin groups!\n\
    \                        If ( sGroup @<> 'ADMIN' & sGroup @<> 'SecurityAdmin' & sGroup @<> 'DataAdmin'\
    \ & sGroup @<> 'OperationsAdmin' );\n                            nCheck = 1;\n                   \
    \         # if we have a user check membership and we don;t need to continue if not in that group\n\
    \                            If ( CellGetS ( cSecCube, pUser, sGroup ) @= '' );\n                \
    \                nCheck = 0;\n                            EndIf;    \n                           \
    \ If ( nCheck = 1 );\n                                # get the groups security assignment\n     \
    \                           sAccess = CellGetS ( cEleSecCube, sElement, sGroup );\n              \
    \                  # if the user has rights to that element then all is good and we can quit the loops\n\
    \                                If ( sAccess @<> '' & sAccess @<> 'NONE' );\n                   \
    \                 nUserCheck = 1;\n                                    iGroup = nGroupMax + 1;\n \
    \                               EndIf;\n                            EndIf;\n                     \
    \   Else;\n                            # if the user is in an admin group them they will have access\n\
    \                            If ( CellGetS ( cSecCube, pUser, sGroup ) @<> '' );\n               \
    \                 nUserCheck = 1;\n                            EndIf;       \n                   \
    \     EndIf;    \n                        iGroup = iGroup + 1;\n                    End;    \n   \
    \                 If ( nUserCheck = 0 );\n                        sAlias = AttrS ( cUserDim, pUser,\
    \ cUserAlias );\n                        If ( sAlias @= '' );\n                            sAlias\
    \ = pUser;\n                        EndIf;\n                        IF( Scan( sAlias, sUsersString\
    \ ) = 0 );\n                            IF( sUsersString @= '' );\n                              sUsersString\
    \ = sUsersString | sAlias;\n                            ELSE;\n                              sUsersString\
    \ = sUsersString | pDelim | ' ' | sAlias;\n                            ENDIF;\n                  \
    \      ENDIF;\n                        IF( pLogoutput = 1 );\n                            sMessage\
    \ = Expand('Private subset %pSubset% contains a keyword and a specific element %sElement% that the\
    \ user %sAlias% do not have access to');\n                            LogOutput('INFO', Expand( cMsgInfoContent\
    \ ) );\n                        ENDIF;\n                    EndIf;\n                EndIf;\n     \
    \           nMDXLength = Long ( sMDXTemp );\n            Else;\n                nMDXLength = 0;\n\
    \            EndIf;    \n        End;  \n    sRow = sRow|'%pFieldDelim%%pQuote%%sElementString%%pQuote%%pFieldDelim%%pQuote%%sUsersString%%pQuote%';\n\
    \    EndIf;\n    nMDXFlag = 0;\n    IF( sTotalOutputRowString @= '' );\n        sTotalOutputRowString\
    \ = Expand(sRow);\n    ELSE;\n        sTotalOutputRowString = sTotalOutputRowString | sCRLF | Expand(sRow);\n\
    \    ENDIF;\nEndIf;\n\nIf ( nMDXFlag = 1 );\n    sMDX = UPPER ( sMDX | vLine ); \nEndIf;    \n\n#\
    \ MDX statement flag starts on 275\n\nIf ( Subst ( vLine, 1, 3 ) @= '275' );\n    nMDXFlag = 1;\n\
    EndIf;\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Write Output data\nIf( nErrors = 0 );\n  IF( pWriteOutput <> 0 );\n      DatasourceAsciiQuoteCharacter\
    \ = '';\n      TextOutput( cExportFile, Expand(sTotalOutputRowString) );\n  ELSE;\n      IF( sGlobPrivateSubsetsTotalString\
    \ @= '' );\n          sGlobPrivateSubsetsTotalString = sTotalOutputRowString;\n      ELSE;\n     \
    \     IF( sTotalOutputRowString @<> '' );\n              sGlobPrivateSubsetsTotalString = sGlobPrivateSubsetsTotalString\
    \ | sCRLF | sTotalOutputRowString;\n          ENDIF;\n      ENDIF;\n  ENDIF;\nENDIF;\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully executed.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Develop an IBM Turbo Integrator process that aims to identify private dynamic subsets of dimensions
    with element security restrictions. The process should evaluate expressions affected by the latest
    MDX security changes and be suitable for both development and production environments.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will find out PRIVATE dynamic subsets of dimensions\
    \ having security on them - element security - and evaluate expressions impacted by the latest MDX\
    \ security changes \n# Use case: Intended for development or production.\n#EndRegion @DOC\n\n##Global\
    \ Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    StringGlobalVariable('sGlobPrivateSubsetsTotalString');\nnProcessReturnCode= 0;\n\n### Constants ###\n\
    cThisProcName       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\n\
    cRandomInt          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pUser:%pUser%, pDimension:%pDimension%,\
    \ pSubset:%pSubset%, pSubsetFile:%pSubsetFile%, pFilePath:%pFilePath%, pFileName:%pFileName%, pDelim:%pDelim%,\
    \ pQuote:%pQuote%.' ;  \ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\n\
    cSecurityPrefix = '}ElementSecurity_';\ncDimDim = '}Dimensions';\ncUserDim = '}Clients';\ncUserAttrDim=\
    \ '}ElementAttributes_}Clients';\ncUserAlias = '}TM1_DefaultDisplayValue';\ncSubsetPrefix = '}Subsets_';\n\
    cGroupDim = '}Groups';\ncSecCube = '}ClientGroups';\nnGroupMax = DimSiz ( cGroupDim );\nnUserMax =\
    \ DimSiz ( cUserDim );\ncEleSecCube = cSecurityPrefix | pDimension;\n\npFieldDelim       = TRIM(pDelim);\n\
    sCRLF             = Char( 13 ) | Char( 10 );\ncLenASCIICode     = 3;\nnDataCount        = 0;\nnErrors\
    \           = 0;\n\n#reset flag and string\nnMDXFlag = 0;\nsMDX = '';\nsTotalRowString = '';\n\n#keywords\
    \ to look out for in an MDX expression\ncKeyWordList = 'DRILLDOWN&.Children&FirstChild&Ancestors&Ascendants&Cousin&DrillUp&FirstSibling&IsAncestor&FirstSibling&LastChild&LastSibling&Descendants';\n\
    cKeyWordList = UPPER ( cKeyWordList );\ncKeyWordDelimiter = '&';\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n\
    # Validate user\nIF( DimIx( cUserDim,  pUser) = 0 );\n    sMessage = Expand('Invalid user: %pUser%');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nENDIF;\n\
    \n# Validate dimension\nIF( DimIx( cDimDim,  pDimension) = 0 );\n    sMessage = Expand('Invalid dimension:\
    \ %pDimension%');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nENDIF;\n\n# Validate subset name\nIF( pSubset @= '' % Scan( pSubset, pSubsetFile ) = 0  );\n\
    \    sMessage = Expand('Invalid subset name: %pSubset%');\n    nErrors = nErrors + 1;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nENDIF;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n# Validate file path\nIf(Trim( pFilePath ) @= '' );\n    pFilePath = GetProcessErrorFileDirectory;\n\
    EndIf;\nIf( SubSt( pFilePath, Long( pFilePath ), 1 ) @= sOSDelim );\n    pFilePath = SubSt( pFilePath,\
    \ 1, Long( pFilePath ) -1 );\nEndIf;\nIf(  FileExists( pFilePath ) = 0 );\n    sMessage = Expand('Invalid\
    \ export directory: %pFilePath%');\n    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\npFilePath = pFilePath | sOSDelim;\n\n# Validate file name\nIf( pFileName\
    \ @= '' );\n    sBaseFileName = Expand('%cThisProcName%_%pUser%_%pDimension%_%pSubset%_Export');\n\
    \    sExt = '.csv';\n    pFileName = sBaseFileName | '.csv';\nElse;\n    # determine file extension.\
    \ If no file extension entered then use .csv as default\n    If( Scan( '.', pFileName ) = 0 );\n \
    \       sExt = '.csv';\n        sBaseFileName = pFileName;\n    Else;\n        sExt = SubSt( pFileName,\
    \ Scan( '.', pFileName ), Long( pFileName ) );\n        sBaseFileName = SubSt( pFileName, 1, Scan(\
    \ '.', pFileName ) - 1 );\n    EndIf;\n    pFileName = sBaseFileName | sExt;\nEndIf;\ncExportFile\
    \ = pFilePath | pFileName;\n\n# Validate file delimiter & quote character\nIf( pFieldDelim @= '' );\n\
    \    pFieldDelim = ',';\nElse;\n    # If length of pFieldDelim is exactly 3 chars and each of them\
    \ is decimal digit, then the pFieldDelim is entered as ASCII code\n    nValid = 0;\n    If ( LONG(pFieldDelim)\
    \ = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n        If( CODE(\
    \ pFieldDelim, nChar ) >= CODE( '0', 1 ) & CODE( pFieldDelim, nChar ) <= CODE( '9', 1 ) );\n     \
    \     nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar + 1;\n\
    \      End;\n    EndIf;\n    If ( nValid<>0 );\n      pFieldDelim=CHAR(StringToNumber( pFieldDelim\
    \ ));\n    Else;\n      pFieldDelim = SubSt( Trim( pFieldDelim ), 1, 1 );\n    EndIf;\nEndIf;\nIf(\
    \ pQuote @= '' );\n    ## Use no quote character \nElse;\n    # If length of pQuote is exactly 3 chars\
    \ and each of them is decimal digit, then the pQuote is entered as ASCII code\n    nValid = 0;\n \
    \   If ( LONG(pQuote) = cLenASCIICode );\n      nChar = 1;\n      While ( nChar <= cLenASCIICode );\n\
    \        If( CODE( pQuote, nChar ) >= CODE( '0', 1 ) & CODE( pQuote, nChar ) <= CODE( '9', 1 ) );\n\
    \          nValid = 1;\n        Else;\n          nValid = 0;\n        EndIf;\n        nChar = nChar\
    \ + 1;\n      End;\n    EndIf;\n    If ( nValid<>0 );\n      pQuote=CHAR(StringToNumber( pQuote ));\n\
    \    Else;\n      pQuote = SubSt( Trim( pQuote ), 1, 1 );\n    EndIf;\nEndIf;\n\n# Validate subset\
    \ file\n\nIf ( FileExists( pSubsetFile ) = 0 );\n    sMessage = Expand('Invalid subset file: %pSubsetFile%');\n\
    \    nErrors = nErrors + 1;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Initialize output\n\n\
    sTotalOutputRowString = '';\nIF( pWriteOutput <> 0 );\n  sTitleRow = '%pQuote%DIMENSION%pQuote%%pFieldDelim%%pQuote%HAS\
    \ SECURITY%pQuote%%pFieldDelim%%pQuote%SUBSET NAME%pQuote%';\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%IS\
    \ PRIVATE%pQuote%%pFieldDelim%%pQuote%MDX EXPRESSION%pQuote%';\n  sTitleRow = sTitleRow|'%pFieldDelim%%pQuote%KEYWORDS%pQuote%%pFieldDelim%%pQuote%ELEMENTS%pQuote%%pFieldDelim%%pQuote%USERS\
    \ WITH NO ACCESS%pQuote%';\n  sTotalOutputRowString = Expand(sTitleRow);\nENDIF;\nsRow = '';\n\n###\
    \ Assign data source\nIf( nErrors = 0 );\n    DataSourceType ='CHARACTERDELIMITED';\n    DatasourceNameForServer\
    \ = pSubsetFile;\n    DatasourceASCIIDelimiter='@@';\nEndIF;\n\n#Section Metadaten\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n# MDX statement flag ends on 278\n\nIf ( Subst ( vLine, 1, 3\
    \ ) @= '278' );\n    # parse this MDX for keywords\n    sKeyWordString = '';\n    nKeywordFlag = 0;\n\
    \    sKeywordList = cKeywordList;\n    nKeywordLength = Long ( sKeywordList );\n    While ( nKeywordLength\
    \ > 0 );\n        nDelimiter = Scan ( cKeywordDelimiter, sKeyWordList );\n        If ( nDelimiter\
    \ = 0 );\n            sKeyword = sKeyWordList;\n            sKeyWordList = '';\n        Else;\n  \
    \          nEnd = nDelimiter - 1;\n            sKeyWord = SubSt ( sKeywordList, 1, nEnd );\n     \
    \       sKeyWordList = Subst ( sKeywordList, nEnd + 2, nKeywordLength - nEnd);\n        EndIf;   \
    \ \n\n        If ( Scan( sKeyWord, sMDX ) > 0 );\n            nKeyWordFlag = nKeyWordFlag + 1;\n \
    \           IF( Long( sKeyWordString ) = 0 );\n              sKeyWordString = sKeyWordString | sKeyWord;\n\
    \            ELSE;\n              sKeyWordString = sKeyWordString | pDelim | ' ' | sKeyWord;\n   \
    \         ENDIF;\n            IF( pLogoutput = 1 );\n                sMessage = 'Keyword ' | sKeyWord\
    \ | ' found in ' |sMDX;\n                LogOutput('INFO', Expand( cMsgInfoContent ) );\n        \
    \    ENDIF;\n        EndIf;   \n        nKeywordLength = Long ( sKeywordList );\n    End;\n    IF(\
    \ sKeyWordString @<> '' );\n        sRow = '%pQuote%%pDimension%%pQuote%%pFieldDelim%%pQuote%Y%pQuote%%pFieldDelim%%pQuote%%pSubset%%pQuote%%pFieldDelim%%pQuote%%pUser%%pQuote%';\n\
    \        sRow = sRow|'%pFieldDelim%%pQuote%%sMDX%%pQuote%';\n        sRow = sRow|'%pFieldDelim%%pQuote%%sKeyWordString%%pQuote%';\n\
    \    ENDIF;\n    # end parsing for keywords\n    # if keywords found then see if we can match an element\
    \ in the MDX with one in the dimension\n    # element will be included within [] but there will be\
    \ [dimension][hierarchy][subset][attribute] so could be a false positive\n    sElementString = '';\n\
    \    sUsersString = '';\n    If ( nKeyWordFlag > 0 );\n        sMDXTemp = sMDX;\n        sStarter\
    \ = '[';\n        sEnder = ']';\n        nMDXLength = Long ( sMDXTemp );\n        While ( nMDXLength\
    \ > 0 );\n            nStarter = SCAN ( sStarter, sMDXTemp );\n            If ( nStarter > 0 );\n\
    \                nEnder = SCAN ( sEnder, sMDXTemp );\n                sElement = SubSt ( sMDXTemp,\
    \ nStarter + 1, nEnder - nStarter -1);\n                nToGo = nMDXLength - nEnder + 1;\n       \
    \         sMDXTemp = Subst ( sMDXTemp, nEnder + 1, nToGo );\n                # check if that is actually\
    \ an element\n                If ( DimIx ( pDimension, sElement ) > 0 );\n                    IF(\
    \ Scan( sElement, sElementString ) = 0 );\n                        IF( sElementString @= '' );\n \
    \                           sElementString = sElementString | sElement;\n                        ELSE;\n\
    \                            sElementString = sElementString | pDelim | ' ' | sElement;\n        \
    \                ENDIF;\n                    ENDIF;\n                    IF( pLogoutput = 1 );\n \
    \                       sMessage = sElement | ' is referenced in the MDX and exists in the dimension';\n\
    \                        LogOutput('INFO', Expand( cMsgInfoContent ) );\n                    ENDIF;\n\
    \                    # now need to loop through relevant groups to see access\n                  \
    \  # loop through all groups to check access to this element\n                    nUserCheck = 0;\n\
    \                    iGroup = 1;\n                    While ( iGroup <= nGroupMax );\n           \
    \             sGroup = DimNm ( cGroupDim, iGroup );\n                        #skip the admin groups!\n\
    \                        If ( sGroup @<> 'ADMIN' & sGroup @<> 'SecurityAdmin' & sGroup @<> 'DataAdmin'\
    \ & sGroup @<> 'OperationsAdmin' );\n                            nCheck = 1;\n                   \
    \         # if we have a user check membership and we don;t need to continue if not in that group\n\
    \                            If ( CellGetS ( cSecCube, pUser, sGroup ) @= '' );\n                \
    \                nCheck = 0;\n                            EndIf;    \n                           \
    \ If ( nCheck = 1 );\n                                # get the groups security assignment\n     \
    \                           sAccess = CellGetS ( cEleSecCube, sElement, sGroup );\n              \
    \                  # if the user has rights to that element then all is good and we can quit the loops\n\
    \                                If ( sAccess @<> '' & sAccess @<> 'NONE' );\n                   \
    \                 nUserCheck = 1;\n                                    iGroup = nGroupMax + 1;\n \
    \                               EndIf;\n                            EndIf;\n                     \
    \   Else;\n                            # if the user is in an admin group them they will have access\n\
    \                            If ( CellGetS ( cSecCube, pUser, sGroup ) @<> '' );\n               \
    \                 nUserCheck = 1;\n                            EndIf;       \n                   \
    \     EndIf;    \n                        iGroup = iGroup + 1;\n                    End;    \n   \
    \                 If ( nUserCheck = 0 );\n                        sAlias = AttrS ( cUserDim, pUser,\
    \ cUserAlias );\n                        If ( sAlias @= '' );\n                            sAlias\
    \ = pUser;\n                        EndIf;\n                        IF( Scan( sAlias, sUsersString\
    \ ) = 0 );\n                            IF( sUsersString @= '' );\n                              sUsersString\
    \ = sUsersString | sAlias;\n                            ELSE;\n                              sUsersString\
    \ = sUsersString | pDelim | ' ' | sAlias;\n                            ENDIF;\n                  \
    \      ENDIF;\n                        IF( pLogoutput = 1 );\n                            sMessage\
    \ = Expand('Private subset %pSubset% contains a keyword and a specific element %sElement% that the\
    \ user %sAlias% do not have access to');\n                            LogOutput('INFO', Expand( cMsgInfoContent\
    \ ) );\n                        ENDIF;\n                    EndIf;\n                EndIf;\n     \
    \           nMDXLength = Long ( sMDXTemp );\n            Else;\n                nMDXLength = 0;\n\
    \            EndIf;    \n        End;  \n    sRow = sRow|'%pFieldDelim%%pQuote%%sElementString%%pQuote%%pFieldDelim%%pQuote%%sUsersString%%pQuote%';\n\
    \    EndIf;\n    nMDXFlag = 0;\n    IF( sTotalOutputRowString @= '' );\n        sTotalOutputRowString\
    \ = Expand(sRow);\n    ELSE;\n        sTotalOutputRowString = sTotalOutputRowString | sCRLF | Expand(sRow);\n\
    \    ENDIF;\nEndIf;\n\nIf ( nMDXFlag = 1 );\n    sMDX = UPPER ( sMDX | vLine ); \nEndIf;    \n\n#\
    \ MDX statement flag starts on 275\n\nIf ( Subst ( vLine, 1, 3 ) @= '275' );\n    nMDXFlag = 1;\n\
    EndIf;\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n### Write Output data\nIf( nErrors = 0 );\n  IF( pWriteOutput <> 0 );\n      DatasourceAsciiQuoteCharacter\
    \ = '';\n      TextOutput( cExportFile, Expand(sTotalOutputRowString) );\n  ELSE;\n      IF( sGlobPrivateSubsetsTotalString\
    \ @= '' );\n          sGlobPrivateSubsetsTotalString = sTotalOutputRowString;\n      ELSE;\n     \
    \     IF( sTotalOutputRowString @<> '' );\n              sGlobPrivateSubsetsTotalString = sGlobPrivateSubsetsTotalString\
    \ | sCRLF | sTotalOutputRowString;\n          ENDIF;\n      ENDIF;\n  ENDIF;\nENDIF;\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully executed.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der dafür sorgt, dass Klientengruppen erstellt
    werden. Beachte dabei, dass eine Gruppe (pGroup) obligatorisch ist, ansonsten wird der Prozess abgebrochen.
    Mehrere Gruppen können mit einem Trennzeichen angegeben werden. Wenn eine Gruppe bereits existiert,
    wird dieser Schritt übersprungen. Der Prozess sollte sowohl für Entwicklungs- als auch Produktionszwecke
    geeignet sein. In Schritt 1 werden anfängliche Sicherheitsgruppen erstellt, und in Schritt 2 kannst
    du weitere Sicherheitsgruppen hinzufügen, wenn sich die geschäftlichen Anforderungen ändern.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create client groups.\n\n# Use case: Intended\
    \ for development or production.\n# 1/ Create initial security groups.\n# 2/ Add security groups as\
    \ business needs change.\n\n# Note:\n# Naturally, a group (pGroup) is mandatory otherwise the process\
    \ will abort.\n# - Multiple groups can be specified separated by a delimiter.\n# - If group already\
    \ exists then the process will skip that group.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pGroup:%pGroup%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n    pDelim          = '&';\nEndIf;\n\n# If no groups\
    \ have been specified then terminate process\nIf( Trim( pGroup ) @= '' );\n    nErrors         = 1;\n\
    \    sMessage        = 'No groups specified';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Alias\nIf( pAlias\
    \ @<> '' );\n    If( DimensionExists( '}ElementAttributes_}Groups' ) = 0 );\n        AttrInsert( '}Groups',\
    \ '', '}TM1_DefaultDisplayValue', 'A' );\n    ElseIf( DimIx( '}ElementAttributes_}Groups', '}TM1_DefaultDisplayValue'\
    \ ) = 0 );\n        AttrInsert( '}Groups', '', '}TM1_DefaultDisplayValue', 'A' );\n    EndIf;\nEndIf;\n\
    \n### Split pGroups into individual groups and add ###\nsGroups = pGroup;\nnDelimiterIndex = 1;\n\
    While( nDelimiterIndex <> 0 );\n    nDelimiterIndex = Scan( pDelim, sGroups );\n    If( nDelimiterIndex\
    \ = 0 );\n        sGroup = sGroups;\n    Else;\n        sGroup = Trim( SubSt( sGroups, 1, nDelimiterIndex\
    \ - 1 ) );\n        sGroups = Trim( Subst( sGroups, nDelimiterIndex + Long(pDelim), Long( sGroups\
    \ ) ) );\n    EndIf;\n    # Don't attempt to add a blank group\n    If( sGroup @<> '' );\n       \
    \ If( DimIx( '}Groups', sGroup ) = 0 );\n            AddGroup( sGroup );\n        Else;\n        \
    \    #Skip group\n        EndIf;\n    EndIf;\nEnd;\n\nIf( nErrors = 0 );\n  DimensionSortOrder( '}Groups',\
    \ 'ByName', 'Ascending', 'ByName' , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Update Alias\n\nIf( nErrors = 0 );\n\n\
    \  sAliases  = pAlias;\n  sGroups   = pGroup;\n  nDelimiterIndex = 1;\n\n  While( nDelimiterIndex\
    \ > 0 );\n    nDelimiterIndex = Scan( pDelim, sAliases );\n    If( nDelimiterIndex = 0 );\n      sAlias\
    \    = sAliases;\n    Else;\n      sAlias    = Trim( SubSt( sAliases, 1, nDelimiterIndex - 1 ) );\n\
    \      sAliases  = Trim( Subst( sAliases, nDelimiterIndex + Long(pDelim), Long( sAliases ) ) );\n\
    \    EndIf;\n    nDelimiterIndex = Scan( pDelim, sGroups );\n    If( nDelimiterIndex = 0 );\n    \
    \  sGroup   = sGroups;\n    Else;\n      sGroup   = Trim( SubSt( sGroups, 1, nDelimiterIndex - 1 )\
    \ );\n      sGroups  = Trim( Subst( sGroups, nDelimiterIndex + Long(pDelim), Long( sGroups ) ) );\n\
    \    EndIf;\n    \n    If( DimIx( '}Groups', sGroup ) > 0 );\n      If( sAlias @<> '' );\n       \
    \ AttrPutS( sAlias, '}Groups', sGroup, '}TM1_DefaultDisplayValue', 1 );\n      EndIf;\n    EndIf;\n\
    \  End;\n\nEndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully created Group %pGroup% .' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that ensures client groups are created. Keep in mind
    that a group (pGroup) is mandatory, and the process will abort if it isn't specified. Multiple groups
    can be indicated by separating them with a delimiter. If a group already exists, the process will
    skip it. The process should be suitable for both development and production purposes. In step 1, create
    initial security groups, and in step 2, add additional security groups as business needs evolve.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will create client groups.\n\n# Use case: Intended\
    \ for development or production.\n# 1/ Create initial security groups.\n# 2/ Add security groups as\
    \ business needs change.\n\n# Note:\n# Naturally, a group (pGroup) is mandatory otherwise the process\
    \ will abort.\n# - Multiple groups can be specified separated by a delimiter.\n# - If group already\
    \ exists then the process will skip that group.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pGroup:%pGroup%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n    pDelim          = '&';\nEndIf;\n\n# If no groups\
    \ have been specified then terminate process\nIf( Trim( pGroup ) @= '' );\n    nErrors         = 1;\n\
    \    sMessage        = 'No groups specified';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Alias\nIf( pAlias\
    \ @<> '' );\n    If( DimensionExists( '}ElementAttributes_}Groups' ) = 0 );\n        AttrInsert( '}Groups',\
    \ '', '}TM1_DefaultDisplayValue', 'A' );\n    ElseIf( DimIx( '}ElementAttributes_}Groups', '}TM1_DefaultDisplayValue'\
    \ ) = 0 );\n        AttrInsert( '}Groups', '', '}TM1_DefaultDisplayValue', 'A' );\n    EndIf;\nEndIf;\n\
    \n### Split pGroups into individual groups and add ###\nsGroups = pGroup;\nnDelimiterIndex = 1;\n\
    While( nDelimiterIndex <> 0 );\n    nDelimiterIndex = Scan( pDelim, sGroups );\n    If( nDelimiterIndex\
    \ = 0 );\n        sGroup = sGroups;\n    Else;\n        sGroup = Trim( SubSt( sGroups, 1, nDelimiterIndex\
    \ - 1 ) );\n        sGroups = Trim( Subst( sGroups, nDelimiterIndex + Long(pDelim), Long( sGroups\
    \ ) ) );\n    EndIf;\n    # Don't attempt to add a blank group\n    If( sGroup @<> '' );\n       \
    \ If( DimIx( '}Groups', sGroup ) = 0 );\n            AddGroup( sGroup );\n        Else;\n        \
    \    #Skip group\n        EndIf;\n    EndIf;\nEnd;\n\nIf( nErrors = 0 );\n  DimensionSortOrder( '}Groups',\
    \ 'ByName', 'Ascending', 'ByName' , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Update Alias\n\nIf( nErrors = 0 );\n\n\
    \  sAliases  = pAlias;\n  sGroups   = pGroup;\n  nDelimiterIndex = 1;\n\n  While( nDelimiterIndex\
    \ > 0 );\n    nDelimiterIndex = Scan( pDelim, sAliases );\n    If( nDelimiterIndex = 0 );\n      sAlias\
    \    = sAliases;\n    Else;\n      sAlias    = Trim( SubSt( sAliases, 1, nDelimiterIndex - 1 ) );\n\
    \      sAliases  = Trim( Subst( sAliases, nDelimiterIndex + Long(pDelim), Long( sAliases ) ) );\n\
    \    EndIf;\n    nDelimiterIndex = Scan( pDelim, sGroups );\n    If( nDelimiterIndex = 0 );\n    \
    \  sGroup   = sGroups;\n    Else;\n      sGroup   = Trim( SubSt( sGroups, 1, nDelimiterIndex - 1 )\
    \ );\n      sGroups  = Trim( Subst( sGroups, nDelimiterIndex + Long(pDelim), Long( sGroups ) ) );\n\
    \    EndIf;\n    \n    If( DimIx( '}Groups', sGroup ) > 0 );\n      If( sAlias @<> '' );\n       \
    \ AttrPutS( sAlias, '}Groups', sGroup, '}TM1_DefaultDisplayValue', 1 );\n      EndIf;\n    EndIf;\n\
    \  End;\n\nEndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully created Group %pGroup% .' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Erstelle einen IBM Turbo Integrator Prozess, der dazu dient, Client-Gruppen zu löschen. Dieser
    Prozess ist sowohl für Entwicklungs- als auch Produktionsumgebungen gedacht. Die Anwendungsfälle umfassen
    die Bereinigung von Sicherheitsgruppen nach dem Go-Live sowie das Löschen veralteter Sicherheitsgruppen,
    wenn sich die Geschäftsanforderungen ändern. Beachte, dass eine Gruppe (pGroup) zwingend erforderlich
    ist, da der Prozess andernfalls abbricht. Mehrere Gruppen können durch ein Trennzeichen angegeben
    werden. Falls eine Gruppe nicht existiert, wird sie übersprungen. Wenn mehrere Gruppen angegeben werden
    und einige nicht existieren, werden die Gruppen, die existieren, trotzdem gelöscht.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete client groups.\n\n# Use case: Intended\
    \ for development or production.\n# 1/ Clean up security groups after go live.\n# 2/ Delete obsolete\
    \ security groups as business needs change.\n\n# Note:\n# Naturally, a group (pGroup) is mandatory\
    \ otherwise the process will abort:\n# - Multiple groups can be specified separated by a delimiter.\n\
    # - If group does not exist then it will be skipped.\n# - If multiple groups are specified and some\
    \ don't exist and some do, then the ones that do exist will still be deleted.\n#EndRegion @DOC\n\n\
    ##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName           = GetProcessName();\ncTimeStamp\
    \              = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt              = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub                = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\n\
    cTempFile               = GetProcessErrorFileDirectory | cTempSub | '.csv';\ncGroupDim           \
    \    = '}Groups';\ncGroupHier              = cGroupDim;\ncUserName               = TM1User();\ncMsgErrorLevel\
    \          = 'ERROR';\ncMsgErrorContent        = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo                = 'Process:%cThisProcName% run with parameters pGroup:%pGroup%, pDelim:%pDelim%.';\n\
    cBuiltInGroups          = 'ADMIN&SecurityAdmin&DataAdmin&OperationsAdmin&';\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n\
    \    pDelim              = '&';\nEndIf;\n\n# If no groups have been specified then terminate process\n\
    If( Trim( pGroup ) @= '' );\n    nErrors             = 1;\n    sMessage            = 'No groups specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before\
    \ continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Check alias exists\nIf( DimensionExists('}ElementAttributes_'|cGroupDim)\
    \ = 0 % DimIx('}ElementAttributes_'|cGroupDim, '}TM1_DefaultDisplayValue') = 0 );\n    AttrInsert(\
    \ cGroupDim, '', '}TM1_DefaultDisplayValue', 'A' );\nEndIf;\n\n### Split pGroups into individual groups\
    \ and delete ###\nsGroups                 = pGroup;\nnDelimiterIndex         = 1;\nWhile( nDelimiterIndex\
    \ <> 0 );\n  nDelimiterIndex = Scan( pDelim, sGroups );\n  If( nDelimiterIndex = 0 );\n        sGroup\
    \          = sGroups;\n  Else;\n        sGroup          = Trim( SubSt( sGroups, 1, nDelimiterIndex\
    \ - 1 ) );\n        sGroups         = Trim( Subst( sGroups, nDelimiterIndex + Long(pDelim), Long(\
    \ sGroups ) ) );\n  EndIf;\n  \n  If( Scan( '*', sGroup ) = 0);\n    # Don't attempt to delete a blank\
    \ group\n    If( sGroup @<> '' );\n        If( DimIx( '}Groups', sGroup ) > 0 );\n            If(\
    \ nErrors = 0 );\n                If( Scan( Upper( sGroup ) |'&', Upper( cBuiltInGroups ) ) = 0 );\n\
    \                    DeleteGroup( sGroup );\n                Else;\n                    nErrors =\
    \ 1;\n                    sMessage= Expand('Attempt to delete built-in group %sGroup%.');\n      \
    \              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                EndIf;\n\
    \            EndIf;\n            If( nErrors > 0 );\n                ItemReject( Expand( cMsgErrorContent\
    \ ) );\n            EndIf;\n        EndIf;\n    EndIf;\n  Else;\n    # Wildcard search string\n  \
    \  iCount = 0;\n    iCheck = 1;\n    sChar = sGroup;\n    While (iCheck > 0);\n      iCheck = Scan('*',sChar);\n\
    \      If( iCheck > 0 );\n        iCount = iCount + 1;\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n\
    \      Endif;\n    End;\n    If(iCount = 1);\n      ##If the wilcardsearch is *String, below code\
    \ will get executed\n      if(Subst(sGroup,iCount,1) @= '*');\n        sGroup1 = '''| Subst(sGroup,iCount+1,(Long(sGroup)-\
    \ iCount))|''';\n        sTempCount = NumbertoString(Long(sGroup)-iCount);\n        sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \                (Right( ['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|')\
    \ ='|sGroup1|'))}+\n                {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n  \
    \              (Right( ['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'| sTempCount|') ='|sGroup1|'))}';\n\
    \        If( SubsetExists( cGroupDim, cTempSub ) = 1 );\n            # If a delimited list of Groups\
    \ includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ cGroupDim, cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cGroupDim, 1 );\n        EndIf;\n\n  \
    \      nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim, cGroupHier, cTempSub);\n        nCount =\
    \ nHier_Sub_Size;\n        While (nCount >= 1);\n          nSubsetIndex = 1;\n          sTemp = HierarchySubsetElementGetIndex\
    \ (cGroupDim, cGroupHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cGroupDim,\
    \ cGroupHier, cTempSub, nCount);\n          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups\
    \ ) ) = 0 );\n            DeleteGroup( sElement );\n          Else;\n            sMessage= 'Attempt\
    \ to delete built-in group %sGroup%.';\n            LogOutput( 'WARN', Expand( cMsgErrorContent )\
    \ );\n          EndIF;\n          nCount = nCount -1;\n        End;\n        ##If the wilcardsearch\
    \ is String*, below code will get executed\n        ElseIf(Subst(sGroup,Long(sGroup),1) @= '*');\n\
    \        sGroup1 = '''| Subst(sGroup,iCount,(Long(sGroup)- iCount))|''';\n        sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'|sGroup1|')\
    \ ='| NumbertoString(iCount)|'))}+\n                {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'|sGroup1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cGroupDim, cTempSub ) = 1 );\n    \
    \        # If a delimited list of Groups includes wildcards then we may have to re-use the subset\
    \ multiple times\n            SubsetMDXSet( cGroupDim, cTempSub, sMDX );\n        Else;\n        \
    \    # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub,\
    \ sMDX, cGroupDim, 1 );\n        EndIf;\n\n        nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim,\
    \ cGroupHier, cTempSub);\n        nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n       \
    \   sTemp = HierarchySubsetElementGetIndex (cGroupDim, cGroupHier, cTempSub, '', 1);\n          sElement\
    \ = HierarchySubsetGetElementName(cGroupDim, cGroupHier, cTempSub, nCount);\n          If( Scan( Upper(\
    \ sElement ) |'&', Upper( cBuiltInGroups ) ) = 0 );\n            DeleteGroup( sElement );\n      \
    \    Else;\n            sMessage= 'Attempt to delete built-in group %sGroup%.';\n            LogOutput(\
    \ 'WARN', Expand( cMsgErrorContent ) );\n          EndIF;\n          nCount = nCount -1;\n       \
    \ End;\n      Endif;\n    Else;\n      ##If the wilcardsearch is *String*, below code will get executed\n\
    \      sGroup1 = '''| Subst(sGroup,iCount,(Long(sGroup)- iCount))|''';\n      sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \              (INSTR(1,['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'|sGroup1|') <>\
    \ 0))}+\n              {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n              (INSTR(1,['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'|sGroup1|')\
    \ <> 0))}';\n      If( SubsetExists( cGroupDim, cTempSub ) = 1 );\n            # If a delimited list\
    \ of Groups includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ cGroupDim, cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cGroupDim, 1 );\n        EndIf;\n\n  \
    \    nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim, cGroupHier, cTempSub);\n      nCount = nHier_Sub_Size;\n\
    \      While (nCount >= 1);\n        sTemp = HierarchySubsetElementGetIndex (cGroupDim, cGroupHier,\
    \ cTempSub, '', 1);\n        sElement = HierarchySubsetGetElementName(cGroupDim, cGroupHier, cTempSub,\
    \ nCount);\n          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups ) ) = 0 );\n       \
    \     DeleteGroup( sElement );\n          Else;\n            sMessage= 'Attempt to delete built-in\
    \ group %sGroup%.';\n            LogOutput( 'WARN', Expand( cMsgErrorContent ) );\n          EndIF;\n\
    \        nCount = nCount -1;\n      End;\n    Endif;\n  EndIf;\nEnd;\n\nIf( nErrors = 0 );\n  DimensionSortOrder(\
    \ '}Groups', 'ByName', 'Ascending', 'ByName' , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted group %pGroup% from dimension %cGroupDim%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: Develop an IBM Turbo Integrator process designed to delete client groups. This process is
    intended for both development and production environments. Use cases include cleaning up security
    groups after go-live and deleting obsolete security groups as business needs change. Note that a group
    (pGroup) is mandatory; otherwise, the process will abort. Multiple groups can be specified and separated
    by a delimiter. If a group does not exist, it will be skipped. If multiple groups are specified and
    some do not exist, the ones that do exist will still be deleted.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will delete client groups.\n\n# Use case: Intended\
    \ for development or production.\n# 1/ Clean up security groups after go live.\n# 2/ Delete obsolete\
    \ security groups as business needs change.\n\n# Note:\n# Naturally, a group (pGroup) is mandatory\
    \ otherwise the process will abort:\n# - Multiple groups can be specified separated by a delimiter.\n\
    # - If group does not exist then it will be skipped.\n# - If multiple groups are specified and some\
    \ don't exist and some do, then the ones that do exist will still be deleted.\n#EndRegion @DOC\n\n\
    ##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName           = GetProcessName();\ncTimeStamp\
    \              = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt              = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncTempSub                = cThisProcName | '_' | cTimeStamp | '_' | cRandomInt;\n\
    cTempFile               = GetProcessErrorFileDirectory | cTempSub | '.csv';\ncGroupDim           \
    \    = '}Groups';\ncGroupHier              = cGroupDim;\ncUserName               = TM1User();\ncMsgErrorLevel\
    \          = 'ERROR';\ncMsgErrorContent        = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo                = 'Process:%cThisProcName% run with parameters pGroup:%pGroup%, pDelim:%pDelim%.';\n\
    cBuiltInGroups          = 'ADMIN&SecurityAdmin&DataAdmin&OperationsAdmin&';\n\n## LogOutput parameters\n\
    IF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters\
    \ ###\nnErrors = 0;\n# If blank delimiter specified then convert to default\nIf( pDelim @= '' );\n\
    \    pDelim              = '&';\nEndIf;\n\n# If no groups have been specified then terminate process\n\
    If( Trim( pGroup ) @= '' );\n    nErrors             = 1;\n    sMessage            = 'No groups specified.';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before\
    \ continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n# Check alias exists\nIf( DimensionExists('}ElementAttributes_'|cGroupDim)\
    \ = 0 % DimIx('}ElementAttributes_'|cGroupDim, '}TM1_DefaultDisplayValue') = 0 );\n    AttrInsert(\
    \ cGroupDim, '', '}TM1_DefaultDisplayValue', 'A' );\nEndIf;\n\n### Split pGroups into individual groups\
    \ and delete ###\nsGroups                 = pGroup;\nnDelimiterIndex         = 1;\nWhile( nDelimiterIndex\
    \ <> 0 );\n  nDelimiterIndex = Scan( pDelim, sGroups );\n  If( nDelimiterIndex = 0 );\n        sGroup\
    \          = sGroups;\n  Else;\n        sGroup          = Trim( SubSt( sGroups, 1, nDelimiterIndex\
    \ - 1 ) );\n        sGroups         = Trim( Subst( sGroups, nDelimiterIndex + Long(pDelim), Long(\
    \ sGroups ) ) );\n  EndIf;\n  \n  If( Scan( '*', sGroup ) = 0);\n    # Don't attempt to delete a blank\
    \ group\n    If( sGroup @<> '' );\n        If( DimIx( '}Groups', sGroup ) > 0 );\n            If(\
    \ nErrors = 0 );\n                If( Scan( Upper( sGroup ) |'&', Upper( cBuiltInGroups ) ) = 0 );\n\
    \                    DeleteGroup( sGroup );\n                Else;\n                    nErrors =\
    \ 1;\n                    sMessage= Expand('Attempt to delete built-in group %sGroup%.');\n      \
    \              LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n                EndIf;\n\
    \            EndIf;\n            If( nErrors > 0 );\n                ItemReject( Expand( cMsgErrorContent\
    \ ) );\n            EndIf;\n        EndIf;\n    EndIf;\n  Else;\n    # Wildcard search string\n  \
    \  iCount = 0;\n    iCheck = 1;\n    sChar = sGroup;\n    While (iCheck > 0);\n      iCheck = Scan('*',sChar);\n\
    \      If( iCheck > 0 );\n        iCount = iCount + 1;\n        sChar = Subst(sChar,iCheck+1,(long(sChar)-iCheck));\n\
    \      Endif;\n    End;\n    If(iCount = 1);\n      ##If the wilcardsearch is *String, below code\
    \ will get executed\n      if(Subst(sGroup,iCount,1) @= '*');\n        sGroup1 = '''| Subst(sGroup,iCount+1,(Long(sGroup)-\
    \ iCount))|''';\n        sTempCount = NumbertoString(Long(sGroup)-iCount);\n        sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \                (Right( ['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'| sTempCount|')\
    \ ='|sGroup1|'))}+\n                {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n  \
    \              (Right( ['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'| sTempCount|') ='|sGroup1|'))}';\n\
    \        If( SubsetExists( cGroupDim, cTempSub ) = 1 );\n            # If a delimited list of Groups\
    \ includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ cGroupDim, cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cGroupDim, 1 );\n        EndIf;\n\n  \
    \      nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim, cGroupHier, cTempSub);\n        nCount =\
    \ nHier_Sub_Size;\n        While (nCount >= 1);\n          nSubsetIndex = 1;\n          sTemp = HierarchySubsetElementGetIndex\
    \ (cGroupDim, cGroupHier, cTempSub, '', 1);\n          sElement = HierarchySubsetGetElementName(cGroupDim,\
    \ cGroupHier, cTempSub, nCount);\n          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups\
    \ ) ) = 0 );\n            DeleteGroup( sElement );\n          Else;\n            sMessage= 'Attempt\
    \ to delete built-in group %sGroup%.';\n            LogOutput( 'WARN', Expand( cMsgErrorContent )\
    \ );\n          EndIF;\n          nCount = nCount -1;\n        End;\n        ##If the wilcardsearch\
    \ is String*, below code will get executed\n        ElseIf(Subst(sGroup,Long(sGroup),1) @= '*');\n\
    \        sGroup1 = '''| Subst(sGroup,iCount,(Long(sGroup)- iCount))|''';\n        sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'|sGroup1|')\
    \ ='| NumbertoString(iCount)|'))}+\n                {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \                (INSTR('| NumbertoString(iCount)|', ['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'|sGroup1|')\
    \ ='| NumbertoString(iCount)|'))}';\n        If( SubsetExists( cGroupDim, cTempSub ) = 1 );\n    \
    \        # If a delimited list of Groups includes wildcards then we may have to re-use the subset\
    \ multiple times\n            SubsetMDXSet( cGroupDim, cTempSub, sMDX );\n        Else;\n        \
    \    # temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub,\
    \ sMDX, cGroupDim, 1 );\n        EndIf;\n\n        nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim,\
    \ cGroupHier, cTempSub);\n        nCount = nHier_Sub_Size;\n        While (nCount >= 1);\n       \
    \   sTemp = HierarchySubsetElementGetIndex (cGroupDim, cGroupHier, cTempSub, '', 1);\n          sElement\
    \ = HierarchySubsetGetElementName(cGroupDim, cGroupHier, cTempSub, nCount);\n          If( Scan( Upper(\
    \ sElement ) |'&', Upper( cBuiltInGroups ) ) = 0 );\n            DeleteGroup( sElement );\n      \
    \    Else;\n            sMessage= 'Attempt to delete built-in group %sGroup%.';\n            LogOutput(\
    \ 'WARN', Expand( cMsgErrorContent ) );\n          EndIF;\n          nCount = nCount -1;\n       \
    \ End;\n      Endif;\n    Else;\n      ##If the wilcardsearch is *String*, below code will get executed\n\
    \      sGroup1 = '''| Subst(sGroup,iCount,(Long(sGroup)- iCount))|''';\n      sMdx = '{FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n\
    \              (INSTR(1,['|cGroupDim|'].['|cGroupHier|'].[}TM1_DefaultDisplayValue],'|sGroup1|') <>\
    \ 0))}+\n              {FILTER({TM1SUBSETALL(['|cGroupDim|'].['|cGroupHier|'])},\n              (INSTR(1,['|cGroupDim|'].['|cGroupHier|'].CurrentMember.Name,'|sGroup1|')\
    \ <> 0))}';\n      If( SubsetExists( cGroupDim, cTempSub ) = 1 );\n            # If a delimited list\
    \ of Groups includes wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet(\
    \ cGroupDim, cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy\
    \ in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, cGroupDim, 1 );\n        EndIf;\n\n  \
    \    nHier_Sub_Size = HierarchySubsetGetSize(cGroupDim, cGroupHier, cTempSub);\n      nCount = nHier_Sub_Size;\n\
    \      While (nCount >= 1);\n        sTemp = HierarchySubsetElementGetIndex (cGroupDim, cGroupHier,\
    \ cTempSub, '', 1);\n        sElement = HierarchySubsetGetElementName(cGroupDim, cGroupHier, cTempSub,\
    \ nCount);\n          If( Scan( Upper( sElement ) |'&', Upper( cBuiltInGroups ) ) = 0 );\n       \
    \     DeleteGroup( sElement );\n          Else;\n            sMessage= 'Attempt to delete built-in\
    \ group %sGroup%.';\n            LogOutput( 'WARN', Expand( cMsgErrorContent ) );\n          EndIF;\n\
    \        nCount = nCount -1;\n      End;\n    Endif;\n  EndIf;\nEnd;\n\nIf( nErrors = 0 );\n  DimensionSortOrder(\
    \ '}Groups', 'ByName', 'Ascending', 'ByName' , 'Ascending' );\nEndIf;\n\n### End Prolog ###\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final\
    \ error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error.\
    \ Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully deleted group %pGroup% from dimension %cGroupDim%.' );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1\
    \ );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog\
    \ ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der Sicherheitszuweisungen für angegebene Objekte
    an bestimmte Gruppen zuweist. Benutze zwei Parameter, pGroup und pObject, die durch Trennzeichen getrennte
    Listen und Wildcards unterstützen. Der Prozess ist für Entwicklungs- oder Produktionsumgebungen gedacht
    und zwei Hauptanwendungsfälle umfassen die erstmalige Sicherheitszuweisung und die Aktualisierung
    von Sicherheitszuweisungen bei Änderungen der Geschäftsanforderungen. Wichtige Hinweise: Die Parameter
    Gruppe (pGroup), Objekttyp (pObjectType) und Sicherheitsstufe (pSecurityLevel) sind obligatorisch,
    bei ihrer Abwesenheit wird der Prozess abgebrochen. Mehrere Gruppen und Objektnamen können mit Trennzeichen
    angegeben werden, müssen jedoch gültig sein. Vor der Nutzung des Prozesses muss die Objektsicherheit
    initialisiert werden und das Sicherheitsupdate muss im Server Explorer durchgeführt werden. Wenn nicht
    existierende Gruppen oder Objekte angegeben werden, werden diese übersprungen; gültige Gruppen und
    Objekte werden jedoch verarbeitet.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will assign security to specified object(s) for specified\
    \ group(s). Both pGroup \n# and pObject parameters support delimited lists and wildcards.\n\n# Use\
    \ case: Intended for develpment or production.\n# 1. Set up initial security assignments.\n# 2. Update\
    \ security assignments a business needs change.\n\n# Note:\n# Naturally, group (pGroup), object type\
    \ (pObjectType) and security level (pSecurityLevel) are mandatory otherwise the process will abort:\n\
    # - Multiple groups can be specified separated by delimiter.\n# Object names (pObject) can be listed\
    \ with delimiters but need to be valid as well. \n# - Before using this process, you must first initialise\
    \ object security.\n# - For Applications, in Server Explorer go to Applications -> Security Assignments\
    \ and assign an access security for an Application. \n# - For other object types follow a similar\
    \ process but for that object type.\n# - Then from the Server Explorer go to your ServerName -> Security\
    \ -> Refresh Security.\n# - Multiple objects can be specified separated by delimiter.\n# - If groups\
    \ and/or objects that don't exist are specified, then they will be skipped but valid groups and ojects\
    \ will still be processed.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncSecurityCube       = '}' | pObjectType | 'Security';\n\
    cTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncUserName           = TM1User();\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pGroup:%pGroup%, pObjectType:%pObjectType%,\
    \ pObject:%pObject%, pSecurityLevel:%pSecurityLevel%, pSecurityRefresh:%pSecurityRefresh%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n# If no groups have been\
    \ specified then terminate process\nIf( Trim( pGroup ) @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'No groups specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate Object Type\nIf( pObjectType @<> 'Application' & pObjectType @<> 'Cube' & pObjectType\
    \ @<> 'Dimension' & pObjectType @<> 'Process' & pObjectType @<> 'Chore' );\n    nErrors         =\
    \ 1;\n    sMessage        = 'Invalid object type specified: ' | pObjectType | '. Valid object types\
    \ are: Application, Cube, Dimension, Process and Chore';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If no objects have been specified then terminate process\nIf( Trim( pObject )\
    \ @= '' );\n    nErrors         = 1;\n    sMessage        = 'No objects specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate that object type has object\
    \ security enabled\nIf( CubeExists( cSecurityCube ) = 0 );\n    sObjectTypePlural = pObjectType;\n\
    \    If( pObjectType @= 'Process');\n        sObjectTypePlural = sObjectTypePlural | 'es';\n    Else;\n\
    \        sObjectTypePlural = sObjectTypePlural | 's';\n    EndIf;\n    nErrors = 1;\n    sMessage\
    \ = 'You must first initialise ' | pObjectType | ' Security. In the Server Explorer go to ' |\n  \
    \             sObjectTypePlural | ' -> Security Assignments, and assign an access security to a '\
    \ |\n               pObjectType | '. Then from the Server Explorer go to your ServerName -> Security\
    \ -> Refresh Security';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Set Object Type Dimension\nsObjectTypeDimension = '}' | pObjectType;\nIf( pObjectType @= 'Application'\
    \ );\n    sObjectTypeDimension = sObjectTypeDimension | 'Entries';\nElseIf( pObjectType @= 'Process'\
    \ );\n    sObjectTypeDimension = sObjectTypeDimension | 'es';\nElse;\n    sObjectTypeDimension = sObjectTypeDimension\
    \ | 's';\nEndIf;\n\n# Validate Security Level\n# Allowable Security Levels by Object Type (excluding\
    \ RESERVE and LOCK):\n#   Cube        : NONE, READ, ADMIN, WRITE\n#   Dimension   : NONE, READ, ADMIN,\
    \ WRITE\n#   Application : NONE, READ, ADMIN\n#   Process     : NONE, READ\n#   Chore       : NONE,\
    \ READ\npSecurityLevel = Upper( pSecurityLevel );\nIf( pSecurityLevel @= 'NONE' % pSecurityLevel @=\
    \ 'READ' % \n  ( pSecurityLevel @= 'ADMIN' & ( pObjectType @= 'Cube' % pObjectType @= 'Dimension'\
    \ % pObjectType @= 'Application' ) ) %\n  ( pSecurityLevel @= 'WRITE' & ( pObjectType @= 'Cube' %\
    \ pObjectType @= 'Dimension' ) ) );\n  # Valid Security Levels\nElse;\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid security level parameter: ' | pSecurityLevel | ' for object type: ' | pObjectType;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If pSecurityRefresh is\
    \ blank then default to yes\nIf( Trim( pSecurityRefresh ) @= '' );\n    pSecurityRefresh = 'Yes';\n\
    EndIf;\n\n# If pSecurityRefresh has not been specified correctly then terminate process\nIf( Upper(\
    \ pSecurityRefresh ) @<> 'YES' & Upper( pSecurityRefresh ) @<> 'NO' );\n    nErrors = 1;\n    sMessage\
    \ = 'Incorrect value for pSecurityRefresh: ' | pSecurityRefresh | '. Valid values are Yes or No';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n\
    \  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Application Security ###\n# Loop through\
    \ list of groups\nsGroups = pGroup;\nnGroupDelimIndex = 1;\n\nWhile( nGroupDelimIndex <> 0 );\n  nGroupDelimIndex\
    \ = Scan( pDelim, sGroups );\n  If( nGroupDelimIndex = 0 );\n    sGroup = sGroups;\n  Else;\n    sGroup\
    \ = Trim( SubSt( sGroups, 1, nGroupDelimIndex - 1 ) );\n    sGroups = Trim( Subst( sGroups, nGroupDelimIndex\
    \ + Long(pDelim), Long( sGroups ) ) );\n  EndIf;\n  \n\n If(Scan('*',sGroup) = 0);\n   \n \n  # Don't\
    \ attempt to process a blank group or ADMIN\n  If( sGroup @<> '' & sGroup @<> 'ADMIN' );\n    # Check\
    \ that Group exists\n    If( DimIx( '}Groups', sGroup ) = 0 );\n        nErrors = 1;\n        sMessage\
    \ = 'Group: ' | sGroup | ' does not exists';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n     ELSE;\n\n      # Loop through list of objects\n      sObjects = pObject;\n      nObjectDelimIndex\
    \ = 1;\n\n      While( nObjectDelimIndex <> 0 );\n        nObjectDelimIndex = Scan( pDelim, sObjects\
    \ );\n        If( nObjectDelimIndex = 0 );\n          sObject = sObjects;\n        Else;\n       \
    \   sObject = Trim( SubSt( sObjects, 1, nObjectDelimIndex - 1 ) );\n          sObjects = Trim( Subst(\
    \ sObjects, nObjectDelimIndex + Long(pDelim), Long( sObjects ) ) );\n        EndIf;\n        If( Scan(\
    \ '*', sObject ) = 0);\n         # Don't attempt to process a blank object\n         If( sObject @<>\
    \ '' );\n           # Check that object exists\n           If( DimIx( sObjectTypeDimension, sObject\
    \ ) = 0 );\n                nErrors = 1;\n                sMessage = 'Object: ' | sObject | ' does\
    \ not exists';\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n       \
    \   ELSE;\n             # Assign Security\n             If( CellIsUpdateable( cSecurityCube, sObject,\
    \ sGroup ) = 1 );\n               If( nErrors = 0);\n                 CellPutS( pSecurityLevel, cSecurityCube,\
    \ sObject, sGroup );\n               EndIf;\n             EndIf;\n           EndIf;\n         EndIf;\n\
    \        ELSE;\n          # Wildcard search string\n         sObject = '''|sObject|''';\n        \
    \ sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sObjectTypeDimension| '])},'| sObject| ')}';\n \
    \        If( SubsetExists( sObjectTypeDimension, cTempSub ) = 1 );\n            # If a delimited list\
    \ of objects includes wildcards then we may have to re-use the subset multiple times\n           \
    \ SubsetMDXSet( sObjectTypeDimension, cTempSub, sMDX );\n         Else;\n            # temp subset,\
    \ therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, sObjectTypeDimension,\
    \ 1 );\n         EndIf;\n         nCountObj = SubsetGetSize( sObjectTypeDimension, cTempSub );\n \
    \        While( nCountObj >= 1 );\n            sObject = SubsetGetElementName( sObjectTypeDimension,\
    \ cTempSub, nCountObj );\n            # Assign Security\n             If( CellIsUpdateable( cSecurityCube,\
    \ sObject, sGroup ) = 1 );\n               If( nErrors = 0);\n                 CellPutS( pSecurityLevel,\
    \ cSecurityCube, sObject, sGroup );\n               EndIf;\n             EndIf;\n            nCountObj\
    \ = nCountObj - 1;\n         End;\n        EndIf;\n      End;\n    EndIf;\n  EndIf;\n ELSE;\n# Wildcard\
    \ search string\n        sGroupDim = '}Groups';\n        sGroup = '''|sGroup|''';\n        sMdx =\
    \ '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sGroupDim| '])},'| sGroup| ')}';\n        If( SubsetExists(\
    \ sGroupDim, cTempSub ) = 1 );\n            # If a delimited list of groups includes wildcards then\
    \ we may have to re-use the subset multiple times\n            SubsetMDXSet( sGroupDim, cTempSub,\
    \ sMDX );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n    \
    \        SubsetCreatebyMDX( cTempSub, sMDX, sGroupDim, 1 );\n        EndIf;\n        # Loop through\
    \ dimensions in groups with wildcard\n        nCountGroup = SubsetGetSize( '}Groups' , cTempSub );\n\
    \        While( nCountGroup >= 1 );\n            \n            sGroup = SubsetGetElementName( '}Groups'\
    \ , cTempSub, nCountGroup );\n            # Validate group name\n            If( Dimix('}Groups',\
    \ sGroup) = 0 );\n                nErrors = 1;\n                sMessage = Expand( 'Group '%sGroup%'\
    \ does not exist.' );\n                LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n       \
    \     Else;\n              # Loop through list of objects\n              sObjects = pObject;\n   \
    \           nObjectDelimIndex = 1;\n\n              While( nObjectDelimIndex <> 0 );\n           \
    \     nObjectDelimIndex = Scan( pDelim, sObjects );\n                If( nObjectDelimIndex = 0 );\n\
    \                  sObject = sObjects;\n                Else;\n                  sObject = Trim( SubSt(\
    \ sObjects, 1, nObjectDelimIndex - 1 ) );\n                  sObjects = Trim( Subst( sObjects, nObjectDelimIndex\
    \ + Long(pDelim), Long( sObjects ) ) );\n                EndIf;\n                If( Scan( '*', sObject\
    \ ) = 0);\n                # Don't attempt to process a blank object\n                  If( sObject\
    \ @<> '' );\n                    # Check that object exists\n                    If( DimIx( sObjectTypeDimension,\
    \ sObject ) = 0 );\n                        nErrors = 1;\n                        sMessage = 'Object:\
    \ ' | sObject | ' does not exists';\n                        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n                    ELSE;\n                      # Assign Security\n                     \
    \ If( CellIsUpdateable( cSecurityCube, sObject, sGroup ) = 1 );\n                        If( nErrors\
    \ = 0);\n                          CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\n \
    \                       EndIf;\n                      EndIf;\n                    EndIf;\n       \
    \           EndIf;\n                ELSE;\n                # Wildcard search string\n            \
    \    sObject = '''|sObject|''';\n                sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sObjectTypeDimension|\
    \ '])},'| sObject| ')}';\n                If( SubsetExists( sObjectTypeDimension, cTempSub ) = 1 );\n\
    \                    # If a delimited list of objects includes wildcards then we may have to re-use\
    \ the subset multiple times\n                    SubsetMDXSet( sObjectTypeDimension, cTempSub, sMDX\
    \ );\n                Else;\n                    # temp subset, therefore no need to destroy in epilog\n\
    \                    SubsetCreatebyMDX( cTempSub, sMDX, sObjectTypeDimension, 1 );\n             \
    \   EndIf;\n                  nCountObj = SubsetGetSize( sObjectTypeDimension, cTempSub );\n     \
    \             While( nCountObj >= 1 );\n                      sObject = SubsetGetElementName( sObjectTypeDimension,\
    \ cTempSub, nCountObj );\n                      # Assign Security\n                      If( CellIsUpdateable(\
    \ cSecurityCube, sObject, sGroup ) = 1 );\n                        If( nErrors = 0);\n           \
    \               CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\n                    \
    \    EndIf;\n                      EndIf;\n                      nCountObj = nCountObj - 1;\n    \
    \              End;\n                EndIf;\n              End;\n            Endif;\n            nCountGroup\
    \ = nCountGroup - 1;\n        End;\n  Endif;    \nEnd;\n\n### Refresh Security ###\n\nIf( Upper( pSecurityRefresh\
    \ ) @= 'YES' );\n  SecurityRefresh;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully assigned\
    \ object %pObject% of type %pObjectType% security level %pSecurityLevel% for group %pGroup%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that assigns security to specified objects for particular
    groups. Use two parameters, pGroup and pObject, which support delimited lists and wildcards. This
    process is intended for development or production environments with two main use cases: setting up
    initial security assignments and updating security assignments as business needs change. Important
    notes: The parameters group (pGroup), object type (pObjectType), and security level (pSecurityLevel)
    are mandatory; the absence of these will cause the process to abort. Multiple groups and object names
    can be specified using delimiters, but they must be valid. Object security must be initialized before
    using the process, and a security update must be done through Server Explorer. If non-existing groups
    or objects are specified, they will be skipped, but valid groups and objects will still be processed.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will assign security to specified object(s) for specified\
    \ group(s). Both pGroup \n# and pObject parameters support delimited lists and wildcards.\n\n# Use\
    \ case: Intended for develpment or production.\n# 1. Set up initial security assignments.\n# 2. Update\
    \ security assignments a business needs change.\n\n# Note:\n# Naturally, group (pGroup), object type\
    \ (pObjectType) and security level (pSecurityLevel) are mandatory otherwise the process will abort:\n\
    # - Multiple groups can be specified separated by delimiter.\n# Object names (pObject) can be listed\
    \ with delimiters but need to be valid as well. \n# - Before using this process, you must first initialise\
    \ object security.\n# - For Applications, in Server Explorer go to Applications -> Security Assignments\
    \ and assign an access security for an Application. \n# - For other object types follow a similar\
    \ process but for that object type.\n# - Then from the Server Explorer go to your ServerName -> Security\
    \ -> Refresh Security.\n# - Multiple objects can be specified separated by delimiter.\n# - If groups\
    \ and/or objects that don't exist are specified, then they will be skipped but valid groups and ojects\
    \ will still be processed.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncSecurityCube       = '}' | pObjectType | 'Security';\n\
    cTempSub            = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncUserName           = TM1User();\n\
    cMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pGroup:%pGroup%, pObjectType:%pObjectType%,\
    \ pObject:%pObject%, pSecurityLevel:%pSecurityLevel%, pSecurityRefresh:%pSecurityRefresh%, pDelim:%pDelim%.'\
    \ ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo )\
    \ );   \nENDIF;\n\n### Validate Parameters ###\nnErrors             = 0;\n# If no groups have been\
    \ specified then terminate process\nIf( Trim( pGroup ) @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'No groups specified.';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    EndIf;\n\n# Validate Object Type\nIf( pObjectType @<> 'Application' & pObjectType @<> 'Cube' & pObjectType\
    \ @<> 'Dimension' & pObjectType @<> 'Process' & pObjectType @<> 'Chore' );\n    nErrors         =\
    \ 1;\n    sMessage        = 'Invalid object type specified: ' | pObjectType | '. Valid object types\
    \ are: Application, Cube, Dimension, Process and Chore';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n# If no objects have been specified then terminate process\nIf( Trim( pObject )\
    \ @= '' );\n    nErrors         = 1;\n    sMessage        = 'No objects specified.';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Validate that object type has object\
    \ security enabled\nIf( CubeExists( cSecurityCube ) = 0 );\n    sObjectTypePlural = pObjectType;\n\
    \    If( pObjectType @= 'Process');\n        sObjectTypePlural = sObjectTypePlural | 'es';\n    Else;\n\
    \        sObjectTypePlural = sObjectTypePlural | 's';\n    EndIf;\n    nErrors = 1;\n    sMessage\
    \ = 'You must first initialise ' | pObjectType | ' Security. In the Server Explorer go to ' |\n  \
    \             sObjectTypePlural | ' -> Security Assignments, and assign an access security to a '\
    \ |\n               pObjectType | '. Then from the Server Explorer go to your ServerName -> Security\
    \ -> Refresh Security';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    # Set Object Type Dimension\nsObjectTypeDimension = '}' | pObjectType;\nIf( pObjectType @= 'Application'\
    \ );\n    sObjectTypeDimension = sObjectTypeDimension | 'Entries';\nElseIf( pObjectType @= 'Process'\
    \ );\n    sObjectTypeDimension = sObjectTypeDimension | 'es';\nElse;\n    sObjectTypeDimension = sObjectTypeDimension\
    \ | 's';\nEndIf;\n\n# Validate Security Level\n# Allowable Security Levels by Object Type (excluding\
    \ RESERVE and LOCK):\n#   Cube        : NONE, READ, ADMIN, WRITE\n#   Dimension   : NONE, READ, ADMIN,\
    \ WRITE\n#   Application : NONE, READ, ADMIN\n#   Process     : NONE, READ\n#   Chore       : NONE,\
    \ READ\npSecurityLevel = Upper( pSecurityLevel );\nIf( pSecurityLevel @= 'NONE' % pSecurityLevel @=\
    \ 'READ' % \n  ( pSecurityLevel @= 'ADMIN' & ( pObjectType @= 'Cube' % pObjectType @= 'Dimension'\
    \ % pObjectType @= 'Application' ) ) %\n  ( pSecurityLevel @= 'WRITE' & ( pObjectType @= 'Cube' %\
    \ pObjectType @= 'Dimension' ) ) );\n  # Valid Security Levels\nElse;\n    nErrors = 1;\n    sMessage\
    \ = 'Invalid security level parameter: ' | pSecurityLevel | ' for object type: ' | pObjectType;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If pSecurityRefresh is\
    \ blank then default to yes\nIf( Trim( pSecurityRefresh ) @= '' );\n    pSecurityRefresh = 'Yes';\n\
    EndIf;\n\n# If pSecurityRefresh has not been specified correctly then terminate process\nIf( Upper(\
    \ pSecurityRefresh ) @<> 'YES' & Upper( pSecurityRefresh ) @<> 'NO' );\n    nErrors = 1;\n    sMessage\
    \ = 'Incorrect value for pSecurityRefresh: ' | pSecurityRefresh | '. Valid values are Yes or No';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# If blank delimiter specified\
    \ then convert to default\nIf( pDelim @= '' );\n    pDelim = '&';\nEndIf;\n\n### Check for errors\
    \ before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n\
    \  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Assign Application Security ###\n# Loop through\
    \ list of groups\nsGroups = pGroup;\nnGroupDelimIndex = 1;\n\nWhile( nGroupDelimIndex <> 0 );\n  nGroupDelimIndex\
    \ = Scan( pDelim, sGroups );\n  If( nGroupDelimIndex = 0 );\n    sGroup = sGroups;\n  Else;\n    sGroup\
    \ = Trim( SubSt( sGroups, 1, nGroupDelimIndex - 1 ) );\n    sGroups = Trim( Subst( sGroups, nGroupDelimIndex\
    \ + Long(pDelim), Long( sGroups ) ) );\n  EndIf;\n  \n\n If(Scan('*',sGroup) = 0);\n   \n \n  # Don't\
    \ attempt to process a blank group or ADMIN\n  If( sGroup @<> '' & sGroup @<> 'ADMIN' );\n    # Check\
    \ that Group exists\n    If( DimIx( '}Groups', sGroup ) = 0 );\n        nErrors = 1;\n        sMessage\
    \ = 'Group: ' | sGroup | ' does not exists';\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n     ELSE;\n\n      # Loop through list of objects\n      sObjects = pObject;\n      nObjectDelimIndex\
    \ = 1;\n\n      While( nObjectDelimIndex <> 0 );\n        nObjectDelimIndex = Scan( pDelim, sObjects\
    \ );\n        If( nObjectDelimIndex = 0 );\n          sObject = sObjects;\n        Else;\n       \
    \   sObject = Trim( SubSt( sObjects, 1, nObjectDelimIndex - 1 ) );\n          sObjects = Trim( Subst(\
    \ sObjects, nObjectDelimIndex + Long(pDelim), Long( sObjects ) ) );\n        EndIf;\n        If( Scan(\
    \ '*', sObject ) = 0);\n         # Don't attempt to process a blank object\n         If( sObject @<>\
    \ '' );\n           # Check that object exists\n           If( DimIx( sObjectTypeDimension, sObject\
    \ ) = 0 );\n                nErrors = 1;\n                sMessage = 'Object: ' | sObject | ' does\
    \ not exists';\n                LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n       \
    \   ELSE;\n             # Assign Security\n             If( CellIsUpdateable( cSecurityCube, sObject,\
    \ sGroup ) = 1 );\n               If( nErrors = 0);\n                 CellPutS( pSecurityLevel, cSecurityCube,\
    \ sObject, sGroup );\n               EndIf;\n             EndIf;\n           EndIf;\n         EndIf;\n\
    \        ELSE;\n          # Wildcard search string\n         sObject = '''|sObject|''';\n        \
    \ sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sObjectTypeDimension| '])},'| sObject| ')}';\n \
    \        If( SubsetExists( sObjectTypeDimension, cTempSub ) = 1 );\n            # If a delimited list\
    \ of objects includes wildcards then we may have to re-use the subset multiple times\n           \
    \ SubsetMDXSet( sObjectTypeDimension, cTempSub, sMDX );\n         Else;\n            # temp subset,\
    \ therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX, sObjectTypeDimension,\
    \ 1 );\n         EndIf;\n         nCountObj = SubsetGetSize( sObjectTypeDimension, cTempSub );\n \
    \        While( nCountObj >= 1 );\n            sObject = SubsetGetElementName( sObjectTypeDimension,\
    \ cTempSub, nCountObj );\n            # Assign Security\n             If( CellIsUpdateable( cSecurityCube,\
    \ sObject, sGroup ) = 1 );\n               If( nErrors = 0);\n                 CellPutS( pSecurityLevel,\
    \ cSecurityCube, sObject, sGroup );\n               EndIf;\n             EndIf;\n            nCountObj\
    \ = nCountObj - 1;\n         End;\n        EndIf;\n      End;\n    EndIf;\n  EndIf;\n ELSE;\n# Wildcard\
    \ search string\n        sGroupDim = '}Groups';\n        sGroup = '''|sGroup|''';\n        sMdx =\
    \ '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sGroupDim| '])},'| sGroup| ')}';\n        If( SubsetExists(\
    \ sGroupDim, cTempSub ) = 1 );\n            # If a delimited list of groups includes wildcards then\
    \ we may have to re-use the subset multiple times\n            SubsetMDXSet( sGroupDim, cTempSub,\
    \ sMDX );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n    \
    \        SubsetCreatebyMDX( cTempSub, sMDX, sGroupDim, 1 );\n        EndIf;\n        # Loop through\
    \ dimensions in groups with wildcard\n        nCountGroup = SubsetGetSize( '}Groups' , cTempSub );\n\
    \        While( nCountGroup >= 1 );\n            \n            sGroup = SubsetGetElementName( '}Groups'\
    \ , cTempSub, nCountGroup );\n            # Validate group name\n            If( Dimix('}Groups',\
    \ sGroup) = 0 );\n                nErrors = 1;\n                sMessage = Expand( 'Group '%sGroup%'\
    \ does not exist.' );\n                LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n       \
    \     Else;\n              # Loop through list of objects\n              sObjects = pObject;\n   \
    \           nObjectDelimIndex = 1;\n\n              While( nObjectDelimIndex <> 0 );\n           \
    \     nObjectDelimIndex = Scan( pDelim, sObjects );\n                If( nObjectDelimIndex = 0 );\n\
    \                  sObject = sObjects;\n                Else;\n                  sObject = Trim( SubSt(\
    \ sObjects, 1, nObjectDelimIndex - 1 ) );\n                  sObjects = Trim( Subst( sObjects, nObjectDelimIndex\
    \ + Long(pDelim), Long( sObjects ) ) );\n                EndIf;\n                If( Scan( '*', sObject\
    \ ) = 0);\n                # Don't attempt to process a blank object\n                  If( sObject\
    \ @<> '' );\n                    # Check that object exists\n                    If( DimIx( sObjectTypeDimension,\
    \ sObject ) = 0 );\n                        nErrors = 1;\n                        sMessage = 'Object:\
    \ ' | sObject | ' does not exists';\n                        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n                    ELSE;\n                      # Assign Security\n                     \
    \ If( CellIsUpdateable( cSecurityCube, sObject, sGroup ) = 1 );\n                        If( nErrors\
    \ = 0);\n                          CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\n \
    \                       EndIf;\n                      EndIf;\n                    EndIf;\n       \
    \           EndIf;\n                ELSE;\n                # Wildcard search string\n            \
    \    sObject = '''|sObject|''';\n                sMdx = '{TM1FILTERBYPATTERN( {TM1SUBSETALL([ ' |sObjectTypeDimension|\
    \ '])},'| sObject| ')}';\n                If( SubsetExists( sObjectTypeDimension, cTempSub ) = 1 );\n\
    \                    # If a delimited list of objects includes wildcards then we may have to re-use\
    \ the subset multiple times\n                    SubsetMDXSet( sObjectTypeDimension, cTempSub, sMDX\
    \ );\n                Else;\n                    # temp subset, therefore no need to destroy in epilog\n\
    \                    SubsetCreatebyMDX( cTempSub, sMDX, sObjectTypeDimension, 1 );\n             \
    \   EndIf;\n                  nCountObj = SubsetGetSize( sObjectTypeDimension, cTempSub );\n     \
    \             While( nCountObj >= 1 );\n                      sObject = SubsetGetElementName( sObjectTypeDimension,\
    \ cTempSub, nCountObj );\n                      # Assign Security\n                      If( CellIsUpdateable(\
    \ cSecurityCube, sObject, sGroup ) = 1 );\n                        If( nErrors = 0);\n           \
    \               CellPutS( pSecurityLevel, cSecurityCube, sObject, sGroup );\n                    \
    \    EndIf;\n                      EndIf;\n                      nCountObj = nCountObj - 1;\n    \
    \              End;\n                EndIf;\n              End;\n            Endif;\n            nCountGroup\
    \ = nCountGroup - 1;\n        End;\n  Endif;    \nEnd;\n\n### Refresh Security ###\n\nIf( Upper( pSecurityRefresh\
    \ ) @= 'YES' );\n  SecurityRefresh;\nEndIf;\n\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n### Return code & final error message handling\nIf( nErrors\
    \ > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully assigned\
    \ object %pObject% of type %pObjectType% security level %pSecurityLevel% for group %pGroup%.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der die TM1-Sicherheit aktualisiert. Der Prozess
    sollte in Entwicklungs- oder Produktionsumgebungen verwendet werden, insbesondere wenn neue Clients
    oder Sicherheitsgruppen hinzugefügt wurden oder wenn Sicherheits-Cubes mit geänderten Regeln vorliegen.
    Beachte, dass dies ein zeitaufwendiger Prozess sein kann und möglicherweise über Nacht durchgeführt
    werden muss.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process refreshes TM1 security.\n\n# Use case: Intended for\
    \ development or production.\n# 1/ Refresh security after new clients or security groups are added.\n\
    # 2/ If security cubes have rules and they had to be changed.\n\n# Note:\n# This can be a time consuming\
    \ process and may need to be run overnight.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \ = GetProcessName();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Refresh Security ###\n\nSecurityRefresh;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully refreshed security.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Develop an IBM Turbo Integrator process that refreshes TM1 security. The process is intended
    for use in development or production environments, particularly when new clients or security groups
    are added or when security cubes have rules that had to be changed. Note that this can be a time-consuming
    process and may need to be run overnight.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process refreshes TM1 security.\n\n# Use case: Intended for\
    \ development or production.\n# 1/ Refresh security after new clients or security groups are added.\n\
    # 2/ If security cubes have rules and they had to be changed.\n\n# Note:\n# This can be a time consuming\
    \ process and may need to be run overnight.\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \ = GetProcessName();\ncTimeStamp = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt = NumberToString(\
    \ INT( RAND( ) * 1000 ));\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters.' ;  \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Refresh Security ###\n\nSecurityRefresh;\n\
    \n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully refreshed security.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Erstelle einen IBM Turbo Integrator Prozess, um persistente Feeders zu löschen. Dieser Vorgang
    sollte sowohl für Entwicklungs- als auch für Produktionsumgebungen geeignet sein. Dabei ist sicherzustellen,
    dass persistente Feeders in der Konfigurationsdatei deaktiviert sind und dass der Bedarf besteht,
    die Feeders erneut zu verarbeiten. Beachte, dass die erneute Verarbeitung der Feeders viel Zeit in
    Anspruch nehmen kann und es ratsam sein könnte, diesen Prozess über Nacht auszuführen.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Delete Persistent feeders.\n\n# Use case: Intended\
    \ for development or production.\n# 1/ Persistent feeders turned off in config file.\n# 2/ Want to\
    \ reprocess feeders.\n\n# Note:\n# Reprocessing feeders could take a long time and it may be better\
    \ to run this overnight.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pRun:%pRun% .'; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Delete Feeders ###\nIf( pRun @= 'Y' );\n\
    \    DeleteAllPersistentFeeders;\nEndIf;\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted persistant feeders.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process to delete persistent feeders. This process should
    be suitable for both development and production environments. Ensure that persistent feeders are turned
    off in the config file and that there is a need to reprocess the feeders. Note that reprocessing the
    feeders could take a significant amount of time and it might be advisable to run this process overnight.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Delete Persistent feeders.\n\n# Use case: Intended\
    \ for development or production.\n# 1/ Persistent feeders turned off in config file.\n# 2/ Want to\
    \ reprocess feeders.\n\n# Note:\n# Reprocessing feeders could take a long time and it may be better\
    \ to run this overnight.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pRun:%pRun% .'; \n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO',\
    \ Expand( cLogInfo ) );   \nENDIF;\n\nnErrors = 0;\n\n### Delete Feeders ###\nIf( pRun @= 'Y' );\n\
    \    DeleteAllPersistentFeeders;\nEndIf;\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully deleted persistant feeders.' );\n\
    \    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der das Sichern des Datenverzeichnisses automatisiert.
    Dieser Prozess soll sowohl in der Entwicklungs- als auch in der Produktionsumgebung eingesetzt werden.
    Die Sicherung des Datenverzeichnisses soll täglich während der Entwicklungsphase und während des Planungszyklus
    durchgeführt werden. Beachte, dass ein gültiges Datenverzeichnis (pSrcDir) und ein Zielverzeichnis
    (pTgtDir) erforderlich sind, da der Prozess andernfalls abbricht. Beschreibe die einzelnen Schritte
    und die Logik, die im Prozess verwendet werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will back up the Data Directory.\n\n# Use case: Intended\
    \ for development and production.\n# 1/ Backup Data directory every day during development.\n# 2/\
    \ Backup Data directory every day during planning cycle.\n\n# Note:\n# Naturally, a valid data directory\
    \ (pSrcDir) and targer directory (pTgtDir) is mandatory otherwise the process will abort.\n#EndRegion\
    \ @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pSrcDir:%pSrcDir%, pTgtDir:%pTgtDir%, pExcludeFilter:%pExcludeFilter%, pDelim:%pDelim%,\
    \ pSubDirCopy:%pSubDirCopy%, pRobocopy:%pRobocopy%.' ;\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors             = 0;\n\n# Remove leading and/or trailing spaces\npSrcDir             = Trim( pSrcDir\
    \ );\npTgtDir             = Trim( pTgtDir );\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n# Remove trailing \\ from directory names if present\nIf( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @=\
    \ sOSDelim );\n    pSrcDir         = SubSt( pSrcDir, 1, Long( pSrcDir ) - 1 );\nEndIf;\nIf( SubSt(\
    \ pTgtDir, Long( pTgtDir ),1 ) @= sOSDelim );\n    pTgtDir         = SubSt( pTgtDir, 1, Long( pTgtDir\
    \ ) - 1 );\nEndIf;\n\n# Check that data directory has been specified\nIf( pSrcDir @= '' );\n    nErrors\
    \         = 1;\n    sMessage        = 'No data directory specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( FileExists( pSrcDir ) = 0 );\n    nErrors         = 1;\n\
    \    sMessage        = 'Source data directory for backup does not exist: ' | pSrcDir;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check that target directory has been\
    \ specified\nIf( pTgtDir @= '' );\n    nErrors         = 1;\n    sMessage        = 'No backup directory\
    \ specified';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( FileExists( pTgtDir\
    \ ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Destination directory for backup does\
    \ not exist: ' | pTgtDir;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Save the model to disk\n\
    ExecuteProcess( '}bedrock.server.savedataall', 'pStrictErrorHandling', pStrictErrorHandling );\nsMessage\
    \ = 'TM1 Save Data All Complete.';\nIf( pLogoutput = 1 );\n\tLogOutput('INFO', sMessage ); \nEndIf;\n\
    \n### Create batch files\nDatasourceASCIIQuoteCharacter='';\n\n### Create Make Directory Batch File\n\
    sFileName           = 'Bedrock.MkDir.bat' ;\nsBackupDir          = pTgtDir | sOSDelim | 'TM1Backup_'\
    \ | cTimeStamp;\nIf(sOS @= 'Windows');\n  ASCIIOUTPUT( sFileName, 'md '' | sBackupDir |''' );\nEndIf;\n\
    \n### Create Exclude File ###\nIf(pRobocopy = 1);\n\t# robocopy uses different file format with rcj\
    \ file and * wildcard character\n\tsFileNameExclude =  pSrcDir | sOSDelim | 'Excludes' | cTimeStamp\
    \ | cRandomInt| '.rcj';\n    ASCIIOUTPUT( sFileNameExclude, '/xf');\n    sExcludeWCPrefix = '*';\n\
    Else;\n\tsFileNameExclude =  'Excludes' | cTimeStamp | cRandomInt| '.txt';\n    sExcludeWCPrefix =\
    \ '';\nEndIf;\npExcludeFilter = TRIM(pExcludeFilter);\n\nIf(pExcludeFilter @<> ''); \n    If( SCAN(pDelim,\
    \ pExcludeFilter) > 0);\n        # parse multiple exclusions\n        While(LONG(pExcludeFilter) >\
    \ 0);\n            If(SCAN(pDelim, pExcludeFilter) > 0);\n                sExcludePart = TRIM(SUBST(pExcludeFilter,\
    \ 1, SCAN(pDelim, pExcludeFilter) - 1));\n                pExcludeFilter = TRIM(DELET(pExcludeFilter,\
    \ 1,SCAN(pDelim, pExcludeFilter) + LONG(pDelim) - 1));\n            Else;\n                sExcludePart\
    \ = pExcludeFilter;\n                pExcludeFilter = '';\n            EndIf;\n            ASCIIOUTPUT(\
    \ sFileNameExclude, sExcludeWCPrefix | sExcludePart);\n        End;\n    Else;\n        ASCIIOUTPUT(\
    \ sFileNameExclude, sExcludeWCPrefix | pExcludeFilter);\n    EndIf;\nElse;\n    ASCIIOUTPUT( sFileNameExclude,\
    \ '');\nEndIf;\n\n### Create Batch File ###\nsFileName = 'Bedrock.Server.DataDir.Backup.bat';\nIf(sOS\
    \ @= 'Windows');\n  If(pSubDirCopy = 1);\n  \tcSubDirCopy = '/s /e';\n  Else;\n  \tcSubDirCopy = '';\n\
    \  EndIf;\n  If(pRobocopy = 1);\n  \tsText = 'robocopy ''| pSrcDir |'' ''| sBackupDir | '' '  | cSubDirCopy\
    \ | ' /job:''| sFileNameExclude | ''';\n  Else;\n  \tsText = 'XCOPY ''| pSrcDir |'' ''| sBackupDir|''\
    \ /i /c '| cSubDirCopy |' /y /exclude:'| sFileNameExclude;\n  EndIf;\n  ASCIIOUTPUT( sFileName, '@ECHO\
    \ OFF');\n  ASCIIOUTPUT( sFileName, sText );\nElse;\n  #sOS is Linux\n  If(pSubDirCopy = 1);\n  \t\
    cSubDirCopy = 'r';\n  Else;\n  \tcSubDirCopy = '';\n  EndIf;\n  sText = 'rsync -' | cSubDirCopy |\
    \ 't --exclude-from=' | sFileNameExclude | ' '' | pSrcDir | '' '' | sBackupDir |''';\nEndIf;\n\nsMessage\
    \ = 'Command Line: ' | sText;\nIf( pLogoutput = 1 );\n\tLogOutput('INFO', sMessage ); \nEndIf;\n\n\
    ### End Prolog ###\n#Section Metadaten\n\n#Section Daten\n\n#Section Epilog\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n# Create backup directory\nIf(sOS @= 'Windows');\n\
    \  ExecuteCommand ( 'Bedrock.MkDir.bat', 1 );\nElse;\n  ExecuteCommand ( 'mkdir '' | sBackupDir |''',\
    \ 1);\nEndIf;\n# Ensure backup directory created else abort\nIf( FileExists( sBackupDir ) = 0 );\n\
    \    nErrors = 1;\n    sMessage = 'Process Quit: Could not create backup directory: ' | sBackupDir;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ProcessQuit;\nELSE;\n      sMessage\
    \ = 'Backup directory exists: ' | sBackupDir;\n      LogOutput('INFO', sMessage ); \nEndIf;\n\n###\
    \ Copy Data Dir to Backup ###\nIf(sOS @= 'Windows');\n  ExecuteCommand ( 'Bedrock.Server.DataDir.Backup.bat',\
    \ 1 );\nElse;\n  ExecuteCommand ( sText, 1 );\nEndIf;\n\n### Delete temporary files ###\nsFileName\
    \ = 'Bedrock.Server.DataDir.Backup.bat' ;\nASCIIDelete( LOWER(sFileName) );\nsFileName = 'Bedrock.MkDir.bat';\n\
    ASCIIDelete( LOWER(sFileName) );\nsFileName = sFileNameExclude;\nASCIIDelete( LOWER(sFileNameExclude)\
    \ );\n\nsMessage = 'Temporary files deleted.';\nIf( pLogoutput = 1 );\n \tLogOutput('INFO', sMessage\
    \ ); \nEndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully Backed up Dir %pSrcDir% to dir\
    \ %pTgtDir%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n  \
    \  nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that automates the backup of the Data Directory. This
    process is intended for use in both development and production environments. The backup of the Data
    Directory should occur daily during the development phase and the planning cycle. Note that a valid
    data directory (pSrcDir) and a target directory (pTgtDir) are mandatory; otherwise, the process will
    abort. Describe the individual steps and the logic used in the process.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will back up the Data Directory.\n\n# Use case: Intended\
    \ for development and production.\n# 1/ Backup Data directory every day during development.\n# 2/\
    \ Backup Data directory every day during planning cycle.\n\n# Note:\n# Naturally, a valid data directory\
    \ (pSrcDir) and targer directory (pTgtDir) is mandatory otherwise the process will abort.\n#EndRegion\
    \ @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt    \
    \      = NumberToString( INT( RAND( ) * 1000 ));\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% Message:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pSrcDir:%pSrcDir%, pTgtDir:%pTgtDir%, pExcludeFilter:%pExcludeFilter%, pDelim:%pDelim%,\
    \ pSubDirCopy:%pSubDirCopy%, pRobocopy:%pRobocopy%.' ;\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors             = 0;\n\n# Remove leading and/or trailing spaces\npSrcDir             = Trim( pSrcDir\
    \ );\npTgtDir             = Trim( pTgtDir );\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n# Remove trailing \\ from directory names if present\nIf( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @=\
    \ sOSDelim );\n    pSrcDir         = SubSt( pSrcDir, 1, Long( pSrcDir ) - 1 );\nEndIf;\nIf( SubSt(\
    \ pTgtDir, Long( pTgtDir ),1 ) @= sOSDelim );\n    pTgtDir         = SubSt( pTgtDir, 1, Long( pTgtDir\
    \ ) - 1 );\nEndIf;\n\n# Check that data directory has been specified\nIf( pSrcDir @= '' );\n    nErrors\
    \         = 1;\n    sMessage        = 'No data directory specified.';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nElseIf( FileExists( pSrcDir ) = 0 );\n    nErrors         = 1;\n\
    \    sMessage        = 'Source data directory for backup does not exist: ' | pSrcDir;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n# Check that target directory has been\
    \ specified\nIf( pTgtDir @= '' );\n    nErrors         = 1;\n    sMessage        = 'No backup directory\
    \ specified';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nElseIf( FileExists( pTgtDir\
    \ ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Destination directory for backup does\
    \ not exist: ' | pTgtDir;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n\
    ### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Save the model to disk\n\
    ExecuteProcess( '}bedrock.server.savedataall', 'pStrictErrorHandling', pStrictErrorHandling );\nsMessage\
    \ = 'TM1 Save Data All Complete.';\nIf( pLogoutput = 1 );\n\tLogOutput('INFO', sMessage ); \nEndIf;\n\
    \n### Create batch files\nDatasourceASCIIQuoteCharacter='';\n\n### Create Make Directory Batch File\n\
    sFileName           = 'Bedrock.MkDir.bat' ;\nsBackupDir          = pTgtDir | sOSDelim | 'TM1Backup_'\
    \ | cTimeStamp;\nIf(sOS @= 'Windows');\n  ASCIIOUTPUT( sFileName, 'md '' | sBackupDir |''' );\nEndIf;\n\
    \n### Create Exclude File ###\nIf(pRobocopy = 1);\n\t# robocopy uses different file format with rcj\
    \ file and * wildcard character\n\tsFileNameExclude =  pSrcDir | sOSDelim | 'Excludes' | cTimeStamp\
    \ | cRandomInt| '.rcj';\n    ASCIIOUTPUT( sFileNameExclude, '/xf');\n    sExcludeWCPrefix = '*';\n\
    Else;\n\tsFileNameExclude =  'Excludes' | cTimeStamp | cRandomInt| '.txt';\n    sExcludeWCPrefix =\
    \ '';\nEndIf;\npExcludeFilter = TRIM(pExcludeFilter);\n\nIf(pExcludeFilter @<> ''); \n    If( SCAN(pDelim,\
    \ pExcludeFilter) > 0);\n        # parse multiple exclusions\n        While(LONG(pExcludeFilter) >\
    \ 0);\n            If(SCAN(pDelim, pExcludeFilter) > 0);\n                sExcludePart = TRIM(SUBST(pExcludeFilter,\
    \ 1, SCAN(pDelim, pExcludeFilter) - 1));\n                pExcludeFilter = TRIM(DELET(pExcludeFilter,\
    \ 1,SCAN(pDelim, pExcludeFilter) + LONG(pDelim) - 1));\n            Else;\n                sExcludePart\
    \ = pExcludeFilter;\n                pExcludeFilter = '';\n            EndIf;\n            ASCIIOUTPUT(\
    \ sFileNameExclude, sExcludeWCPrefix | sExcludePart);\n        End;\n    Else;\n        ASCIIOUTPUT(\
    \ sFileNameExclude, sExcludeWCPrefix | pExcludeFilter);\n    EndIf;\nElse;\n    ASCIIOUTPUT( sFileNameExclude,\
    \ '');\nEndIf;\n\n### Create Batch File ###\nsFileName = 'Bedrock.Server.DataDir.Backup.bat';\nIf(sOS\
    \ @= 'Windows');\n  If(pSubDirCopy = 1);\n  \tcSubDirCopy = '/s /e';\n  Else;\n  \tcSubDirCopy = '';\n\
    \  EndIf;\n  If(pRobocopy = 1);\n  \tsText = 'robocopy ''| pSrcDir |'' ''| sBackupDir | '' '  | cSubDirCopy\
    \ | ' /job:''| sFileNameExclude | ''';\n  Else;\n  \tsText = 'XCOPY ''| pSrcDir |'' ''| sBackupDir|''\
    \ /i /c '| cSubDirCopy |' /y /exclude:'| sFileNameExclude;\n  EndIf;\n  ASCIIOUTPUT( sFileName, '@ECHO\
    \ OFF');\n  ASCIIOUTPUT( sFileName, sText );\nElse;\n  #sOS is Linux\n  If(pSubDirCopy = 1);\n  \t\
    cSubDirCopy = 'r';\n  Else;\n  \tcSubDirCopy = '';\n  EndIf;\n  sText = 'rsync -' | cSubDirCopy |\
    \ 't --exclude-from=' | sFileNameExclude | ' '' | pSrcDir | '' '' | sBackupDir |''';\nEndIf;\n\nsMessage\
    \ = 'Command Line: ' | sText;\nIf( pLogoutput = 1 );\n\tLogOutput('INFO', sMessage ); \nEndIf;\n\n\
    ### End Prolog ###\n#Section Metadaten\n\n#Section Daten\n\n#Section Epilog\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n# Create backup directory\nIf(sOS @= 'Windows');\n\
    \  ExecuteCommand ( 'Bedrock.MkDir.bat', 1 );\nElse;\n  ExecuteCommand ( 'mkdir '' | sBackupDir |''',\
    \ 1);\nEndIf;\n# Ensure backup directory created else abort\nIf( FileExists( sBackupDir ) = 0 );\n\
    \    nErrors = 1;\n    sMessage = 'Process Quit: Could not create backup directory: ' | sBackupDir;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    ProcessQuit;\nELSE;\n      sMessage\
    \ = 'Backup directory exists: ' | sBackupDir;\n      LogOutput('INFO', sMessage ); \nEndIf;\n\n###\
    \ Copy Data Dir to Backup ###\nIf(sOS @= 'Windows');\n  ExecuteCommand ( 'Bedrock.Server.DataDir.Backup.bat',\
    \ 1 );\nElse;\n  ExecuteCommand ( sText, 1 );\nEndIf;\n\n### Delete temporary files ###\nsFileName\
    \ = 'Bedrock.Server.DataDir.Backup.bat' ;\nASCIIDelete( LOWER(sFileName) );\nsFileName = 'Bedrock.MkDir.bat';\n\
    ASCIIDelete( LOWER(sFileName) );\nsFileName = sFileNameExclude;\nASCIIDelete( LOWER(sFileNameExclude)\
    \ );\n\nsMessage = 'Temporary files deleted.';\nIf( pLogoutput = 1 );\n \tLogOutput('INFO', sMessage\
    \ ); \nEndIf;\n\n### Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage\
    \ = 'the process incurred at least 1 error. Please see above lines in this file for more details.';\n\
    \    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log\
    \ for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n\
    \    sProcessAction = Expand( 'Process:%cThisProcName% successfully Backed up Dir %pSrcDir% to dir\
    \ %pTgtDir%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n  \
    \  nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der alle Dateien und Prozesse im Datenverzeichnis
    auflistet und die Ausgabe als Textdatei im selben Verzeichnis speichert. Der Prozess sollte für die
    Produktionsumgebung geeignet sein und eine Auflistung von Dateien in jedem Ordner ermöglichen. Beachte,
    dass der TI-Prozess zuerst eine Batch-Datei erstellt, die verschiedene Objekttypen separat auflistet
    und sie dann ausführt. In einigen Fällen muss der Pfad zur Batch-Datei im Datenverzeichnis vollständig
    qualifiziert sein. Die Batch-Datei wird im Epilog gelöscht.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will list all files and processes in the data directory\
    \ as text file output in the data directory itself.\n\n# Use case: Intended for production.\n# 1/\
    \ Obtain a listing of files in any folder.\n\n# Note:\n# The TI 1st creates a batch file that will\
    \ list all the different type of objects seperately and then executes it.\n# In some cases the path\
    \ to the batch file (in the data directory) must be fully qualified.\n# The batch file is deleted\
    \ in Epilog.\n#EndRegion @DOC\n\n### TO DELETE - just included as temp measure so process compiles\n\
    pDebug = 0;\n### TO DELETE - just included as temp measure so process compiles\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName           = TM1User();\n\
    cTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pSrcDir:%pSrcDir%.'\
    \ ;  \n#cDebugFile = GetProcessErrorFileDirectory | cProcess | '.' | cTimeStamp | '.' | sRandomInt\
    \ ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':'\
    \ );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0\
    \ );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n\
    If( sOS @= 'Linux' );\n  cBatchFile = LOWER(cThisProcName) | '.sh';\nElse;\n  cBatchFile = cThisProcName\
    \ | '.bat';\nEndIf;\n\n### Build Command ###\nnErrors         = 0;\n\nIf( pSrcDir @= '' );\n    #\
    \ If no data directory provided then use current directory\n    sCommand    = cBatchFile;\nElse;\n\
    \    # Trim off trailing backslash if present\n    If( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @= sOSDelim\
    \ );\n        pSrcDir = SubSt( pSrcDir, 1, Long( pSrcDir ) - 1 );\n    EndIf;\n    # Check that data\
    \ directory exists\n    If( FileExists( pSrcDir ) = 0 );\n        nErrors  = 1;\n        sMessage\
    \ = 'Data directory does not exist: ' | pSrcDir;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        sCommand = pSrcDir | sOSDelim | cBatchFile;\n    EndIf;\nEndIf;\n\n###\
    \ Create Batch File ###\nDatasourceASCIIQuoteCharacter='';\nIf( sOS @= 'Windows');\n  ASCIIOUTPUT(\
    \ sCommand, 'dir /b /s *.* > List_All_Data_Directory_Files.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b\
    \ /s }*.* > List_All_Control_Objects.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b *.cub > List_All_Cubes.txt');\n\
    \  \n  ASCIIOUTPUT( sCommand, 'dir /b *.dim > List_All_Dimensions.txt');\n  ASCIIOUTPUT( sCommand,\
    \ 'dir /b *.pro > List_All_Processes.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b *.cho > List_All_Chores.txt');\n\
    \  ASCIIOUTPUT( sCommand, 'dir /b *Bedrock*.pro > List_All_Bedrock_Processes.txt');\n  \n  ASCIIOUTPUT(\
    \ sCommand, 'dir /b /s *.vue > List_All_Views.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b /s *.sub >\
    \ List_All_Subsets.txt');\nElse;\n  ASCIIOUTPUT( sCommand, 'find '$PWD' -type f > List_All_Data_Directory_Files.txt\
    \ ;');\n  ASCIIOUTPUT( sCommand, 'find '$PWD' -type f -name '}*' > List_All_Control_Objects.txt ;');\n\
    \  ASCIIOUTPUT( sCommand, 'find '$PWD' -type f -name '*.cub' > List_All_Cubes.txt ;');\n  \n  ASCIIOUTPUT(\
    \ sCommand, 'find '$PWD' -type f -name '*.dim' > List_All_Dimensions.txt ;');\n  ASCIIOUTPUT( sCommand,\
    \ 'find '$PWD' -type f -name '*.pro' > List_All_Processes.txt ;');\n  ASCIIOUTPUT( sCommand, 'find\
    \ '$PWD' -type f -name '*.cho' > List_All_Chores.txt ;');\n  ASCIIOUTPUT( sCommand, 'find '$PWD' -type\
    \ f -iname '*Bedrock*.pro' > List_All_Bedrock_Processes.txt ;');\n  \n  ASCIIOUTPUT( sCommand, 'find\
    \ '$PWD' -type f -name '*.vue' > List_All_Views.txt ;');\n  ASCIIOUTPUT( sCommand, 'find '$PWD' -type\
    \ f -name '*.sub' > List_All_Subsets.txt ;');\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### VALIDATION ###\n# Check that batch file\
    \ exists\nIf( FileExists( sCommand ) = 0 );\n    nErrors = 1;\n    sMessage = 'Batch file not found:\
    \ ' | sCommand;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Execute\
    \ Batch File ###\nIf( nErrors = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand ( sCommand, 1 );\n\
    \  Else;\n    ExecuteCommand ( 'sh ' | sCommand, 1 );\n  EndIf;\nEndIf;\n\n### Delete temporary batch\
    \ file\nASCIIDelete ( sCommand );\n\n### Return code & final error message handling\nIf( nErrors >\
    \ 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully listed contents\
    \ from %pSrcDir% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that lists all files and processes in the data directory
    and outputs them as a text file in the same directory. The process should be suitable for a production
    environment and allow for listing files in any folder. Note that the TI first creates a batch file
    that lists different types of objects separately and then executes it. In some instances, the path
    to the batch file in the data directory must be fully qualified. The batch file is deleted in the
    epilog.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will list all files and processes in the data directory\
    \ as text file output in the data directory itself.\n\n# Use case: Intended for production.\n# 1/\
    \ Obtain a listing of files in any folder.\n\n# Note:\n# The TI 1st creates a batch file that will\
    \ list all the different type of objects seperately and then executes it.\n# In some cases the path\
    \ to the batch file (in the data directory) must be fully qualified.\n# The batch file is deleted\
    \ in Epilog.\n#EndRegion @DOC\n\n### TO DELETE - just included as temp measure so process compiles\n\
    pDebug = 0;\n### TO DELETE - just included as temp measure so process compiles\n\n### Global Variables\n\
    StringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode=\
    \ 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName           = TM1User();\n\
    cTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT(\
    \ RAND( ) * 1000 ));\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pSrcDir:%pSrcDir%.'\
    \ ;  \n#cDebugFile = GetProcessErrorFileDirectory | cProcess | '.' | cTimeStamp | '.' | sRandomInt\
    \ ;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );\
    \   \nENDIF;\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':'\
    \ );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0\
    \ );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n\
    If( sOS @= 'Linux' );\n  cBatchFile = LOWER(cThisProcName) | '.sh';\nElse;\n  cBatchFile = cThisProcName\
    \ | '.bat';\nEndIf;\n\n### Build Command ###\nnErrors         = 0;\n\nIf( pSrcDir @= '' );\n    #\
    \ If no data directory provided then use current directory\n    sCommand    = cBatchFile;\nElse;\n\
    \    # Trim off trailing backslash if present\n    If( SubSt( pSrcDir, Long( pSrcDir ), 1 ) @= sOSDelim\
    \ );\n        pSrcDir = SubSt( pSrcDir, 1, Long( pSrcDir ) - 1 );\n    EndIf;\n    # Check that data\
    \ directory exists\n    If( FileExists( pSrcDir ) = 0 );\n        nErrors  = 1;\n        sMessage\
    \ = 'Data directory does not exist: ' | pSrcDir;\n        LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    Else;\n        sCommand = pSrcDir | sOSDelim | cBatchFile;\n    EndIf;\nEndIf;\n\n###\
    \ Create Batch File ###\nDatasourceASCIIQuoteCharacter='';\nIf( sOS @= 'Windows');\n  ASCIIOUTPUT(\
    \ sCommand, 'dir /b /s *.* > List_All_Data_Directory_Files.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b\
    \ /s }*.* > List_All_Control_Objects.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b *.cub > List_All_Cubes.txt');\n\
    \  \n  ASCIIOUTPUT( sCommand, 'dir /b *.dim > List_All_Dimensions.txt');\n  ASCIIOUTPUT( sCommand,\
    \ 'dir /b *.pro > List_All_Processes.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b *.cho > List_All_Chores.txt');\n\
    \  ASCIIOUTPUT( sCommand, 'dir /b *Bedrock*.pro > List_All_Bedrock_Processes.txt');\n  \n  ASCIIOUTPUT(\
    \ sCommand, 'dir /b /s *.vue > List_All_Views.txt');\n  ASCIIOUTPUT( sCommand, 'dir /b /s *.sub >\
    \ List_All_Subsets.txt');\nElse;\n  ASCIIOUTPUT( sCommand, 'find '$PWD' -type f > List_All_Data_Directory_Files.txt\
    \ ;');\n  ASCIIOUTPUT( sCommand, 'find '$PWD' -type f -name '}*' > List_All_Control_Objects.txt ;');\n\
    \  ASCIIOUTPUT( sCommand, 'find '$PWD' -type f -name '*.cub' > List_All_Cubes.txt ;');\n  \n  ASCIIOUTPUT(\
    \ sCommand, 'find '$PWD' -type f -name '*.dim' > List_All_Dimensions.txt ;');\n  ASCIIOUTPUT( sCommand,\
    \ 'find '$PWD' -type f -name '*.pro' > List_All_Processes.txt ;');\n  ASCIIOUTPUT( sCommand, 'find\
    \ '$PWD' -type f -name '*.cho' > List_All_Chores.txt ;');\n  ASCIIOUTPUT( sCommand, 'find '$PWD' -type\
    \ f -iname '*Bedrock*.pro' > List_All_Bedrock_Processes.txt ;');\n  \n  ASCIIOUTPUT( sCommand, 'find\
    \ '$PWD' -type f -name '*.vue' > List_All_Views.txt ;');\n  ASCIIOUTPUT( sCommand, 'find '$PWD' -type\
    \ f -name '*.sub' > List_All_Subsets.txt ;');\nEndIf;\n\n### End Prolog ###\n#Section Metadaten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### VALIDATION ###\n# Check that batch file\
    \ exists\nIf( FileExists( sCommand ) = 0 );\n    nErrors = 1;\n    sMessage = 'Batch file not found:\
    \ ' | sCommand;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Execute\
    \ Batch File ###\nIf( nErrors = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand ( sCommand, 1 );\n\
    \  Else;\n    ExecuteCommand ( 'sh ' | sCommand, 1 );\n  EndIf;\nEndIf;\n\n### Delete temporary batch\
    \ file\nASCIIDelete ( sCommand );\n\n### Return code & final error message handling\nIf( nErrors >\
    \ 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in this file\
    \ for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName% completed with\
    \ errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit;\
    \ \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName% successfully listed contents\
    \ from %pSrcDir% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n\
    \    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der alle Dateien in einem Verzeichnis entschlüsselt,
    indem das Dienstprogramm tm1crypt verwendet wird. Berücksichtige dabei den Anwendungsfall, dass mehrere
    Dateien in einem Verzeichnis verschlüsselt oder entschlüsselt werden sollen, und es Unterprozesse
    aufruft. Beachte: Die generierten Befehle funktionieren nur, wenn die TM1-Instanz verschlüsselt ist.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process unencrypts all files existing in a directory,\
    \ using the tm1crypt utility\n\n# Use case: To encrypts / unencrypts multile file in a directory.\
    \ Calls sub-process.\n\n\n# Note: Generated commands will only work when the TM1 isntance is entrypted\n\
    # \n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp \
    \         = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pType:%pType%, pDirectory:%pDirectory%, pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%,\
    \ pTM1CryptLocation:%pTM1CryptLocation%, pAction:%pAction%.' ;  \ncMsgInfoContent     = 'User:%cUserName%\
    \ Process:%cThisProcName% InfoMsg:%sMessage%';\nnDataCount        = 0;\nnErrors           = 0;\n\n\
    ## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \n### Validate Parameters ###\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n## Validate the source directory\nIf ( pDirectory @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'pDirectory is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;\nsSourcePath = pDirectory;\nIf ( SubSt ( pDirectory, Long ( pDirectory ), 1 ) @<> sOSDelim\
    \ );\n  sSourcePath = sSourcePath | sOSDelim;\nEndIf;\n\n## Validate the action\nsAction = '';\nIf\
    \ ( pAction @= '4' % pAction @= '5');\n    sAction = pAction;\nELSE;\n    nErrors         = 1;\n \
    \   sMessage        = 'Specified Action is not valid';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate config and exe\nIf ( FileExists( pConfigLocation ) = 0 );\n    nErrors\
    \         = 1;\n    sMessage        = 'Specified config file not found';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\nIf ( FileExists( pTM1CryptLocation ) = 0 );\n    nErrors\
    \         = 1;\n    sMessage        = 'Specified tm1crypt file not found';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n## Validate the dest path\nsDestPath = pDestPath;\nIf\
    \ ( pDestPath @= '' );\n    sMessage        = 'pDestPath is Blank, using logging dir';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\nEndIf;\n\
    If ( SubSt ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath | sOSDelim;\n\
    EndIf;\n\nIf ( sDestPath @= sSourcePath );\n    nErrors         = 1;\n    sMessage        = 'Destination\
    \ is the same as source';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsFile = '';\nsPrev = '';\n\
    sFile = WildcardFileSearch( sSourcePath | '****' | pType , sPrev);\n\nWhile ( sFile @<> '' );\n  IF(\
    \ pLogoutput = 1 );\n      sMessage = 'Processing file: ' | sFile;\n      LogOutput('INFO', Expand(\
    \ cMsgInfoContent ) );\n  ENDIF;\n  nRet = ExecuteProcess('}bedrock.server.encrypt.file',\n     'pSourcePath',\
    \ sSourcePath,\n     'pSourceFile', sFile,\n     'pDestPath', sDestPath,\n     'pConfigLocation',\
    \ pConfigLocation,\n     'pTM1CryptLocation', pTM1CryptLocation,\n     'pAction', pAction\n    );\n\
    \  If( nRet <> ProcessExitNormal() );\n      nErrors = nErrors + 1;\n      sMessage= 'Error in processing\
    \ file: %sFile%.';\n      DataSourceType = 'NULL';\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  EndIf;\n  sPrev = sFile;\n  sFile = WildcardFileSearch( sSourcePath | '*' | pType , sPrev);\n\
    End;  \n  \n#Section Metadaten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section\
    \ Epilog\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully processed directory %pDirectory%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that unencrypts all files in a directory using the
    tm1crypt utility. Consider the use case of encrypting or unencrypting multiple files in a directory
    and calling sub-processes. Note: The generated commands will only work when the TM1 instance is encrypted.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process unencrypts all files existing in a directory,\
    \ using the tm1crypt utility\n\n# Use case: To encrypts / unencrypts multile file in a directory.\
    \ Calls sub-process.\n\n\n# Note: Generated commands will only work when the TM1 isntance is entrypted\n\
    # \n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncTimeStamp \
    \         = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt          = NumberToString( INT( RAND(\
    \ ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent\
    \    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName%\
    \ run with parameters pType:%pType%, pDirectory:%pDirectory%, pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%,\
    \ pTM1CryptLocation:%pTM1CryptLocation%, pAction:%pAction%.' ;  \ncMsgInfoContent     = 'User:%cUserName%\
    \ Process:%cThisProcName% InfoMsg:%sMessage%';\nnDataCount        = 0;\nnErrors           = 0;\n\n\
    ## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\
    \n### Validate Parameters ###\n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n## Validate the source directory\nIf ( pDirectory @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'pDirectory is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;\nsSourcePath = pDirectory;\nIf ( SubSt ( pDirectory, Long ( pDirectory ), 1 ) @<> sOSDelim\
    \ );\n  sSourcePath = sSourcePath | sOSDelim;\nEndIf;\n\n## Validate the action\nsAction = '';\nIf\
    \ ( pAction @= '4' % pAction @= '5');\n    sAction = pAction;\nELSE;\n    nErrors         = 1;\n \
    \   sMessage        = 'Specified Action is not valid';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n## Validate config and exe\nIf ( FileExists( pConfigLocation ) = 0 );\n    nErrors\
    \         = 1;\n    sMessage        = 'Specified config file not found';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\nIf ( FileExists( pTM1CryptLocation ) = 0 );\n    nErrors\
    \         = 1;\n    sMessage        = 'Specified tm1crypt file not found';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n## Validate the dest path\nsDestPath = pDestPath;\nIf\
    \ ( pDestPath @= '' );\n    sMessage        = 'pDestPath is Blank, using logging dir';\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\nEndIf;\n\
    If ( SubSt ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath | sOSDelim;\n\
    EndIf;\n\nIf ( sDestPath @= sSourcePath );\n    nErrors         = 1;\n    sMessage        = 'Destination\
    \ is the same as source';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\
    \n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n\
    \      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsFile = '';\nsPrev = '';\n\
    sFile = WildcardFileSearch( sSourcePath | '****' | pType , sPrev);\n\nWhile ( sFile @<> '' );\n  IF(\
    \ pLogoutput = 1 );\n      sMessage = 'Processing file: ' | sFile;\n      LogOutput('INFO', Expand(\
    \ cMsgInfoContent ) );\n  ENDIF;\n  nRet = ExecuteProcess('}bedrock.server.encrypt.file',\n     'pSourcePath',\
    \ sSourcePath,\n     'pSourceFile', sFile,\n     'pDestPath', sDestPath,\n     'pConfigLocation',\
    \ pConfigLocation,\n     'pTM1CryptLocation', pTM1CryptLocation,\n     'pAction', pAction\n    );\n\
    \  If( nRet <> ProcessExitNormal() );\n      nErrors = nErrors + 1;\n      sMessage= 'Error in processing\
    \ file: %sFile%.';\n      DataSourceType = 'NULL';\n      LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\n  EndIf;\n  sPrev = sFile;\n  sFile = WildcardFileSearch( sSourcePath | '*' | pType , sPrev);\n\
    End;  \n  \n#Section Metadaten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section\
    \ Epilog\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully processed directory %pDirectory%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Beschreibe einen IBM Turbo Integrator Prozess, der die Verschlüsselung und Entschlüsselung
    einer Datei unter Verwendung des tm1crypt-Dienstprogramms durchführt. Der Prozess sollte eine einzelne
    Datei zum Verschlüsseln oder Entschlüsseln verwenden können. Beachte, dass die generierten Befehle
    nur funktionieren, wenn die TM1-Instanz verschlüsselt ist.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process encrypts / unencrypts a file using the\
    \ tm1crypt utility\n# Use case: To encrypts / unencrypts a single file\n# Note: Generated commands\
    \ will only work when the TM1 isntance is entrypted\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pSourcePath:%pSourcePath%, pSourceFile:%pSourceFile%,\
    \ pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%, pTM1CryptLocation:%pTM1CryptLocation%,\
    \ pAction:%pAction%.' ;  \ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\n\
    nDataCount        = 0;\nnErrors           = 0;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n## check\
    \ operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## Validate the action\nsAction =\
    \ '';\nIf ( pAction @= '4' % pAction @= '5');\n    sAction = pAction;\nELSE;\n    nErrors        \
    \ = 1;\n    sMessage        = 'Specified Action is not valid';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n## Validate config and exe\nIf ( FileExists( pConfigLocation )\
    \ = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified config file not found';\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nIf ( FileExists( pTM1CryptLocation\
    \ ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified tm1crypt file not found';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\n## Validate the source\
    \ file/path and dest file/path\nIf ( pSourcePath @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'pSourcePath is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;\nsSourcePath = pSourcePath;\nIf ( SubSt ( pSourcePath, Long ( pSourcePath ), 1 ) @<> sOSDelim\
    \ );\n  sSourcePath = sSourcePath | sOSDelim;\nEndIf;\n\nsDestPath = pDestPath;\nIf ( pDestPath @=\
    \ '' );\n    sMessage        = 'pDestPath is Blank, using logging dir';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\nEndIf;\nIf ( SubSt\
    \ ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath | sOSDelim;\nEndIf;\n\
    \nIf ( pSourceFile @= '' );\n    nErrors         = 1;\n    sMessage        = 'pSourceFile is Blank';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsFileSrc = sSourcePath | pSourceFile;\n\
    \nIf ( FileExists( sFileSrc ) = 0 );\n    nErrors         = 1;\n    sMessage        = '%sFileSrc%\
    \ not found';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nsFileDest\
    \ = sDestPath;\nIf ( SubSt ( sFileDest, Long ( sFileDest ), 1 ) @= sOSDelim );\n  sFileDest = SubSt\
    \ ( sFileDest, 1, Long ( sFileDest ) - 1 );\nEndIf;\n\nIf ( sFileDest @= sSourcePath );\n    nErrors\
    \         = 1;\n    sMessage        = 'Destination is the same as source';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n## Create contents of the bat file\n\nDatasourceASCIIQuoteCharacter= '';\n\nsBat = ''' |\
    \ pTM1CryptLocation | '' -i '' | pConfigLocation | '' -action ' | sAction | ' -filesrc '' | sFileSrc\
    \ | '' -filedest '' | sFileDest |''';\nIf( sOS @= 'Windows' );\n    sBatFile = sDestPath | pSourceFile\
    \ | '.bat';\nElse;\n    sBatFile = sDestPath | pSourceFile | '.sh';\nEndIf;\nASCIIOutput( sBatFile,\
    \ sBat);\n\n#Section Metadaten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section\
    \ Epilog\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Run that\
    \ bat file\n\nIf( nErrors = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand( sBatfile, 1 );\n  Else;\n\
    \    ExecuteCommand ( 'sh ' | sBatfile, 1 );\n  EndIf;\n  ASCIIDelete( sBatFile );\nEndIf;\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully processed file %pSourceFile%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Describe an IBM Turbo Integrator process that performs the encryption and decryption of a
    file using the tm1crypt utility. The process should be able to encrypt or decrypt a single file. Note
    that the generated commands will only work when the TM1 instance is encrypted.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process encrypts / unencrypts a file using the\
    \ tm1crypt utility\n# Use case: To encrypts / unencrypts a single file\n# Note: Generated commands\
    \ will only work when the TM1 isntance is entrypted\n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pSourcePath:%pSourcePath%, pSourceFile:%pSourceFile%,\
    \ pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%, pTM1CryptLocation:%pTM1CryptLocation%,\
    \ pAction:%pAction%.' ;  \ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\n\
    nDataCount        = 0;\nnErrors           = 0;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n## check\
    \ operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## Validate the action\nsAction =\
    \ '';\nIf ( pAction @= '4' % pAction @= '5');\n    sAction = pAction;\nELSE;\n    nErrors        \
    \ = 1;\n    sMessage        = 'Specified Action is not valid';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n## Validate config and exe\nIf ( FileExists( pConfigLocation )\
    \ = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified config file not found';\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nIf ( FileExists( pTM1CryptLocation\
    \ ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified tm1crypt file not found';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\n## Validate the source\
    \ file/path and dest file/path\nIf ( pSourcePath @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'pSourcePath is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;\nsSourcePath = pSourcePath;\nIf ( SubSt ( pSourcePath, Long ( pSourcePath ), 1 ) @<> sOSDelim\
    \ );\n  sSourcePath = sSourcePath | sOSDelim;\nEndIf;\n\nsDestPath = pDestPath;\nIf ( pDestPath @=\
    \ '' );\n    sMessage        = 'pDestPath is Blank, using logging dir';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\nEndIf;\nIf ( SubSt\
    \ ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath | sOSDelim;\nEndIf;\n\
    \nIf ( pSourceFile @= '' );\n    nErrors         = 1;\n    sMessage        = 'pSourceFile is Blank';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsFileSrc = sSourcePath | pSourceFile;\n\
    \nIf ( FileExists( sFileSrc ) = 0 );\n    nErrors         = 1;\n    sMessage        = '%sFileSrc%\
    \ not found';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nsFileDest\
    \ = sDestPath;\nIf ( SubSt ( sFileDest, Long ( sFileDest ), 1 ) @= sOSDelim );\n  sFileDest = SubSt\
    \ ( sFileDest, 1, Long ( sFileDest ) - 1 );\nEndIf;\n\nIf ( sFileDest @= sSourcePath );\n    nErrors\
    \         = 1;\n    sMessage        = 'Destination is the same as source';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n## Create contents of the bat file\n\nDatasourceASCIIQuoteCharacter= '';\n\nsBat = ''' |\
    \ pTM1CryptLocation | '' -i '' | pConfigLocation | '' -action ' | sAction | ' -filesrc '' | sFileSrc\
    \ | '' -filedest '' | sFileDest |''';\nIf( sOS @= 'Windows' );\n    sBatFile = sDestPath | pSourceFile\
    \ | '.bat';\nElse;\n    sBatFile = sDestPath | pSourceFile | '.sh';\nEndIf;\nASCIIOutput( sBatFile,\
    \ sBat);\n\n#Section Metadaten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section\
    \ Epilog\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Run that\
    \ bat file\n\nIf( nErrors = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand( sBatfile, 1 );\n  Else;\n\
    \    ExecuteCommand ( 'sh ' | sBatfile, 1 );\n  EndIf;\n  ASCIIDelete( sBatFile );\nEndIf;\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully processed file %pSourceFile%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der die Verschlüsselung bzw. Entschlüsselung
    einer Datei unter Verwendung des tm1crypt-Dienstprogramms ermöglicht. Der Anwendungsfall besteht darin,
    eine einzelne Datei zu verschlüsseln oder zu entschlüsseln. Beachte, dass die generierten Befehle
    nur funktionieren, wenn die TM1-Instanz verschlüsselt ist.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process encrypts / unencrypts a file using the\
    \ tm1crypt utility\n\n# Use case: To encrypts / unencrypts a single file\n\n# Note: Generated commands\
    \ will only work when the TM1 isntance is entrypted\n# \n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pSourcePath:%pSourcePath%, pSourceFile:%pSourceFile%,\
    \ pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%, pTM1CryptLocation:%pTM1CryptLocation%,\
    \ pAction:%pAction%.' ;  \ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\n\
    nDataCount        = 0;\nnErrors           = 0;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n## check\
    \ operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## Validate the action\nsAction =\
    \ '';\nIf ( pAction @= '4' % pAction @= '5');\n    sAction = pAction;\nELSE;\n    nErrors        \
    \ = 1;\n    sMessage        = 'Specified Action is not valid';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n## Validate config and exe\nIf ( FileExists( pConfigLocation )\
    \ = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified config file not found';\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nIf ( FileExists( pTM1CryptLocation\
    \ ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified tm1crypt file not found';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\n## Validate the source\
    \ file/path and dest file/path\nIf ( pSourcePath @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'pSourcePath is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;\nsSourcePath = pSourcePath;\nIf ( SubSt ( pSourcePath, Long ( pSourcePath ), 1 ) @<> sOSDelim\
    \ );\n  sSourcePath = sSourcePath | sOSDelim;\nEndIf;\n\nsDestPath = pDestPath;\nIf ( pDestPath @=\
    \ '' );\n    sMessage        = 'pDestPath is Blank, using logging dir';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\nEndIf;\nIf ( SubSt\
    \ ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath | sOSDelim;\nEndIf;\n\
    \nIf ( pSourceFile @= '' );\n    nErrors         = 1;\n    sMessage        = 'pSourceFile is Blank';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsFileSrc = sSourcePath | pSourceFile;\n\
    \nIf ( FileExists( sFileSrc ) = 0 );\n    nErrors         = 1;\n    sMessage        = '%sFileSrc%\
    \ not found';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nsFileDest\
    \ = sDestPath;\nIf ( SubSt ( sFileDest, Long ( sFileDest ), 1 ) @= sOSDelim );\n  sFileDest = SubSt\
    \ ( sFileDest, 1, Long ( sFileDest ) - 1 );\nEndIf;\n\nIf ( sFileDest @= sSourcePath );\n    nErrors\
    \         = 1;\n    sMessage        = 'Destination is the same as source';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n## Create contents of the bat file\n\nDatasourceASCIIQuoteCharacter= '';\n\nsBat = ''' |\
    \ pTM1CryptLocation | '' -i '' | pConfigLocation | '' -action ' | sAction | ' -filesrc '' | sFileSrc\
    \ | '' -filedest '' | sFileDest |''';\nIf( sOS @= 'Windows' );\n    sBatFile = sDestPath | pSourceFile\
    \ | '.bat';\nElse;\n    sBatFile = sDestPath | pSourceFile | '.sh';\nEndIf;\nASCIIOutput( sBatFile,\
    \ sBat);\n\n#Section Metadaten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section\
    \ Epilog\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Run that\
    \ bat file\n\nIf( nErrors = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand( sBatfile, 1 );\n  Else;\n\
    \    ExecuteCommand ( 'sh ' | sBatfile, 1 );\n  EndIf;\n  ASCIIDelete( sBatFile );\nEndIf;\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully processed file %pSourceFile%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Develop an IBM Turbo Integrator process that enables the encryption or decryption of a file
    using the tm1crypt utility. The use case is to encrypt or decrypt a single file. Note that the generated
    commands will only work when the TM1 instance is encrypted.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process this process encrypts / unencrypts a file using the\
    \ tm1crypt utility\n\n# Use case: To encrypts / unencrypts a single file\n\n# Note: Generated commands\
    \ will only work when the TM1 isntance is entrypted\n# \n#EndRegion @DOC\n\n##Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \       = GetProcessName();\ncTimeStamp          = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt\
    \          = NumberToString( INT( RAND( ) * 1000 ));\ncUserName           = TM1User();\ncMsgErrorLevel\
    \      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo            = 'Process:%cThisProcName% run with parameters pSourcePath:%pSourcePath%, pSourceFile:%pSourceFile%,\
    \ pDestPath:%pDestPath%, pConfigLocation:%pConfigLocation%, pTM1CryptLocation:%pTM1CryptLocation%,\
    \ pAction:%pAction%.' ;  \ncMsgInfoContent    = 'User:%cUserName% Process:%cThisProcName% InfoMsg:%sMessage%';\n\
    nDataCount        = 0;\nnErrors           = 0;\n\n## LogOutput parameters\nIF( pLogoutput = 1 );\n\
    \    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\n## check\
    \ operating system\nIf( SubSt( GetProcessErrorFileDirectory, 2, 1 ) @= ':' );\n  sOS = 'Windows';\n\
    \  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory ) > 0 );\n  sOS = 'Linux';\n  sOSDelim\
    \ = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\n## Validate the action\nsAction =\
    \ '';\nIf ( pAction @= '4' % pAction @= '5');\n    sAction = pAction;\nELSE;\n    nErrors        \
    \ = 1;\n    sMessage        = 'Specified Action is not valid';\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\nEndIf;\n\n## Validate config and exe\nIf ( FileExists( pConfigLocation )\
    \ = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified config file not found';\n   \
    \ LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nIf ( FileExists( pTM1CryptLocation\
    \ ) = 0 );\n    nErrors         = 1;\n    sMessage        = 'Specified tm1crypt file not found';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\n## Validate the source\
    \ file/path and dest file/path\nIf ( pSourcePath @= '' );\n    nErrors         = 1;\n    sMessage\
    \        = 'pSourcePath is Blank';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    Endif;\nsSourcePath = pSourcePath;\nIf ( SubSt ( pSourcePath, Long ( pSourcePath ), 1 ) @<> sOSDelim\
    \ );\n  sSourcePath = sSourcePath | sOSDelim;\nEndIf;\n\nsDestPath = pDestPath;\nIf ( pDestPath @=\
    \ '' );\n    sMessage        = 'pDestPath is Blank, using logging dir';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sDestPath = GetProcessErrorFileDirectory;\nEndIf;\nIf ( SubSt\
    \ ( sDestPath, Long ( sDestPath ), 1 ) @<> sOSDelim );\n  sDestPath = sDestPath | sOSDelim;\nEndIf;\n\
    \nIf ( pSourceFile @= '' );\n    nErrors         = 1;\n    sMessage        = 'pSourceFile is Blank';\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;\nsFileSrc = sSourcePath | pSourceFile;\n\
    \nIf ( FileExists( sFileSrc ) = 0 );\n    nErrors         = 1;\n    sMessage        = '%sFileSrc%\
    \ not found';\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndif;  \n\nsFileDest\
    \ = sDestPath;\nIf ( SubSt ( sFileDest, Long ( sFileDest ), 1 ) @= sOSDelim );\n  sFileDest = SubSt\
    \ ( sFileDest, 1, Long ( sFileDest ) - 1 );\nEndIf;\n\nIf ( sFileDest @= sSourcePath );\n    nErrors\
    \         = 1;\n    sMessage        = 'Destination is the same as source';\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\nEndif;  \n\n### Check for errors before continuing\nIf( nErrors <>\
    \ 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\n\
    EndIf;\n\n## Create contents of the bat file\n\nDatasourceASCIIQuoteCharacter= '';\n\nsBat = ''' |\
    \ pTM1CryptLocation | '' -i '' | pConfigLocation | '' -action ' | sAction | ' -filesrc '' | sFileSrc\
    \ | '' -filedest '' | sFileDest |''';\nIf( sOS @= 'Windows' );\n    sBatFile = sDestPath | pSourceFile\
    \ | '.bat';\nElse;\n    sBatFile = sDestPath | pSourceFile | '.sh';\nEndIf;\nASCIIOutput( sBatFile,\
    \ sBat);\n\n#Section Metadaten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    #Section Daten\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section\
    \ Epilog\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Run that\
    \ bat file\n\nIf( nErrors = 0 );\n  If(sOS @= 'Windows');\n    ExecuteCommand( sBatfile, 1 );\n  Else;\n\
    \    ExecuteCommand ( 'sh ' | sBatfile, 1 );\n  EndIf;\n  ASCIIDelete( sBatFile );\nEndIf;\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully processed file %pSourceFile%.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: 'Erstelle einen IBM Turbo Integrator Prozess, der die ExecuteCommand Funktion ausführt und
    die Ausgabe in den Serverprotokollen druckt. Dieser Prozess ist für den produktiven Einsatz gedacht
    und bietet folgende Anwendungsfälle: 1) Führe die ExecuteCommand Funktion von jedem Teil des Modells
    aus, einschließlich RushTI oder einem Drittanbietersystem, ohne direkten Zugriff auf den TI-Editor.
    2) Entferne die Notwendigkeit, einen einmaligen Prozess zur Nutzung dieser Funktion zu erstellen.
    3) Komprimiere oder dekomprimiere Dateien. 4) Kopiere Dateien und Ordner vom TM1-Server. 5) Lösche
    Dateien und Ordner vom TM1-Server. 6) Liste und beende Aufgaben, die auf dem TM1-Server ausgeführt
    werden. 7) Exportiere und importiere Registrierungsschlüssel wie ODBC-Datenquellen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will run the TI ExecuteCommand function and print the\
    \ output to Server Logs.\n\n# Use case: Intended for production.\n# 1/ To run an ExecuteCommand function\
    \ from any part of the model, including RushTI or third party system without direct access to TI Editor.\n\
    # 2/ To remove the requirement of creating a one off process to use this function\n# 3/ To compress/uncompress\
    \ files\n# 4/ To copy files and folders from the TM1 server\n# 5/ To delete files and folders from\
    \ the TM1 server\n# 6/ To list and kill tasks running in the TM1 server\n# 7/ To export and import\
    \ registry keys such as ODBC data sources\n\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \ = GetProcessName();\ncUser = TM1User();\ncUserName = CellGetS('}ElementAttributes_}Clients', cUser,\
    \ '}TM1_DefaultDisplayValue');\ncUserName = IF( cUserName @<> '', cUserName, 'admin' );\ncMsgErrorLevel\
    \ = 'ERROR';\ncMsgErrorContent = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cCmdOutputDir = GetProcessErrorFileDirectory;\ncCmdOutputFile = cCmdOutputDir | GetProcessName() |\
    \ '.txt';\n\n## LogOutput parameters\nIf( pLogOutput = 1 );\n  sLogInfo = Expand('Process '%cThisProcName%'\
    \ run with parameters: pCommand: '%pCommand%', pWait: %pWait%, pPowerShell: %pPowerShell%'); \n  LogOutput\
    \ ( 'INFO', sLogInfo );\n  nStart = Now();\nEndIf;\n\n### Validate Parameters ###\nnErrors = 0;\n\
    If ( pCommand @= '' );\n  sMessage = 'parameter pCommand is blank';\n  LogOutput ( 'ERROR', sMessage\
    \ );\n  ProcessQuit;\nEndIf;\n\n### ExecuteCommand ###\n\n# Check if the pCommand parameter is enclosed\
    \ in quotes and remove it if it is\nIf( Subst(pCommand, 1, 1) @= ''' );\n  sCommand = Delet(pCommand,\
    \ 1, 1);\n  sCommand = Delet(sCommand, Long(sCommand), 1);\nElse;\n  sCommand = pCommand;\nEndIf;\n\
    \nIf( pPowerShell = 1 );\n  #Prepare the full command for Powershell\n  sCommand = 'POWERSHELL.EXE\
    \ -Command '& {' | pCommand | '}' 1> ' | cCmdOutputFile | ' 2>&1';\nElse;\n  #Prepare the full command\
    \ for Windows CMD\n  sCommand = 'CMD.EXE /C '' | sCommand | '' 1> ' | cCmdOutputFile | ' 2>&1';\n\
    EndIf;\n\n#Execute the command in the TM1 server\nExecuteCommand ( sCommand, pWait );\n\n#If pLogOutput\
    \ is true then define the command output file as data source\nIf( pLogOutput = 1 );\n  DataSourceType\
    \ = 'CHARACTERDELIMITED';\n  DatasourceNameForServer = cCmdOutputFile;\nEndIf;\n#Section Metadaten\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n# Write the command output to Server\
    \ Logs\nsLogInfo = Expand('Process '%cThisProcName%': %vCommandOutput%');\nLogOutput( 'INFO', sLogInfo);\n\
    #Section Epilog\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### LogOutput\
    \ ###\n\nIf( pLogOutput = 1 );\n    sSec     = NumberToStringEx( 86400*(Now() - nStart),'#,##0.0',\
    \ '.', ',' );\n    sLogInfo = Expand('Process '%cThisProcName%' completed in %sSec% seconds.'); \n\
    \    LogOutput( 'INFO', sLogInfo );\nEndIf;\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in\
    \ this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process '%cThisProcName%'\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process '%cThisProcName%'\
    \ completed successfully.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### Optional: Clean the command output file\n#sCommand = 'CMD.EXE\
    \ /C 'TYPE NUL > '' | cCmdOutputFile | '' '';\n#ExecuteCommand( sCommand, 0 );\n\n### End Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that executes the ExecuteCommand function and prints
    the output to the Server Logs. This process is intended for production use and offers the following
    use cases: 1) Execute the ExecuteCommand function from any part of the model, including RushTI or
    a third-party system, without direct access to the TI Editor. 2) Eliminate the need to create a one-off
    process to use this function. 3) Compress or decompress files. 4) Copy files and folders from the
    TM1 server. 5) Delete files and folders from the TM1 server. 6) List and kill tasks running on the
    TM1 server. 7) Export and import registry keys such as ODBC data sources.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will run the TI ExecuteCommand function and print the\
    \ output to Server Logs.\n\n# Use case: Intended for production.\n# 1/ To run an ExecuteCommand function\
    \ from any part of the model, including RushTI or third party system without direct access to TI Editor.\n\
    # 2/ To remove the requirement of creating a one off process to use this function\n# 3/ To compress/uncompress\
    \ files\n# 4/ To copy files and folders from the TM1 server\n# 5/ To delete files and folders from\
    \ the TM1 server\n# 6/ To list and kill tasks running in the TM1 server\n# 7/ To export and import\
    \ registry keys such as ODBC data sources\n\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \ = GetProcessName();\ncUser = TM1User();\ncUserName = CellGetS('}ElementAttributes_}Clients', cUser,\
    \ '}TM1_DefaultDisplayValue');\ncUserName = IF( cUserName @<> '', cUserName, 'admin' );\ncMsgErrorLevel\
    \ = 'ERROR';\ncMsgErrorContent = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cCmdOutputDir = GetProcessErrorFileDirectory;\ncCmdOutputFile = cCmdOutputDir | GetProcessName() |\
    \ '.txt';\n\n## LogOutput parameters\nIf( pLogOutput = 1 );\n  sLogInfo = Expand('Process '%cThisProcName%'\
    \ run with parameters: pCommand: '%pCommand%', pWait: %pWait%, pPowerShell: %pPowerShell%'); \n  LogOutput\
    \ ( 'INFO', sLogInfo );\n  nStart = Now();\nEndIf;\n\n### Validate Parameters ###\nnErrors = 0;\n\
    If ( pCommand @= '' );\n  sMessage = 'parameter pCommand is blank';\n  LogOutput ( 'ERROR', sMessage\
    \ );\n  ProcessQuit;\nEndIf;\n\n### ExecuteCommand ###\n\n# Check if the pCommand parameter is enclosed\
    \ in quotes and remove it if it is\nIf( Subst(pCommand, 1, 1) @= ''' );\n  sCommand = Delet(pCommand,\
    \ 1, 1);\n  sCommand = Delet(sCommand, Long(sCommand), 1);\nElse;\n  sCommand = pCommand;\nEndIf;\n\
    \nIf( pPowerShell = 1 );\n  #Prepare the full command for Powershell\n  sCommand = 'POWERSHELL.EXE\
    \ -Command '& {' | pCommand | '}' 1> ' | cCmdOutputFile | ' 2>&1';\nElse;\n  #Prepare the full command\
    \ for Windows CMD\n  sCommand = 'CMD.EXE /C '' | sCommand | '' 1> ' | cCmdOutputFile | ' 2>&1';\n\
    EndIf;\n\n#Execute the command in the TM1 server\nExecuteCommand ( sCommand, pWait );\n\n#If pLogOutput\
    \ is true then define the command output file as data source\nIf( pLogOutput = 1 );\n  DataSourceType\
    \ = 'CHARACTERDELIMITED';\n  DatasourceNameForServer = cCmdOutputFile;\nEndIf;\n#Section Metadaten\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n# Write the command output to Server\
    \ Logs\nsLogInfo = Expand('Process '%cThisProcName%': %vCommandOutput%');\nLogOutput( 'INFO', sLogInfo);\n\
    #Section Epilog\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### LogOutput\
    \ ###\n\nIf( pLogOutput = 1 );\n    sSec     = NumberToStringEx( 86400*(Now() - nStart),'#,##0.0',\
    \ '.', ',' );\n    sLogInfo = Expand('Process '%cThisProcName%' completed in %sSec% seconds.'); \n\
    \    LogOutput( 'INFO', sLogInfo );\nEndIf;\n\n### Return code & final error message handling\nIf(\
    \ nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines in\
    \ this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process '%cThisProcName%'\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process '%cThisProcName%'\
    \ completed successfully.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### Optional: Clean the command output file\n#sCommand = 'CMD.EXE\
    \ /C 'TYPE NUL > '' | cCmdOutputFile | '' '';\n#ExecuteCommand( sCommand, 0 );\n\n### End Epilog ###"
- question: Erstelle einen IBM Turbo Integrator Prozess, der die Lokalisierung von Würfel- und Dimensionsnamen
    übernimmt. Zusätzlich soll der Prozess optional die Attribute für angegebene Dimensionen, sowie Teilmengen
    für angegebene Dimensionen und Ansichten für angegebene Würfel lokalisieren. Beachte, dass wenn keine
    Dimensionen- oder Würfelnamen spezifiziert sind, nur die Standardlokalisierung von Würfel- und Dimensionsnamen
    durchgeführt wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process localizes cube & dimension names & optionally localizes:\n\
    # * attributes for specified dimension(s)\n# * subsets for specified dimension(s)\n# * views for specified\
    \ cube(s)\n\n# Note:\n# If no dimension or cube names are passed, then just cube & dimension names\
    \ will be localized.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\\
    m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub         \
    \ = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\nIf( Trim( pDelim ) @= '' );\n    pDelim = '&';\nEndIf;\n\nIf( pSub <> 1 );\n    pSub\
    \ = 0;\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nIF( CubeExists(\
    \ '}CubeAttributes' ) = 0 );\n    CubeAttrInsert( '', 'Caption', 'S');\nELSEIF( DimIx( '}CubeAttributes',\
    \ 'Caption' ) = 0 );\n    CubeAttrInsert( '', 'Caption', 'S');\nENDIF;\nIF( CubeExists( '}DimensionAttributes'\
    \ ) = 0 );\n    DimensionAttrInsert( '', 'Caption', 'S');\nELSEIF( DimIx( '}DimensionAttributes',\
    \ 'Caption' ) = 0 );\n    DimensionAttrInsert( '', 'Caption', 'S');\nENDIF;\n\nIF( CubeExists( '}LocalizedCubeAttributes'\
    \ ) = 0 );\n    CubeAttrPutS( '', '}CubeAttributes', 'Caption', 'en');\nENDIF;\nIF( CubeExists( '}LocalizedDimensionAttributes'\
    \ ) = 0 );\n    DimensionAttrPutS( '', '}Cultures', 'Caption', 'en');\nENDIF;\n\n### Localization\
    \ of attributes (& subsets) for any dimension passed\n# Loop through dimensions in pDim \nsDims  \
    \             = Trim( pDim );\nnDimDelimiterIndex  = 1;\n# Get 1st dimension\nWhile( pDim @<> '' &\
    \ nDimDelimiterIndex > 0 );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim,\
    \ sDims );\n    If( nDimDelimiterIndex = 0 );\n        sDim        = sDims;\n    Else;\n        sDim\
    \        = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims       = Trim( Subst(\
    \ sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n    # Check if sDim\
    \ has wildcard\n    If( Scan( '*', sDim ) = 0);\n        If( DimensionExists(sDim) = 0 );\n      \
    \      nErrors = 1;\n            sMessage = Expand( 'Dimension '%sDim%' does not exist.' );\n    \
    \        LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            sAttrDim =\
    \ '}ElementAttributes_' | sDim;\n            sLocAttrDim = '}LocalizedElementAttributes_' | sDim;\
    \ \n            sSubDim = '}Subsets_' | sDim;\n            sSubAttr = '}SubsetAttributes_' | sDim;\n\
    \            sLocSubAttr = '}LocalizedSubsetAttributes_' | sDim;\n            IF( CubeExists( sAttrDim\
    \ ) = 0 );\n                AttrInsert( sDim, '', 'Caption', 'S' );\n            ELSEIF( DimIx( sAttrDim,\
    \ 'Caption' ) = 0 );\n                AttrInsert( sDim, '', 'Caption', 'S' );\n            ENDIF;\n\
    \            IF( CubeExists( sLocAttrDim ) = 0 );\n                sFirstEle = '';\n             \
    \   sFirstEle = DimNm( sDim, 1 );\n                IF( sFirstEle @<> '' );\n                    AttrPutS(\
    \ '', sDim, sFirstEle, 'Caption', 'en' );\n                ENDIF;\n            ENDIF;\n          \
    \  If( pSub = 1 & DimSiz( sSubDim ) > 0 );\n                If( CubeExists( sSubAttr ) = 0 );\n  \
    \                  SubsetAttrInsert( sDim, '', 'Caption', 'S' );\n                EndIf;\n       \
    \         If( CubeExists( sLocSubAttr ) = 0 );\n                    sSub = DimNm( sSubDim, 1 );\n\
    \                    If( Scan( ':', sSub ) > 0 );\n                        sDim = sDim |':'| SubSt(\
    \ sSub, 1, Scan( ':', sSub ) - 1 );\n                        sSub = SubSt( sSub, Scan( ':', sSub )\
    \ + 1, Long( sSub ) );\n                    EndIf;\n                    SubsetAttrPutS( '', sDim,\
    \ sSub, 'Caption', 'en' );\n                EndIf;\n            EndIf;\n        Endif;\n    Else;\n\
    \        # Create subset of dimensions using Wildcard to loop through dimensions in pDim with wildcard\n\
    \        sMdx = Expand('{TM1FILTERBYPATTERN( EXCEPT ( EXCEPT ( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ), TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '}ElementAttributes_*')\
    \ ) , '%sDim%' )}');\n        If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n            # If\
    \ a delimited list of dim names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n        Else;\n            #\
    \ temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX,\
    \ '}Dimensions' , 1 );\n        EndIf;\n        \n        # Loop through dimensions in subset created\
    \ based on wildcard\n        nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n        While(\
    \ nCountDim >= 1 );\n            sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim\
    \ );\n            If( DimensionExists(sDim) = 0 );\n                nErrors = 1;\n               \
    \ sMessage = Expand( 'Dimension %sDim% does not exist.' );\n                LogOutput( 'ERROR', Expand(\
    \ cMsgErrorContent ) );\n            Else;\n                sAttrDim = '}ElementAttributes_' | sDim;\n\
    \                sLocAttrDim = '}LocalizedElementAttributes_' | sDim; \n                sSubDim =\
    \ '}Subsets_' | sDim;\n                sSubAttr = '}SubsetAttributes_' | sDim;\n                sLocSubAttr\
    \ = '}LocalizedSubsetAttributes_' | sDim;\n                IF( CubeExists( sAttrDim ) = 0 );\n   \
    \                 AttrInsert( sDim, '', 'Caption', 'S' );\n                ELSEIF( DimIx( sAttrDim,\
    \ 'Caption' ) = 0 );\n                    AttrInsert( sDim, '', 'Caption', 'S' );\n              \
    \  ENDIF;\n                IF( CubeExists( sLocAttrDim ) = 0 );\n                    sFirstEle = '';\n\
    \                    sFirstEle = DimNm( sDim, 1 );\n                    IF( sFirstEle @<> '' );\n\
    \                        AttrPutS( '', sDim, sFirstEle, 'Caption', 'en' );\n                    ENDIF;\n\
    \                ENDIF;\n                If( pSub = 1 );\n                    If( CubeExists( sSubAttr\
    \ ) = 0 );\n                        SubsetAttrInsert( sDim, '', 'Caption', 'S' );\n              \
    \      EndIf;\n                    If( CubeExists( sLocSubAttr ) = 0 & DimSiz( sSubDim ) > 0 );\n\
    \                        sSub = DimNm( sSubDim, 1 );\n                        If( Scan( ':', sSub\
    \ ) > 0 );\n                            sDim = sDim |':'| SubSt( sSub, 1, Scan( ':', sSub ) - 1 );\n\
    \                            sSub = SubSt( sSub, Scan( ':', sSub ) + 1, Long( sSub ) );\n        \
    \                EndIf;\n                        SubsetAttrPutS( '', sDim, sSub, 'Caption', 'en' );\n\
    \                    EndIf;\n                EndIf;\n            Endif;\n            nCountDim = nCountDim\
    \ - 1;\n        End;\n    EndIf;\nEnd;\n\n### Localization of views for any cube passed\n# Loop through\
    \ cubes in pCube \nsCubes              = Trim( pCube );\nnCubDelimiterIndex  = 1;\n# Get 1st Cube\n\
    While( pCube @<> '' & nCubDelimiterIndex > 0 );\n    # Extract 1st cube > sCube\n    nCubDelimiterIndex\
    \ = Scan( pDelim, sCubes );\n    If( nCubDelimiterIndex = 0 );\n        sCube       = sCubes;\n  \
    \  Else;\n        sCube       = Trim( SubSt( sCubes, 1, nCubDelimiterIndex - 1 ) );\n        sCubes\
    \      = Trim( Subst( sCubes, nCubDelimiterIndex + Long(pDelim), Long( sCubes ) ) );\n    EndIf;\n\
    \    \n    # Check if sCube has wildcard\n    If( Scan( '*', sCube ) = 0);\n        If( CubeExists(sCube)\
    \ = 0 );\n            nErrors = 1;\n            sMessage = Expand( 'Cube '%sCube%' does not exist.'\
    \ );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            sViewDim\
    \ = '}Views_' | sCube;\n            sViewAttr = '}ViewAttributes_' | sCube;\n            sLocViewAttr\
    \ = '}LocalizedViewAttributes_' | sCube;\n            IF( CubeExists( sViewAttr ) = 0 & DimensionExists(\
    \ sViewDim ) = 1 );\n                ViewAttrInsert( sCube, '', 'Caption', 'S' );\n            ENDIF;\n\
    \            IF( CubeExists( sLocViewAttr ) = 0 & DimSiz( sViewDim ) >= 1 );\n                ViewAttrPutS(\
    \ '', sCube, DimNm( sViewDim, 1 ), 'Caption', 'en' );\n            ENDIF;\n        Endif;\n    Else;\n\
    \        # Create subset of cubes using Wildcard to loop through cubes in pCube with wildcard\n  \
    \      sMdx = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ),  '%sCube%' )}');\n        If(\
    \ SubsetExists( '}Cubes' , cTempSub ) = 1 );\n            # If a delimited list of Cub names includes\
    \ wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet( '}Cubes'\
    \ , cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n        EndIf;\n        \n      \
    \  # Loop through cubes in subset created based on wildcard\n        nCountCub = SubsetGetSize( '}Cubes'\
    \ , cTempSub );\n        While( nCountCub >= 1 );\n            sCube = SubsetGetElementName( '}Cubes'\
    \ , cTempSub, nCountCub );\n            If( CubeExists(sCube) = 0 );\n                nErrors = 1;\n\
    \                sMessage = Expand( 'Cube %sCube% does not exist.' );\n                LogOutput(\
    \ 'ERROR', Expand( cMsgErrorContent ) );\n            Else;\n                sViewDim = '}Views_'\
    \ | sCube;\n                sViewAttr = '}ViewAttributes_' | sCube;\n                sLocViewAttr\
    \ = '}LocalizedViewAttributes_' | sCube;\n                IF( CubeExists( sViewAttr ) = 0 & DimensionExists(\
    \ sViewDim ) = 1 );\n                    ViewAttrInsert( sCube, '', 'Caption', 'S' );\n          \
    \      ENDIF;\n                IF( CubeExists( sLocViewAttr ) = 0 & DimSiz( sViewDim ) >= 1 );\n \
    \                   ViewAttrPutS( '', sCube, DimNm( sViewDim, 1 ), 'Caption', 'en' );\n          \
    \      ENDIF;\n            Endif;\n            nCountCub = nCountCub - 1;\n        End;\n    EndIf;\n\
    End;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% localized cube & dimension names & localized attributes for dimensions\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Create an IBM Turbo Integrator process that handles the localization of cube and dimension
    names. Additionally, the process should optionally localize attributes for specified dimensions, subsets
    for specified dimensions, and views for specified cubes. Note that if no dimension or cube names are
    specified, only the standard localization of cube and dimension names will be performed.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process localizes cube & dimension names & optionally localizes:\n\
    # * attributes for specified dimension(s)\n# * subsets for specified dimension(s)\n# * views for specified\
    \ cube(s)\n\n# Note:\n# If no dimension or cube names are passed, then just cube & dimension names\
    \ will be localized.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncTimeStamp        = TimSt( Now, '\\Y\\\
    m\\d\\h\\i\\s' );\ncRandomInt        = NumberToString( INT( RAND( ) * 1000 ));\ncTempSub         \
    \ = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pDim:%pDim%, pDelim:%pDelim%.'; \n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors = 0;\n\nIf( Trim( pDelim ) @= '' );\n    pDelim = '&';\nEndIf;\n\nIf( pSub <> 1 );\n    pSub\
    \ = 0;\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nIF( CubeExists(\
    \ '}CubeAttributes' ) = 0 );\n    CubeAttrInsert( '', 'Caption', 'S');\nELSEIF( DimIx( '}CubeAttributes',\
    \ 'Caption' ) = 0 );\n    CubeAttrInsert( '', 'Caption', 'S');\nENDIF;\nIF( CubeExists( '}DimensionAttributes'\
    \ ) = 0 );\n    DimensionAttrInsert( '', 'Caption', 'S');\nELSEIF( DimIx( '}DimensionAttributes',\
    \ 'Caption' ) = 0 );\n    DimensionAttrInsert( '', 'Caption', 'S');\nENDIF;\n\nIF( CubeExists( '}LocalizedCubeAttributes'\
    \ ) = 0 );\n    CubeAttrPutS( '', '}CubeAttributes', 'Caption', 'en');\nENDIF;\nIF( CubeExists( '}LocalizedDimensionAttributes'\
    \ ) = 0 );\n    DimensionAttrPutS( '', '}Cultures', 'Caption', 'en');\nENDIF;\n\n### Localization\
    \ of attributes (& subsets) for any dimension passed\n# Loop through dimensions in pDim \nsDims  \
    \             = Trim( pDim );\nnDimDelimiterIndex  = 1;\n# Get 1st dimension\nWhile( pDim @<> '' &\
    \ nDimDelimiterIndex > 0 );\n    # Extract 1st dimension > sDim\n    nDimDelimiterIndex = Scan( pDelim,\
    \ sDims );\n    If( nDimDelimiterIndex = 0 );\n        sDim        = sDims;\n    Else;\n        sDim\
    \        = Trim( SubSt( sDims, 1, nDimDelimiterIndex - 1 ) );\n        sDims       = Trim( Subst(\
    \ sDims, nDimDelimiterIndex + Long(pDelim), Long( sDims ) ) );\n    EndIf;\n    \n    # Check if sDim\
    \ has wildcard\n    If( Scan( '*', sDim ) = 0);\n        If( DimensionExists(sDim) = 0 );\n      \
    \      nErrors = 1;\n            sMessage = Expand( 'Dimension '%sDim%' does not exist.' );\n    \
    \        LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            sAttrDim =\
    \ '}ElementAttributes_' | sDim;\n            sLocAttrDim = '}LocalizedElementAttributes_' | sDim;\
    \ \n            sSubDim = '}Subsets_' | sDim;\n            sSubAttr = '}SubsetAttributes_' | sDim;\n\
    \            sLocSubAttr = '}LocalizedSubsetAttributes_' | sDim;\n            IF( CubeExists( sAttrDim\
    \ ) = 0 );\n                AttrInsert( sDim, '', 'Caption', 'S' );\n            ELSEIF( DimIx( sAttrDim,\
    \ 'Caption' ) = 0 );\n                AttrInsert( sDim, '', 'Caption', 'S' );\n            ENDIF;\n\
    \            IF( CubeExists( sLocAttrDim ) = 0 );\n                sFirstEle = '';\n             \
    \   sFirstEle = DimNm( sDim, 1 );\n                IF( sFirstEle @<> '' );\n                    AttrPutS(\
    \ '', sDim, sFirstEle, 'Caption', 'en' );\n                ENDIF;\n            ENDIF;\n          \
    \  If( pSub = 1 & DimSiz( sSubDim ) > 0 );\n                If( CubeExists( sSubAttr ) = 0 );\n  \
    \                  SubsetAttrInsert( sDim, '', 'Caption', 'S' );\n                EndIf;\n       \
    \         If( CubeExists( sLocSubAttr ) = 0 );\n                    sSub = DimNm( sSubDim, 1 );\n\
    \                    If( Scan( ':', sSub ) > 0 );\n                        sDim = sDim |':'| SubSt(\
    \ sSub, 1, Scan( ':', sSub ) - 1 );\n                        sSub = SubSt( sSub, Scan( ':', sSub )\
    \ + 1, Long( sSub ) );\n                    EndIf;\n                    SubsetAttrPutS( '', sDim,\
    \ sSub, 'Caption', 'en' );\n                EndIf;\n            EndIf;\n        Endif;\n    Else;\n\
    \        # Create subset of dimensions using Wildcard to loop through dimensions in pDim with wildcard\n\
    \        sMdx = Expand('{TM1FILTERBYPATTERN( EXCEPT ( EXCEPT ( TM1SUBSETALL( [}Dimensions] ) , TM1FILTERBYPATTERN(\
    \ TM1SUBSETALL( [}Dimensions] ) , '*:*') ), TM1FILTERBYPATTERN( TM1SUBSETALL( [}Dimensions] ) , '}ElementAttributes_*')\
    \ ) , '%sDim%' )}');\n        If( SubsetExists( '}Dimensions' , cTempSub ) = 1 );\n            # If\
    \ a delimited list of dim names includes wildcards then we may have to re-use the subset multiple\
    \ times\n            SubsetMDXSet( '}Dimensions' , cTempSub, sMDX );\n        Else;\n            #\
    \ temp subset, therefore no need to destroy in epilog\n            SubsetCreatebyMDX( cTempSub, sMDX,\
    \ '}Dimensions' , 1 );\n        EndIf;\n        \n        # Loop through dimensions in subset created\
    \ based on wildcard\n        nCountDim = SubsetGetSize( '}Dimensions' , cTempSub );\n        While(\
    \ nCountDim >= 1 );\n            sDim = SubsetGetElementName( '}Dimensions' , cTempSub, nCountDim\
    \ );\n            If( DimensionExists(sDim) = 0 );\n                nErrors = 1;\n               \
    \ sMessage = Expand( 'Dimension %sDim% does not exist.' );\n                LogOutput( 'ERROR', Expand(\
    \ cMsgErrorContent ) );\n            Else;\n                sAttrDim = '}ElementAttributes_' | sDim;\n\
    \                sLocAttrDim = '}LocalizedElementAttributes_' | sDim; \n                sSubDim =\
    \ '}Subsets_' | sDim;\n                sSubAttr = '}SubsetAttributes_' | sDim;\n                sLocSubAttr\
    \ = '}LocalizedSubsetAttributes_' | sDim;\n                IF( CubeExists( sAttrDim ) = 0 );\n   \
    \                 AttrInsert( sDim, '', 'Caption', 'S' );\n                ELSEIF( DimIx( sAttrDim,\
    \ 'Caption' ) = 0 );\n                    AttrInsert( sDim, '', 'Caption', 'S' );\n              \
    \  ENDIF;\n                IF( CubeExists( sLocAttrDim ) = 0 );\n                    sFirstEle = '';\n\
    \                    sFirstEle = DimNm( sDim, 1 );\n                    IF( sFirstEle @<> '' );\n\
    \                        AttrPutS( '', sDim, sFirstEle, 'Caption', 'en' );\n                    ENDIF;\n\
    \                ENDIF;\n                If( pSub = 1 );\n                    If( CubeExists( sSubAttr\
    \ ) = 0 );\n                        SubsetAttrInsert( sDim, '', 'Caption', 'S' );\n              \
    \      EndIf;\n                    If( CubeExists( sLocSubAttr ) = 0 & DimSiz( sSubDim ) > 0 );\n\
    \                        sSub = DimNm( sSubDim, 1 );\n                        If( Scan( ':', sSub\
    \ ) > 0 );\n                            sDim = sDim |':'| SubSt( sSub, 1, Scan( ':', sSub ) - 1 );\n\
    \                            sSub = SubSt( sSub, Scan( ':', sSub ) + 1, Long( sSub ) );\n        \
    \                EndIf;\n                        SubsetAttrPutS( '', sDim, sSub, 'Caption', 'en' );\n\
    \                    EndIf;\n                EndIf;\n            Endif;\n            nCountDim = nCountDim\
    \ - 1;\n        End;\n    EndIf;\nEnd;\n\n### Localization of views for any cube passed\n# Loop through\
    \ cubes in pCube \nsCubes              = Trim( pCube );\nnCubDelimiterIndex  = 1;\n# Get 1st Cube\n\
    While( pCube @<> '' & nCubDelimiterIndex > 0 );\n    # Extract 1st cube > sCube\n    nCubDelimiterIndex\
    \ = Scan( pDelim, sCubes );\n    If( nCubDelimiterIndex = 0 );\n        sCube       = sCubes;\n  \
    \  Else;\n        sCube       = Trim( SubSt( sCubes, 1, nCubDelimiterIndex - 1 ) );\n        sCubes\
    \      = Trim( Subst( sCubes, nCubDelimiterIndex + Long(pDelim), Long( sCubes ) ) );\n    EndIf;\n\
    \    \n    # Check if sCube has wildcard\n    If( Scan( '*', sCube ) = 0);\n        If( CubeExists(sCube)\
    \ = 0 );\n            nErrors = 1;\n            sMessage = Expand( 'Cube '%sCube%' does not exist.'\
    \ );\n            LogOutput( 'ERROR', Expand( cMsgErrorContent ) );\n        Else;\n            sViewDim\
    \ = '}Views_' | sCube;\n            sViewAttr = '}ViewAttributes_' | sCube;\n            sLocViewAttr\
    \ = '}LocalizedViewAttributes_' | sCube;\n            IF( CubeExists( sViewAttr ) = 0 & DimensionExists(\
    \ sViewDim ) = 1 );\n                ViewAttrInsert( sCube, '', 'Caption', 'S' );\n            ENDIF;\n\
    \            IF( CubeExists( sLocViewAttr ) = 0 & DimSiz( sViewDim ) >= 1 );\n                ViewAttrPutS(\
    \ '', sCube, DimNm( sViewDim, 1 ), 'Caption', 'en' );\n            ENDIF;\n        Endif;\n    Else;\n\
    \        # Create subset of cubes using Wildcard to loop through cubes in pCube with wildcard\n  \
    \      sMdx = Expand('{TM1FILTERBYPATTERN( TM1SUBSETALL( [}Cubes] ),  '%sCube%' )}');\n        If(\
    \ SubsetExists( '}Cubes' , cTempSub ) = 1 );\n            # If a delimited list of Cub names includes\
    \ wildcards then we may have to re-use the subset multiple times\n            SubsetMDXSet( '}Cubes'\
    \ , cTempSub, sMDX );\n        Else;\n            # temp subset, therefore no need to destroy in epilog\n\
    \            SubsetCreatebyMDX( cTempSub, sMDX, '}Cubes' , 1 );\n        EndIf;\n        \n      \
    \  # Loop through cubes in subset created based on wildcard\n        nCountCub = SubsetGetSize( '}Cubes'\
    \ , cTempSub );\n        While( nCountCub >= 1 );\n            sCube = SubsetGetElementName( '}Cubes'\
    \ , cTempSub, nCountCub );\n            If( CubeExists(sCube) = 0 );\n                nErrors = 1;\n\
    \                sMessage = Expand( 'Cube %sCube% does not exist.' );\n                LogOutput(\
    \ 'ERROR', Expand( cMsgErrorContent ) );\n            Else;\n                sViewDim = '}Views_'\
    \ | sCube;\n                sViewAttr = '}ViewAttributes_' | sCube;\n                sLocViewAttr\
    \ = '}LocalizedViewAttributes_' | sCube;\n                IF( CubeExists( sViewAttr ) = 0 & DimensionExists(\
    \ sViewDim ) = 1 );\n                    ViewAttrInsert( sCube, '', 'Caption', 'S' );\n          \
    \      ENDIF;\n                IF( CubeExists( sLocViewAttr ) = 0 & DimSiz( sViewDim ) >= 1 );\n \
    \                   ViewAttrPutS( '', sCube, DimNm( sViewDim, 1 ), 'Caption', 'en' );\n          \
    \      ENDIF;\n            Endif;\n            nCountCub = nCountCub - 1;\n        End;\n    EndIf;\n\
    End;\n\n### End Prolog ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n###\
    \ Return code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred\
    \ at least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode\
    \ = 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% localized cube & dimension names & localized attributes for dimensions\
    \ %pDim%.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der Logdateien, CSV-Dateien und Debug-Dateien
    löscht, die 'x' Tage alt sind. Dieser Prozess ist für den produktiven Einsatz gedacht und dient dazu,
    alte Dateien zu bereinigen, um Speicherplatz auf der Festplatte zu sparen. Beachten Sie, dass das
    Zielverzeichnis (pTgtDir) auf den Standardwert in der TM1-Konfigurationsdatei zurückgesetzt wird,
    wenn es leer gelassen wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will deletes the log files, csv file, debug files which\
    \ are 'x' days old.\n\n# Use case: Intended for production.\n# 1/ Process cleans up old files to save\
    \ space on hard disk.\n\n# Note:\n# The target directory (pTgtDir) will default to setting in TM1\
    \ configuration file if left blank.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pTgtDir:%pTgtDir%, pLogDays:%pLogDays%, pErrorDays:%pErrorDays%, pBedrockDays:%pBedrockDays%,\
    \ pCSVDays:%pCSVDays%.' ;  \n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \n\
    ENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIF( pTgtDir @= '');\n    pTgtDir = GetProcessErrorFileDirectory;\n\
    ELSE;\n    ## Remove leading and/or trailing spaces\n    pTgtDir = Trim( pTgtDir );\nENDIF;\n\n##\
    \ Remove trailing \\ from directory names if present\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @=\
    \ sOSDelim );\n    pTgtDir = SubSt( pTgtDir, 1, Long( pTgtDir ) - 1 );\nEndIf;\n\n# Check that target\
    \ Logging Directory exists\nIf( FileExists( pTgtDir ) = 0 );\n    nErrors = 1;\n    sMessage = 'Logging\
    \ directory does not exist: ' | pTgtDir;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsLogDays       \
    \ = NumberToString( ROUND( pLogDays ) );\nsErrorDays      = NumberToString( ROUND( pErrorDays ) );\n\
    sBedrockDays    = NumberToString( ROUND( pBedrockDays ) );\nsCSVDays        = NumberToString( ROUND(\
    \ pCSVDays ) );\n\n### Create Execute File File ###\nDatasourceASCIIQuoteCharacter='';\n\nIf( sOS\
    \ @= 'Windows');\n  sFileName = GetProcessName() | '.bat';\n  If( SubSt(pTgtDir, 1, 2) @<> '\\' );\n\
    \    # local or mapped drive, use forfiles to delete files matching pattern and expiry days\n    ASCIIOUTPUT(sFileName,\
    \ Expand('forfiles -p '%pTgtDir%' -s -m tm1s*.log -d -%sLogDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('forfiles -p '%pTgtDir%' -s -m tm1auditstore*.log -d -%sLogDays% -c 'cmd /c del @path''));\n\
    \    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%' -s -m TM1ProcessError*.log -d -%sErrorDays%\
    \ -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%' -s -m Bedrock*.*\
    \ -d -%sBedrockDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%'\
    \ -s -m *.csv -d -%sCSVDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles\
    \ -p '%pTgtDir%' -s -m *.cma -d -%sCSVDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('forfiles -p '%pTgtDir%' -s -m *.txt -d -%sCSVDays% -c 'cmd /c del @path''));\n  Else;\n\
    \    # UNC shared folder path (forfiles command doesn't work with UNC use robocopy instead, create\
    \ temp dir, move files to temp dir, then delete folder and contents)\n    ASCIIOUTPUT(sFileName, Expand('robocopy\
    \ '%pTgtDir%' '%pTgtDir%\bedrocklogclear' 'tm1s*.log' /mov /purge /MINAGE:%sLogDays% /copyall /s'));\n\
    \    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear' 'tm1auditstore*.log'\
    \ /mov /purge /MINAGE:%sLogDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%'\
    \ '%pTgtDir%\bedrocklogclear' 'Bedrock*.*' /mov /purge /MINAGE:%sErrorDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear' 'TM1ProcessError*.log' /mov /purge /MINAGE:%sBedrockDays%\
    \ /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear'\
    \ '*.csv' /mov /purge /MINAGE:%sCSVDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy\
    \ '%pTgtDir%' '%pTgtDir%\bedrocklogclear' '*.cma' /mov /purge /MINAGE:%sCSVDays% /copyall /s'));\n\
    \    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear' '*.txt' /mov\
    \ /purge /MINAGE:%sCSVDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('rmdir /s /q '%pTgtDir%\b\
    edrocklogclear''));\n  EndIf;\nElse;\n  sFileName = GetProcessName() | '.sh';\n  ASCIIOUTPUT(sFileName,\
    \ Expand('find '%pTgtDir%' -type f -mtime +%sLogDays% -name 'tm1s*.log' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName,\
    \ Expand('find '%pTgtDir%' -type f -mtime +%sLogDays% -name 'tm1auditstore*.log' -exec rm {}\\;'));\n\
    \  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f -mtime +%sErrorDays% -name 'TM1ProcessError*.log'\
    \ -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f -mtime +%sBedrockDays%\
    \ -name 'bedrock*.*' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f\
    \ -mtime +%sCSVDays% -name '*.csv' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%'\
    \ -type f -mtime +%sCSVDays% -name '*.cma' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find\
    \ '%pTgtDir%' -type f -mtime +%sCSVDays% -name '*.txt' -exec rm {}\\;'));\nEndIf;\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Copy Data\
    \ Dir to Backup ###\nsCommand = sFileName;\n\nIf(sOS @= 'Windows');\n  ExecuteCommand( sCommand, 1\
    \ );\nElse;\n  ExecuteCommand( 'sh ' | sCommand, 1 );\nEndIf;\nASCIIDelete( sFileName);\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted log files from %pTgtDir% older then  %pLogDays%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that deletes log files, CSV files, and debug files
    which are 'x' days old. This process is intended for production use and serves to clean up old files
    to save space on the hard disk. Note that the target directory (pTgtDir) will default to the setting
    in the TM1 configuration file if left blank.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will deletes the log files, csv file, debug files which\
    \ are 'x' days old.\n\n# Use case: Intended for production.\n# 1/ Process cleans up old files to save\
    \ space on hard disk.\n\n# Note:\n# The target directory (pTgtDir) will default to setting in TM1\
    \ configuration file if left blank.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\ncLogInfo          = 'Process:%cThisProcName%\
    \ run with parameters pTgtDir:%pTgtDir%, pLogDays:%pLogDays%, pErrorDays:%pErrorDays%, pBedrockDays:%pBedrockDays%,\
    \ pCSVDays:%pCSVDays%.' ;  \n\n## check operating system\nIf( SubSt( GetProcessErrorFileDirectory,\
    \ 2, 1 ) @= ':' );\n  sOS = 'Windows';\n  sOSDelim = '';\nElseIf( Scan( '/', GetProcessErrorFileDirectory\
    \ ) > 0 );\n  sOS = 'Linux';\n  sOSDelim = '/';\nElse;\n  sOS = 'Windows';\n  sOSDelim = '';\nEndIf;\n\
    \n## LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \n\
    ENDIF;\n\n### Validate Parameters ###\nnErrors = 0;\n\nIF( pTgtDir @= '');\n    pTgtDir = GetProcessErrorFileDirectory;\n\
    ELSE;\n    ## Remove leading and/or trailing spaces\n    pTgtDir = Trim( pTgtDir );\nENDIF;\n\n##\
    \ Remove trailing \\ from directory names if present\nIf( SubSt( pTgtDir, Long( pTgtDir ), 1 ) @=\
    \ sOSDelim );\n    pTgtDir = SubSt( pTgtDir, 1, Long( pTgtDir ) - 1 );\nEndIf;\n\n# Check that target\
    \ Logging Directory exists\nIf( FileExists( pTgtDir ) = 0 );\n    nErrors = 1;\n    sMessage = 'Logging\
    \ directory does not exist: ' | pTgtDir;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nEndIf;\n\n### Check for errors before continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling\
    \ = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n  EndIf;\nEndIf;\n\nsLogDays       \
    \ = NumberToString( ROUND( pLogDays ) );\nsErrorDays      = NumberToString( ROUND( pErrorDays ) );\n\
    sBedrockDays    = NumberToString( ROUND( pBedrockDays ) );\nsCSVDays        = NumberToString( ROUND(\
    \ pCSVDays ) );\n\n### Create Execute File File ###\nDatasourceASCIIQuoteCharacter='';\n\nIf( sOS\
    \ @= 'Windows');\n  sFileName = GetProcessName() | '.bat';\n  If( SubSt(pTgtDir, 1, 2) @<> '\\' );\n\
    \    # local or mapped drive, use forfiles to delete files matching pattern and expiry days\n    ASCIIOUTPUT(sFileName,\
    \ Expand('forfiles -p '%pTgtDir%' -s -m tm1s*.log -d -%sLogDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('forfiles -p '%pTgtDir%' -s -m tm1auditstore*.log -d -%sLogDays% -c 'cmd /c del @path''));\n\
    \    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%' -s -m TM1ProcessError*.log -d -%sErrorDays%\
    \ -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%' -s -m Bedrock*.*\
    \ -d -%sBedrockDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles -p '%pTgtDir%'\
    \ -s -m *.csv -d -%sCSVDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName, Expand('forfiles\
    \ -p '%pTgtDir%' -s -m *.cma -d -%sCSVDays% -c 'cmd /c del @path''));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('forfiles -p '%pTgtDir%' -s -m *.txt -d -%sCSVDays% -c 'cmd /c del @path''));\n  Else;\n\
    \    # UNC shared folder path (forfiles command doesn't work with UNC use robocopy instead, create\
    \ temp dir, move files to temp dir, then delete folder and contents)\n    ASCIIOUTPUT(sFileName, Expand('robocopy\
    \ '%pTgtDir%' '%pTgtDir%\bedrocklogclear' 'tm1s*.log' /mov /purge /MINAGE:%sLogDays% /copyall /s'));\n\
    \    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear' 'tm1auditstore*.log'\
    \ /mov /purge /MINAGE:%sLogDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%'\
    \ '%pTgtDir%\bedrocklogclear' 'Bedrock*.*' /mov /purge /MINAGE:%sErrorDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName,\
    \ Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear' 'TM1ProcessError*.log' /mov /purge /MINAGE:%sBedrockDays%\
    \ /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear'\
    \ '*.csv' /mov /purge /MINAGE:%sCSVDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('robocopy\
    \ '%pTgtDir%' '%pTgtDir%\bedrocklogclear' '*.cma' /mov /purge /MINAGE:%sCSVDays% /copyall /s'));\n\
    \    ASCIIOUTPUT(sFileName, Expand('robocopy '%pTgtDir%' '%pTgtDir%\bedrocklogclear' '*.txt' /mov\
    \ /purge /MINAGE:%sCSVDays% /copyall /s'));\n    ASCIIOUTPUT(sFileName, Expand('rmdir /s /q '%pTgtDir%\b\
    edrocklogclear''));\n  EndIf;\nElse;\n  sFileName = GetProcessName() | '.sh';\n  ASCIIOUTPUT(sFileName,\
    \ Expand('find '%pTgtDir%' -type f -mtime +%sLogDays% -name 'tm1s*.log' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName,\
    \ Expand('find '%pTgtDir%' -type f -mtime +%sLogDays% -name 'tm1auditstore*.log' -exec rm {}\\;'));\n\
    \  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f -mtime +%sErrorDays% -name 'TM1ProcessError*.log'\
    \ -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f -mtime +%sBedrockDays%\
    \ -name 'bedrock*.*' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%' -type f\
    \ -mtime +%sCSVDays% -name '*.csv' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find '%pTgtDir%'\
    \ -type f -mtime +%sCSVDays% -name '*.cma' -exec rm {}\\;'));\n  ASCIIOUTPUT(sFileName, Expand('find\
    \ '%pTgtDir%' -type f -mtime +%sCSVDays% -name '*.txt' -exec rm {}\\;'));\nEndIf;\n\n### End Prolog\
    \ ###\n#Section Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Section Daten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section\
    \ Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n### Copy Data\
    \ Dir to Backup ###\nsCommand = sFileName;\n\nIf(sOS @= 'Windows');\n  ExecuteCommand( sCommand, 1\
    \ );\nElse;\n  ExecuteCommand( 'sh ' | sCommand, 1 );\nEndIf;\nASCIIDelete( sFileName);\n\n### Return\
    \ code & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at\
    \ least 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode =\
    \ 0;\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand(\
    \ '%sProcessReturnCode% Process:%cThisProcName% completed with errors. Check tm1server.log for details.'\
    \ );\n    If( pStrictErrorHandling = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction\
    \ = Expand( 'Process:%cThisProcName% successfully deleted log files from %pTgtDir% older then  %pLogDays%.'\
    \ );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode\
    \ = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\n\
    EndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der alle Daten auf die Festplatte speichert.
    Dieser Prozess sollte im Produktionsumfeld eingesetzt werden. Er kann während des Planungszyklus mehrmals
    täglich ausgeführt werden. Beachte, dass je nach vergangener Zeit seit dem letzten Datenspeichern
    dieser Vorgang mehrere Sekunden oder sogar Minuten dauern kann. Deshalb sollte die Ausführung idealerweise
    in eine Mittagspause eingeplant werden.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Save All Data to disk.\n\n# Use case: Intended\
    \ for production.\n# 1/ This could be run mulitple times a day during the planning cycle.\n\n# Note:\n\
    # Depending on how long since the last data save this could take several seconds if not minutes so\
    \ schedule if over lunch break.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\n## LogOutput parameters\n\n\
    ### Validate Parameters ###\n\nnErrors = 0;\n\n### LogOutput ###\nIf( pLogOutput = 1 );\n    sLogInfo\
    \ = Expand('Process:%cThisProcName% commenced.'); \n    LogOutput( 'INFO', sLogInfo );\n    nStart\
    \   = Now();\nEndIf;\n\n### Save Data ###\n\nSaveDataAll;\n\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### LogOutput ###\n\nIf( pLogOutput = 1 );\n    sSec     = NumberToStringEx(\
    \ 86400*(Now() - nStart),'#,##0.0', '.', ',' );\n    sLogInfo = Expand('Process:%cThisProcName% completed.\
    \ Elapsed time %sSec% seconds.'); \n    LogOutput( 'INFO', sLogInfo );\nEndIf;\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully saved all cube data.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that saves all data to disk. This process is intended
    for use in production environments and can be executed multiple times a day during the planning cycle.
    Note that depending on the time elapsed since the last data save, this process may take several seconds
    or even minutes, so it is advisable to schedule it during a lunch break.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will Save All Data to disk.\n\n# Use case: Intended\
    \ for production.\n# 1/ This could be run mulitple times a day during the planning cycle.\n\n# Note:\n\
    # Depending on how long since the last data save this could take several seconds if not minutes so\
    \ schedule if over lunch break.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName\
    \     = GetProcessName();\ncUserName         = TM1User();\ncMsgErrorLevel    = 'ERROR';\ncMsgErrorContent\
    \  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\n## LogOutput parameters\n\n\
    ### Validate Parameters ###\n\nnErrors = 0;\n\n### LogOutput ###\nIf( pLogOutput = 1 );\n    sLogInfo\
    \ = Expand('Process:%cThisProcName% commenced.'); \n    LogOutput( 'INFO', sLogInfo );\n    nStart\
    \   = Now();\nEndIf;\n\n### Save Data ###\n\nSaveDataAll;\n\n#Section Metadaten\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n### LogOutput ###\n\nIf( pLogOutput = 1 );\n    sSec     = NumberToStringEx(\
    \ 86400*(Now() - nStart),'#,##0.0', '.', ',' );\n    sLogInfo = Expand('Process:%cThisProcName% completed.\
    \ Elapsed time %sSec% seconds.'); \n    LogOutput( 'INFO', sLogInfo );\nEndIf;\n\n### Return code\
    \ & final error message handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least\
    \ 1 error. Please see above lines in this file for more details.';\n    nProcessReturnCode = 0;\n\
    \    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ Process:%cThisProcName% completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling\
    \ = 1 ); \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully saved all cube data.' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% %sProcessAction%'\
    \ );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO', Expand( sProcessAction\
    \ ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: 'Entwickle einen IBM Turbo Integrator Prozess, der einen Eingabestring pInputString basierend
    auf den Regeln in pChanges validiert und Zeichen ändert oder eliminiert, um eine globale Variable
    sOutputString zu erstellen. Diese Variable kann im Quell-TI verwendet werden. Beachte: pInputString
    ist der Eingabestring, der basierend auf Dateisystembeschränkungen oder unerwünschten Anfangszeichen
    validiert werden muss. pUndesirableFileSystem sind Zeichen, die in Objekt- oder Elementnamen aufgrund
    von Dateisystembeschränkungen des Betriebssystems als unerwünscht gelten. pUndesirable1st sind Zeichen,
    die aufgrund von TM1-Beschränkungen als erste Zeichen in Objekt- oder Elementnamen unerwünscht sind.
    pChanges definiert die Regel, wie unerwünschte Zeichen geändert werden sollen. Sie kann aus mehreren,
    durch pDelim getrennten Definitionen bestehen. Jede Definition enthält ein unerwünschtes Zeichen und
    das gewünschte Zeichen, getrennt durch pSeperator. pReplaceIfNotFound ist eine allgemeine Ersatzregel
    für Zeichen, die in pUndesirableFileSystem oder pUndesirable1st aufgeführt sind und keine Regel in
    pChanges haben. pDelim ist ein Zeichen, das verwendet wird, um Definitionen in pChanges zu trennen.
    pSeperator trennt das aktuelle von dem gewünschten Zeichen innerhalb jeder Definition in pChanges.
    pMode kann verwendet werden, um zu bestimmen, ob der TI pUndesirableFileSystem oder pUndesirable1st
    betrachtet, ohne die Zeichen in diesen Parametern ändern zu müssen.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will validate a string pInputString based on rules\
    \ in pChanges and change or \n# eliminate characters to create a global variable sOutputString that\
    \ can be used in the source TI.\n\n# Note:\n# - pInputString: This is the input string that needs\
    \ to be validated based on file system \n#   limitations or undesirable 1st characters.\n\n# - pUndesirableFileSystem:\
    \ These are characters considered undesirable (even forbidden) in \n#   object/element names due to\
    \ file system limitations of the operation system. \n\n# - pUndesirable1st: These are characters considered\
    \ undesirable as 1st characters in object/element\n#   names due to TM1 limitations.\n\n# - pChanges:\
    \ This string defines the rule of how to change undesirable characters. It can be made up\n#   of\
    \ many definitions delimited by pDelim (e.g. `&` which is not considered undesirable\n#   anywhere).\
    \ Each definition would contain a character considered undesirable and the desired \n#   character\
    \ separatedby pSeperator (e.g. to change a `%` to Percentage and `'` to inches, it would\n#   be `%,Percentage&',inches`\
    \ if pDelim = `&` and pSeperator = `,`).\n\n# - pReplaceIfNotFound: This is a catch all for characters\
    \ listed in pUndesirableFileSystem or \n#   pUndesirable1st that don't have a rule in pChanges.\n\n\
    # - pDelim: This is a character that is used to seperate definitions in pChanges.\n\n# - pSeperator:\
    \ This is a character used to seperate the current and desired character within each\n#   definition\
    \ in pChanges.\n\n# - pMode: This can be used to limit whether the TI looks at pUndesirableFileSystem\
    \ or pUndesirable1st \n#   without having to delete the characters in those parameters.\n#EndRegion\
    \ @DOC\n\n#Region # Variables & Constants\n# Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    StringGlobalVariable('sOutputString');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode\
    \ = 0;\n\n# Constants \ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp\
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncSubset         = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= '%cThisProcName% : %sMessage% : %cUserName%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pLogOutput=%pLogOutput%, pInputString=%pInputString%, pUndesirableFileSystem=%pUndesirableFileSystem%,\
    \ pUndesirable1st=%pUndesirable1st%, pChanges=%pChanges%, pReplaceIfNotFound=%pReplaceIfNotFound%,\
    \ pDelim=%pDelim%, pSeperator=%pSeperator%, pMode=%pMode%';\n\n# Variables\nnErrors         = 0;\n\
    #EndRegion\n\n#Region # LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );\nENDIF;\n#EndRegion\n\n#Region # Validate parameters\n## Validate pInputString parameter\n\
    IF( Trim( pInputString ) @= '' );\n    nErrors     =1;\n    sError      = Expand('No element name\
    \ specified in pInputString.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nELSE;\n\
    \    sElementToUpdate        = Trim( pInputString ) ;\nENDIF;\n\n## Validate pMode parameter\nIF(\
    \ pMode <>1 & pMode <>2 & pMode <>3 );\n    nErrors     =1;\n    sError      = Expand('pMode parameter\
    \ must be 1, 2 or 3 not %pMode%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    ENDIF;\n\n## Validate pDelim parameter\nIF( Trim( pDelim ) @= '' );\n    nErrors     =1;\n    sError\
    \      = Expand('No delimiter specified in pDelim.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nELSE;\n    sDelim      = SUBST( Trim( pDelim ) , 1 , 1 );\nENDIF;\n\n## Validate pSeperator\
    \ parameter\nIF( Trim( pSeperator ) @= '' );\n    nErrors     =1;\n    sError      = Expand('No seperator\
    \ specified in pSeperator.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nELSE;\n\
    \    sSeperator      = SUBST( Trim( pSeperator ) , 1 , 1 );\nENDIF;\n\n## Validate pChanges parameter\n\
    #pChanges        = Trim( pChanges );\nIF( pChanges @= '' );\n    \nELSEIF( SUBST( pChanges , LONG(\
    \ pChanges ) , 1 )@<> sDelim );\n    pChanges    = pChanges | sDelim ;\nENDIF;\n\n#pChanges      \
    \  = Trim( pChanges );\nIF( pReplaceIfNotFound @= '' );\n    sReplaceIfNotFound  = '';\nELSE;\n  \
    \  sReplaceIfNotFound  = Trim( pReplaceIfNotFound );\nENDIF;\n\n##### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n#EndRegion \n\n#Region # Prepare for While loop to validate each character seperately\n\
    sEle                        = TRIM( pInputString );\nnEle                        = LONG( sEle );\n\
    sOutputString               = '';\nnCount                      = 1;\n# Loop through each character\
    \ to see if valid\n# If no script inlcuded in pChanges then the invalid character will be replaced\
    \  with pReplaceIfNotFound\nWHILE( nCount <= nEle );\n    sChar                   = SUBST( sEle ,\
    \ nCount , 1 );\n    sChanges                = TRIM( pChanges );\n    nUndesirableFileSystem  = SCAN(\
    \ sChar , pUndesirableFileSystem );\n    nUndesirable1st         = SCAN( sChar , pUndesirable1st );\n\
    \    ## Test if sChar contains undesirable \n    IF( nUndesirableFileSystem >0 & ( pMode=1 % pMode=3)\
    \ );\n        ## Test if sChar in pChanges\n        nChange             = SCAN( sChar , sChanges );\n\
    \        IF( nChange >0 );\n            sChanges        = SUBST( sChanges , nChange , 999 );\n   \
    \         nNewLong        = SCAN( sDelim , sChanges );       \n            sNew            = SUBST(\
    \ sChanges , 3  , nNewLong-3 );\n            #sOutputString   = sOutputString | sNew ;\n        ELSE;\n\
    \            sNew            = sReplaceIfNotFound ;\n        ENDIF;   \n    ELSEIF( nUndesirable1st\
    \ >0 & nCount=1 & ( pMode=2 % pMode=3) );\n        ## Test if sChar in pChanges\n        nChange \
    \            = SCAN( sChar , sChanges );\n        IF( nChange >0 );\n            sChanges        =\
    \ SUBST( sChanges , nChange , 999 );\n            nNewLong        = SCAN( sDelim , sChanges );   \
    \    \n            sNew            = SUBST( sChanges , 3  , nNewLong-3 );\n            #sOutputString\
    \   = sOutputString | sNew ;\n        ELSE;\n            sNew            = pReplaceIfNotFound ;\n\
    \        ENDIF;        \n    ELSE;\n        sNew                = sChar;\n    ENDIF;\n    sOutputString\
    \           = sOutputString | sNew ;\n    # Loop through the rest of the characters\n    nCount  \
    \                = nCount + 1 ;\nEND;\n#EndRegion\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\nIF( nCount <> 1000000 );\n    #AttrPutS( NumberToString( StringToNumber( sUpdatesNew\
    \ ) )  , sDim2 , sUpdatesNew , 'Number');\nENDIF;\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ has validated the string the element '%pInputString%' and returned '%sOutputString%'.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: 'Develop an IBM Turbo Integrator process that validates an input string pInputString based
    on the rules in pChanges and changes or eliminates characters to create a global variable sOutputString
    that can be used in the source TI. Note: pInputString is the input string that needs to be validated
    based on file system limitations or undesirable initial characters. pUndesirableFileSystem are characters
    considered undesirable (or forbidden) in object/element names due to the operating system''s file
    system limitations. pUndesirable1st are characters considered undesirable as first characters in object/element
    names due to TM1 limitations. pChanges defines the rule of how to change undesirable characters. It
    can consist of many definitions separated by pDelim. Each definition contains an undesirable character
    and the desired character, separated by pSeperator. pReplaceIfNotFound is a catch-all for characters
    listed in pUndesirableFileSystem or pUndesirable1st that do not have a rule in pChanges. pDelim is
    a character used to separate definitions in pChanges. pSeperator is used to separate the current and
    desired character within each definition in pChanges. pMode can be used to determine whether the TI
    looks at pUndesirableFileSystem or pUndesirable1st without having to change the characters in these
    parameters.'
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will validate a string pInputString based on rules\
    \ in pChanges and change or \n# eliminate characters to create a global variable sOutputString that\
    \ can be used in the source TI.\n\n# Note:\n# - pInputString: This is the input string that needs\
    \ to be validated based on file system \n#   limitations or undesirable 1st characters.\n\n# - pUndesirableFileSystem:\
    \ These are characters considered undesirable (even forbidden) in \n#   object/element names due to\
    \ file system limitations of the operation system. \n\n# - pUndesirable1st: These are characters considered\
    \ undesirable as 1st characters in object/element\n#   names due to TM1 limitations.\n\n# - pChanges:\
    \ This string defines the rule of how to change undesirable characters. It can be made up\n#   of\
    \ many definitions delimited by pDelim (e.g. `&` which is not considered undesirable\n#   anywhere).\
    \ Each definition would contain a character considered undesirable and the desired \n#   character\
    \ separatedby pSeperator (e.g. to change a `%` to Percentage and `'` to inches, it would\n#   be `%,Percentage&',inches`\
    \ if pDelim = `&` and pSeperator = `,`).\n\n# - pReplaceIfNotFound: This is a catch all for characters\
    \ listed in pUndesirableFileSystem or \n#   pUndesirable1st that don't have a rule in pChanges.\n\n\
    # - pDelim: This is a character that is used to seperate definitions in pChanges.\n\n# - pSeperator:\
    \ This is a character used to seperate the current and desired character within each\n#   definition\
    \ in pChanges.\n\n# - pMode: This can be used to limit whether the TI looks at pUndesirableFileSystem\
    \ or pUndesirable1st \n#   without having to delete the characters in those parameters.\n#EndRegion\
    \ @DOC\n\n#Region # Variables & Constants\n# Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    StringGlobalVariable('sOutputString');\nNumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode\
    \ = 0;\n\n# Constants \ncThisProcName   = GetProcessName();\ncUserName       = TM1User();\ncTimeStamp\
    \      = TimSt( Now, '\\Y\\m\\d\\h\\i\\s' );\ncRandomInt      = NumberToString( INT( RAND( ) * 1000\
    \ ));\ncSubset         = cThisProcName |'_'| cTimeStamp |'_'| cRandomInt;\ncMsgErrorLevel  = 'ERROR';\n\
    cMsgErrorContent= '%cThisProcName% : %sMessage% : %cUserName%';\ncLogInfo        = 'Process:%cThisProcName%\
    \ run with parameters pLogOutput=%pLogOutput%, pInputString=%pInputString%, pUndesirableFileSystem=%pUndesirableFileSystem%,\
    \ pUndesirable1st=%pUndesirable1st%, pChanges=%pChanges%, pReplaceIfNotFound=%pReplaceIfNotFound%,\
    \ pDelim=%pDelim%, pSeperator=%pSeperator%, pMode=%pMode%';\n\n# Variables\nnErrors         = 0;\n\
    #EndRegion\n\n#Region # LogOutput parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand(\
    \ cLogInfo ) );\nENDIF;\n#EndRegion\n\n#Region # Validate parameters\n## Validate pInputString parameter\n\
    IF( Trim( pInputString ) @= '' );\n    nErrors     =1;\n    sError      = Expand('No element name\
    \ specified in pInputString.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nELSE;\n\
    \    sElementToUpdate        = Trim( pInputString ) ;\nENDIF;\n\n## Validate pMode parameter\nIF(\
    \ pMode <>1 & pMode <>2 & pMode <>3 );\n    nErrors     =1;\n    sError      = Expand('pMode parameter\
    \ must be 1, 2 or 3 not %pMode%.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\n\
    ENDIF;\n\n## Validate pDelim parameter\nIF( Trim( pDelim ) @= '' );\n    nErrors     =1;\n    sError\
    \      = Expand('No delimiter specified in pDelim.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent\
    \ ) );\nELSE;\n    sDelim      = SUBST( Trim( pDelim ) , 1 , 1 );\nENDIF;\n\n## Validate pSeperator\
    \ parameter\nIF( Trim( pSeperator ) @= '' );\n    nErrors     =1;\n    sError      = Expand('No seperator\
    \ specified in pSeperator.');\n    LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nELSE;\n\
    \    sSeperator      = SUBST( Trim( pSeperator ) , 1 , 1 );\nENDIF;\n\n## Validate pChanges parameter\n\
    #pChanges        = Trim( pChanges );\nIF( pChanges @= '' );\n    \nELSEIF( SUBST( pChanges , LONG(\
    \ pChanges ) , 1 )@<> sDelim );\n    pChanges    = pChanges | sDelim ;\nENDIF;\n\n#pChanges      \
    \  = Trim( pChanges );\nIF( pReplaceIfNotFound @= '' );\n    sReplaceIfNotFound  = '';\nELSE;\n  \
    \  sReplaceIfNotFound  = Trim( pReplaceIfNotFound );\nENDIF;\n\n##### Check for errors before continuing\n\
    If( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n      ProcessBreak;\n\
    \  EndIf;\nEndIf;\n#EndRegion \n\n#Region # Prepare for While loop to validate each character seperately\n\
    sEle                        = TRIM( pInputString );\nnEle                        = LONG( sEle );\n\
    sOutputString               = '';\nnCount                      = 1;\n# Loop through each character\
    \ to see if valid\n# If no script inlcuded in pChanges then the invalid character will be replaced\
    \  with pReplaceIfNotFound\nWHILE( nCount <= nEle );\n    sChar                   = SUBST( sEle ,\
    \ nCount , 1 );\n    sChanges                = TRIM( pChanges );\n    nUndesirableFileSystem  = SCAN(\
    \ sChar , pUndesirableFileSystem );\n    nUndesirable1st         = SCAN( sChar , pUndesirable1st );\n\
    \    ## Test if sChar contains undesirable \n    IF( nUndesirableFileSystem >0 & ( pMode=1 % pMode=3)\
    \ );\n        ## Test if sChar in pChanges\n        nChange             = SCAN( sChar , sChanges );\n\
    \        IF( nChange >0 );\n            sChanges        = SUBST( sChanges , nChange , 999 );\n   \
    \         nNewLong        = SCAN( sDelim , sChanges );       \n            sNew            = SUBST(\
    \ sChanges , 3  , nNewLong-3 );\n            #sOutputString   = sOutputString | sNew ;\n        ELSE;\n\
    \            sNew            = sReplaceIfNotFound ;\n        ENDIF;   \n    ELSEIF( nUndesirable1st\
    \ >0 & nCount=1 & ( pMode=2 % pMode=3) );\n        ## Test if sChar in pChanges\n        nChange \
    \            = SCAN( sChar , sChanges );\n        IF( nChange >0 );\n            sChanges        =\
    \ SUBST( sChanges , nChange , 999 );\n            nNewLong        = SCAN( sDelim , sChanges );   \
    \    \n            sNew            = SUBST( sChanges , 3  , nNewLong-3 );\n            #sOutputString\
    \   = sOutputString | sNew ;\n        ELSE;\n            sNew            = pReplaceIfNotFound ;\n\
    \        ENDIF;        \n    ELSE;\n        sNew                = sChar;\n    ENDIF;\n    sOutputString\
    \           = sOutputString | sNew ;\n    # Loop through the rest of the characters\n    nCount  \
    \                = nCount + 1 ;\nEND;\n#EndRegion\n\n#Section Metadaten\n\n#****Begin: Generated Statements***\n\
    #****End: Generated Statements****\n\n#Section Daten\n\n#****Begin: Generated Statements***\n#****End:\
    \ Generated Statements****\n\n#Section Epilog\n\n#****Begin: Generated Statements***\n#****End: Generated\
    \ Statements****\n\nIF( nCount <> 1000000 );\n    #AttrPutS( NumberToString( StringToNumber( sUpdatesNew\
    \ ) )  , sDim2 , sUpdatesNew , 'Number');\nENDIF;\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ has validated the string the element '%pInputString%' and returned '%sOutputString%'.' );\n    sProcessReturnCode\
    \ = Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der es ermöglicht, einen Prozess in einem Wartezustand
    für die angegebene Zeit in Sekunden zu setzen. Stelle sicher, dass der Prozess effektiv pausiert wird
    und nach der angegebenen Wartezeit ordnungsgemäß fortgesetzt wird.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This Bedrock TM1 TI will put a process in a wait state for time\
    \ specified in seconds.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\nsWaitSec = NumberToString( pWaitSec\
    \ );\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName         = TM1User();\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pWaitSec:%sWaitSec%.'; \n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors\
    \ = 0;\n\n### SLEEP ##\nnWaitTime = pWaitSec * 1000;\nSleep ( nWaitTime );\n#Section Metadaten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully waited for %sWaitSec% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Develop an IBM Turbo Integrator process that allows putting a process into a wait state for
    the specified time in seconds. Ensure that the process is effectively paused and resumes properly
    after the specified wait time.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This Bedrock TM1 TI will put a process in a wait state for time\
    \ specified in seconds.\n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\n\
    NumericGlobalVariable('nProcessReturnCode');\nnProcessReturnCode= 0;\nsWaitSec = NumberToString( pWaitSec\
    \ );\n\n### Constants ###\ncThisProcName     = GetProcessName();\ncUserName         = TM1User();\n\
    cMsgErrorLevel    = 'ERROR';\ncMsgErrorContent  = 'User:%cUserName% Process:%cThisProcName% ErrorMsg:%sMessage%';\n\
    cLogInfo          = 'Process:%cThisProcName% run with parameters pWaitSec:%sWaitSec%.'; \n\n## LogOutput\
    \ parameters\nIF( pLogoutput = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\nnErrors\
    \ = 0;\n\n### SLEEP ##\nnWaitTime = pWaitSec * 1000;\nSleep ( nWaitTime );\n#Section Metadaten\n\n\
    #****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n#Section Epilog\n\n#****Begin: Generated\
    \ Statements***\n#****End: Generated Statements****\n\n### Return code & final error message handling\n\
    If( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see above lines\
    \ in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel, Expand(\
    \ cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully waited for %sWaitSec% .' );\n    sProcessReturnCode = Expand( '%sProcessReturnCode%\
    \ %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput = 1 );\n        LogOutput('INFO',\
    \ Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End Epilog ###"
- question: Entwickle einen IBM Turbo Integrator Prozess, der eine Nachricht in das TM1-Server-Message-Log
    schreibt. Dein Prozess sollte die Schritte zur Initialisierung, Ausführung und Fehlerbehandlung klar
    definieren.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will write a Message into the TM1 server Message Log.\
    \ \n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pLevel:%pLevel%,\
    \ pMessage:%pMessage%.' ; \ncLF                 = Char ( 10 );\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors             = 0;\nsErrors             = '';\n\n# ValidateType\nsType               = Upper\
    \ ( pLevel );\nIf( sType @<> 'ERROR' & sType @<> 'WARN' & sType @<> 'DEBUG' & sType @<> 'INFO' );\n\
    \    nErrors         = nErrors + 1;\n    sMessage        = 'Invalid Type: ' | pLevel | cLF;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( Long ( pMessage ) = 0 );\n    nErrors\
    \         = nErrors + 1;\n    sMessage        = sErrors | 'pMessage can not be empty.'  | cLF;\n \
    \   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before\
    \ continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Action ###\nLogOutput ( sType , pMessage );\n\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see\
    \ above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully wrote message type %pLevel% with message %pMessage%.' );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
- question: Develop an IBM Turbo Integrator process that writes a message into the TM1 server message
    log. Your process should clearly define the steps for initialization, execution, and error handling.
  answer: "#Section Prolog\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\
    \n#Region @DOC\n# Description:\n# This process will write a Message into the TM1 server Message Log.\
    \ \n#EndRegion @DOC\n\n### Global Variables\nStringGlobalVariable('sProcessReturnCode');\nNumericGlobalVariable('nProcessReturnCode');\n\
    nProcessReturnCode= 0;\n\n### Constants ###\ncThisProcName       = GetProcessName();\ncUserName  \
    \         = TM1User();\ncMsgErrorLevel      = 'ERROR';\ncMsgErrorContent    = 'User:%cUserName% Process:%cThisProcName%\
    \ ErrorMsg:%sMessage%';\ncLogInfo            = 'Process:%cThisProcName% run with parameters pLevel:%pLevel%,\
    \ pMessage:%pMessage%.' ; \ncLF                 = Char ( 10 );\n\n## LogOutput parameters\nIF( pLogoutput\
    \ = 1 );\n    LogOutput('INFO', Expand( cLogInfo ) );   \nENDIF;\n\n### Validate Parameters ###\n\
    nErrors             = 0;\nsErrors             = '';\n\n# ValidateType\nsType               = Upper\
    \ ( pLevel );\nIf( sType @<> 'ERROR' & sType @<> 'WARN' & sType @<> 'DEBUG' & sType @<> 'INFO' );\n\
    \    nErrors         = nErrors + 1;\n    sMessage        = 'Invalid Type: ' | pLevel | cLF;\n    LogOutput(\
    \ cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\nIf( Long ( pMessage ) = 0 );\n    nErrors\
    \         = nErrors + 1;\n    sMessage        = sErrors | 'pMessage can not be empty.'  | cLF;\n \
    \   LogOutput( cMsgErrorLevel, Expand( cMsgErrorContent ) );\nEndIf;\n\n### Check for errors before\
    \ continuing\nIf( nErrors <> 0 );\n  If( pStrictErrorHandling = 1 ); \n      ProcessQuit; \n  Else;\n\
    \      ProcessBreak;\n  EndIf;\nEndIf;\n\n### Action ###\nLogOutput ( sType , pMessage );\n\n#Section\
    \ Metadaten\n\n#****Begin: Generated Statements***\n#****End: Generated Statements****\n#Section Daten\n\
    \n#****Begin: Generated Statements***\n#****End: Generated Statements****\n\n#Section Epilog\n\n#****Begin:\
    \ Generated Statements***\n#****End: Generated Statements****\n\n### Return code & final error message\
    \ handling\nIf( nErrors > 0 );\n    sMessage = 'the process incurred at least 1 error. Please see\
    \ above lines in this file for more details.';\n    nProcessReturnCode = 0;\n    LogOutput( cMsgErrorLevel,\
    \ Expand( cMsgErrorContent ) );\n    sProcessReturnCode = Expand( '%sProcessReturnCode% Process:%cThisProcName%\
    \ completed with errors. Check tm1server.log for details.' );\n    If( pStrictErrorHandling = 1 );\
    \ \n        ProcessQuit; \n    EndIf;\nElse;\n    sProcessAction = Expand( 'Process:%cThisProcName%\
    \ successfully wrote message type %pLevel% with message %pMessage%.' );\n    sProcessReturnCode =\
    \ Expand( '%sProcessReturnCode% %sProcessAction%' );\n    nProcessReturnCode = 1;\n    If( pLogoutput\
    \ = 1 );\n        LogOutput('INFO', Expand( sProcessAction ) );   \n    EndIf;\nEndIf;\n\n### End\
    \ Epilog ###"
